import * as React from "react";
import React__default, { useMemo, createContext, useState, useRef, useEffect, useContext, startTransition, forwardRef, useLayoutEffect, useCallback, useId as useId$2, memo as memo$1, Component, createElement, Suspense } from "react";
import { useQueryClient, useMutation, useSuspenseQuery, useQuery, useSuspenseQueries, QueryErrorResetBoundary, QueryClientProvider, QueryClient } from "@tanstack/react-query";
import { useParams, useLocation, useNavigate, NavLink, useMatch, Outlet, RouterProvider } from "react-router-dom";
import { useFormContext, useFieldArray, useWatch, FormProvider, Controller, useForm, get as get$2, set as set$1, appendErrors } from "react-hook-form";
import { useTranslation as useTranslation$1, initReactI18next } from "react-i18next";
import { create } from "zustand";
import * as ReactDOM from "react-dom";
import ReactDOM__default from "react-dom";
function _mergeNamespaces(n2, m) {
  for (var i2 = 0; i2 < m.length; i2++) {
    const e = m[i2];
    if (typeof e !== "string" && !Array.isArray(e)) {
      for (const k in e) {
        if (k !== "default" && !(k in n2)) {
          const d = Object.getOwnPropertyDescriptor(e, k);
          if (d) {
            Object.defineProperty(n2, k, d.get ? d : {
              enumerable: true,
              get: () => e[k]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace(n2) {
  if (n2.__esModule) return n2;
  var f = n2.default;
  if (typeof f == "function") {
    var a = function a2() {
      if (this instanceof a2) {
        return Reflect.construct(f, arguments, this.constructor);
      }
      return f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n2, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n2[k];
      }
    });
  });
  return a;
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production_min;
function requireReactJsxRuntime_production_min() {
  if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min;
  hasRequiredReactJsxRuntime_production_min = 1;
  var f = React__default, k = Symbol.for("react.element"), l = Symbol.for("react.fragment"), m = Object.prototype.hasOwnProperty, n2 = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p = { key: true, ref: true, __self: true, __source: true };
  function q(c, a, g) {
    var b, d = {}, e = null, h = null;
    void 0 !== g && (e = "" + g);
    void 0 !== a.key && (e = "" + a.key);
    void 0 !== a.ref && (h = a.ref);
    for (b in a) m.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);
    if (c && c.defaultProps) for (b in a = c.defaultProps, a) void 0 === d[b] && (d[b] = a[b]);
    return { $$typeof: k, type: c, key: e, ref: h, props: d, _owner: n2.current };
  }
  reactJsxRuntime_production_min.Fragment = l;
  reactJsxRuntime_production_min.jsx = q;
  reactJsxRuntime_production_min.jsxs = q;
  return reactJsxRuntime_production_min;
}
var reactJsxRuntime_development = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_development;
function requireReactJsxRuntime_development() {
  if (hasRequiredReactJsxRuntime_development) return reactJsxRuntime_development;
  hasRequiredReactJsxRuntime_development = 1;
  if (process.env.NODE_ENV !== "production") {
    (function() {
      var React2 = React__default;
      var REACT_ELEMENT_TYPE = Symbol.for("react.element");
      var REACT_PORTAL_TYPE = Symbol.for("react.portal");
      var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
      var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
      var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
      var REACT_CONTEXT_TYPE = Symbol.for("react.context");
      var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
      var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
      var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
      var REACT_MEMO_TYPE = Symbol.for("react.memo");
      var REACT_LAZY_TYPE = Symbol.for("react.lazy");
      var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable !== "object") {
          return null;
        }
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        if (typeof maybeIterator === "function") {
          return maybeIterator;
        }
        return null;
      }
      var ReactSharedInternals = React2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function error2(format2) {
        {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format2, args);
          }
        }
      }
      function printWarning(level, format2, args) {
        {
          var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
          var stack = ReactDebugCurrentFrame2.getStackAddendum();
          if (stack !== "") {
            format2 += "%s";
            args = args.concat([stack]);
          }
          var argsWithFormat = args.map(function(item) {
            return String(item);
          });
          argsWithFormat.unshift("Warning: " + format2);
          Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      var enableScopeAPI = false;
      var enableCacheElement = false;
      var enableTransitionTracing = false;
      var enableLegacyHidden = false;
      var enableDebugTracing = false;
      var REACT_MODULE_REFERENCE;
      {
        REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
      }
      function isValidElementType(type2) {
        if (typeof type2 === "string" || typeof type2 === "function") {
          return true;
        }
        if (type2 === REACT_FRAGMENT_TYPE || type2 === REACT_PROFILER_TYPE || enableDebugTracing || type2 === REACT_STRICT_MODE_TYPE || type2 === REACT_SUSPENSE_TYPE || type2 === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type2 === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
          return true;
        }
        if (typeof type2 === "object" && type2 !== null) {
          if (type2.$$typeof === REACT_LAZY_TYPE || type2.$$typeof === REACT_MEMO_TYPE || type2.$$typeof === REACT_PROVIDER_TYPE || type2.$$typeof === REACT_CONTEXT_TYPE || type2.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
          // types supported by any Flight configuration anywhere since
          // we don't know which Flight build this will end up being used
          // with.
          type2.$$typeof === REACT_MODULE_REFERENCE || type2.getModuleId !== void 0) {
            return true;
          }
        }
        return false;
      }
      function getWrappedName(outerType, innerType, wrapperName) {
        var displayName = outerType.displayName;
        if (displayName) {
          return displayName;
        }
        var functionName = innerType.displayName || innerType.name || "";
        return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
      }
      function getContextName(type2) {
        return type2.displayName || "Context";
      }
      function getComponentNameFromType(type2) {
        if (type2 == null) {
          return null;
        }
        {
          if (typeof type2.tag === "number") {
            error2("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
          }
        }
        if (typeof type2 === "function") {
          return type2.displayName || type2.name || null;
        }
        if (typeof type2 === "string") {
          return type2;
        }
        switch (type2) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if (typeof type2 === "object") {
          switch (type2.$$typeof) {
            case REACT_CONTEXT_TYPE:
              var context = type2;
              return getContextName(context) + ".Consumer";
            case REACT_PROVIDER_TYPE:
              var provider = type2;
              return getContextName(provider._context) + ".Provider";
            case REACT_FORWARD_REF_TYPE:
              return getWrappedName(type2, type2.render, "ForwardRef");
            case REACT_MEMO_TYPE:
              var outerName = type2.displayName || null;
              if (outerName !== null) {
                return outerName;
              }
              return getComponentNameFromType(type2.type) || "Memo";
            case REACT_LAZY_TYPE: {
              var lazyComponent = type2;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;
              try {
                return getComponentNameFromType(init(payload));
              } catch (x) {
                return null;
              }
            }
          }
        }
        return null;
      }
      var assign = Object.assign;
      var disabledDepth = 0;
      var prevLog;
      var prevInfo;
      var prevWarn;
      var prevError;
      var prevGroup;
      var prevGroupCollapsed;
      var prevGroupEnd;
      function disabledLog() {
      }
      disabledLog.__reactDisabledLog = true;
      function disableLogs() {
        {
          if (disabledDepth === 0) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
              configurable: true,
              enumerable: true,
              value: disabledLog,
              writable: true
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
      }
      function reenableLogs() {
        {
          disabledDepth--;
          if (disabledDepth === 0) {
            var props = {
              configurable: true,
              enumerable: true,
              writable: true
            };
            Object.defineProperties(console, {
              log: assign({}, props, {
                value: prevLog
              }),
              info: assign({}, props, {
                value: prevInfo
              }),
              warn: assign({}, props, {
                value: prevWarn
              }),
              error: assign({}, props, {
                value: prevError
              }),
              group: assign({}, props, {
                value: prevGroup
              }),
              groupCollapsed: assign({}, props, {
                value: prevGroupCollapsed
              }),
              groupEnd: assign({}, props, {
                value: prevGroupEnd
              })
            });
          }
          if (disabledDepth < 0) {
            error2("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
          }
        }
      }
      var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
      var prefix;
      function describeBuiltInComponentFrame(name2, source2, ownerFn) {
        {
          if (prefix === void 0) {
            try {
              throw Error();
            } catch (x) {
              var match2 = x.stack.trim().match(/\n( *(at )?)/);
              prefix = match2 && match2[1] || "";
            }
          }
          return "\n" + prefix + name2;
        }
      }
      var reentry = false;
      var componentFrameCache;
      {
        var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
        componentFrameCache = new PossiblyWeakMap();
      }
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry) {
          return "";
        }
        {
          var frame = componentFrameCache.get(fn);
          if (frame !== void 0) {
            return frame;
          }
        }
        var control;
        reentry = true;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var previousDispatcher;
        {
          previousDispatcher = ReactCurrentDispatcher.current;
          ReactCurrentDispatcher.current = null;
          disableLogs();
        }
        try {
          if (construct) {
            var Fake = function() {
              throw Error();
            };
            Object.defineProperty(Fake.prototype, "props", {
              set: function() {
                throw Error();
              }
            });
            if (typeof Reflect === "object" && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x) {
                control = x;
              }
              Reflect.construct(fn, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x) {
                control = x;
              }
              fn.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x) {
              control = x;
            }
            fn();
          }
        } catch (sample) {
          if (sample && control && typeof sample.stack === "string") {
            var sampleLines = sample.stack.split("\n");
            var controlLines = control.stack.split("\n");
            var s2 = sampleLines.length - 1;
            var c = controlLines.length - 1;
            while (s2 >= 1 && c >= 0 && sampleLines[s2] !== controlLines[c]) {
              c--;
            }
            for (; s2 >= 1 && c >= 0; s2--, c--) {
              if (sampleLines[s2] !== controlLines[c]) {
                if (s2 !== 1 || c !== 1) {
                  do {
                    s2--;
                    c--;
                    if (c < 0 || sampleLines[s2] !== controlLines[c]) {
                      var _frame = "\n" + sampleLines[s2].replace(" at new ", " at ");
                      if (fn.displayName && _frame.includes("<anonymous>")) {
                        _frame = _frame.replace("<anonymous>", fn.displayName);
                      }
                      {
                        if (typeof fn === "function") {
                          componentFrameCache.set(fn, _frame);
                        }
                      }
                      return _frame;
                    }
                  } while (s2 >= 1 && c >= 0);
                }
                break;
              }
            }
          }
        } finally {
          reentry = false;
          {
            ReactCurrentDispatcher.current = previousDispatcher;
            reenableLogs();
          }
          Error.prepareStackTrace = previousPrepareStackTrace;
        }
        var name2 = fn ? fn.displayName || fn.name : "";
        var syntheticFrame = name2 ? describeBuiltInComponentFrame(name2) : "";
        {
          if (typeof fn === "function") {
            componentFrameCache.set(fn, syntheticFrame);
          }
        }
        return syntheticFrame;
      }
      function describeFunctionComponentFrame(fn, source2, ownerFn) {
        {
          return describeNativeComponentFrame(fn, false);
        }
      }
      function shouldConstruct(Component2) {
        var prototype = Component2.prototype;
        return !!(prototype && prototype.isReactComponent);
      }
      function describeUnknownElementTypeFrameInDEV(type2, source2, ownerFn) {
        if (type2 == null) {
          return "";
        }
        if (typeof type2 === "function") {
          {
            return describeNativeComponentFrame(type2, shouldConstruct(type2));
          }
        }
        if (typeof type2 === "string") {
          return describeBuiltInComponentFrame(type2);
        }
        switch (type2) {
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame("Suspense");
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
        }
        if (typeof type2 === "object") {
          switch (type2.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeFunctionComponentFrame(type2.render);
            case REACT_MEMO_TYPE:
              return describeUnknownElementTypeFrameInDEV(type2.type, source2, ownerFn);
            case REACT_LAZY_TYPE: {
              var lazyComponent = type2;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;
              try {
                return describeUnknownElementTypeFrameInDEV(init(payload), source2, ownerFn);
              } catch (x) {
              }
            }
          }
        }
        return "";
      }
      var hasOwnProperty2 = Object.prototype.hasOwnProperty;
      var loggedTypeFailures = {};
      var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement(element) {
        {
          if (element) {
            var owner2 = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner2 ? owner2.type : null);
            ReactDebugCurrentFrame.setExtraStackFrame(stack);
          } else {
            ReactDebugCurrentFrame.setExtraStackFrame(null);
          }
        }
      }
      function checkPropTypes(typeSpecs, values, location2, componentName, element) {
        {
          var has2 = Function.call.bind(hasOwnProperty2);
          for (var typeSpecName in typeSpecs) {
            if (has2(typeSpecs, typeSpecName)) {
              var error$1 = void 0;
              try {
                if (typeof typeSpecs[typeSpecName] !== "function") {
                  var err = Error((componentName || "React class") + ": " + location2 + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  err.name = "Invariant Violation";
                  throw err;
                }
                error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location2, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ex) {
                error$1 = ex;
              }
              if (error$1 && !(error$1 instanceof Error)) {
                setCurrentlyValidatingElement(element);
                error2("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location2, typeSpecName, typeof error$1);
                setCurrentlyValidatingElement(null);
              }
              if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                loggedTypeFailures[error$1.message] = true;
                setCurrentlyValidatingElement(element);
                error2("Failed %s type: %s", location2, error$1.message);
                setCurrentlyValidatingElement(null);
              }
            }
          }
        }
      }
      var isArrayImpl = Array.isArray;
      function isArray2(a) {
        return isArrayImpl(a);
      }
      function typeName(value2) {
        {
          var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
          var type2 = hasToStringTag && value2[Symbol.toStringTag] || value2.constructor.name || "Object";
          return type2;
        }
      }
      function willCoercionThrow(value2) {
        {
          try {
            testStringCoercion(value2);
            return false;
          } catch (e) {
            return true;
          }
        }
      }
      function testStringCoercion(value2) {
        return "" + value2;
      }
      function checkKeyStringCoercion(value2) {
        {
          if (willCoercionThrow(value2)) {
            error2("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value2));
            return testStringCoercion(value2);
          }
        }
      }
      var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
      var RESERVED_PROPS = {
        key: true,
        ref: true,
        __self: true,
        __source: true
      };
      var specialPropKeyWarningShown;
      var specialPropRefWarningShown;
      function hasValidRef(config) {
        {
          if (hasOwnProperty2.call(config, "ref")) {
            var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
            if (getter && getter.isReactWarning) {
              return false;
            }
          }
        }
        return config.ref !== void 0;
      }
      function hasValidKey(config) {
        {
          if (hasOwnProperty2.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) {
              return false;
            }
          }
        }
        return config.key !== void 0;
      }
      function warnIfStringRefCannotBeAutoConverted(config, self2) {
        {
          if (typeof config.ref === "string" && ReactCurrentOwner.current && self2) ;
        }
      }
      function defineKeyPropWarningGetter(props, displayName) {
        {
          var warnAboutAccessingKey = function() {
            if (!specialPropKeyWarningShown) {
              specialPropKeyWarningShown = true;
              error2("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
            }
          };
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
      }
      function defineRefPropWarningGetter(props, displayName) {
        {
          var warnAboutAccessingRef = function() {
            if (!specialPropRefWarningShown) {
              specialPropRefWarningShown = true;
              error2("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
            }
          };
          warnAboutAccessingRef.isReactWarning = true;
          Object.defineProperty(props, "ref", {
            get: warnAboutAccessingRef,
            configurable: true
          });
        }
      }
      var ReactElement = function(type2, key, ref, self2, source2, owner2, props) {
        var element = {
          // This tag allows us to uniquely identify this as a React Element
          $$typeof: REACT_ELEMENT_TYPE,
          // Built-in properties that belong on the element
          type: type2,
          key,
          ref,
          props,
          // Record the component responsible for creating this element.
          _owner: owner2
        };
        {
          element._store = {};
          Object.defineProperty(element._store, "validated", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: false
          });
          Object.defineProperty(element, "_self", {
            configurable: false,
            enumerable: false,
            writable: false,
            value: self2
          });
          Object.defineProperty(element, "_source", {
            configurable: false,
            enumerable: false,
            writable: false,
            value: source2
          });
          if (Object.freeze) {
            Object.freeze(element.props);
            Object.freeze(element);
          }
        }
        return element;
      };
      function jsxDEV(type2, config, maybeKey, source2, self2) {
        {
          var propName;
          var props = {};
          var key = null;
          var ref = null;
          if (maybeKey !== void 0) {
            {
              checkKeyStringCoercion(maybeKey);
            }
            key = "" + maybeKey;
          }
          if (hasValidKey(config)) {
            {
              checkKeyStringCoercion(config.key);
            }
            key = "" + config.key;
          }
          if (hasValidRef(config)) {
            ref = config.ref;
            warnIfStringRefCannotBeAutoConverted(config, self2);
          }
          for (propName in config) {
            if (hasOwnProperty2.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
              props[propName] = config[propName];
            }
          }
          if (type2 && type2.defaultProps) {
            var defaultProps = type2.defaultProps;
            for (propName in defaultProps) {
              if (props[propName] === void 0) {
                props[propName] = defaultProps[propName];
              }
            }
          }
          if (key || ref) {
            var displayName = typeof type2 === "function" ? type2.displayName || type2.name || "Unknown" : type2;
            if (key) {
              defineKeyPropWarningGetter(props, displayName);
            }
            if (ref) {
              defineRefPropWarningGetter(props, displayName);
            }
          }
          return ReactElement(type2, key, ref, self2, source2, ReactCurrentOwner.current, props);
        }
      }
      var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
      var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement$1(element) {
        {
          if (element) {
            var owner2 = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner2 ? owner2.type : null);
            ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
          } else {
            ReactDebugCurrentFrame$1.setExtraStackFrame(null);
          }
        }
      }
      var propTypesMisspellWarningShown;
      {
        propTypesMisspellWarningShown = false;
      }
      function isValidElement(object) {
        {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
      }
      function getDeclarationErrorAddendum() {
        {
          if (ReactCurrentOwner$1.current) {
            var name2 = getComponentNameFromType(ReactCurrentOwner$1.current.type);
            if (name2) {
              return "\n\nCheck the render method of `" + name2 + "`.";
            }
          }
          return "";
        }
      }
      function getSourceInfoErrorAddendum(source2) {
        {
          return "";
        }
      }
      var ownerHasKeyUseWarning = {};
      function getCurrentComponentErrorInfo(parentType) {
        {
          var info = getDeclarationErrorAddendum();
          if (!info) {
            var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
            if (parentName) {
              info = "\n\nCheck the top-level render call using <" + parentName + ">.";
            }
          }
          return info;
        }
      }
      function validateExplicitKey(element, parentType) {
        {
          if (!element._store || element._store.validated || element.key != null) {
            return;
          }
          element._store.validated = true;
          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            return;
          }
          ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
          var childOwner = "";
          if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
            childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
          }
          setCurrentlyValidatingElement$1(element);
          error2('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
          setCurrentlyValidatingElement$1(null);
        }
      }
      function validateChildKeys(node, parentType) {
        {
          if (typeof node !== "object") {
            return;
          }
          if (isArray2(node)) {
            for (var i2 = 0; i2 < node.length; i2++) {
              var child = node[i2];
              if (isValidElement(child)) {
                validateExplicitKey(child, parentType);
              }
            }
          } else if (isValidElement(node)) {
            if (node._store) {
              node._store.validated = true;
            }
          } else if (node) {
            var iteratorFn = getIteratorFn(node);
            if (typeof iteratorFn === "function") {
              if (iteratorFn !== node.entries) {
                var iterator = iteratorFn.call(node);
                var step;
                while (!(step = iterator.next()).done) {
                  if (isValidElement(step.value)) {
                    validateExplicitKey(step.value, parentType);
                  }
                }
              }
            }
          }
        }
      }
      function validatePropTypes(element) {
        {
          var type2 = element.type;
          if (type2 === null || type2 === void 0 || typeof type2 === "string") {
            return;
          }
          var propTypes2;
          if (typeof type2 === "function") {
            propTypes2 = type2.propTypes;
          } else if (typeof type2 === "object" && (type2.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
          // Inner props are checked in the reconciler.
          type2.$$typeof === REACT_MEMO_TYPE)) {
            propTypes2 = type2.propTypes;
          } else {
            return;
          }
          if (propTypes2) {
            var name2 = getComponentNameFromType(type2);
            checkPropTypes(propTypes2, element.props, "prop", name2, element);
          } else if (type2.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
            propTypesMisspellWarningShown = true;
            var _name = getComponentNameFromType(type2);
            error2("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
          }
          if (typeof type2.getDefaultProps === "function" && !type2.getDefaultProps.isReactClassApproved) {
            error2("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
          }
        }
      }
      function validateFragmentProps(fragment2) {
        {
          var keys2 = Object.keys(fragment2.props);
          for (var i2 = 0; i2 < keys2.length; i2++) {
            var key = keys2[i2];
            if (key !== "children" && key !== "key") {
              setCurrentlyValidatingElement$1(fragment2);
              error2("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
              setCurrentlyValidatingElement$1(null);
              break;
            }
          }
          if (fragment2.ref !== null) {
            setCurrentlyValidatingElement$1(fragment2);
            error2("Invalid attribute `ref` supplied to `React.Fragment`.");
            setCurrentlyValidatingElement$1(null);
          }
        }
      }
      var didWarnAboutKeySpread = {};
      function jsxWithValidation(type2, props, key, isStaticChildren, source2, self2) {
        {
          var validType = isValidElementType(type2);
          if (!validType) {
            var info = "";
            if (type2 === void 0 || typeof type2 === "object" && type2 !== null && Object.keys(type2).length === 0) {
              info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            }
            var sourceInfo = getSourceInfoErrorAddendum();
            if (sourceInfo) {
              info += sourceInfo;
            } else {
              info += getDeclarationErrorAddendum();
            }
            var typeString;
            if (type2 === null) {
              typeString = "null";
            } else if (isArray2(type2)) {
              typeString = "array";
            } else if (type2 !== void 0 && type2.$$typeof === REACT_ELEMENT_TYPE) {
              typeString = "<" + (getComponentNameFromType(type2.type) || "Unknown") + " />";
              info = " Did you accidentally export a JSX literal instead of a component?";
            } else {
              typeString = typeof type2;
            }
            error2("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
          }
          var element = jsxDEV(type2, props, key, source2, self2);
          if (element == null) {
            return element;
          }
          if (validType) {
            var children = props.children;
            if (children !== void 0) {
              if (isStaticChildren) {
                if (isArray2(children)) {
                  for (var i2 = 0; i2 < children.length; i2++) {
                    validateChildKeys(children[i2], type2);
                  }
                  if (Object.freeze) {
                    Object.freeze(children);
                  }
                } else {
                  error2("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
                }
              } else {
                validateChildKeys(children, type2);
              }
            }
          }
          {
            if (hasOwnProperty2.call(props, "key")) {
              var componentName = getComponentNameFromType(type2);
              var keys2 = Object.keys(props).filter(function(k) {
                return k !== "key";
              });
              var beforeExample = keys2.length > 0 ? "{key: someKey, " + keys2.join(": ..., ") + ": ...}" : "{key: someKey}";
              if (!didWarnAboutKeySpread[componentName + beforeExample]) {
                var afterExample = keys2.length > 0 ? "{" + keys2.join(": ..., ") + ": ...}" : "{}";
                error2('A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);
                didWarnAboutKeySpread[componentName + beforeExample] = true;
              }
            }
          }
          if (type2 === REACT_FRAGMENT_TYPE) {
            validateFragmentProps(element);
          } else {
            validatePropTypes(element);
          }
          return element;
        }
      }
      function jsxWithValidationStatic(type2, props, key) {
        {
          return jsxWithValidation(type2, props, key, true);
        }
      }
      function jsxWithValidationDynamic(type2, props, key) {
        {
          return jsxWithValidation(type2, props, key, false);
        }
      }
      var jsx = jsxWithValidationDynamic;
      var jsxs = jsxWithValidationStatic;
      reactJsxRuntime_development.Fragment = REACT_FRAGMENT_TYPE;
      reactJsxRuntime_development.jsx = jsx;
      reactJsxRuntime_development.jsxs = jsxs;
    })();
  }
  return reactJsxRuntime_development;
}
var hasRequiredJsxRuntime;
function requireJsxRuntime() {
  if (hasRequiredJsxRuntime) return jsxRuntime.exports;
  hasRequiredJsxRuntime = 1;
  if (process.env.NODE_ENV === "production") {
    jsxRuntime.exports = requireReactJsxRuntime_production_min();
  } else {
    jsxRuntime.exports = requireReactJsxRuntime_development();
  }
  return jsxRuntime.exports;
}
var jsxRuntimeExports = requireJsxRuntime();
function toDate(argument) {
  const argStr = Object.prototype.toString.call(argument);
  if (argument instanceof Date || typeof argument === "object" && argStr === "[object Date]") {
    return new argument.constructor(+argument);
  } else if (typeof argument === "number" || argStr === "[object Number]" || typeof argument === "string" || argStr === "[object String]") {
    return new Date(argument);
  } else {
    return /* @__PURE__ */ new Date(NaN);
  }
}
function constructFrom(date, value2) {
  if (date instanceof Date) {
    return new date.constructor(value2);
  } else {
    return new Date(value2);
  }
}
function addDays(date, amount) {
  const _date = toDate(date);
  if (isNaN(amount)) return constructFrom(date, NaN);
  if (!amount) {
    return _date;
  }
  _date.setDate(_date.getDate() + amount);
  return _date;
}
function addMonths(date, amount) {
  const _date = toDate(date);
  if (isNaN(amount)) return constructFrom(date, NaN);
  if (!amount) {
    return _date;
  }
  const dayOfMonth = _date.getDate();
  const endOfDesiredMonth = constructFrom(date, _date.getTime());
  endOfDesiredMonth.setMonth(_date.getMonth() + amount + 1, 0);
  const daysInMonth = endOfDesiredMonth.getDate();
  if (dayOfMonth >= daysInMonth) {
    return endOfDesiredMonth;
  } else {
    _date.setFullYear(
      endOfDesiredMonth.getFullYear(),
      endOfDesiredMonth.getMonth(),
      dayOfMonth
    );
    return _date;
  }
}
const millisecondsInWeek = 6048e5;
const millisecondsInDay = 864e5;
const millisecondsInMinute = 6e4;
const millisecondsInHour = 36e5;
let defaultOptions$1 = {};
function getDefaultOptions() {
  return defaultOptions$1;
}
function startOfWeek(date, options) {
  var _a, _b, _c, _d;
  const defaultOptions2 = getDefaultOptions();
  const weekStartsOn = (options == null ? void 0 : options.weekStartsOn) ?? ((_b = (_a = options == null ? void 0 : options.locale) == null ? void 0 : _a.options) == null ? void 0 : _b.weekStartsOn) ?? defaultOptions2.weekStartsOn ?? ((_d = (_c = defaultOptions2.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.weekStartsOn) ?? 0;
  const _date = toDate(date);
  const day2 = _date.getDay();
  const diff = (day2 < weekStartsOn ? 7 : 0) + day2 - weekStartsOn;
  _date.setDate(_date.getDate() - diff);
  _date.setHours(0, 0, 0, 0);
  return _date;
}
function startOfISOWeek(date) {
  return startOfWeek(date, { weekStartsOn: 1 });
}
function getISOWeekYear(date) {
  const _date = toDate(date);
  const year = _date.getFullYear();
  const fourthOfJanuaryOfNextYear = constructFrom(date, 0);
  fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
  const startOfNextYear = startOfISOWeek(fourthOfJanuaryOfNextYear);
  const fourthOfJanuaryOfThisYear = constructFrom(date, 0);
  fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
  const startOfThisYear = startOfISOWeek(fourthOfJanuaryOfThisYear);
  if (_date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (_date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
function startOfDay(date) {
  const _date = toDate(date);
  _date.setHours(0, 0, 0, 0);
  return _date;
}
function getTimezoneOffsetInMilliseconds(date) {
  const _date = toDate(date);
  const utcDate = new Date(
    Date.UTC(
      _date.getFullYear(),
      _date.getMonth(),
      _date.getDate(),
      _date.getHours(),
      _date.getMinutes(),
      _date.getSeconds(),
      _date.getMilliseconds()
    )
  );
  utcDate.setUTCFullYear(_date.getFullYear());
  return +date - +utcDate;
}
function differenceInCalendarDays(dateLeft, dateRight) {
  const startOfDayLeft = startOfDay(dateLeft);
  const startOfDayRight = startOfDay(dateRight);
  const timestampLeft = +startOfDayLeft - getTimezoneOffsetInMilliseconds(startOfDayLeft);
  const timestampRight = +startOfDayRight - getTimezoneOffsetInMilliseconds(startOfDayRight);
  return Math.round((timestampLeft - timestampRight) / millisecondsInDay);
}
function startOfISOWeekYear(date) {
  const year = getISOWeekYear(date);
  const fourthOfJanuary = constructFrom(date, 0);
  fourthOfJanuary.setFullYear(year, 0, 4);
  fourthOfJanuary.setHours(0, 0, 0, 0);
  return startOfISOWeek(fourthOfJanuary);
}
function addWeeks(date, amount) {
  const days2 = amount * 7;
  return addDays(date, days2);
}
function addYears(date, amount) {
  return addMonths(date, amount * 12);
}
function max$4(dates) {
  let result;
  dates.forEach(function(dirtyDate) {
    const currentDate = toDate(dirtyDate);
    if (result === void 0 || result < currentDate || isNaN(Number(currentDate))) {
      result = currentDate;
    }
  });
  return result || /* @__PURE__ */ new Date(NaN);
}
function min$4(dates) {
  let result;
  dates.forEach((dirtyDate) => {
    const date = toDate(dirtyDate);
    if (!result || result > date || isNaN(+date)) {
      result = date;
    }
  });
  return result || /* @__PURE__ */ new Date(NaN);
}
function isSameDay(dateLeft, dateRight) {
  const dateLeftStartOfDay = startOfDay(dateLeft);
  const dateRightStartOfDay = startOfDay(dateRight);
  return +dateLeftStartOfDay === +dateRightStartOfDay;
}
function isDate(value2) {
  return value2 instanceof Date || typeof value2 === "object" && Object.prototype.toString.call(value2) === "[object Date]";
}
function isValid$1(date) {
  if (!isDate(date) && typeof date !== "number") {
    return false;
  }
  const _date = toDate(date);
  return !isNaN(Number(_date));
}
function differenceInCalendarMonths(dateLeft, dateRight) {
  const _dateLeft = toDate(dateLeft);
  const _dateRight = toDate(dateRight);
  const yearDiff = _dateLeft.getFullYear() - _dateRight.getFullYear();
  const monthDiff = _dateLeft.getMonth() - _dateRight.getMonth();
  return yearDiff * 12 + monthDiff;
}
function differenceInCalendarWeeks(dateLeft, dateRight, options) {
  const startOfWeekLeft = startOfWeek(dateLeft, options);
  const startOfWeekRight = startOfWeek(dateRight, options);
  const timestampLeft = +startOfWeekLeft - getTimezoneOffsetInMilliseconds(startOfWeekLeft);
  const timestampRight = +startOfWeekRight - getTimezoneOffsetInMilliseconds(startOfWeekRight);
  return Math.round((timestampLeft - timestampRight) / millisecondsInWeek);
}
function endOfDay(date) {
  const _date = toDate(date);
  _date.setHours(23, 59, 59, 999);
  return _date;
}
function endOfMonth(date) {
  const _date = toDate(date);
  const month2 = _date.getMonth();
  _date.setFullYear(_date.getFullYear(), month2 + 1, 0);
  _date.setHours(23, 59, 59, 999);
  return _date;
}
function startOfMonth(date) {
  const _date = toDate(date);
  _date.setDate(1);
  _date.setHours(0, 0, 0, 0);
  return _date;
}
function startOfYear(date) {
  const cleanDate = toDate(date);
  const _date = constructFrom(date, 0);
  _date.setFullYear(cleanDate.getFullYear(), 0, 1);
  _date.setHours(0, 0, 0, 0);
  return _date;
}
function endOfWeek(date, options) {
  var _a, _b, _c, _d;
  const defaultOptions2 = getDefaultOptions();
  const weekStartsOn = (options == null ? void 0 : options.weekStartsOn) ?? ((_b = (_a = options == null ? void 0 : options.locale) == null ? void 0 : _a.options) == null ? void 0 : _b.weekStartsOn) ?? defaultOptions2.weekStartsOn ?? ((_d = (_c = defaultOptions2.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.weekStartsOn) ?? 0;
  const _date = toDate(date);
  const day2 = _date.getDay();
  const diff = (day2 < weekStartsOn ? -7 : 0) + 6 - (day2 - weekStartsOn);
  _date.setDate(_date.getDate() + diff);
  _date.setHours(23, 59, 59, 999);
  return _date;
}
function endOfISOWeek(date) {
  return endOfWeek(date, { weekStartsOn: 1 });
}
const formatDistanceLocale = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
};
const formatDistance = (token, count2, options) => {
  let result;
  const tokenValue = formatDistanceLocale[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count2 === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count2.toString());
  }
  if (options == null ? void 0 : options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "in " + result;
    } else {
      return result + " ago";
    }
  }
  return result;
};
function buildFormatLongFn(args) {
  return (options = {}) => {
    const width = options.width ? String(options.width) : args.defaultWidth;
    const format2 = args.formats[width] || args.formats[args.defaultWidth];
    return format2;
  };
}
const dateFormats = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
const timeFormats = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
const dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: "full"
  })
};
const formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
};
const formatRelative = (token, _date, _baseDate, _options) => formatRelativeLocale[token];
function buildLocalizeFn(args) {
  return (value2, options) => {
    const context = (options == null ? void 0 : options.context) ? String(options.context) : "standalone";
    let valuesArray;
    if (context === "formatting" && args.formattingValues) {
      const defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      const width = (options == null ? void 0 : options.width) ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      const defaultWidth = args.defaultWidth;
      const width = (options == null ? void 0 : options.width) ? String(options.width) : args.defaultWidth;
      valuesArray = args.values[width] || args.values[defaultWidth];
    }
    const index2 = args.argumentCallback ? args.argumentCallback(value2) : value2;
    return valuesArray[index2];
  };
}
const eraValues = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
};
const quarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
};
const monthValues = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ],
  wide: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ]
};
const dayValues = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ]
};
const dayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
};
const formattingDayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
};
const ordinalNumber = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);
  const rem100 = number % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + "st";
      case 2:
        return number + "nd";
      case 3:
        return number + "rd";
    }
  }
  return number + "th";
};
const localize = {
  ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: "wide"
  })
};
function buildMatchFn(args) {
  return (string, options = {}) => {
    const width = options.width;
    const matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    const matchResult = string.match(matchPattern);
    if (!matchResult) {
      return null;
    }
    const matchedString = matchResult[0];
    const parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    const key = Array.isArray(parsePatterns) ? findIndex$1(parsePatterns, (pattern) => pattern.test(matchedString)) : (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
      findKey(parsePatterns, (pattern) => pattern.test(matchedString))
    );
    let value2;
    value2 = args.valueCallback ? args.valueCallback(key) : key;
    value2 = options.valueCallback ? (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
      options.valueCallback(value2)
    ) : value2;
    const rest = string.slice(matchedString.length);
    return { value: value2, rest };
  };
}
function findKey(object, predicate) {
  for (const key in object) {
    if (Object.prototype.hasOwnProperty.call(object, key) && predicate(object[key])) {
      return key;
    }
  }
  return void 0;
}
function findIndex$1(array, predicate) {
  for (let key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }
  return void 0;
}
function buildMatchPatternFn(args) {
  return (string, options = {}) => {
    const matchResult = string.match(args.matchPattern);
    if (!matchResult) return null;
    const matchedString = matchResult[0];
    const parseResult = string.match(args.parsePattern);
    if (!parseResult) return null;
    let value2 = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value2 = options.valueCallback ? options.valueCallback(value2) : value2;
    const rest = string.slice(matchedString.length);
    return { value: value2, rest };
  };
}
const matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
const parseOrdinalNumberPattern = /\d+/i;
const matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
const parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
const matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
const parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
const parseMonthPatterns = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^may/i,
    /^jun/i,
    /^jul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
const matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
const parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
const matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
const parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
const match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: (value2) => parseInt(value2, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: "any"
  })
};
const enUS = {
  code: "en-US",
  formatDistance,
  formatLong,
  formatRelative,
  localize,
  match,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
function getDayOfYear(date) {
  const _date = toDate(date);
  const diff = differenceInCalendarDays(_date, startOfYear(_date));
  const dayOfYear = diff + 1;
  return dayOfYear;
}
function getISOWeek(date) {
  const _date = toDate(date);
  const diff = +startOfISOWeek(_date) - +startOfISOWeekYear(_date);
  return Math.round(diff / millisecondsInWeek) + 1;
}
function getWeekYear(date, options) {
  var _a, _b, _c, _d;
  const _date = toDate(date);
  const year = _date.getFullYear();
  const defaultOptions2 = getDefaultOptions();
  const firstWeekContainsDate = (options == null ? void 0 : options.firstWeekContainsDate) ?? ((_b = (_a = options == null ? void 0 : options.locale) == null ? void 0 : _a.options) == null ? void 0 : _b.firstWeekContainsDate) ?? defaultOptions2.firstWeekContainsDate ?? ((_d = (_c = defaultOptions2.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.firstWeekContainsDate) ?? 1;
  const firstWeekOfNextYear = constructFrom(date, 0);
  firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setHours(0, 0, 0, 0);
  const startOfNextYear = startOfWeek(firstWeekOfNextYear, options);
  const firstWeekOfThisYear = constructFrom(date, 0);
  firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setHours(0, 0, 0, 0);
  const startOfThisYear = startOfWeek(firstWeekOfThisYear, options);
  if (_date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (_date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
function startOfWeekYear(date, options) {
  var _a, _b, _c, _d;
  const defaultOptions2 = getDefaultOptions();
  const firstWeekContainsDate = (options == null ? void 0 : options.firstWeekContainsDate) ?? ((_b = (_a = options == null ? void 0 : options.locale) == null ? void 0 : _a.options) == null ? void 0 : _b.firstWeekContainsDate) ?? defaultOptions2.firstWeekContainsDate ?? ((_d = (_c = defaultOptions2.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.firstWeekContainsDate) ?? 1;
  const year = getWeekYear(date, options);
  const firstWeek = constructFrom(date, 0);
  firstWeek.setFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setHours(0, 0, 0, 0);
  const _date = startOfWeek(firstWeek, options);
  return _date;
}
function getWeek(date, options) {
  const _date = toDate(date);
  const diff = +startOfWeek(_date, options) - +startOfWeekYear(_date, options);
  return Math.round(diff / millisecondsInWeek) + 1;
}
function addLeadingZeros(number, targetLength) {
  const sign = number < 0 ? "-" : "";
  const output = Math.abs(number).toString().padStart(targetLength, "0");
  return sign + output;
}
const lightFormatters = {
  // Year
  y(date, token) {
    const signedYear = date.getFullYear();
    const year = signedYear > 0 ? signedYear : 1 - signedYear;
    return addLeadingZeros(token === "yy" ? year % 100 : year, token.length);
  },
  // Month
  M(date, token) {
    const month2 = date.getMonth();
    return token === "M" ? String(month2 + 1) : addLeadingZeros(month2 + 1, 2);
  },
  // Day of the month
  d(date, token) {
    return addLeadingZeros(date.getDate(), token.length);
  },
  // AM or PM
  a(date, token) {
    const dayPeriodEnumValue = date.getHours() / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
        return dayPeriodEnumValue.toUpperCase();
      case "aaa":
        return dayPeriodEnumValue;
      case "aaaaa":
        return dayPeriodEnumValue[0];
      case "aaaa":
      default:
        return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
    }
  },
  // Hour [1-12]
  h(date, token) {
    return addLeadingZeros(date.getHours() % 12 || 12, token.length);
  },
  // Hour [0-23]
  H(date, token) {
    return addLeadingZeros(date.getHours(), token.length);
  },
  // Minute
  m(date, token) {
    return addLeadingZeros(date.getMinutes(), token.length);
  },
  // Second
  s(date, token) {
    return addLeadingZeros(date.getSeconds(), token.length);
  },
  // Fraction of second
  S(date, token) {
    const numberOfDigits = token.length;
    const milliseconds = date.getMilliseconds();
    const fractionalSeconds = Math.trunc(
      milliseconds * Math.pow(10, numberOfDigits - 3)
    );
    return addLeadingZeros(fractionalSeconds, token.length);
  }
};
const dayPeriodEnum = {
  am: "am",
  pm: "pm",
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
};
const formatters$1 = {
  // Era
  G: function(date, token, localize2) {
    const era = date.getFullYear() > 0 ? 1 : 0;
    switch (token) {
      // AD, BC
      case "G":
      case "GG":
      case "GGG":
        return localize2.era(era, { width: "abbreviated" });
      // A, B
      case "GGGGG":
        return localize2.era(era, { width: "narrow" });
      // Anno Domini, Before Christ
      case "GGGG":
      default:
        return localize2.era(era, { width: "wide" });
    }
  },
  // Year
  y: function(date, token, localize2) {
    if (token === "yo") {
      const signedYear = date.getFullYear();
      const year = signedYear > 0 ? signedYear : 1 - signedYear;
      return localize2.ordinalNumber(year, { unit: "year" });
    }
    return lightFormatters.y(date, token);
  },
  // Local week-numbering year
  Y: function(date, token, localize2, options) {
    const signedWeekYear = getWeekYear(date, options);
    const weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
    if (token === "YY") {
      const twoDigitYear = weekYear % 100;
      return addLeadingZeros(twoDigitYear, 2);
    }
    if (token === "Yo") {
      return localize2.ordinalNumber(weekYear, { unit: "year" });
    }
    return addLeadingZeros(weekYear, token.length);
  },
  // ISO week-numbering year
  R: function(date, token) {
    const isoWeekYear = getISOWeekYear(date);
    return addLeadingZeros(isoWeekYear, token.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function(date, token) {
    const year = date.getFullYear();
    return addLeadingZeros(year, token.length);
  },
  // Quarter
  Q: function(date, token, localize2) {
    const quarter = Math.ceil((date.getMonth() + 1) / 3);
    switch (token) {
      // 1, 2, 3, 4
      case "Q":
        return String(quarter);
      // 01, 02, 03, 04
      case "QQ":
        return addLeadingZeros(quarter, 2);
      // 1st, 2nd, 3rd, 4th
      case "Qo":
        return localize2.ordinalNumber(quarter, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "QQQ":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "formatting"
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "QQQQQ":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "formatting"
        });
      // 1st quarter, 2nd quarter, ...
      case "QQQQ":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone quarter
  q: function(date, token, localize2) {
    const quarter = Math.ceil((date.getMonth() + 1) / 3);
    switch (token) {
      // 1, 2, 3, 4
      case "q":
        return String(quarter);
      // 01, 02, 03, 04
      case "qq":
        return addLeadingZeros(quarter, 2);
      // 1st, 2nd, 3rd, 4th
      case "qo":
        return localize2.ordinalNumber(quarter, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "qqq":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "standalone"
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "qqqqq":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "standalone"
        });
      // 1st quarter, 2nd quarter, ...
      case "qqqq":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // Month
  M: function(date, token, localize2) {
    const month2 = date.getMonth();
    switch (token) {
      case "M":
      case "MM":
        return lightFormatters.M(date, token);
      // 1st, 2nd, ..., 12th
      case "Mo":
        return localize2.ordinalNumber(month2 + 1, { unit: "month" });
      // Jan, Feb, ..., Dec
      case "MMM":
        return localize2.month(month2, {
          width: "abbreviated",
          context: "formatting"
        });
      // J, F, ..., D
      case "MMMMM":
        return localize2.month(month2, {
          width: "narrow",
          context: "formatting"
        });
      // January, February, ..., December
      case "MMMM":
      default:
        return localize2.month(month2, { width: "wide", context: "formatting" });
    }
  },
  // Stand-alone month
  L: function(date, token, localize2) {
    const month2 = date.getMonth();
    switch (token) {
      // 1, 2, ..., 12
      case "L":
        return String(month2 + 1);
      // 01, 02, ..., 12
      case "LL":
        return addLeadingZeros(month2 + 1, 2);
      // 1st, 2nd, ..., 12th
      case "Lo":
        return localize2.ordinalNumber(month2 + 1, { unit: "month" });
      // Jan, Feb, ..., Dec
      case "LLL":
        return localize2.month(month2, {
          width: "abbreviated",
          context: "standalone"
        });
      // J, F, ..., D
      case "LLLLL":
        return localize2.month(month2, {
          width: "narrow",
          context: "standalone"
        });
      // January, February, ..., December
      case "LLLL":
      default:
        return localize2.month(month2, { width: "wide", context: "standalone" });
    }
  },
  // Local week of year
  w: function(date, token, localize2, options) {
    const week2 = getWeek(date, options);
    if (token === "wo") {
      return localize2.ordinalNumber(week2, { unit: "week" });
    }
    return addLeadingZeros(week2, token.length);
  },
  // ISO week of year
  I: function(date, token, localize2) {
    const isoWeek = getISOWeek(date);
    if (token === "Io") {
      return localize2.ordinalNumber(isoWeek, { unit: "week" });
    }
    return addLeadingZeros(isoWeek, token.length);
  },
  // Day of the month
  d: function(date, token, localize2) {
    if (token === "do") {
      return localize2.ordinalNumber(date.getDate(), { unit: "date" });
    }
    return lightFormatters.d(date, token);
  },
  // Day of year
  D: function(date, token, localize2) {
    const dayOfYear = getDayOfYear(date);
    if (token === "Do") {
      return localize2.ordinalNumber(dayOfYear, { unit: "dayOfYear" });
    }
    return addLeadingZeros(dayOfYear, token.length);
  },
  // Day of week
  E: function(date, token, localize2) {
    const dayOfWeek = date.getDay();
    switch (token) {
      // Tue
      case "E":
      case "EE":
      case "EEE":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      // T
      case "EEEEE":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "EEEEEE":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      // Tuesday
      case "EEEE":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Local day of week
  e: function(date, token, localize2, options) {
    const dayOfWeek = date.getDay();
    const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      // Numerical value (Nth day of week with current locale or weekStartsOn)
      case "e":
        return String(localDayOfWeek);
      // Padded numerical value
      case "ee":
        return addLeadingZeros(localDayOfWeek, 2);
      // 1st, 2nd, ..., 7th
      case "eo":
        return localize2.ordinalNumber(localDayOfWeek, { unit: "day" });
      case "eee":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      // T
      case "eeeee":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "eeeeee":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      // Tuesday
      case "eeee":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone local day of week
  c: function(date, token, localize2, options) {
    const dayOfWeek = date.getDay();
    const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      // Numerical value (same as in `e`)
      case "c":
        return String(localDayOfWeek);
      // Padded numerical value
      case "cc":
        return addLeadingZeros(localDayOfWeek, token.length);
      // 1st, 2nd, ..., 7th
      case "co":
        return localize2.ordinalNumber(localDayOfWeek, { unit: "day" });
      case "ccc":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "standalone"
        });
      // T
      case "ccccc":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "standalone"
        });
      // Tu
      case "cccccc":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "standalone"
        });
      // Tuesday
      case "cccc":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // ISO day of week
  i: function(date, token, localize2) {
    const dayOfWeek = date.getDay();
    const isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
    switch (token) {
      // 2
      case "i":
        return String(isoDayOfWeek);
      // 02
      case "ii":
        return addLeadingZeros(isoDayOfWeek, token.length);
      // 2nd
      case "io":
        return localize2.ordinalNumber(isoDayOfWeek, { unit: "day" });
      // Tue
      case "iii":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      // T
      case "iiiii":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "iiiiii":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      // Tuesday
      case "iiii":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM or PM
  a: function(date, token, localize2) {
    const hours2 = date.getHours();
    const dayPeriodEnumValue = hours2 / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM, PM, midnight, noon
  b: function(date, token, localize2) {
    const hours2 = date.getHours();
    let dayPeriodEnumValue;
    if (hours2 === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon;
    } else if (hours2 === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight;
    } else {
      dayPeriodEnumValue = hours2 / 12 >= 1 ? "pm" : "am";
    }
    switch (token) {
      case "b":
      case "bb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function(date, token, localize2) {
    const hours2 = date.getHours();
    let dayPeriodEnumValue;
    if (hours2 >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening;
    } else if (hours2 >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    } else if (hours2 >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night;
    }
    switch (token) {
      case "B":
      case "BB":
      case "BBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Hour [1-12]
  h: function(date, token, localize2) {
    if (token === "ho") {
      let hours2 = date.getHours() % 12;
      if (hours2 === 0) hours2 = 12;
      return localize2.ordinalNumber(hours2, { unit: "hour" });
    }
    return lightFormatters.h(date, token);
  },
  // Hour [0-23]
  H: function(date, token, localize2) {
    if (token === "Ho") {
      return localize2.ordinalNumber(date.getHours(), { unit: "hour" });
    }
    return lightFormatters.H(date, token);
  },
  // Hour [0-11]
  K: function(date, token, localize2) {
    const hours2 = date.getHours() % 12;
    if (token === "Ko") {
      return localize2.ordinalNumber(hours2, { unit: "hour" });
    }
    return addLeadingZeros(hours2, token.length);
  },
  // Hour [1-24]
  k: function(date, token, localize2) {
    let hours2 = date.getHours();
    if (hours2 === 0) hours2 = 24;
    if (token === "ko") {
      return localize2.ordinalNumber(hours2, { unit: "hour" });
    }
    return addLeadingZeros(hours2, token.length);
  },
  // Minute
  m: function(date, token, localize2) {
    if (token === "mo") {
      return localize2.ordinalNumber(date.getMinutes(), { unit: "minute" });
    }
    return lightFormatters.m(date, token);
  },
  // Second
  s: function(date, token, localize2) {
    if (token === "so") {
      return localize2.ordinalNumber(date.getSeconds(), { unit: "second" });
    }
    return lightFormatters.s(date, token);
  },
  // Fraction of second
  S: function(date, token) {
    return lightFormatters.S(date, token);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function(date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset();
    if (timezoneOffset === 0) {
      return "Z";
    }
    switch (token) {
      // Hours and optional minutes
      case "X":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XX`
      case "XXXX":
      case "XX":
        return formatTimezone(timezoneOffset);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XXX`
      case "XXXXX":
      case "XXX":
      // Hours and minutes with `:` delimiter
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function(date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset();
    switch (token) {
      // Hours and optional minutes
      case "x":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xx`
      case "xxxx":
      case "xx":
        return formatTimezone(timezoneOffset);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xxx`
      case "xxxxx":
      case "xxx":
      // Hours and minutes with `:` delimiter
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (GMT)
  O: function(date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset();
    switch (token) {
      // Short
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      // Long
      case "OOOO":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (specific non-location)
  z: function(date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset();
    switch (token) {
      // Short
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      // Long
      case "zzzz":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  // Seconds timestamp
  t: function(date, token, _localize) {
    const timestamp = Math.trunc(date.getTime() / 1e3);
    return addLeadingZeros(timestamp, token.length);
  },
  // Milliseconds timestamp
  T: function(date, token, _localize) {
    const timestamp = date.getTime();
    return addLeadingZeros(timestamp, token.length);
  }
};
function formatTimezoneShort(offset2, delimiter = "") {
  const sign = offset2 > 0 ? "-" : "+";
  const absOffset = Math.abs(offset2);
  const hours2 = Math.trunc(absOffset / 60);
  const minutes2 = absOffset % 60;
  if (minutes2 === 0) {
    return sign + String(hours2);
  }
  return sign + String(hours2) + delimiter + addLeadingZeros(minutes2, 2);
}
function formatTimezoneWithOptionalMinutes(offset2, delimiter) {
  if (offset2 % 60 === 0) {
    const sign = offset2 > 0 ? "-" : "+";
    return sign + addLeadingZeros(Math.abs(offset2) / 60, 2);
  }
  return formatTimezone(offset2, delimiter);
}
function formatTimezone(offset2, delimiter = "") {
  const sign = offset2 > 0 ? "-" : "+";
  const absOffset = Math.abs(offset2);
  const hours2 = addLeadingZeros(Math.trunc(absOffset / 60), 2);
  const minutes2 = addLeadingZeros(absOffset % 60, 2);
  return sign + hours2 + delimiter + minutes2;
}
const dateLongFormatter = (pattern, formatLong2) => {
  switch (pattern) {
    case "P":
      return formatLong2.date({ width: "short" });
    case "PP":
      return formatLong2.date({ width: "medium" });
    case "PPP":
      return formatLong2.date({ width: "long" });
    case "PPPP":
    default:
      return formatLong2.date({ width: "full" });
  }
};
const timeLongFormatter = (pattern, formatLong2) => {
  switch (pattern) {
    case "p":
      return formatLong2.time({ width: "short" });
    case "pp":
      return formatLong2.time({ width: "medium" });
    case "ppp":
      return formatLong2.time({ width: "long" });
    case "pppp":
    default:
      return formatLong2.time({ width: "full" });
  }
};
const dateTimeLongFormatter = (pattern, formatLong2) => {
  const matchResult = pattern.match(/(P+)(p+)?/) || [];
  const datePattern = matchResult[1];
  const timePattern = matchResult[2];
  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong2);
  }
  let dateTimeFormat;
  switch (datePattern) {
    case "P":
      dateTimeFormat = formatLong2.dateTime({ width: "short" });
      break;
    case "PP":
      dateTimeFormat = formatLong2.dateTime({ width: "medium" });
      break;
    case "PPP":
      dateTimeFormat = formatLong2.dateTime({ width: "long" });
      break;
    case "PPPP":
    default:
      dateTimeFormat = formatLong2.dateTime({ width: "full" });
      break;
  }
  return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter(timePattern, formatLong2));
};
const longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};
const dayOfYearTokenRE = /^D+$/;
const weekYearTokenRE = /^Y+$/;
const throwTokens = ["D", "DD", "YY", "YYYY"];
function isProtectedDayOfYearToken(token) {
  return dayOfYearTokenRE.test(token);
}
function isProtectedWeekYearToken(token) {
  return weekYearTokenRE.test(token);
}
function warnOrThrowProtectedError(token, format2, input) {
  const _message = message$2(token, format2, input);
  console.warn(_message);
  if (throwTokens.includes(token)) throw new RangeError(_message);
}
function message$2(token, format2, input) {
  const subject = token[0] === "Y" ? "years" : "days of the month";
  return `Use \`${token.toLowerCase()}\` instead of \`${token}\` (in \`${format2}\`) for formatting ${subject} to the input \`${input}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;
}
const formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
const longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
const escapedStringRegExp = /^'([^]*?)'?$/;
const doubleQuoteRegExp = /''/g;
const unescapedLatinCharacterRegExp = /[a-zA-Z]/;
function format(date, formatStr, options) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const defaultOptions2 = getDefaultOptions();
  const locale = (options == null ? void 0 : options.locale) ?? defaultOptions2.locale ?? enUS;
  const firstWeekContainsDate = (options == null ? void 0 : options.firstWeekContainsDate) ?? ((_b = (_a = options == null ? void 0 : options.locale) == null ? void 0 : _a.options) == null ? void 0 : _b.firstWeekContainsDate) ?? defaultOptions2.firstWeekContainsDate ?? ((_d = (_c = defaultOptions2.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.firstWeekContainsDate) ?? 1;
  const weekStartsOn = (options == null ? void 0 : options.weekStartsOn) ?? ((_f = (_e = options == null ? void 0 : options.locale) == null ? void 0 : _e.options) == null ? void 0 : _f.weekStartsOn) ?? defaultOptions2.weekStartsOn ?? ((_h = (_g = defaultOptions2.locale) == null ? void 0 : _g.options) == null ? void 0 : _h.weekStartsOn) ?? 0;
  const originalDate = toDate(date);
  if (!isValid$1(originalDate)) {
    throw new RangeError("Invalid time value");
  }
  let parts = formatStr.match(longFormattingTokensRegExp).map((substring) => {
    const firstCharacter = substring[0];
    if (firstCharacter === "p" || firstCharacter === "P") {
      const longFormatter = longFormatters[firstCharacter];
      return longFormatter(substring, locale.formatLong);
    }
    return substring;
  }).join("").match(formattingTokensRegExp).map((substring) => {
    if (substring === "''") {
      return { isToken: false, value: "'" };
    }
    const firstCharacter = substring[0];
    if (firstCharacter === "'") {
      return { isToken: false, value: cleanEscapedString(substring) };
    }
    if (formatters$1[firstCharacter]) {
      return { isToken: true, value: substring };
    }
    if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
      throw new RangeError(
        "Format string contains an unescaped latin alphabet character `" + firstCharacter + "`"
      );
    }
    return { isToken: false, value: substring };
  });
  if (locale.localize.preprocessor) {
    parts = locale.localize.preprocessor(originalDate, parts);
  }
  const formatterOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale
  };
  return parts.map((part) => {
    if (!part.isToken) return part.value;
    const token = part.value;
    if (!(options == null ? void 0 : options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(token) || !(options == null ? void 0 : options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(token)) {
      warnOrThrowProtectedError(token, formatStr, String(date));
    }
    const formatter = formatters$1[token[0]];
    return formatter(originalDate, token, locale.localize, formatterOptions);
  }).join("");
}
function cleanEscapedString(input) {
  const matched = input.match(escapedStringRegExp);
  if (!matched) {
    return input;
  }
  return matched[1].replace(doubleQuoteRegExp, "'");
}
function formatISO(date, options) {
  const _date = toDate(date);
  if (isNaN(_date.getTime())) {
    throw new RangeError("Invalid time value");
  }
  let result = "";
  let tzOffset = "";
  const dateDelimiter = "-";
  const timeDelimiter = ":";
  {
    const day2 = addLeadingZeros(_date.getDate(), 2);
    const month2 = addLeadingZeros(_date.getMonth() + 1, 2);
    const year = addLeadingZeros(_date.getFullYear(), 4);
    result = `${year}${dateDelimiter}${month2}${dateDelimiter}${day2}`;
  }
  {
    const offset2 = _date.getTimezoneOffset();
    if (offset2 !== 0) {
      const absoluteOffset = Math.abs(offset2);
      const hourOffset = addLeadingZeros(Math.trunc(absoluteOffset / 60), 2);
      const minuteOffset = addLeadingZeros(absoluteOffset % 60, 2);
      const sign = offset2 < 0 ? "+" : "-";
      tzOffset = `${sign}${hourOffset}:${minuteOffset}`;
    } else {
      tzOffset = "Z";
    }
    const hour2 = addLeadingZeros(_date.getHours(), 2);
    const minute2 = addLeadingZeros(_date.getMinutes(), 2);
    const second2 = addLeadingZeros(_date.getSeconds(), 2);
    const separator = result === "" ? "" : "T";
    const time2 = [hour2, minute2, second2].join(timeDelimiter);
    result = `${result}${separator}${time2}${tzOffset}`;
  }
  return result;
}
function getDaysInMonth(date) {
  const _date = toDate(date);
  const year = _date.getFullYear();
  const monthIndex = _date.getMonth();
  const lastDayOfMonth2 = constructFrom(date, 0);
  lastDayOfMonth2.setFullYear(year, monthIndex + 1, 0);
  lastDayOfMonth2.setHours(0, 0, 0, 0);
  return lastDayOfMonth2.getDate();
}
function getUnixTime(date) {
  return Math.trunc(+toDate(date) / 1e3);
}
function lastDayOfMonth(date) {
  const _date = toDate(date);
  const month2 = _date.getMonth();
  _date.setFullYear(_date.getFullYear(), month2 + 1, 0);
  _date.setHours(0, 0, 0, 0);
  return _date;
}
function getWeeksInMonth(date, options) {
  return differenceInCalendarWeeks(
    lastDayOfMonth(date),
    startOfMonth(date),
    options
  ) + 1;
}
function isAfter(date, dateToCompare) {
  const _date = toDate(date);
  const _dateToCompare = toDate(dateToCompare);
  return _date.getTime() > _dateToCompare.getTime();
}
function isBefore(date, dateToCompare) {
  const _date = toDate(date);
  const _dateToCompare = toDate(dateToCompare);
  return +_date < +_dateToCompare;
}
function isSameMonth(dateLeft, dateRight) {
  const _dateLeft = toDate(dateLeft);
  const _dateRight = toDate(dateRight);
  return _dateLeft.getFullYear() === _dateRight.getFullYear() && _dateLeft.getMonth() === _dateRight.getMonth();
}
function isSameYear(dateLeft, dateRight) {
  const _dateLeft = toDate(dateLeft);
  const _dateRight = toDate(dateRight);
  return _dateLeft.getFullYear() === _dateRight.getFullYear();
}
function subDays(date, amount) {
  return addDays(date, -amount);
}
function parseISO(argument, options) {
  const additionalDigits = 2;
  const dateStrings = splitDateString(argument);
  let date;
  if (dateStrings.date) {
    const parseYearResult = parseYear(dateStrings.date, additionalDigits);
    date = parseDate(parseYearResult.restDateString, parseYearResult.year);
  }
  if (!date || isNaN(date.getTime())) {
    return /* @__PURE__ */ new Date(NaN);
  }
  const timestamp = date.getTime();
  let time2 = 0;
  let offset2;
  if (dateStrings.time) {
    time2 = parseTime(dateStrings.time);
    if (isNaN(time2)) {
      return /* @__PURE__ */ new Date(NaN);
    }
  }
  if (dateStrings.timezone) {
    offset2 = parseTimezone(dateStrings.timezone);
    if (isNaN(offset2)) {
      return /* @__PURE__ */ new Date(NaN);
    }
  } else {
    const dirtyDate = new Date(timestamp + time2);
    const result = /* @__PURE__ */ new Date(0);
    result.setFullYear(
      dirtyDate.getUTCFullYear(),
      dirtyDate.getUTCMonth(),
      dirtyDate.getUTCDate()
    );
    result.setHours(
      dirtyDate.getUTCHours(),
      dirtyDate.getUTCMinutes(),
      dirtyDate.getUTCSeconds(),
      dirtyDate.getUTCMilliseconds()
    );
    return result;
  }
  return new Date(timestamp + time2 + offset2);
}
const patterns = {
  dateTimeDelimiter: /[T ]/,
  timeZoneDelimiter: /[Z ]/i,
  timezone: /([Z+-].*)$/
};
const dateRegex$1 = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/;
const timeRegex$1 = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/;
const timezoneRegex = /^([+-])(\d{2})(?::?(\d{2}))?$/;
function splitDateString(dateString) {
  const dateStrings = {};
  const array = dateString.split(patterns.dateTimeDelimiter);
  let timeString;
  if (array.length > 2) {
    return dateStrings;
  }
  if (/:/.test(array[0])) {
    timeString = array[0];
  } else {
    dateStrings.date = array[0];
    timeString = array[1];
    if (patterns.timeZoneDelimiter.test(dateStrings.date)) {
      dateStrings.date = dateString.split(patterns.timeZoneDelimiter)[0];
      timeString = dateString.substr(
        dateStrings.date.length,
        dateString.length
      );
    }
  }
  if (timeString) {
    const token = patterns.timezone.exec(timeString);
    if (token) {
      dateStrings.time = timeString.replace(token[1], "");
      dateStrings.timezone = token[1];
    } else {
      dateStrings.time = timeString;
    }
  }
  return dateStrings;
}
function parseYear(dateString, additionalDigits) {
  const regex = new RegExp(
    "^(?:(\\d{4}|[+-]\\d{" + (4 + additionalDigits) + "})|(\\d{2}|[+-]\\d{" + (2 + additionalDigits) + "})$)"
  );
  const captures = dateString.match(regex);
  if (!captures) return { year: NaN, restDateString: "" };
  const year = captures[1] ? parseInt(captures[1]) : null;
  const century = captures[2] ? parseInt(captures[2]) : null;
  return {
    year: century === null ? year : century * 100,
    restDateString: dateString.slice((captures[1] || captures[2]).length)
  };
}
function parseDate(dateString, year) {
  if (year === null) return /* @__PURE__ */ new Date(NaN);
  const captures = dateString.match(dateRegex$1);
  if (!captures) return /* @__PURE__ */ new Date(NaN);
  const isWeekDate = !!captures[4];
  const dayOfYear = parseDateUnit(captures[1]);
  const month2 = parseDateUnit(captures[2]) - 1;
  const day2 = parseDateUnit(captures[3]);
  const week2 = parseDateUnit(captures[4]);
  const dayOfWeek = parseDateUnit(captures[5]) - 1;
  if (isWeekDate) {
    if (!validateWeekDate(year, week2, dayOfWeek)) {
      return /* @__PURE__ */ new Date(NaN);
    }
    return dayOfISOWeekYear(year, week2, dayOfWeek);
  } else {
    const date = /* @__PURE__ */ new Date(0);
    if (!validateDate(year, month2, day2) || !validateDayOfYearDate(year, dayOfYear)) {
      return /* @__PURE__ */ new Date(NaN);
    }
    date.setUTCFullYear(year, month2, Math.max(dayOfYear, day2));
    return date;
  }
}
function parseDateUnit(value2) {
  return value2 ? parseInt(value2) : 1;
}
function parseTime(timeString) {
  const captures = timeString.match(timeRegex$1);
  if (!captures) return NaN;
  const hours2 = parseTimeUnit(captures[1]);
  const minutes2 = parseTimeUnit(captures[2]);
  const seconds = parseTimeUnit(captures[3]);
  if (!validateTime(hours2, minutes2, seconds)) {
    return NaN;
  }
  return hours2 * millisecondsInHour + minutes2 * millisecondsInMinute + seconds * 1e3;
}
function parseTimeUnit(value2) {
  return value2 && parseFloat(value2.replace(",", ".")) || 0;
}
function parseTimezone(timezoneString) {
  if (timezoneString === "Z") return 0;
  const captures = timezoneString.match(timezoneRegex);
  if (!captures) return 0;
  const sign = captures[1] === "+" ? -1 : 1;
  const hours2 = parseInt(captures[2]);
  const minutes2 = captures[3] && parseInt(captures[3]) || 0;
  if (!validateTimezone(hours2, minutes2)) {
    return NaN;
  }
  return sign * (hours2 * millisecondsInHour + minutes2 * millisecondsInMinute);
}
function dayOfISOWeekYear(isoWeekYear, week2, day2) {
  const date = /* @__PURE__ */ new Date(0);
  date.setUTCFullYear(isoWeekYear, 0, 4);
  const fourthOfJanuaryDay = date.getUTCDay() || 7;
  const diff = (week2 - 1) * 7 + day2 + 1 - fourthOfJanuaryDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}
const daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function isLeapYearIndex(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
function validateDate(year, month2, date) {
  return month2 >= 0 && month2 <= 11 && date >= 1 && date <= (daysInMonths[month2] || (isLeapYearIndex(year) ? 29 : 28));
}
function validateDayOfYearDate(year, dayOfYear) {
  return dayOfYear >= 1 && dayOfYear <= (isLeapYearIndex(year) ? 366 : 365);
}
function validateWeekDate(_year, week2, day2) {
  return week2 >= 1 && week2 <= 53 && day2 >= 0 && day2 <= 6;
}
function validateTime(hours2, minutes2, seconds) {
  if (hours2 === 24) {
    return minutes2 === 0 && seconds === 0;
  }
  return seconds >= 0 && seconds < 60 && minutes2 >= 0 && minutes2 < 60 && hours2 >= 0 && hours2 < 25;
}
function validateTimezone(_hours, minutes2) {
  return minutes2 >= 0 && minutes2 <= 59;
}
function setMonth(date, month2) {
  const _date = toDate(date);
  const year = _date.getFullYear();
  const day2 = _date.getDate();
  const dateWithDesiredMonth = constructFrom(date, 0);
  dateWithDesiredMonth.setFullYear(year, month2, 15);
  dateWithDesiredMonth.setHours(0, 0, 0, 0);
  const daysInMonth = getDaysInMonth(dateWithDesiredMonth);
  _date.setMonth(month2, Math.min(day2, daysInMonth));
  return _date;
}
function setYear(date, year) {
  const _date = toDate(date);
  if (isNaN(+_date)) {
    return constructFrom(date, NaN);
  }
  _date.setFullYear(year);
  return _date;
}
const useApi = () => {
  const { client, fetchClient } = useAuth();
  const apiMethods = useMemo(() => {
    return {
      /**
       * Fetch login options for the current tenant.
       * @returns {Promise<Object>} Login options.
       */
      getLoginOptions: async () => {
        const resp = await client.options.login.listForCurrentTenant();
        return resp;
      },
      /**
       * Fetch the current user details.
       * @returns {Promise<Object>} Current user details.
       */
      getCurrentUser: async () => {
        const resp = await client.user.current();
        return resp;
      },
      /**
       * Check if the current user has a specific role.
       * @param {string} role - Role to check.
       * @returns {Promise<boolean>} True if the role is present.
       */
      checkRole: async (role) => {
        const resp = await client.user.currentWithEffectiveRoles();
        return resp.data.effectiveRoles.some(
          (element) => element.name === role
        );
      },
      /**
       * Fetch inventory details for a given ID.
       * @param {string} id - Inventory ID.
       * @param {boolean} [withParentChild=true] - Include parent/child data.
       * @param {Object} [filter={}] - Additional filters.
       * @returns {Promise<Object>} Inventory details.
       */
      getInventory: async (id2, withParentChild = true, filter2 = {}) => {
        const inventoryfilter = {
          withParents: withParentChild,
          withChildren: withParentChild,
          ...filter2
        };
        const resp = await client.inventory.detail(id2, inventoryfilter);
        return resp;
      },
      /**
       * Fetch all inventory data.
       * @param {Object} [filter={}] - Additional filters.
       * @returns {Promise<Object>} List of inventory items.
       */
      getAllInventory: async (filter2 = {}) => {
        const resp = await client.inventory.list({
          pageSize: 2e3,
          withParents: true,
          withTotalPages: true,
          ...filter2
        });
        return resp;
      },
      /**
       * Fetch inventory items by fragment type.
       * @param {string} fragmentType - Fragment type to filter.
       * @param {number} [pageSize=2000] - Number of items per page.
       * @param {number} [currentPage=1] - Current page number.
       * @returns {Promise<Object>} List of inventory items with the specified fragment type.
       */
      getInventoryByFragmentType: async (fragmentType, pageSize = 2e3, currentPage = 1) => {
        const filter2 = {
          fragmentType,
          pageSize,
          currentPage,
          withTotalPages: true,
          withParents: true
        };
        const resp = await client.inventory.list(filter2);
        return resp;
      },
      /**
       * Search inventory items by text.
       * @param {string} text - Search text.
       * @param {Array<string>} context - Group IDs to search within.
       * @param {number} [pageSize=2000] - Number of items per page.
       * @returns {Promise<Array<Object>>} Search results.
       */
      getInventoryByText: async (text2, context, pageSize = 2e3) => {
        const filter2 = {
          pageSize,
          withTotalPages: true,
          withParents: true
        };
        if (context && context.length > 0) {
          filter2.query = `$filter=name eq '*${text2}*' and bygroupid(${context})`;
        } else {
          filter2.query = `$filter=name eq '*${text2}*'`;
        }
        const resp = await client.inventory.list(filter2).then((res) => res.data);
        return resp;
      },
      /**
       * Fetch supported features for a device.
       * @param {string} id - Device ID.
       * @returns {Promise<Object>} Supported features and details.
       */
      getSupported: async (id2) => {
        const filter2 = {
          pageSize: 2e3
        };
        const detail = await client.inventory.detail(id2);
        const measurements = await client.inventory.getSupportedMeasurements(id2);
        const series2 = await client.inventory.getSupportedSeries(id2);
        const assetKPIs = await client.inventory.assetKPIsList(id2, filter2);
        return {
          detail,
          supportedMeasurements: measurements,
          supportedSeries: series2,
          KPIs: assetKPIs
        };
      },
      /**
       * Create an inventory item.
       * @param {Object} body - Inventory item details.
       * @returns {Promise<Object>} Created inventory item.
       */
      postInventory: async (body) => {
        const resp = await client.inventory.create(body);
        return resp;
      },
      /**
       * Update an inventory item.
       * @param {string} id - Inventory item ID.
       * @param {Object} body - Updated inventory details.
       * @returns {Promise<Object>} Updated inventory item.
       */
      putInventory: async (id2, body) => {
        const info = { id: id2, ...body };
        const resp = await client.inventory.update(info);
        return resp;
      },
      /**
       * Remove an inventory item.
       * @param {string} id - Inventory item ID.
       * @param {Object} [option={}] - Additional options for removal.
       * @returns {Promise<Object>} Response from the removal operation.
       */
      removeInventory: async (id2, option = {}) => {
        const resp = await client.inventory.delete(id2, option);
        return resp;
      },
      /**
       * Add a child inventory item to a parent item.
       * @param {Object} body - Child inventory details.
       * @param {string} parentId - Parent inventory ID.
       * @returns {Promise<Object>} Created child inventory item.
       */
      postChildInventory: async (body, parentId) => {
        const resp = await client.inventory.childAdditionsCreate(
          body,
          parentId
        );
        return resp;
      },
      /**
       * Fetch all home devices.
       * @returns {Promise<Array<Object>>} List of home devices.
       */
      homeDeviceInventory: async () => {
        const filter2 = {
          pageSize: 2e3,
          withTotalPages: true,
          fragmentType: "c8y_IsDevice"
        };
        const resp = await client.inventory.list(filter2).then((res) => res.data);
        return resp;
      },
      /**
       * Fetch all home groups.
       * @returns {Promise<Array<Object>>} List of home groups.
       */
      homeGroupInventory: async () => {
        const filter2 = {
          pageSize: 2e3,
          withTotalPages: true,
          fragmentType: "c8y_IsDeviceGroup",
          type: "c8y_DeviceGroup"
        };
        const resp = await client.inventory.list(filter2);
        return resp.data;
      },
      /**
       * Fetch child assets of an inventory item.
       * @param {string} id - Inventory item ID.
       * @param {Object} [filter={}] - Additional filters.
       * @returns {Promise<Array<Object>>} List of child assets.
       */
      getChildAssetsList: async (id2, filter2 = {}) => {
        const params = {
          pageSize: 2e3,
          ...filter2
        };
        const resp = await client.inventory.childAssetsList(id2, params).then((res) => res.data);
        return resp;
      },
      /**
       * Fetch child devices of an inventory item.
       * @param {string} id - Inventory item ID.
       * @param {Object} [filter={}] - Additional filters.
       * @returns {Promise<Array<Object>>} List of child devices.
       */
      getChildDevicesList: async (id2, filter2 = {}) => {
        const params = {
          pageSize: 2e3,
          ...filter2
        };
        const resp = await client.inventory.childDevicesList(id2, params).then((res) => res.data);
        return resp;
      },
      /**
       * Fetch dashboards for a given device or group.
       * @param {string} id - Source ID.
       * @param {string} category - Category (group/device).
       * @param {string} type - Type of entity.
       * @returns {Promise<Array<Object>>} List of dashboards.
       */
      getDashboards: async (id2, category, type2) => {
        const resp1 = await client.inventory.list({
          fragmentType: `u5s_Dashboard!${category}!${id2}`,
          pageSize: 2e3,
          currentPage: 1
        });
        const resp2 = await client.inventory.list({
          fragmentType: `u5s_Dashboard!type!${type2}`,
          pageSize: 2e3,
          currentPage: 1
        });
        return await Promise.allSettled([resp1, resp2]).then(
          (res) => res.flatMap((r2) => r2["value"]["data"])
        );
      },
      /**
       * Fetch events with filters.
       * @param {Object} filter - Event filters.
       * @returns {Promise<Object>} List of events.
       */
      getEvents: async (filter2) => {
        const resp = await client.event.list(filter2);
        return resp;
      },
      /**
       * Fetch events by type for a given source ID.
       * @param {Object} params - Parameters for filtering.
       * @returns {Promise<Object>} Filtered events.
       */
      getEventsByType: async ({
        id: id2,
        type: type2,
        revert = false,
        pageSize = 2e3
      }) => {
        const filter2 = {
          pageSize,
          source: id2,
          type: type2,
          withTotalPages: true,
          withSourceAssets: true,
          withSourceDevices: true,
          revert
        };
        const resp = await client.event.list(filter2);
        return resp;
      },
      /**
       * Fetch events by fragment type.
       * @param {string} id - Source ID.
       * @param {string} type - Event type.
       * @param {string} fragment - Fragment type.
       * @param {string} dateTo - End date for the query.
       * @param {boolean} [revert=false] - Reverse order.
       * @param {number} [pageSize=2000] - Number of events per page.
       * @returns {Promise<Object>} List of events.
       */
      getEventsByFragment: async (id2, type2, fragment2, dateTo, revert = false, pageSize = 2e3) => {
        const filter2 = {
          dateTo,
          pageSize,
          source: id2,
          type: type2,
          fragmentType: fragment2,
          withTotalPages: true,
          withSourceAssets: true,
          withSourceDevices: true,
          revert
        };
        const resp = await client.event.list(filter2);
        return resp;
      },
      /**
       * Fetch events by date range.
       * @param {string} id - Source ID.
       * @param {string} type - Event type.
       * @param {string} dateFrom - Start date for the query.
       * @param {string} dateTo - End date for the query.
       * @param {boolean} [revert=false] - Reverse order.
       * @param {number} [pageSize=2000] - Number of events per page.
       * @returns {Promise<Object>} List of events.
       */
      getEventsByDate: async (id2, type2, dateFrom, dateTo, revert = false, pageSize = 2e3) => {
        const filter2 = {
          dateFrom,
          dateTo,
          pageSize,
          source: id2,
          type: type2,
          withTotalPages: true,
          withSourceAssets: true,
          withSourceDevices: true,
          revert
        };
        const resp = await client.event.list(filter2);
        return resp;
      },
      /**
       * Create multiple events.
       * @param {Object} body - Events data.
       * @returns {Promise<Array<Object>>} Response for each created event.
       */
      postEvents: async (body) => {
        const resp = await Promise.allSettled(
          body["events"].map((event) => client.event.create(event))
        );
        return resp;
      },
      /**
       * Fetch measurements with filters.
       * @param {Object} params - Query parameters.
       * @param {string} params.id - Source ID.
       * @param {string} params.fragment - Measurement fragment type.
       * @param {string} params.series - Measurement series.
       * @param {number} params.pageSize - Number of measurements per page.
       * @returns {Promise<Object>} List of measurements.
       */
      getMeasurements: async ({ id: id2, fragment: fragment2, series: series2, pageSize }) => {
        const filter2 = {
          source: id2,
          dateTo: formatISO(/* @__PURE__ */ new Date()),
          valueFragmentType: fragment2,
          valueFragmentSeries: series2,
          pageSize,
          revert: true
        };
        const resp = await client.measurement.list(filter2);
        return resp;
      },
      /**
       * Fetch measurements by fragment type.
       * @param {string} id - Source ID.
       * @param {string} fragment - Fragment type.
       * @param {number} pageSize - Number of measurements per page.
       * @returns {Promise<Object>} List of measurements.
       */
      getMeasurementsByFragment: async (id2, fragment2, pageSize) => {
        const filter2 = {
          source: id2,
          dateTo: formatISO(/* @__PURE__ */ new Date()),
          valueFragmentType: fragment2,
          pageSize,
          revert: true
        };
        const resp = await client.measurement.list(filter2);
        return resp;
      },
      /**
       * Fetch measurements by date range.
       * @param {string} id - Source ID.
       * @param {string} measurementFragment - Measurement fragment type.
       * @param {string} measurementSeries - Measurement series.
       * @param {string} dateFrom - Start date.
       * @param {string} dateTo - End date.
       * @param {boolean} [revert=true] - Reverse order.
       * @param {number} [pageSize=2000] - Number of measurements per page.
       * @returns {Promise<Object>} List of measurements.
       */
      getMeasurementsByDate: async (id2, measurementFragment, measurementSeries, dateFrom, dateTo, revert = true, pageSize = 2e3) => {
        const filter2 = {
          source: id2,
          dateFrom,
          dateTo,
          valueFragmentType: measurementFragment,
          valueFragmentSeries: measurementSeries,
          pageSize,
          revert
        };
        const resp = await client.measurement.list(filter2);
        return resp;
      },
      /**
       * Fetch measurement by series data.
       * @param {string} id - Source ID.
       * @param {string} dateFrom - Start date.
       * @param {string} dateTo - End date.
       * @param {Array<string>} series - Measurement series.
       * @param {string} aggregationType - Aggregation type.
       * @returns {Promise<Object>} Measurement series data.
       */
      getMeasurementsBySeries: async (id2, dateFrom, dateTo, series2, aggregationType2) => {
        const filter2 = {
          dateFrom,
          dateTo,
          pageSize: 2e3,
          revert: true,
          series: series2,
          source: id2
        };
        if (aggregationType2 && aggregationType2 !== "none") {
          filter2.aggregationType = aggregationType2;
        }
        const resp = await client.measurement.listSeries(filter2);
        return resp;
      },
      /**
       * Subscribe to a real-time channel.
       * @param {string} channel - Real-time channel.
       * @param {Function} callback - Callback function for updates.
       * @returns {Object} Subscription handle.
       */
      realtimeSub: (channel, callback) => {
        return client.realtime.subscribe(channel, callback);
      },
      /**
       * Unsubscribe from a real-time channel.
       * @param {Object} sub - Subscription handle.
       * @returns {Promise<void>} Unsubscribe response.
       */
      realtimeUnSub: (sub) => {
        return client.realtime.unsubscribe(sub);
      },
      /**
       * Fetch alarms with filters.
       * @param {Object} filter - Alarm filters.
       * @returns {Promise<Object>} List of alarms.
       */
      getAlarms: async (filter2) => {
        const resp = await client.alarm.list(filter2);
        return resp;
      },
      /**
       * Update an alarm.
       * @param {Object} entity - Alarm entity with updated data.
       * @returns {Promise<Object>} Updated alarm entity.
       */
      putAlarm: async (entity) => {
        return client.alarm.update(entity);
      },
      /**
       * Update data points for an inventory item.
       * @param {string} id - Inventory item ID.
       * @param {Object} data - Data points to update.
       * @returns {Promise<Object>} Updated inventory item.
       */
      putDataPoints: async (id2, data) => {
        const body = {
          id: id2,
          c8y_DataPoint: data
        };
        const resp = await client.inventory.update(body);
        return resp;
      },
      /**
       * Fetch data points for an inventory item.
       * @param {string} id - Inventory item ID.
       * @returns {Promise<Array<Object>>} List of data points.
       */
      getDataPoints: async (id2) => {
        const resp1 = client.inventory.getMeasurementsAndSeries(id2);
        const resp2 = client.inventory.assetKPIsList(id2, { pageSize: 2e3 });
        return await Promise.all([resp1, resp2]);
      },
      /**
       * Fetch the current user's roles and permissions.
       * @returns {Promise<Object>} User's roles and permissions data.
       */
      manageRole: async () => {
        const resp = await client.user.currentWithEffectiveRoles();
        return resp.data;
      },
      /**
       * Fetch the external ID of an inventory item.
       * @param {string} sourceId - Source ID of the inventory item.
       * @returns {Promise<Array<Object>>} List of external IDs.
       */
      getExternalId: async (sourceId) => {
        const resp = await client.identity.list(sourceId);
        return resp.data;
      },
      /**
       * Create a command operation for a device.
       * @param {string} sourceId - Device ID.
       * @param {string} c8y_Command - Command text to send.
       * @param {string} description - Description of the command operation.
       * @returns {Promise<Object>} Created operation object.
       */
      createOperation: async (sourceId, c8y_Command, description2) => {
        const body = {
          deviceId: sourceId,
          c8y_Command: {
            text: c8y_Command
          },
          description: description2
        };
        const resp = await client.operation.create(body);
        return resp;
      },
      /**
       * Fetch a binary object from the inventory.
       * @param {string} source - Source ID of the binary object.
       * @returns {Promise<Object>} Binary object data.
       */
      getBinary: async (source2) => {
        const resp = await fetchClient.fetch(`inventory/binaries/${source2}`);
        return resp;
      }
    };
  }, [client, fetchClient]);
  return apiMethods;
};
var __assign$1 = function() {
  __assign$1 = Object.assign || function __assign2(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p)) t2[p] = s2[p];
    }
    return t2;
  };
  return __assign$1.apply(this, arguments);
};
function __rest$1(s2, e) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0)
    t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2]))
        t2[p[i2]] = s2[p[i2]];
    }
  return t2;
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __spreadArray$1(to, from, pack) {
  if (pack || arguments.length === 2) for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
    if (ar || !(i2 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
      ar[i2] = from[i2];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
typeof SuppressedError === "function" ? SuppressedError : function(error2, suppressed, message2) {
  var e = new Error(message2);
  return e.name = "SuppressedError", e.error = error2, e.suppressed = suppressed, e;
};
class Paging {
  constructor(service, statistics, filter2) {
    this.filter = filter2;
    this.service = service;
    this.currentPage = statistics.currentPage;
    this.nextPage = statistics.nextPage;
    this.prevPage = statistics.prevPage;
    this.pageSize = statistics.pageSize;
    this.totalPages = statistics.totalPages;
  }
  /**
   * Gets the next page of available data from the server.
   * @param filter
   */
  next(filter2 = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.list(this.getFilter(filter2, this.nextPage));
    });
  }
  /**
   * Gets the previous page of available data from server.
   * @param filter
   */
  prev(filter2 = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.list(this.getFilter(filter2, this.prevPage));
    });
  }
  /**
   * Method used by next(), prev() and goto() to call the service.list method.
   * It is public so it can be overriden in special cases (like children objects
   * in inventory).
   * @param filter
   */
  list(filter2 = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.service.list(filter2);
    });
  }
  /**
   * Goes to the page that you define as page parameter.
   * @param page
   * @param filter
   */
  goto(page, filter2 = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.list(this.getFilter(filter2, page));
    });
  }
  getFilter(filter2, page) {
    return Object.assign(filter2, this.filter, { currentPage: page });
  }
}
class Service {
  constructor(client, realtime2) {
    this.client = client;
    this.realtime = realtime2;
    this.cache = /* @__PURE__ */ new Map();
    const methodsToHide = ["list", "create", "update", "detail", "delete"];
    const prototype = Object.getPrototypeOf(this);
    methodsToHide.forEach((method) => {
      if (!prototype.hasOwnProperty(method)) {
        Object.defineProperty(this, method, {
          get() {
            return void 0;
          }
        });
      }
    });
  }
  list(filter2 = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      const headers = { accept: "application/json" };
      const url2 = this.listUrl;
      const res = yield this.fetch(url2, this.changeFetchOptions({ headers, params: filter2 }, url2));
      const json = yield res.json();
      const data = this.propertyName ? json[this.propertyName] : json;
      const paging = this.getPaging(json, filter2);
      return { res, data, paging };
    });
  }
  detail(entityOrId, filter2 = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      const headers = { accept: "application/json" };
      const url2 = this.getDetailUrl(entityOrId);
      const res = yield this.fetch(url2, this.changeFetchOptions({ headers, params: Object.assign({}, filter2) }, url2));
      const data = yield res.json();
      return { res, data };
    });
  }
  create(entity) {
    return __awaiter(this, void 0, void 0, function* () {
      const url2 = this.listUrl;
      const method = "POST";
      const body = JSON.stringify(this.onBeforeCreate(entity));
      const headers = { "content-type": "application/json", accept: "application/json" };
      const res = yield this.fetch(url2, this.changeFetchOptions({ method, body, headers }, url2));
      const data = yield res.json();
      return { res, data };
    });
  }
  update(entity) {
    return __awaiter(this, void 0, void 0, function* () {
      const url2 = this.getDetailUrl(entity);
      const method = "PUT";
      const body = JSON.stringify(this.onBeforeUpdate(entity));
      const headers = { "content-type": "application/json", accept: "application/json" };
      const res = yield this.fetch(url2, this.changeFetchOptions({ method, body, headers }, url2));
      const data = yield res.json();
      return { res, data };
    });
  }
  delete(entityOrId, params) {
    return __awaiter(this, void 0, void 0, function* () {
      const method = "DELETE";
      const url2 = this.getDetailUrl(entityOrId);
      const res = yield this.fetch(url2, this.changeFetchOptions({ method, params }, url2));
      return { res, data: null };
    });
  }
  onBeforeCreate(obj) {
    delete obj.id;
    return obj;
  }
  onBeforeUpdate(objWithId) {
    return objWithId;
  }
  changeFetchOptions(options, _url = "") {
    return options;
  }
  getUrl(url2 = "") {
    const baseUrl = this.baseUrl.replace(/\/+$/, "");
    const partialUrl = url2.replace(/^\/+/, "");
    return `${baseUrl}/${partialUrl}`;
  }
  getEntityId(entityOrId) {
    if (entityOrId === void 0 || entityOrId === null) {
      return "";
    }
    if (typeof entityOrId === "object") {
      return this.getEntityId(entityOrId.id);
    }
    return `${entityOrId}`;
  }
  getDetailUrl(entityOrId) {
    const id2 = this.getEntityId(entityOrId);
    return `${this.listUrl}/${id2}`;
  }
  fetch(url2, init) {
    return __awaiter(this, void 0, void 0, function* () {
      const fullUrl = this.getUrl(url2);
      const res = yield this.client.fetch(fullUrl, init);
      return yield this.handleErrorStatusCodes(res);
    });
  }
  /**
   * Checks the response for errors and throws exceptions, otherwise returns the response as is.
   *
   * @param response The response from server.
   *
   * @returns If no errors are detected, it returns the same response.
   *
   * @throws If an error is detected, it throws `{ res, data }`, where `data` contains error details from server.
   */
  handleErrorStatusCodes(response) {
    return __awaiter(this, void 0, void 0, function* () {
      if (response.status >= 400) {
        let data = null;
        try {
          data = yield response.json();
        } catch (ex) {
          try {
            data = yield response.text();
          } catch (ex2) {
          }
        }
        throw { res: response, data };
      }
      return response;
    });
  }
  mimeType(type2) {
    return `application/vnd.com.nsn.cumulocity.${type2}+json`;
  }
  getIdString(reference) {
    let id2;
    if (typeof reference === "object") {
      id2 = reference.id;
    } else {
      id2 = reference;
    }
    return String(id2);
  }
  getPaging(json, filter2) {
    if (json.statistics) {
      const statistics = Object.assign(Object.assign({}, json.statistics), { nextPage: this.getCurrentPageFromLink(json.next), prevPage: this.getCurrentPageFromLink(json.prev) });
      return new Paging(this, statistics, filter2);
    }
    return null;
  }
  getCurrentPageFromLink(link2 = "") {
    const matches = link2.match(/currentPage=(-{0,1}\d+)/);
    return matches && parseInt(matches[1], 10);
  }
}
var browserPonyfill = { exports: {} };
var hasRequiredBrowserPonyfill;
function requireBrowserPonyfill() {
  if (hasRequiredBrowserPonyfill) return browserPonyfill.exports;
  hasRequiredBrowserPonyfill = 1;
  (function(module2, exports2) {
    var __global__ = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || typeof commonjsGlobal !== "undefined" && commonjsGlobal;
    var __globalThis__ = function() {
      function F() {
        this.fetch = false;
        this.DOMException = __global__.DOMException;
      }
      F.prototype = __global__;
      return new F();
    }();
    (function(globalThis2) {
      (function(exports3) {
        var global2 = typeof globalThis2 !== "undefined" && globalThis2 || typeof self !== "undefined" && self || typeof global2 !== "undefined" && global2;
        var support = {
          searchParams: "URLSearchParams" in global2,
          iterable: "Symbol" in global2 && "iterator" in Symbol,
          blob: "FileReader" in global2 && "Blob" in global2 && function() {
            try {
              new Blob();
              return true;
            } catch (e) {
              return false;
            }
          }(),
          formData: "FormData" in global2,
          arrayBuffer: "ArrayBuffer" in global2
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name2) {
          if (typeof name2 !== "string") {
            name2 = String(name2);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name2) || name2 === "") {
            throw new TypeError('Invalid character in header field name: "' + name2 + '"');
          }
          return name2.toLowerCase();
        }
        function normalizeValue(value2) {
          if (typeof value2 !== "string") {
            value2 = String(value2);
          }
          return value2;
        }
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value2 = items.shift();
              return { done: value2 === void 0, value: value2 };
            }
          };
          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        function Headers2(headers) {
          this.map = {};
          if (headers instanceof Headers2) {
            headers.forEach(function(value2, name2) {
              this.append(name2, value2);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name2) {
              this.append(name2, headers[name2]);
            }, this);
          }
        }
        Headers2.prototype.append = function(name2, value2) {
          name2 = normalizeName(name2);
          value2 = normalizeValue(value2);
          var oldValue = this.map[name2];
          this.map[name2] = oldValue ? oldValue + ", " + value2 : value2;
        };
        Headers2.prototype["delete"] = function(name2) {
          delete this.map[normalizeName(name2)];
        };
        Headers2.prototype.get = function(name2) {
          name2 = normalizeName(name2);
          return this.has(name2) ? this.map[name2] : null;
        };
        Headers2.prototype.has = function(name2) {
          return this.map.hasOwnProperty(normalizeName(name2));
        };
        Headers2.prototype.set = function(name2, value2) {
          this.map[normalizeName(name2)] = normalizeValue(value2);
        };
        Headers2.prototype.forEach = function(callback, thisArg) {
          for (var name2 in this.map) {
            if (this.map.hasOwnProperty(name2)) {
              callback.call(thisArg, this.map[name2], name2, this);
            }
          }
        };
        Headers2.prototype.keys = function() {
          var items = [];
          this.forEach(function(value2, name2) {
            items.push(name2);
          });
          return iteratorFor(items);
        };
        Headers2.prototype.values = function() {
          var items = [];
          this.forEach(function(value2) {
            items.push(value2);
          });
          return iteratorFor(items);
        };
        Headers2.prototype.entries = function() {
          var items = [];
          this.forEach(function(value2, name2) {
            items.push([name2, value2]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers2.prototype[Symbol.iterator] = Headers2.prototype.entries;
        }
        function consumed(body) {
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise;
        }
        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsText(blob);
          return promise;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars2 = new Array(view.length);
          for (var i2 = 0; i2 < view.length; i2++) {
            chars2[i2] = String.fromCharCode(view[i2]);
          }
          return chars2.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this.bodyUsed = this.bodyUsed;
            this._bodyInit = body;
            if (!body) {
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
            this.arrayBuffer = function() {
              if (this._bodyArrayBuffer) {
                var isConsumed = consumed(this);
                if (isConsumed) {
                  return isConsumed;
                }
                if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
                  return Promise.resolve(
                    this._bodyArrayBuffer.buffer.slice(
                      this._bodyArrayBuffer.byteOffset,
                      this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
                    )
                  );
                } else {
                  return Promise.resolve(this._bodyArrayBuffer);
                }
              } else {
                return this.blob().then(readBlobAsArrayBuffer);
              }
            };
          }
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request(input, options) {
          if (!(this instanceof Request)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          options = options || {};
          var body = options.body;
          if (input instanceof Request) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers2(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers2(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal;
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
          if (this.method === "GET" || this.method === "HEAD") {
            if (options.cache === "no-store" || options.cache === "no-cache") {
              var reParamSearch = /([?&])_=[^&]*/;
              if (reParamSearch.test(this.url)) {
                this.url = this.url.replace(reParamSearch, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
              } else {
                var reQueryString = /\?/;
                this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
              }
            }
          }
        }
        Request.prototype.clone = function() {
          return new Request(this, { body: this._bodyInit });
        };
        function decode(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes) {
            if (bytes) {
              var split = bytes.split("=");
              var name2 = split.shift().replace(/\+/g, " ");
              var value2 = split.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name2), decodeURIComponent(value2));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers2();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split("\r").map(function(header) {
            return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
          }).forEach(function(line2) {
            var parts = line2.split(":");
            var key = parts.shift().trim();
            if (key) {
              var value2 = parts.join(":").trim();
              headers.append(key, value2);
            }
          });
          return headers;
        }
        Body.call(Request.prototype);
        function Response(bodyInit, options) {
          if (!(this instanceof Response)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = options.statusText === void 0 ? "" : "" + options.statusText;
          this.headers = new Headers2(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response.prototype);
        Response.prototype.clone = function() {
          return new Response(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers2(this.headers),
            url: this.url
          });
        };
        Response.error = function() {
          var response = new Response(null, { status: 0, statusText: "" });
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response.redirect = function(url2, status2) {
          if (redirectStatuses.indexOf(status2) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response(null, { status: status2, headers: { location: url2 } });
        };
        exports3.DOMException = global2.DOMException;
        try {
          new exports3.DOMException();
        } catch (err) {
          exports3.DOMException = function(message2, name2) {
            this.message = message2;
            this.name = name2;
            var error2 = Error(message2);
            this.stack = error2.stack;
          };
          exports3.DOMException.prototype = Object.create(Error.prototype);
          exports3.DOMException.prototype.constructor = exports3.DOMException;
        }
        function fetch2(input, init) {
          return new Promise(function(resolve, reject) {
            var request3 = new Request(input, init);
            if (request3.signal && request3.signal.aborted) {
              return reject(new exports3.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                status: xhr.status,
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              setTimeout(function() {
                resolve(new Response(body, options));
              }, 0);
            };
            xhr.onerror = function() {
              setTimeout(function() {
                reject(new TypeError("Network request failed"));
              }, 0);
            };
            xhr.ontimeout = function() {
              setTimeout(function() {
                reject(new TypeError("Network request failed"));
              }, 0);
            };
            xhr.onabort = function() {
              setTimeout(function() {
                reject(new exports3.DOMException("Aborted", "AbortError"));
              }, 0);
            };
            function fixUrl(url2) {
              try {
                return url2 === "" && global2.location.href ? global2.location.href : url2;
              } catch (e) {
                return url2;
              }
            }
            xhr.open(request3.method, fixUrl(request3.url), true);
            if (request3.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request3.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr) {
              if (support.blob) {
                xhr.responseType = "blob";
              } else if (support.arrayBuffer && request3.headers.get("Content-Type") && request3.headers.get("Content-Type").indexOf("application/octet-stream") !== -1) {
                xhr.responseType = "arraybuffer";
              }
            }
            if (init && typeof init.headers === "object" && !(init.headers instanceof Headers2)) {
              Object.getOwnPropertyNames(init.headers).forEach(function(name2) {
                xhr.setRequestHeader(name2, normalizeValue(init.headers[name2]));
              });
            } else {
              request3.headers.forEach(function(value2, name2) {
                xhr.setRequestHeader(name2, value2);
              });
            }
            if (request3.signal) {
              request3.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request3.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request3._bodyInit === "undefined" ? null : request3._bodyInit);
          });
        }
        fetch2.polyfill = true;
        if (!global2.fetch) {
          global2.fetch = fetch2;
          global2.Headers = Headers2;
          global2.Request = Request;
          global2.Response = Response;
        }
        exports3.Headers = Headers2;
        exports3.Request = Request;
        exports3.Response = Response;
        exports3.fetch = fetch2;
        return exports3;
      })({});
    })(__globalThis__);
    __globalThis__.fetch.ponyfill = true;
    delete __globalThis__.fetch.polyfill;
    var ctx = __global__.fetch ? __global__ : __globalThis__;
    exports2 = ctx.fetch;
    exports2.default = ctx.fetch;
    exports2.fetch = ctx.fetch;
    exports2.Headers = ctx.Headers;
    exports2.Request = ctx.Request;
    exports2.Response = ctx.Response;
    module2.exports = exports2;
  })(browserPonyfill, browserPonyfill.exports);
  return browserPonyfill.exports;
}
var browserPonyfillExports = requireBrowserPonyfill();
const fetch$1 = /* @__PURE__ */ getDefaultExportFromCjs(browserPonyfillExports);
let auths = /* @__PURE__ */ new WeakMap();
class FetchClient {
  constructor(authOrBaseUrl, baseUrl) {
    this.baseUrl = baseUrl;
    this.tenant = "";
    this.defaultHeaders = {};
    if (typeof authOrBaseUrl === "string") {
      baseUrl = authOrBaseUrl;
    } else {
      this.setAuth(authOrBaseUrl);
    }
    this.baseUrl = this.resolveServerUrl(baseUrl);
  }
  setAuth(auth) {
    auths.set(this, auth);
  }
  fetch(url2, init) {
    return __awaiter(this, void 0, void 0, function* () {
      let fetchFn = fetch$1;
      try {
        fetchFn = window.fetch || fetchFn;
      } catch (e) {
      }
      const fullUrl = this.getUrl(url2, init);
      const options = this.getFetchOptions(init);
      const optionsWithAdjustedBody = this.adjustOptionsForFormData(options);
      return fetchFn(fullUrl, optionsWithAdjustedBody);
    });
  }
  getUrl(url2 = "", options) {
    const params = options && options.params;
    let paramPart = "";
    if (params && Object.keys(params).length) {
      paramPart = Object.keys(params).map((k) => {
        let vals = params[k];
        const encodedKey = encodeURIComponent(k);
        if (!Array.isArray(vals)) {
          vals = [vals];
        }
        return vals.map((v) => `${encodedKey}=${encodeURIComponent(v)}`).join("&");
      }).join("&");
      paramPart = `?${paramPart}`;
    }
    const baseUrl = this.baseUrl.replace(/\/+$/, "").replace(/^\/+/, "");
    const partialUrl = url2.replace(/\/+$/, "").replace(/^\/+/, "");
    return `${baseUrl}/${partialUrl}${paramPart}`;
  }
  getFetchOptions(options = {}) {
    let clonedOptions = Object.assign({}, options);
    const auth = auths.get(this);
    clonedOptions.headers = Object.assign({}, this.defaultHeaders, clonedOptions.headers, {
      UseXBasic: true
    });
    delete clonedOptions.params;
    clonedOptions = auth ? auth.getFetchOptions(clonedOptions) : clonedOptions;
    return clonedOptions;
  }
  getCometdHandshake(config = {}) {
    const auth = auths.get(this);
    return auth ? auth.getCometdHandshake(config) : config;
  }
  resolveServerUrl(baseUrl = "") {
    if (baseUrl && baseUrl.startsWith("http")) {
      return baseUrl.replace(/\/+$/, "");
    }
    try {
      const location2 = window.location;
      return `${location2.protocol}//${location2.host}/${baseUrl.replace(/\/+$/, "")}`;
    } catch (ex) {
      throw Error("Your environment does not support relative URLs. Please provide a base URL.");
    }
  }
  adjustOptionsForFormData(options) {
    const newOptions = Object.assign(options, { body: options.body });
    return newOptions;
  }
}
var error = function(message2) {
  function E2() {
    this.message = message2;
  }
  E2.prototype = new Error();
  E2.prototype.name = "InvalidCharacterError";
  E2.prototype.code = 5;
  return E2;
};
var chars$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
var E = error("The string to be encoded contains characters out of range");
var _btoa = typeof btoa !== "undefined" ? function(input) {
  return btoa(input);
} : function(input) {
  var str = String(input);
  var output = "";
  for (
    var block, charCode, idx = 0, map2 = chars$1;
    // if the next str index does not exist:
    //   change the mapping table to "="
    //   check if d has no fractional digits
    str.charAt(idx | 0) || (map2 = "=", idx % 1);
    // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
    output += map2.charAt(63 & block >> 8 - idx % 1 * 8)
  ) {
    charCode = str.charCodeAt(idx += 3 / 4);
    if (charCode > 255) {
      throw new E();
    }
    block = block << 8 | charCode;
  }
  return output;
};
var utf8 = function(input) {
  return encodeURIComponent(input).replace(/%([0-9A-F]{2})/g, function(match2, p1) {
    return String.fromCharCode("0x" + p1);
  });
};
const btoa$1 = function(input) {
  return _btoa(utf8(input));
};
error("The string to be decoded is not correctly encoded");
var secrets$1 = /* @__PURE__ */ new WeakMap();
class BasicAuth {
  /**
   * Authenticates the given user against the given tenant.
   * @param name
   * @param password
   * @param tenant
   */
  constructor(credentials) {
    this.updateCredentials(credentials);
  }
  updateCredentials({ tenant: tenant2, user, password: password2, token, tfa } = {}) {
    const secret = secrets$1.get(this) || {};
    if (user && tenant2) {
      user = `${tenant2}/${user}`;
    }
    user = user || this.user;
    password2 = password2 || secret.password;
    if (!token && user && password2) {
      token = btoa$1(`${user}:${password2}`);
    }
    if (user) {
      this.user = user;
    }
    token = token || secret.token;
    tfa = tfa || secret.tfa;
    secrets$1.set(this, { tfa, token, password: password2 });
    return token;
  }
  getFetchOptions(options) {
    const secret = secrets$1.get(this);
    const { token, tfa } = secret;
    const xsrfToken = this.getCookieValue("XSRF-TOKEN");
    const headers = Object.assign({ Authorization: `Basic ${token || ""}` }, xsrfToken ? { "X-XSRF-TOKEN": xsrfToken } : void 0);
    if (tfa) {
      headers.tfatoken = tfa;
    }
    options.headers = Object.assign(headers, options.headers);
    return options;
  }
  getCometdHandshake(config = {}) {
    const secret = secrets$1.get(this);
    const { token, tfa } = secret;
    const KEY = "com.cumulocity.authn";
    const ext = config.ext = config.ext || {};
    ext[KEY] = Object.assign(ext[KEY] || {}, { token, tfa });
    return config;
  }
  logout() {
    delete this.user;
    secrets$1.set(this, {});
  }
  getCookieValue(name2) {
    try {
      const value2 = document.cookie.match("(^|;)\\s*" + name2 + "\\s*=\\s*([^;]+)");
      return value2 ? value2.pop() : void 0;
    } catch (ex) {
      return void 0;
    }
  }
}
const secrets = /* @__PURE__ */ new WeakMap();
class BearerAuth {
  constructor(token) {
    secrets.set(this, { token });
  }
  getFetchOptions(options) {
    const token = this.getToken();
    options.headers = Object.assign({ Authorization: `Bearer ${token}` }, options.headers);
    return options;
  }
  updateCredentials({ token }) {
    secrets.set(this, { token });
    return;
  }
  getCometdHandshake(config = {}) {
    const secret = secrets.get(this);
    const { tfa } = secret;
    const token = this.getToken();
    const KEY = "com.cumulocity.authn";
    const ext = config.ext = config.ext || {};
    ext[KEY] = Object.assign(ext[KEY] || {}, { token, tfa });
    return config;
  }
  logout() {
    secrets.set(this, {});
  }
  getToken() {
    const secret = secrets.get(this);
    const { token } = secret;
    return token;
  }
}
class BearerAuthFromSessionStorage extends BearerAuth {
  constructor(throwIfNoTokenPresent = true) {
    super();
    const token = this.getToken();
    if (!token && throwIfNoTokenPresent) {
      throw new Error("No token present in session storage");
    }
  }
  updateCredentials({ token }) {
    if (!token) {
      return;
    }
    super.updateCredentials({ token });
    return;
  }
  getToken() {
    const token = sessionStorage.getItem(BearerAuthFromSessionStorage.sessionStorageKey);
    if (token) {
      const shouldKeepToken = sessionStorage.getItem(BearerAuthFromSessionStorage.sessionStorageKeyToKeepToken) === "true";
      if (!shouldKeepToken) {
        sessionStorage.removeItem(BearerAuthFromSessionStorage.sessionStorageKey);
      }
      this.updateCredentials({ token });
      return token;
    }
    return super.getToken();
  }
}
BearerAuthFromSessionStorage.sessionStorageKey = "bearerAuthToken";
BearerAuthFromSessionStorage.sessionStorageKeyToKeepToken = `bearerAuthTokenKeep`;
class CookieAuth {
  constructor() {
    this.logoutUrl = "user/logout";
  }
  updateCredentials({ user } = {}) {
    this.user = user;
    return void 0;
  }
  getFetchOptions(options) {
    const xsrfToken = this.getCookieValue("XSRF-TOKEN");
    const headers = { "X-XSRF-TOKEN": xsrfToken };
    options.headers = Object.assign(headers, options.headers);
    return options;
  }
  getCometdHandshake(config = {}) {
    const KEY = "com.cumulocity.authn";
    const xsrfToken = this.getCookieValue("XSRF-TOKEN");
    const ext = config.ext = config.ext || {};
    ext[KEY] = Object.assign(ext[KEY] || {}, { xsrfToken });
    return config;
  }
  logout() {
    return __awaiter(this, void 0, void 0, function* () {
      if (this.user) {
        delete this.user;
      }
      const client = new FetchClient();
      client.setAuth(this);
      const method = "POST";
      const body = JSON.stringify({});
      const headers = { "content-type": "application/json", accept: "application/json" };
      return client.fetch(this.logoutUrl, { headers, body, method });
    });
  }
  getCookieValue(name2) {
    const value2 = document.cookie.match("(^|;)\\s*" + name2 + "\\s*=\\s*([^;]+)");
    return value2 ? value2.pop() : "";
  }
}
class MicroserviceClientRequestAuth {
  /**
   * Authenticates using the credentials which were
   * provided within the request headers of the
   * client call to the microservice.
   * @param headers
   */
  constructor(headers = {}) {
    this.xsrfToken = this.getCookieValue(headers, "XSRF-TOKEN");
    this.authTokenFromCookie = this.getCookieValue(headers, "authorization");
    this.authTokenFromHeader = headers.authorization;
  }
  updateCredentials() {
    return void 0;
  }
  getFetchOptions(options) {
    const headers = Object.assign({ Authorization: this.authTokenFromCookie ? `Bearer ${this.authTokenFromCookie}` : this.authTokenFromHeader }, this.xsrfToken ? { "X-XSRF-TOKEN": this.xsrfToken } : void 0);
    options.headers = Object.assign(headers, options.headers);
    return options;
  }
  getCometdHandshake(config = {}) {
    const KEY = "com.cumulocity.authn";
    const xsrfToken = this.xsrfToken;
    let token = this.authTokenFromCookie;
    if (!token && this.authTokenFromHeader) {
      token = this.authTokenFromHeader.replace("Basic ", "").replace("Bearer ", "");
    }
    const ext = config.ext = config.ext || {};
    ext[KEY] = Object.assign(ext[KEY] || {}, Object.assign({ token }, xsrfToken ? { xsrfToken } : void 0));
    return config;
  }
  logout() {
    if (this.authTokenFromCookie) {
      delete this.authTokenFromCookie;
    }
    if (this.authTokenFromHeader) {
      delete this.authTokenFromHeader;
    }
    if (this.xsrfToken) {
      delete this.xsrfToken;
    }
  }
  getCookieValue(headers, name2) {
    try {
      const value2 = headers && headers.cookie && headers.cookie.match("(^|;)\\s*" + name2 + "\\s*=\\s*([^;]+)");
      return value2 ? value2.pop() : void 0;
    } catch (ex) {
      return void 0;
    }
  }
}
class NodeJSCookieAuth extends MicroserviceClientRequestAuth {
  constructor(cookieResponse) {
    super();
    const setCookiesHeader = cookieResponse.headers.get("set-cookie");
    if (!setCookiesHeader) {
      throw Error("No Cookie set");
    }
    this.authTokenFromCookie = this.getCookieValue({ cookie: setCookiesHeader }, "authorization");
  }
}
class QueriesUtil {
  constructor() {
    this.operatorFns = {
      __not: (operand) => {
        return `not(${this.buildQueryFilter(operand, null)})`;
      },
      __and: (operand) => {
        return this.buildQueryFilter(operand, null, "and");
      },
      __or: (operand) => {
        return this.buildQueryFilter(operand, null, "or");
      },
      __eq: (operand, contextKey) => {
        if (typeof operand === "object" && operand !== null) {
          return this.buildQueryFilter(operand, contextKey);
        }
        return `${contextKey} eq ${this.quoteString(operand)}`;
      },
      __gt: (operand, contextKey) => {
        return `${contextKey} gt ${this.quoteString(operand)}`;
      },
      __ge: (operand, contextKey) => {
        return `${contextKey} ge ${this.quoteString(operand)}`;
      },
      __lt: (operand, contextKey) => {
        return `${contextKey} lt ${this.quoteString(operand)}`;
      },
      __le: (operand, contextKey) => {
        return `${contextKey} le ${this.quoteString(operand)}`;
      },
      __in: (operand, contextKey) => {
        const stmts = operand.filter((op) => !!op).map((op) => {
          return `${contextKey} eq ${this.quoteString(op)}`;
        });
        return this.glue(stmts, "or");
      },
      __bygroupid: (operand) => {
        return `bygroupid(${operand})`;
      },
      __has: (operand) => {
        return `has(${operand})`;
      },
      __useFilterQueryString: (queryString) => {
        var _a;
        const query = (_a = queryString.match(/\(.*\)/)) === null || _a === void 0 ? void 0 : _a[0];
        return query === null || query === void 0 ? void 0 : query.substring(1, query.length - 1);
      }
    };
  }
  /**
   * Builds query string from provided query object.
   *
   * @param query Object containing filters and sort order for querying managed objects. Supported filters are:
   * - **__and** - Specifies conditions, e.g. `{__and: [{__has: 'c8y_IsDevice'}, {'count': {__gt: 0}}]}`.
   * - **__or** - Specifies alternative conditions, e.g. `{__or: [{__bygroupid: 10300}, {__bygroupid: 10400}]}`.
   * - **__eq** - Specified fragment must be equal to given value, e.g. `{'status': 'AVAILABLE'}` (no nested object required).
   * - **__lt** - Specified fragment must be less then given value, e.g. `{'count': {__lt: 10}}`.
   * - **__gt** - Specified fragment must be greater then given value, e.g. `{'count': {__gt: 0}}`.
   * - **__in** - Specified fragment must be equal to one of values in the list, e.g. `{'status': {__in: ['AVAILABLE', 'UNAVAILABLE']}}`.
   * - **__not** - Negates condition, e.g. `{__not: {'status': 'AVAILABLE'}}`.
   * - **__bygroupid** - True if filtered managed object is assigned to given group, e.g. `{__bygroupid: 10300}`.
   * - **__has** - Specified fragment must have a value defined, e.g. `{__has: 'c8y_IsDevice'}`.
   * - **__useFilterQueryString** - Gets rid of the `$filter=() $orderby=` parts of a query and keeps only what's between the most
   *                                exterior parentheses of the $filter.
   *                                EXAMPLE: takes a query of the form
   *                                `$filter=(name eq 'RaspPi*') $orderby=name asc`
   *                                and turns it into
   *                                `name eq 'RaspPi*'`
   *                                This is necessary for searching for smart groups, which are identified by their own query
   *                                that needs to be passed through.
   *
   * Note: if you want to specify the order, you need to wrap your filters within `__filter` property and then add `__orderby` with the array of field paths and sort directions (1 for ascending, -1 for descending), for example:
   * - `{ __filter: { ... }, __orderby: [{ 'creationTime': -1 }, { 'name': 1 }] }`
   *
   * @returns {string} Returns a query string ready to be sent in request params to backend.
   *
   * **Example**
   * ```typescript
   *   const query = {
   *     __filter: {
   *       'name': 'My Device*',
   *       'c8y_Availability.status': {
   *         __in: ['AVAILABLE', 'UNAVAILABLE']
   *       },
   *       'creationTime': {
   *         __lt: '2015-11-30T13:28:123Z'
   *       },
   *       'c8y_ActiveAlarmsStatus.critical': {
   *         __gt: 0
   *       },
   *       __or: [
   *         {__not: {__has: 'c8y_ActiveAlarmsStatus.major'}},
   *         {
   *           __or: [
   *             {__bygroupid: 10300},
   *             {__bygroupid: 10400}
   *           ]
   *         }
   *       ]
   *     },
   *     __orderby: [
   *       {'name': 1},
   *       {'creationTime': -1},
   *       {'c8y_ActiveAlarmsStatus.critical': -1}
   *     ]
   *   };
   *
   *   const params = {
   *     query: queriesUtil.buildQuery(query)
   *   };
   * ```
   */
  buildQuery(query) {
    const q = [];
    const filter2 = this.buildQueryFilter(query.__filter || query);
    const orderBy2 = this.buildQueryOrderby(query.__orderby);
    if (filter2) {
      q.push(`$filter=(${filter2})`);
    }
    if (orderBy2) {
      q.push(`$orderby=${orderBy2}`);
    }
    return q.join(" ");
  }
  buildQueryFilter(queryFilter, _queryKey, _glueType) {
    const queryKey = _queryKey || null;
    const glueType = _glueType || "and";
    const q = [];
    if (Array.isArray(queryFilter)) {
      queryFilter.forEach((qFilter) => {
        const _q = this.buildQueryFilter(qFilter, null, glueType);
        if (_q) {
          q.push(_q);
        }
      });
    } else {
      let _q;
      Object.keys(queryFilter).forEach((k) => {
        if (this.operatorFns[k] !== void 0) {
          _q = this.operatorFns[k](queryFilter[k], queryKey);
          if (_q) {
            q.push(_q);
          }
        } else {
          _q = this.operatorFns.__eq(queryFilter[k], k);
          if (_q) {
            q.push(_q);
          }
        }
      });
    }
    return this.glue(q, glueType);
  }
  buildQueryOrderby(queryOrderbys) {
    const o2 = [];
    if (queryOrderbys) {
      queryOrderbys.forEach((q) => {
        Object.keys(q).forEach((k) => {
          if (q[k] !== 0) {
            o2.push(`${k} ${q[k] > 0 ? "asc" : "desc"}`);
          }
        });
      });
    }
    return o2.join(",");
  }
  addAndFilter(query, filter2) {
    return this.addFilter(query, filter2, "and");
  }
  addOrFilter(query, filter2) {
    return this.addFilter(query, filter2, "or");
  }
  addFilter(query, filter2, operator2) {
    const oldFilter = query.__orderby ? query.__filter || {} : query.__filter || query;
    const newFilter = { [`__${operator2}`]: this.skipEmptyObjects([oldFilter, filter2]) };
    if (!query.__filter && !query.__orderby) {
      return newFilter;
    }
    query.__filter = newFilter;
    return query;
  }
  prependOrderbys(query, orderbys) {
    return this.addOrderbys(query, orderbys, "prepend");
  }
  appendOrderbys(query, orderbys) {
    return this.addOrderbys(query, orderbys, "append");
  }
  addOrderbys(query, orderbys, how) {
    const oldFilter = query.__orderby ? query.__filter || {} : query.__filter || query;
    const oldOrderbys = query.__orderby || [];
    const newOrderbys = how === "prepend" ? [...orderbys, ...oldOrderbys] : [...oldOrderbys, ...orderbys];
    const newQuery = {
      __orderby: this.skipEmptyObjects(newOrderbys)
    };
    if (!this.isEmptyObject(oldFilter)) {
      newQuery.__filter = oldFilter;
    }
    return newQuery;
  }
  extractAndMergeOrderBys(queries) {
    if ((queries === null || queries === void 0 ? void 0 : queries.length) > 0) {
      const orderByQuery = queries.map((query) => {
        const token = "$orderby=";
        const tokenIndex = query.lastIndexOf(token);
        return tokenIndex !== -1 ? query.substring(tokenIndex + token.length) : null;
      }).filter((orderBy2) => orderBy2 !== null).join(",");
      return orderByQuery ? `$orderby=${orderByQuery}` : "";
    }
  }
  glue(stmts, type2) {
    return stmts.length > 1 ? `(${stmts.join(`) ${type2} (`)})` : stmts[0];
  }
  quoteString(s2) {
    return typeof s2 === "string" ? `'${this.escapeSingleQuote(s2)}'` : s2;
  }
  skipEmptyObjects(objs) {
    return objs.filter((obj) => !this.isEmptyObject(obj));
  }
  isEmptyObject(obj) {
    return Object.keys(obj).length === 0;
  }
  // OData does not support single quotes in the query. We need to replace all single quotes with double quotes.
  // http://docs.oasis-open.org/odata/odata/v4.01/cs01/part2-url-conventions/odata-v4.01-cs01-part2-url-conventions.html#sec_URLComponents
  escapeSingleQuote(s2) {
    if (typeof s2 !== "string") {
      return s2;
    }
    return s2.replace(/\'/g, "''");
  }
}
var cometd$1 = { exports: {} };
var cometd = cometd$1.exports;
var hasRequiredCometd;
function requireCometd() {
  if (hasRequiredCometd) return cometd$1.exports;
  hasRequiredCometd = 1;
  (function(module2, exports2) {
    (function(root2, factory) {
      {
        module2.exports = factory();
      }
    })(cometd, function() {
      var Scheduler = function() {
        var _ids = 0;
        var _tasks = {};
        this.register = function(funktion) {
          var id2 = ++_ids;
          _tasks[id2] = funktion;
          return id2;
        };
        this.unregister = function(id2) {
          var funktion = _tasks[id2];
          delete _tasks[id2];
          return funktion;
        };
        this.setTimeout = function(funktion, delay) {
          return window.setTimeout(funktion, delay);
        };
        this.clearTimeout = function(id2) {
          window.clearTimeout(id2);
        };
      };
      function WorkerScheduler() {
        var _tasks = {};
        self.onmessage = function(e) {
          var cmd = e.data;
          var id2 = _tasks[cmd.id];
          switch (cmd.type) {
            case "setTimeout":
              _tasks[cmd.id] = self.setTimeout(function() {
                delete _tasks[cmd.id];
                self.postMessage({
                  id: cmd.id
                });
              }, cmd.delay);
              break;
            case "clearTimeout":
              delete _tasks[cmd.id];
              if (id2) {
                self.clearTimeout(id2);
              }
              break;
            default:
              throw "Unknown command " + cmd.type;
          }
        };
      }
      var Utils = {
        isString: function(value2) {
          if (value2 === void 0 || value2 === null) {
            return false;
          }
          return typeof value2 === "string" || value2 instanceof String;
        },
        isArray: function(value2) {
          if (value2 === void 0 || value2 === null) {
            return false;
          }
          return value2 instanceof Array;
        },
        /**
         * Returns whether the given element is contained into the given array.
         * @param element the element to check presence for
         * @param array the array to check for the element presence
         * @return the index of the element, if present, or a negative index if the element is not present
         */
        inArray: function(element, array) {
          for (var i2 = 0; i2 < array.length; ++i2) {
            if (element === array[i2]) {
              return i2;
            }
          }
          return -1;
        }
      };
      var TransportRegistry = function() {
        var _types = [];
        var _transports = {};
        this.getTransportTypes = function() {
          return _types.slice(0);
        };
        this.findTransportTypes = function(version2, crossDomain, url2) {
          var result = [];
          for (var i2 = 0; i2 < _types.length; ++i2) {
            var type2 = _types[i2];
            if (_transports[type2].accept(version2, crossDomain, url2) === true) {
              result.push(type2);
            }
          }
          return result;
        };
        this.negotiateTransport = function(types, version2, crossDomain, url2) {
          for (var i2 = 0; i2 < _types.length; ++i2) {
            var type2 = _types[i2];
            for (var j = 0; j < types.length; ++j) {
              if (type2 === types[j]) {
                var transport = _transports[type2];
                if (transport.accept(version2, crossDomain, url2) === true) {
                  return transport;
                }
              }
            }
          }
          return null;
        };
        this.add = function(type2, transport, index2) {
          var existing = false;
          for (var i2 = 0; i2 < _types.length; ++i2) {
            if (_types[i2] === type2) {
              existing = true;
              break;
            }
          }
          if (!existing) {
            if (typeof index2 !== "number") {
              _types.push(type2);
            } else {
              _types.splice(index2, 0, type2);
            }
            _transports[type2] = transport;
          }
          return !existing;
        };
        this.find = function(type2) {
          for (var i2 = 0; i2 < _types.length; ++i2) {
            if (_types[i2] === type2) {
              return _transports[type2];
            }
          }
          return null;
        };
        this.remove = function(type2) {
          for (var i2 = 0; i2 < _types.length; ++i2) {
            if (_types[i2] === type2) {
              _types.splice(i2, 1);
              var transport = _transports[type2];
              delete _transports[type2];
              return transport;
            }
          }
          return null;
        };
        this.clear = function() {
          _types = [];
          _transports = {};
        };
        this.reset = function(init) {
          for (var i2 = 0; i2 < _types.length; ++i2) {
            _transports[_types[i2]].reset(init);
          }
        };
      };
      var Transport = function() {
        var _type;
        var _cometd;
        var _url;
        this.registered = function(type2, cometd2) {
          _type = type2;
          _cometd = cometd2;
        };
        this.unregistered = function() {
          _type = null;
          _cometd = null;
        };
        this._debug = function() {
          _cometd._debug.apply(_cometd, arguments);
        };
        this._mixin = function() {
          return _cometd._mixin.apply(_cometd, arguments);
        };
        this.getConfiguration = function() {
          return _cometd.getConfiguration();
        };
        this.getAdvice = function() {
          return _cometd.getAdvice();
        };
        this.setTimeout = function(funktion, delay) {
          return _cometd.setTimeout(funktion, delay);
        };
        this.clearTimeout = function(id2) {
          _cometd.clearTimeout(id2);
        };
        this.convertToMessages = function(response) {
          if (Utils.isString(response)) {
            try {
              return JSON.parse(response);
            } catch (x) {
              this._debug("Could not convert to JSON the following string", '"' + response + '"');
              throw x;
            }
          }
          if (Utils.isArray(response)) {
            return response;
          }
          if (response === void 0 || response === null) {
            return [];
          }
          if (response instanceof Object) {
            return [response];
          }
          throw "Conversion Error " + response + ", typeof " + typeof response;
        };
        this.accept = function(version2, crossDomain, url2) {
          throw "Abstract";
        };
        this.getType = function() {
          return _type;
        };
        this.getURL = function() {
          return _url;
        };
        this.setURL = function(url2) {
          _url = url2;
        };
        this.send = function(envelope, metaConnect) {
          throw "Abstract";
        };
        this.reset = function(init) {
          this._debug("Transport", _type, "reset", init ? "initial" : "retry");
        };
        this.abort = function() {
          this._debug("Transport", _type, "aborted");
        };
        this.toString = function() {
          return this.getType();
        };
      };
      Transport.derive = function(baseObject) {
        function F() {
        }
        F.prototype = baseObject;
        return new F();
      };
      var RequestTransport = function() {
        var _super = new Transport();
        var _self = Transport.derive(_super);
        var _requestIds = 0;
        var _metaConnectRequest = null;
        var _requests = [];
        var _envelopes = [];
        function _coalesceEnvelopes(envelope) {
          while (_envelopes.length > 0) {
            var envelopeAndRequest = _envelopes[0];
            var newEnvelope = envelopeAndRequest[0];
            var newRequest = envelopeAndRequest[1];
            if (newEnvelope.url === envelope.url && newEnvelope.sync === envelope.sync) {
              _envelopes.shift();
              envelope.messages = envelope.messages.concat(newEnvelope.messages);
              this._debug("Coalesced", newEnvelope.messages.length, "messages from request", newRequest.id);
              continue;
            }
            break;
          }
        }
        function _transportSend(envelope, request3) {
          this.transportSend(envelope, request3);
          request3.expired = false;
          if (!envelope.sync) {
            var maxDelay = this.getConfiguration().maxNetworkDelay;
            var delay = maxDelay;
            if (request3.metaConnect === true) {
              delay += this.getAdvice().timeout;
            }
            this._debug("Transport", this.getType(), "waiting at most", delay, "ms for the response, maxNetworkDelay", maxDelay);
            var self2 = this;
            request3.timeout = this.setTimeout(function() {
              request3.expired = true;
              var errorMessage = "Request " + request3.id + " of transport " + self2.getType() + " exceeded " + delay + " ms max network delay";
              var failure = {
                reason: errorMessage
              };
              var xhr = request3.xhr;
              failure.httpCode = self2.xhrStatus(xhr);
              self2.abortXHR(xhr);
              self2._debug(errorMessage);
              self2.complete(request3, false, request3.metaConnect);
              envelope.onFailure(xhr, envelope.messages, failure);
            }, delay);
          }
        }
        function _queueSend(envelope) {
          var requestId = ++_requestIds;
          var request3 = {
            id: requestId,
            metaConnect: false,
            envelope
          };
          if (_requests.length < this.getConfiguration().maxConnections - 1) {
            _requests.push(request3);
            _transportSend.call(this, envelope, request3);
          } else {
            this._debug("Transport", this.getType(), "queueing request", requestId, "envelope", envelope);
            _envelopes.push([envelope, request3]);
          }
        }
        function _metaConnectComplete(request3) {
          var requestId = request3.id;
          this._debug("Transport", this.getType(), "/meta/connect complete, request", requestId);
          if (_metaConnectRequest !== null && _metaConnectRequest.id !== requestId) {
            throw "/meta/connect request mismatch, completing request " + requestId;
          }
          _metaConnectRequest = null;
        }
        function _complete(request3, success) {
          var index2 = Utils.inArray(request3, _requests);
          if (index2 >= 0) {
            _requests.splice(index2, 1);
          }
          if (_envelopes.length > 0) {
            var envelopeAndRequest = _envelopes.shift();
            var nextEnvelope = envelopeAndRequest[0];
            var nextRequest = envelopeAndRequest[1];
            this._debug("Transport dequeued request", nextRequest.id);
            if (success) {
              if (this.getConfiguration().autoBatch) {
                _coalesceEnvelopes.call(this, nextEnvelope);
              }
              _queueSend.call(this, nextEnvelope);
              this._debug("Transport completed request", request3.id, nextEnvelope);
            } else {
              var self2 = this;
              this.setTimeout(function() {
                self2.complete(nextRequest, false, nextRequest.metaConnect);
                var failure = {
                  reason: "Previous request failed"
                };
                var xhr = nextRequest.xhr;
                failure.httpCode = self2.xhrStatus(xhr);
                nextEnvelope.onFailure(xhr, nextEnvelope.messages, failure);
              }, 0);
            }
          }
        }
        _self.complete = function(request3, success, metaConnect) {
          if (metaConnect) {
            _metaConnectComplete.call(this, request3);
          } else {
            _complete.call(this, request3, success);
          }
        };
        _self.transportSend = function(envelope, request3) {
          throw "Abstract";
        };
        _self.transportSuccess = function(envelope, request3, responses) {
          if (!request3.expired) {
            this.clearTimeout(request3.timeout);
            this.complete(request3, true, request3.metaConnect);
            if (responses && responses.length > 0) {
              envelope.onSuccess(responses);
            } else {
              envelope.onFailure(request3.xhr, envelope.messages, {
                httpCode: 204
              });
            }
          }
        };
        _self.transportFailure = function(envelope, request3, failure) {
          if (!request3.expired) {
            this.clearTimeout(request3.timeout);
            this.complete(request3, false, request3.metaConnect);
            envelope.onFailure(request3.xhr, envelope.messages, failure);
          }
        };
        function _metaConnectSend(envelope) {
          if (_metaConnectRequest !== null) {
            throw "Concurrent /meta/connect requests not allowed, request id=" + _metaConnectRequest.id + " not yet completed";
          }
          var requestId = ++_requestIds;
          this._debug("Transport", this.getType(), "/meta/connect send, request", requestId, "envelope", envelope);
          var request3 = {
            id: requestId,
            metaConnect: true,
            envelope
          };
          _transportSend.call(this, envelope, request3);
          _metaConnectRequest = request3;
        }
        _self.send = function(envelope, metaConnect) {
          if (metaConnect) {
            _metaConnectSend.call(this, envelope);
          } else {
            _queueSend.call(this, envelope);
          }
        };
        _self.abort = function() {
          _super.abort();
          for (var i2 = 0; i2 < _requests.length; ++i2) {
            var request3 = _requests[i2];
            if (request3) {
              this._debug("Aborting request", request3);
              if (!this.abortXHR(request3.xhr)) {
                this.transportFailure(request3.envelope, request3, { reason: "abort" });
              }
            }
          }
          var metaConnectRequest = _metaConnectRequest;
          if (metaConnectRequest) {
            this._debug("Aborting /meta/connect request", metaConnectRequest);
            if (!this.abortXHR(metaConnectRequest.xhr)) {
              this.transportFailure(metaConnectRequest.envelope, metaConnectRequest, { reason: "abort" });
            }
          }
          this.reset(true);
        };
        _self.reset = function(init) {
          _super.reset(init);
          _metaConnectRequest = null;
          _requests = [];
          _envelopes = [];
        };
        _self.abortXHR = function(xhr) {
          if (xhr) {
            try {
              var state = xhr.readyState;
              xhr.abort();
              return state !== window.XMLHttpRequest.UNSENT;
            } catch (x) {
              this._debug(x);
            }
          }
          return false;
        };
        _self.xhrStatus = function(xhr) {
          if (xhr) {
            try {
              return xhr.status;
            } catch (x) {
              this._debug(x);
            }
          }
          return -1;
        };
        return _self;
      };
      var LongPollingTransport = function() {
        var _super = new RequestTransport();
        var _self = Transport.derive(_super);
        var _supportsCrossDomain = true;
        _self.accept = function(version2, crossDomain, url2) {
          return _supportsCrossDomain || !crossDomain;
        };
        _self.newXMLHttpRequest = function() {
          return new window.XMLHttpRequest();
        };
        function _copyContext(xhr) {
          try {
            xhr.context = _self.context;
          } catch (e) {
            this._debug("Could not copy transport context into XHR", e);
          }
        }
        _self.xhrSend = function(packet) {
          var xhr = _self.newXMLHttpRequest();
          _copyContext(xhr);
          xhr.withCredentials = true;
          xhr.open("POST", packet.url, packet.sync !== true);
          var headers = packet.headers;
          if (headers) {
            for (var headerName in headers) {
              if (headers.hasOwnProperty(headerName)) {
                xhr.setRequestHeader(headerName, headers[headerName]);
              }
            }
          }
          xhr.setRequestHeader("Content-Type", "application/json;charset=UTF-8");
          xhr.onload = function() {
            if (xhr.status === 200) {
              packet.onSuccess(xhr.responseText);
            } else {
              packet.onError(xhr.statusText);
            }
          };
          xhr.onabort = xhr.onerror = function() {
            packet.onError(xhr.statusText);
          };
          xhr.send(packet.body);
          return xhr;
        };
        _self.transportSend = function(envelope, request3) {
          this._debug("Transport", this.getType(), "sending request", request3.id, "envelope", envelope);
          var self2 = this;
          try {
            var sameStack = true;
            request3.xhr = this.xhrSend({
              transport: this,
              url: envelope.url,
              sync: envelope.sync,
              headers: this.getConfiguration().requestHeaders,
              body: JSON.stringify(envelope.messages),
              onSuccess: function(response) {
                self2._debug("Transport", self2.getType(), "received response", response);
                var success = false;
                try {
                  var received = self2.convertToMessages(response);
                  if (received.length === 0) {
                    _supportsCrossDomain = false;
                    self2.transportFailure(envelope, request3, {
                      httpCode: 204
                    });
                  } else {
                    success = true;
                    self2.transportSuccess(envelope, request3, received);
                  }
                } catch (x) {
                  self2._debug(x);
                  if (!success) {
                    _supportsCrossDomain = false;
                    var failure = {
                      exception: x
                    };
                    failure.httpCode = self2.xhrStatus(request3.xhr);
                    self2.transportFailure(envelope, request3, failure);
                  }
                }
              },
              onError: function(reason, exception) {
                self2._debug("Transport", self2.getType(), "received error", reason, exception);
                _supportsCrossDomain = false;
                var failure = {
                  reason,
                  exception
                };
                failure.httpCode = self2.xhrStatus(request3.xhr);
                if (sameStack) {
                  self2.setTimeout(function() {
                    self2.transportFailure(envelope, request3, failure);
                  }, 0);
                } else {
                  self2.transportFailure(envelope, request3, failure);
                }
              }
            });
            sameStack = false;
          } catch (x) {
            _supportsCrossDomain = false;
            this.setTimeout(function() {
              self2.transportFailure(envelope, request3, {
                exception: x
              });
            }, 0);
          }
        };
        _self.reset = function(init) {
          _super.reset(init);
          _supportsCrossDomain = true;
        };
        return _self;
      };
      var CallbackPollingTransport = function() {
        var _super = new RequestTransport();
        var _self = Transport.derive(_super);
        var jsonp = 0;
        _self.accept = function(version2, crossDomain, url2) {
          return true;
        };
        _self.jsonpSend = function(packet) {
          var head = document.getElementsByTagName("head")[0];
          var script = document.createElement("script");
          var callbackName = "_cometd_jsonp_" + jsonp++;
          window[callbackName] = function(responseText) {
            head.removeChild(script);
            delete window[callbackName];
            packet.onSuccess(responseText);
          };
          var url2 = packet.url;
          url2 += url2.indexOf("?") < 0 ? "?" : "&";
          url2 += "jsonp=" + callbackName;
          url2 += "&message=" + encodeURIComponent(packet.body);
          script.src = url2;
          script.async = packet.sync !== true;
          script.type = "application/javascript";
          script.onerror = function(e) {
            packet.onError("jsonp " + e.type);
          };
          head.appendChild(script);
        };
        function _failTransportFn(envelope, request3, x) {
          var self2 = this;
          return function() {
            self2.transportFailure(envelope, request3, "error", x);
          };
        }
        _self.transportSend = function(envelope, request3) {
          var self2 = this;
          var start2 = 0;
          var length = envelope.messages.length;
          var lengths = [];
          while (length > 0) {
            var json = JSON.stringify(envelope.messages.slice(start2, start2 + length));
            var urlLength = envelope.url.length + encodeURI(json).length;
            var maxLength = this.getConfiguration().maxURILength;
            if (urlLength > maxLength) {
              if (length === 1) {
                var x = "Bayeux message too big (" + urlLength + " bytes, max is " + maxLength + ") for transport " + this.getType();
                this.setTimeout(_failTransportFn.call(this, envelope, request3, x), 0);
                return;
              }
              --length;
              continue;
            }
            lengths.push(length);
            start2 += length;
            length = envelope.messages.length - start2;
          }
          var envelopeToSend = envelope;
          if (lengths.length > 1) {
            var begin = 0;
            var end2 = lengths[0];
            this._debug("Transport", this.getType(), "split", envelope.messages.length, "messages into", lengths.join(" + "));
            envelopeToSend = this._mixin(false, {}, envelope);
            envelopeToSend.messages = envelope.messages.slice(begin, end2);
            envelopeToSend.onSuccess = envelope.onSuccess;
            envelopeToSend.onFailure = envelope.onFailure;
            for (var i2 = 1; i2 < lengths.length; ++i2) {
              var nextEnvelope = this._mixin(false, {}, envelope);
              begin = end2;
              end2 += lengths[i2];
              nextEnvelope.messages = envelope.messages.slice(begin, end2);
              nextEnvelope.onSuccess = envelope.onSuccess;
              nextEnvelope.onFailure = envelope.onFailure;
              this.send(nextEnvelope, request3.metaConnect);
            }
          }
          this._debug("Transport", this.getType(), "sending request", request3.id, "envelope", envelopeToSend);
          try {
            var sameStack = true;
            this.jsonpSend({
              transport: this,
              url: envelopeToSend.url,
              sync: envelopeToSend.sync,
              headers: this.getConfiguration().requestHeaders,
              body: JSON.stringify(envelopeToSend.messages),
              onSuccess: function(responses) {
                var success = false;
                try {
                  var received = self2.convertToMessages(responses);
                  if (received.length === 0) {
                    self2.transportFailure(envelopeToSend, request3, {
                      httpCode: 204
                    });
                  } else {
                    success = true;
                    self2.transportSuccess(envelopeToSend, request3, received);
                  }
                } catch (x2) {
                  self2._debug(x2);
                  if (!success) {
                    self2.transportFailure(envelopeToSend, request3, {
                      exception: x2
                    });
                  }
                }
              },
              onError: function(reason, exception) {
                var failure = {
                  reason,
                  exception
                };
                if (sameStack) {
                  self2.setTimeout(function() {
                    self2.transportFailure(envelopeToSend, request3, failure);
                  }, 0);
                } else {
                  self2.transportFailure(envelopeToSend, request3, failure);
                }
              }
            });
            sameStack = false;
          } catch (xx) {
            this.setTimeout(function() {
              self2.transportFailure(envelopeToSend, request3, {
                exception: xx
              });
            }, 0);
          }
        };
        return _self;
      };
      var WebSocketTransport = function() {
        var _super = new Transport();
        var _self = Transport.derive(_super);
        var _cometd;
        var _webSocketSupported = true;
        var _webSocketConnected = false;
        var _stickyReconnect = true;
        var _context = null;
        var _connecting = null;
        var _connected = false;
        var _successCallback = null;
        _self.reset = function(init) {
          _super.reset(init);
          _webSocketSupported = true;
          if (init) {
            _webSocketConnected = false;
          }
          _stickyReconnect = true;
          _context = null;
          _connecting = null;
          _connected = false;
        };
        function _forceClose(context, event) {
          if (context) {
            this.webSocketClose(context, event.code, event.reason);
            this.onClose(context, event);
          }
        }
        function _sameContext(context) {
          return context === _connecting || context === _context;
        }
        function _storeEnvelope(context, envelope, metaConnect) {
          var messageIds = [];
          for (var i2 = 0; i2 < envelope.messages.length; ++i2) {
            var message2 = envelope.messages[i2];
            if (message2.id) {
              messageIds.push(message2.id);
            }
          }
          context.envelopes[messageIds.join(",")] = [envelope, metaConnect];
          this._debug("Transport", this.getType(), "stored envelope, envelopes", context.envelopes);
        }
        function _websocketConnect(context) {
          if (_connecting) {
            return;
          }
          var url2 = _cometd.getURL().replace(/^http/, "ws");
          this._debug("Transport", this.getType(), "connecting to URL", url2);
          try {
            var protocol = _cometd.getConfiguration().protocol;
            context.webSocket = protocol ? new window.WebSocket(url2, protocol) : new window.WebSocket(url2);
            _connecting = context;
          } catch (x) {
            _webSocketSupported = false;
            this._debug("Exception while creating WebSocket object", x);
            throw x;
          }
          _stickyReconnect = _cometd.getConfiguration().stickyReconnect !== false;
          var self2 = this;
          var connectTimeout = _cometd.getConfiguration().connectTimeout;
          if (connectTimeout > 0) {
            context.connectTimer = this.setTimeout(function() {
              _cometd._debug("Transport", self2.getType(), "timed out while connecting to URL", url2, ":", connectTimeout, "ms");
              _forceClose.call(self2, context, { code: 1e3, reason: "Connect Timeout" });
            }, connectTimeout);
          }
          var onopen = function() {
            _cometd._debug("WebSocket onopen", context);
            if (context.connectTimer) {
              self2.clearTimeout(context.connectTimer);
            }
            if (_sameContext(context)) {
              _connecting = null;
              _context = context;
              _webSocketConnected = true;
              self2.onOpen(context);
            } else {
              _cometd._warn("Closing extra WebSocket connection", this, "active connection", _context);
              _forceClose.call(self2, context, { code: 1e3, reason: "Extra Connection" });
            }
          };
          var onclose = function(event) {
            event = event || { code: 1e3 };
            _cometd._debug("WebSocket onclose", context, event, "connecting", _connecting, "current", _context);
            if (context.connectTimer) {
              self2.clearTimeout(context.connectTimer);
            }
            self2.onClose(context, event);
          };
          var onmessage = function(wsMessage) {
            _cometd._debug("WebSocket onmessage", wsMessage, context);
            self2.onMessage(context, wsMessage);
          };
          context.webSocket.onopen = onopen;
          context.webSocket.onclose = onclose;
          context.webSocket.onerror = function() {
            onclose({ code: 1e3, reason: "Error" });
          };
          context.webSocket.onmessage = onmessage;
          this._debug("Transport", this.getType(), "configured callbacks on", context);
        }
        function _webSocketSend(context, envelope, metaConnect) {
          var json = JSON.stringify(envelope.messages);
          context.webSocket.send(json);
          this._debug("Transport", this.getType(), "sent", envelope, "/meta/connect =", metaConnect);
          var maxDelay = this.getConfiguration().maxNetworkDelay;
          var delay = maxDelay;
          if (metaConnect) {
            delay += this.getAdvice().timeout;
            _connected = true;
          }
          var self2 = this;
          var messageIds = [];
          for (var i2 = 0; i2 < envelope.messages.length; ++i2) {
            (function() {
              var message2 = envelope.messages[i2];
              if (message2.id) {
                messageIds.push(message2.id);
                context.timeouts[message2.id] = self2.setTimeout(function() {
                  _cometd._debug("Transport", self2.getType(), "timing out message", message2.id, "after", delay, "on", context);
                  _forceClose.call(self2, context, { code: 1e3, reason: "Message Timeout" });
                }, delay);
              }
            })();
          }
          this._debug("Transport", this.getType(), "waiting at most", delay, "ms for messages", messageIds, "maxNetworkDelay", maxDelay, ", timeouts:", context.timeouts);
        }
        _self._notifySuccess = function(fn, messages) {
          fn.call(this, messages);
        };
        _self._notifyFailure = function(fn, context, messages, failure) {
          fn.call(this, context, messages, failure);
        };
        function _send(context, envelope, metaConnect) {
          try {
            if (context === null) {
              context = _connecting || {
                envelopes: {},
                timeouts: {}
              };
              _storeEnvelope.call(this, context, envelope, metaConnect);
              _websocketConnect.call(this, context);
            } else {
              _storeEnvelope.call(this, context, envelope, metaConnect);
              _webSocketSend.call(this, context, envelope, metaConnect);
            }
          } catch (x) {
            var self2 = this;
            this.setTimeout(function() {
              _forceClose.call(self2, context, {
                code: 1e3,
                reason: "Exception",
                exception: x
              });
            }, 0);
          }
        }
        _self.onOpen = function(context) {
          var envelopes = context.envelopes;
          this._debug("Transport", this.getType(), "opened", context, "pending messages", envelopes);
          for (var key in envelopes) {
            if (envelopes.hasOwnProperty(key)) {
              var element = envelopes[key];
              var envelope = element[0];
              var metaConnect = element[1];
              _successCallback = envelope.onSuccess;
              _webSocketSend.call(this, context, envelope, metaConnect);
            }
          }
        };
        _self.onMessage = function(context, wsMessage) {
          this._debug("Transport", this.getType(), "received websocket message", wsMessage, context);
          var close2 = false;
          var messages = this.convertToMessages(wsMessage.data);
          var messageIds = [];
          for (var i2 = 0; i2 < messages.length; ++i2) {
            var message2 = messages[i2];
            if (/^\/meta\//.test(message2.channel) || message2.data === void 0) {
              if (message2.id) {
                messageIds.push(message2.id);
                var timeout = context.timeouts[message2.id];
                if (timeout) {
                  this.clearTimeout(timeout);
                  delete context.timeouts[message2.id];
                  this._debug("Transport", this.getType(), "removed timeout for message", message2.id, ", timeouts", context.timeouts);
                }
              }
            }
            if ("/meta/connect" === message2.channel) {
              _connected = false;
            }
            if ("/meta/disconnect" === message2.channel && !_connected) {
              close2 = true;
            }
          }
          var removed = false;
          var envelopes = context.envelopes;
          for (var j = 0; j < messageIds.length; ++j) {
            var id2 = messageIds[j];
            for (var key in envelopes) {
              if (envelopes.hasOwnProperty(key)) {
                var ids = key.split(",");
                var index2 = Utils.inArray(id2, ids);
                if (index2 >= 0) {
                  removed = true;
                  ids.splice(index2, 1);
                  var envelope = envelopes[key][0];
                  var metaConnect = envelopes[key][1];
                  delete envelopes[key];
                  if (ids.length > 0) {
                    envelopes[ids.join(",")] = [envelope, metaConnect];
                  }
                  break;
                }
              }
            }
          }
          if (removed) {
            this._debug("Transport", this.getType(), "removed envelope, envelopes", envelopes);
          }
          this._notifySuccess(_successCallback, messages);
          if (close2) {
            this.webSocketClose(context, 1e3, "Disconnect");
          }
        };
        _self.onClose = function(context, event) {
          this._debug("Transport", this.getType(), "closed", context, event);
          if (_sameContext(context)) {
            _webSocketSupported = _stickyReconnect && _webSocketConnected;
            _connecting = null;
            _context = null;
          }
          var timeouts = context.timeouts;
          context.timeouts = {};
          for (var id2 in timeouts) {
            if (timeouts.hasOwnProperty(id2)) {
              this.clearTimeout(timeouts[id2]);
            }
          }
          var envelopes = context.envelopes;
          context.envelopes = {};
          for (var key in envelopes) {
            if (envelopes.hasOwnProperty(key)) {
              var envelope = envelopes[key][0];
              var metaConnect = envelopes[key][1];
              if (metaConnect) {
                _connected = false;
              }
              var failure = {
                websocketCode: event.code,
                reason: event.reason
              };
              if (event.exception) {
                failure.exception = event.exception;
              }
              this._notifyFailure(envelope.onFailure, context, envelope.messages, failure);
            }
          }
        };
        _self.registered = function(type2, cometd2) {
          _super.registered(type2, cometd2);
          _cometd = cometd2;
        };
        _self.accept = function(version2, crossDomain, url2) {
          this._debug("Transport", this.getType(), "accept, supported:", _webSocketSupported);
          return _webSocketSupported && !!window.WebSocket && _cometd.websocketEnabled !== false;
        };
        _self.send = function(envelope, metaConnect) {
          this._debug("Transport", this.getType(), "sending", envelope, "/meta/connect =", metaConnect);
          _send.call(this, _context, envelope, metaConnect);
        };
        _self.webSocketClose = function(context, code, reason) {
          try {
            if (context.webSocket) {
              context.webSocket.close(code, reason);
            }
          } catch (x) {
            this._debug(x);
          }
        };
        _self.abort = function() {
          _super.abort();
          _forceClose.call(this, _context, { code: 1e3, reason: "Abort" });
          this.reset(true);
        };
        return _self;
      };
      var CometD = function(name2) {
        var _scheduler = new Scheduler();
        var _cometd = this;
        var _name = name2 || "default";
        var _crossDomain = false;
        var _transports = new TransportRegistry();
        var _transport;
        var _status = "disconnected";
        var _messageId = 0;
        var _clientId = null;
        var _batch = 0;
        var _messageQueue = [];
        var _internalBatch = false;
        var _listenerId = 0;
        var _listeners = {};
        var _backoff = 0;
        var _scheduledSend = null;
        var _extensions = [];
        var _advice = {};
        var _handshakeProps;
        var _handshakeCallback;
        var _callbacks = {};
        var _remoteCalls = {};
        var _reestablish = false;
        var _connected = false;
        var _unconnectTime = 0;
        var _handshakeMessages = 0;
        var _metaConnect = null;
        var _config = {
          useWorkerScheduler: true,
          protocol: null,
          stickyReconnect: true,
          connectTimeout: 0,
          maxConnections: 2,
          backoffIncrement: 1e3,
          maxBackoff: 6e4,
          logLevel: "info",
          maxNetworkDelay: 1e4,
          requestHeaders: {},
          appendMessageTypeToURL: true,
          autoBatch: false,
          urls: {},
          maxURILength: 2e3,
          advice: {
            timeout: 6e4,
            interval: 0,
            reconnect: void 0,
            maxInterval: 0
          }
        };
        function _fieldValue(object, name3) {
          try {
            return object[name3];
          } catch (x) {
            return void 0;
          }
        }
        this._mixin = function(deep, target2, objects) {
          var result = target2 || {};
          for (var i2 = 2; i2 < arguments.length; ++i2) {
            var object = arguments[i2];
            if (object === void 0 || object === null) {
              continue;
            }
            for (var propName in object) {
              if (object.hasOwnProperty(propName)) {
                var prop = _fieldValue(object, propName);
                var targ = _fieldValue(result, propName);
                if (prop === target2) {
                  continue;
                }
                if (prop === void 0) {
                  continue;
                }
                if (deep && typeof prop === "object" && prop !== null) {
                  if (prop instanceof Array) {
                    result[propName] = this._mixin(deep, targ instanceof Array ? targ : [], prop);
                  } else {
                    var source2 = typeof targ === "object" && !(targ instanceof Array) ? targ : {};
                    result[propName] = this._mixin(deep, source2, prop);
                  }
                } else {
                  result[propName] = prop;
                }
              }
            }
          }
          return result;
        };
        function _isString(value2) {
          return Utils.isString(value2);
        }
        function _isFunction(value2) {
          if (value2 === void 0 || value2 === null) {
            return false;
          }
          return typeof value2 === "function";
        }
        function _zeroPad(value2, length) {
          var result = "";
          while (--length > 0) {
            if (value2 >= Math.pow(10, length)) {
              break;
            }
            result += "0";
          }
          result += value2;
          return result;
        }
        function _log(level, args) {
          if (window.console) {
            var logger = window.console[level];
            if (_isFunction(logger)) {
              var now = /* @__PURE__ */ new Date();
              [].splice.call(args, 0, 0, _zeroPad(now.getHours(), 2) + ":" + _zeroPad(now.getMinutes(), 2) + ":" + _zeroPad(now.getSeconds(), 2) + "." + _zeroPad(now.getMilliseconds(), 3));
              logger.apply(window.console, args);
            }
          }
        }
        this._warn = function() {
          _log("warn", arguments);
        };
        this._info = function() {
          if (_config.logLevel !== "warn") {
            _log("info", arguments);
          }
        };
        this._debug = function() {
          if (_config.logLevel === "debug") {
            _log("debug", arguments);
          }
        };
        function _splitURL(url2) {
          return new RegExp("(^https?://)?(((\\[[^\\]]+])|([^:/?#]+))(:(\\d+))?)?([^?#]*)(.*)?").exec(url2);
        }
        this._isCrossDomain = function(hostAndPort) {
          if (window.location && window.location.host) {
            if (hostAndPort) {
              return hostAndPort !== window.location.host;
            }
          }
          return false;
        };
        function _configure(configuration2) {
          _cometd._debug("Configuring cometd object with", configuration2);
          if (_isString(configuration2)) {
            configuration2 = {
              url: configuration2
            };
          }
          if (!configuration2) {
            configuration2 = {};
          }
          _config = _cometd._mixin(false, _config, configuration2);
          var url2 = _cometd.getURL();
          if (!url2) {
            throw "Missing required configuration parameter 'url' specifying the Bayeux server URL";
          }
          var urlParts = _splitURL(url2);
          var hostAndPort = urlParts[2];
          var uri = urlParts[8];
          var afterURI = urlParts[9];
          _crossDomain = _cometd._isCrossDomain(hostAndPort);
          if (_config.appendMessageTypeToURL) {
            if (afterURI !== void 0 && afterURI.length > 0) {
              _cometd._info("Appending message type to URI " + uri + afterURI + " is not supported, disabling 'appendMessageTypeToURL' configuration");
              _config.appendMessageTypeToURL = false;
            } else {
              var uriSegments = uri.split("/");
              var lastSegmentIndex = uriSegments.length - 1;
              if (uri.match(/\/$/)) {
                lastSegmentIndex -= 1;
              }
              if (uriSegments[lastSegmentIndex].indexOf(".") >= 0) {
                _cometd._info("Appending message type to URI " + uri + " is not supported, disabling 'appendMessageTypeToURL' configuration");
                _config.appendMessageTypeToURL = false;
              }
            }
          }
          if (window.Worker && window.Blob && window.URL && _config.useWorkerScheduler) {
            var code = WorkerScheduler.toString();
            code = code.substring(code.indexOf("{") + 1, code.lastIndexOf("}"));
            var blob = new window.Blob([code], {
              type: "application/json"
            });
            var blobURL = window.URL.createObjectURL(blob);
            var worker = new window.Worker(blobURL);
            _scheduler.setTimeout = function(funktion, delay) {
              var id2 = _scheduler.register(funktion);
              worker.postMessage({
                id: id2,
                type: "setTimeout",
                delay
              });
              return id2;
            };
            _scheduler.clearTimeout = function(id2) {
              _scheduler.unregister(id2);
              worker.postMessage({
                id: id2,
                type: "clearTimeout"
              });
            };
            worker.onmessage = function(e) {
              var id2 = e.data.id;
              var funktion = _scheduler.unregister(id2);
              if (funktion) {
                funktion();
              }
            };
          }
        }
        function _removeListener(subscription) {
          if (subscription) {
            var subscriptions = _listeners[subscription.channel];
            if (subscriptions && subscriptions[subscription.id]) {
              delete subscriptions[subscription.id];
              _cometd._debug("Removed", subscription.listener ? "listener" : "subscription", subscription);
            }
          }
        }
        function _removeSubscription(subscription) {
          if (subscription && !subscription.listener) {
            _removeListener(subscription);
          }
        }
        function _clearSubscriptions() {
          for (var channel in _listeners) {
            if (_listeners.hasOwnProperty(channel)) {
              var subscriptions = _listeners[channel];
              if (subscriptions) {
                for (var id2 in subscriptions) {
                  if (subscriptions.hasOwnProperty(id2)) {
                    _removeSubscription(subscriptions[id2]);
                  }
                }
              }
            }
          }
        }
        function _setStatus(newStatus) {
          if (_status !== newStatus) {
            _cometd._debug("Status", _status, "->", newStatus);
            _status = newStatus;
          }
        }
        function _isDisconnected() {
          return _status === "disconnecting" || _status === "disconnected";
        }
        function _nextMessageId() {
          var result = ++_messageId;
          return "" + result;
        }
        function _applyExtension(scope, callback, name3, message2, outgoing) {
          try {
            return callback.call(scope, message2);
          } catch (x) {
            var handler = _cometd.onExtensionException;
            if (_isFunction(handler)) {
              _cometd._debug("Invoking extension exception handler", name3, x);
              try {
                handler.call(_cometd, x, name3, outgoing, message2);
              } catch (xx) {
                _cometd._info("Exception during execution of extension exception handler", name3, xx);
              }
            } else {
              _cometd._info("Exception during execution of extension", name3, x);
            }
            return message2;
          }
        }
        function _applyIncomingExtensions(message2) {
          for (var i2 = 0; i2 < _extensions.length; ++i2) {
            if (message2 === void 0 || message2 === null) {
              break;
            }
            var extension = _extensions[i2];
            var callback = extension.extension.incoming;
            if (_isFunction(callback)) {
              var result = _applyExtension(extension.extension, callback, extension.name, message2, false);
              message2 = result === void 0 ? message2 : result;
            }
          }
          return message2;
        }
        function _applyOutgoingExtensions(message2) {
          for (var i2 = _extensions.length - 1; i2 >= 0; --i2) {
            if (message2 === void 0 || message2 === null) {
              break;
            }
            var extension = _extensions[i2];
            var callback = extension.extension.outgoing;
            if (_isFunction(callback)) {
              var result = _applyExtension(extension.extension, callback, extension.name, message2, true);
              message2 = result === void 0 ? message2 : result;
            }
          }
          return message2;
        }
        function _notify(channel, message2) {
          var subscriptions = _listeners[channel];
          if (subscriptions) {
            for (var id2 in subscriptions) {
              if (subscriptions.hasOwnProperty(id2)) {
                var subscription = subscriptions[id2];
                if (subscription) {
                  try {
                    subscription.callback.call(subscription.scope, message2);
                  } catch (x) {
                    var handler = _cometd.onListenerException;
                    if (_isFunction(handler)) {
                      _cometd._debug("Invoking listener exception handler", subscription, x);
                      try {
                        handler.call(_cometd, x, subscription, subscription.listener, message2);
                      } catch (xx) {
                        _cometd._info("Exception during execution of listener exception handler", subscription, xx);
                      }
                    } else {
                      _cometd._info("Exception during execution of listener", subscription, message2, x);
                    }
                  }
                }
              }
            }
          }
        }
        function _notifyListeners(channel, message2) {
          _notify(channel, message2);
          var channelParts = channel.split("/");
          var last2 = channelParts.length - 1;
          for (var i2 = last2; i2 > 0; --i2) {
            var channelPart = channelParts.slice(0, i2).join("/") + "/*";
            if (i2 === last2) {
              _notify(channelPart, message2);
            }
            channelPart += "*";
            _notify(channelPart, message2);
          }
        }
        function _cancelDelayedSend() {
          if (_scheduledSend !== null) {
            _cometd.clearTimeout(_scheduledSend);
          }
          _scheduledSend = null;
        }
        function _delayedSend(operation2, delay) {
          _cancelDelayedSend();
          var time2 = _advice.interval + delay;
          _cometd._debug("Function scheduled in", time2, "ms, interval =", _advice.interval, "backoff =", _backoff, operation2);
          _scheduledSend = _cometd.setTimeout(operation2, time2);
        }
        var _handleMessages;
        var _handleFailure;
        function _send(messages, metaConnect, extraPath) {
          for (var i2 = 0; i2 < messages.length; ++i2) {
            var message2 = messages[i2];
            var messageId = message2.id;
            if (_clientId) {
              message2.clientId = _clientId;
            }
            message2 = _applyOutgoingExtensions(message2);
            if (message2 !== void 0 && message2 !== null) {
              message2.id = messageId;
              messages[i2] = message2;
            } else {
              delete _callbacks[messageId];
              messages.splice(i2--, 1);
            }
          }
          if (messages.length === 0) {
            return;
          }
          if (metaConnect) {
            _metaConnect = messages[0];
          }
          var url2 = _cometd.getURL();
          if (_config.appendMessageTypeToURL) {
            if (!url2.match(/\/$/)) {
              url2 = url2 + "/";
            }
            if (extraPath) {
              url2 = url2 + extraPath;
            }
          }
          var envelope = {
            url: url2,
            sync: false,
            messages,
            onSuccess: function(rcvdMessages) {
              try {
                _handleMessages.call(_cometd, rcvdMessages);
              } catch (x) {
                _cometd._info("Exception during handling of messages", x);
              }
            },
            onFailure: function(conduit, messages2, failure) {
              try {
                var transport = _cometd.getTransport();
                failure.connectionType = transport ? transport.getType() : "unknown";
                _handleFailure.call(_cometd, conduit, messages2, failure);
              } catch (x) {
                _cometd._info("Exception during handling of failure", x);
              }
            }
          };
          _cometd._debug("Send", envelope);
          _transport.send(envelope, metaConnect);
        }
        function _queueSend(message2) {
          if (_batch > 0 || _internalBatch === true) {
            _messageQueue.push(message2);
          } else {
            _send([message2], false);
          }
        }
        this.send = _queueSend;
        function _resetBackoff() {
          _backoff = 0;
        }
        function _increaseBackoff() {
          if (_backoff < _config.maxBackoff) {
            _backoff += _config.backoffIncrement;
          }
          return _backoff;
        }
        function _startBatch() {
          ++_batch;
          _cometd._debug("Starting batch, depth", _batch);
        }
        function _flushBatch() {
          var messages = _messageQueue;
          _messageQueue = [];
          if (messages.length > 0) {
            _send(messages, false);
          }
        }
        function _endBatch() {
          --_batch;
          _cometd._debug("Ending batch, depth", _batch);
          if (_batch < 0) {
            throw "Calls to startBatch() and endBatch() are not paired";
          }
          if (_batch === 0 && !_isDisconnected() && !_internalBatch) {
            _flushBatch();
          }
        }
        function _connect() {
          if (!_isDisconnected()) {
            var bayeuxMessage = {
              id: _nextMessageId(),
              channel: "/meta/connect",
              connectionType: _transport.getType()
            };
            if (!_connected) {
              bayeuxMessage.advice = {
                timeout: 0
              };
            }
            _setStatus("connecting");
            _cometd._debug("Connect sent", bayeuxMessage);
            _send([bayeuxMessage], true, "connect");
            _setStatus("connected");
          }
        }
        function _delayedConnect(delay) {
          _setStatus("connecting");
          _delayedSend(function() {
            _connect();
          }, delay);
        }
        function _updateAdvice(newAdvice) {
          if (newAdvice) {
            _advice = _cometd._mixin(false, {}, _config.advice, newAdvice);
            _cometd._debug("New advice", _advice);
          }
        }
        function _disconnect(abort) {
          _cancelDelayedSend();
          if (abort && _transport) {
            _transport.abort();
          }
          _crossDomain = false;
          _transport = null;
          _setStatus("disconnected");
          _clientId = null;
          _batch = 0;
          _resetBackoff();
          _reestablish = false;
          _connected = false;
          _unconnectTime = 0;
          _metaConnect = null;
          if (_messageQueue.length > 0) {
            var messages = _messageQueue;
            _messageQueue = [];
            _handleFailure.call(_cometd, void 0, messages, {
              reason: "Disconnected"
            });
          }
        }
        function _notifyTransportException(oldTransport, newTransport, failure) {
          var handler = _cometd.onTransportException;
          if (_isFunction(handler)) {
            _cometd._debug("Invoking transport exception handler", oldTransport, newTransport, failure);
            try {
              handler.call(_cometd, failure, oldTransport, newTransport);
            } catch (x) {
              _cometd._info("Exception during execution of transport exception handler", x);
            }
          }
        }
        function _handshake(handshakeProps, handshakeCallback) {
          if (_isFunction(handshakeProps)) {
            handshakeCallback = handshakeProps;
            handshakeProps = void 0;
          }
          _clientId = null;
          _clearSubscriptions();
          if (_isDisconnected()) {
            _transports.reset(true);
          }
          _updateAdvice({});
          _batch = 0;
          _internalBatch = true;
          _handshakeProps = handshakeProps;
          _handshakeCallback = handshakeCallback;
          var version2 = "1.0";
          var url2 = _cometd.getURL();
          var transportTypes = _transports.findTransportTypes(version2, _crossDomain, url2);
          var bayeuxMessage = {
            id: _nextMessageId(),
            version: version2,
            minimumVersion: version2,
            channel: "/meta/handshake",
            supportedConnectionTypes: transportTypes,
            advice: {
              timeout: _advice.timeout,
              interval: _advice.interval
            }
          };
          var message2 = _cometd._mixin(false, {}, _handshakeProps, bayeuxMessage);
          _cometd._putCallback(message2.id, handshakeCallback);
          if (!_transport) {
            _transport = _transports.negotiateTransport(transportTypes, version2, _crossDomain, url2);
            if (!_transport) {
              var failure = "Could not find initial transport among: " + _transports.getTransportTypes();
              _cometd._warn(failure);
              throw failure;
            }
          }
          _cometd._debug("Initial transport is", _transport.getType());
          _setStatus("handshaking");
          _cometd._debug("Handshake sent", message2);
          _send([message2], false, "handshake");
        }
        function _delayedHandshake(delay) {
          _setStatus("handshaking");
          _internalBatch = true;
          _delayedSend(function() {
            _handshake(_handshakeProps, _handshakeCallback);
          }, delay);
        }
        function _notifyCallback(callback, message2) {
          try {
            callback.call(_cometd, message2);
          } catch (x) {
            var handler = _cometd.onCallbackException;
            if (_isFunction(handler)) {
              _cometd._debug("Invoking callback exception handler", x);
              try {
                handler.call(_cometd, x, message2);
              } catch (xx) {
                _cometd._info("Exception during execution of callback exception handler", xx);
              }
            } else {
              _cometd._info("Exception during execution of message callback", x);
            }
          }
        }
        this._getCallback = function(messageId) {
          return _callbacks[messageId];
        };
        this._putCallback = function(messageId, callback) {
          var result = this._getCallback(messageId);
          if (_isFunction(callback)) {
            _callbacks[messageId] = callback;
          }
          return result;
        };
        function _handleCallback(message2) {
          var callback = _cometd._getCallback([message2.id]);
          if (_isFunction(callback)) {
            delete _callbacks[message2.id];
            _notifyCallback(callback, message2);
          }
        }
        function _handleRemoteCall(message2) {
          var context = _remoteCalls[message2.id];
          delete _remoteCalls[message2.id];
          if (context) {
            _cometd._debug("Handling remote call response for", message2, "with context", context);
            var timeout = context.timeout;
            if (timeout) {
              _cometd.clearTimeout(timeout);
            }
            var callback = context.callback;
            if (_isFunction(callback)) {
              _notifyCallback(callback, message2);
              return true;
            }
          }
          return false;
        }
        this.onTransportFailure = function(message2, failureInfo, failureHandler) {
          this._debug("Transport failure", failureInfo, "for", message2);
          var transports = this.getTransportRegistry();
          var url2 = this.getURL();
          var crossDomain = this._isCrossDomain(_splitURL(url2)[2]);
          var version2 = "1.0";
          var transportTypes = transports.findTransportTypes(version2, crossDomain, url2);
          if (failureInfo.action === "none") {
            if (message2.channel === "/meta/handshake") {
              if (!failureInfo.transport) {
                var failure = "Could not negotiate transport, client=[" + transportTypes + "], server=[" + message2.supportedConnectionTypes + "]";
                this._warn(failure);
                _notifyTransportException(_transport.getType(), null, {
                  reason: failure,
                  connectionType: _transport.getType(),
                  transport: _transport
                });
              }
            }
          } else {
            failureInfo.delay = this.getBackoffPeriod();
            if (message2.channel === "/meta/handshake") {
              if (!failureInfo.transport) {
                var oldTransportType = _transport ? _transport.getType() : null;
                var newTransport = transports.negotiateTransport(transportTypes, version2, crossDomain, url2);
                if (!newTransport) {
                  this._warn("Could not negotiate transport, client=[" + transportTypes + "]");
                  _notifyTransportException(oldTransportType, null, message2.failure);
                  failureInfo.action = "none";
                } else {
                  var newTransportType = newTransport.getType();
                  this._debug("Transport", oldTransportType, "->", newTransportType);
                  _notifyTransportException(oldTransportType, newTransportType, message2.failure);
                  failureInfo.action = "handshake";
                  failureInfo.transport = newTransport;
                }
              }
              if (failureInfo.action !== "none") {
                this.increaseBackoffPeriod();
              }
            } else {
              var now = (/* @__PURE__ */ new Date()).getTime();
              if (_unconnectTime === 0) {
                _unconnectTime = now;
              }
              if (failureInfo.action === "retry") {
                failureInfo.delay = this.increaseBackoffPeriod();
                var maxInterval = _advice.maxInterval;
                if (maxInterval > 0) {
                  var expiration = _advice.timeout + _advice.interval + maxInterval;
                  var unconnected = now - _unconnectTime;
                  if (unconnected + _backoff > expiration) {
                    failureInfo.action = "handshake";
                  }
                }
              }
              if (failureInfo.action === "handshake") {
                failureInfo.delay = 0;
                transports.reset(false);
                this.resetBackoffPeriod();
              }
            }
          }
          failureHandler.call(_cometd, failureInfo);
        };
        function _handleTransportFailure(failureInfo) {
          _cometd._debug("Transport failure handling", failureInfo);
          if (failureInfo.transport) {
            _transport = failureInfo.transport;
          }
          if (failureInfo.url) {
            _transport.setURL(failureInfo.url);
          }
          var action = failureInfo.action;
          var delay = failureInfo.delay || 0;
          switch (action) {
            case "handshake":
              _delayedHandshake(delay);
              break;
            case "retry":
              _delayedConnect(delay);
              break;
            case "none":
              _disconnect(true);
              break;
            default:
              throw "Unknown action " + action;
          }
        }
        function _failHandshake(message2, failureInfo) {
          _handleCallback(message2);
          _notifyListeners("/meta/handshake", message2);
          _notifyListeners("/meta/unsuccessful", message2);
          if (_isDisconnected()) {
            failureInfo.action = "none";
          }
          _cometd.onTransportFailure.call(_cometd, message2, failureInfo, _handleTransportFailure);
        }
        function _handshakeResponse(message2) {
          var url2 = _cometd.getURL();
          if (message2.successful) {
            var crossDomain = _cometd._isCrossDomain(_splitURL(url2)[2]);
            var newTransport = _transports.negotiateTransport(message2.supportedConnectionTypes, message2.version, crossDomain, url2);
            if (newTransport === null) {
              message2.successful = false;
              _failHandshake(message2, {
                cause: "negotiation",
                action: "none",
                transport: null
              });
              return;
            } else if (_transport !== newTransport) {
              _cometd._debug("Transport", _transport.getType(), "->", newTransport.getType());
              _transport = newTransport;
            }
            _clientId = message2.clientId;
            _internalBatch = false;
            _flushBatch();
            message2.reestablish = _reestablish;
            _reestablish = true;
            _handleCallback(message2);
            _notifyListeners("/meta/handshake", message2);
            _handshakeMessages = message2["x-messages"] || 0;
            var action = _isDisconnected() ? "none" : _advice.reconnect || "retry";
            switch (action) {
              case "retry":
                _resetBackoff();
                if (_handshakeMessages === 0) {
                  _delayedConnect(0);
                } else {
                  _cometd._debug("Processing", _handshakeMessages, "handshake-delivered messages");
                }
                break;
              case "none":
                _disconnect(true);
                break;
              default:
                throw "Unrecognized advice action " + action;
            }
          } else {
            _failHandshake(message2, {
              cause: "unsuccessful",
              action: _advice.reconnect || "handshake",
              transport: _transport
            });
          }
        }
        function _handshakeFailure(message2) {
          _failHandshake(message2, {
            cause: "failure",
            action: "handshake",
            transport: null
          });
        }
        function _matchMetaConnect(connect) {
          if (_status === "disconnected") {
            return true;
          }
          if (_metaConnect && _metaConnect.id === connect.id) {
            _metaConnect = null;
            return true;
          }
          return false;
        }
        function _failConnect(message2, failureInfo) {
          _notifyListeners("/meta/connect", message2);
          _notifyListeners("/meta/unsuccessful", message2);
          if (_isDisconnected()) {
            failureInfo.action = "none";
          }
          _cometd.onTransportFailure.call(_cometd, message2, failureInfo, _handleTransportFailure);
        }
        function _connectResponse(message2) {
          if (_matchMetaConnect(message2)) {
            _connected = message2.successful;
            if (_connected) {
              _notifyListeners("/meta/connect", message2);
              var action = _isDisconnected() ? "none" : _advice.reconnect || "retry";
              switch (action) {
                case "retry":
                  _resetBackoff();
                  _delayedConnect(_backoff);
                  break;
                case "none":
                  _disconnect(false);
                  break;
                default:
                  throw "Unrecognized advice action " + action;
              }
            } else {
              _failConnect(message2, {
                cause: "unsuccessful",
                action: _advice.reconnect || "retry",
                transport: _transport
              });
            }
          } else {
            _cometd._debug("Mismatched /meta/connect reply", message2);
          }
        }
        function _connectFailure(message2) {
          if (_matchMetaConnect(message2)) {
            _connected = false;
            _failConnect(message2, {
              cause: "failure",
              action: "retry",
              transport: null
            });
          } else {
            _cometd._debug("Mismatched /meta/connect failure", message2);
          }
        }
        function _failDisconnect(message2) {
          _disconnect(true);
          _handleCallback(message2);
          _notifyListeners("/meta/disconnect", message2);
          _notifyListeners("/meta/unsuccessful", message2);
        }
        function _disconnectResponse(message2) {
          if (message2.successful) {
            _disconnect(false);
            _handleCallback(message2);
            _notifyListeners("/meta/disconnect", message2);
          } else {
            _failDisconnect(message2);
          }
        }
        function _disconnectFailure(message2) {
          _failDisconnect(message2);
        }
        function _failSubscribe(message2) {
          var subscriptions = _listeners[message2.subscription];
          if (subscriptions) {
            for (var id2 in subscriptions) {
              if (subscriptions.hasOwnProperty(id2)) {
                var subscription = subscriptions[id2];
                if (subscription && !subscription.listener) {
                  delete subscriptions[id2];
                  _cometd._debug("Removed failed subscription", subscription);
                }
              }
            }
          }
          _handleCallback(message2);
          _notifyListeners("/meta/subscribe", message2);
          _notifyListeners("/meta/unsuccessful", message2);
        }
        function _subscribeResponse(message2) {
          if (message2.successful) {
            _handleCallback(message2);
            _notifyListeners("/meta/subscribe", message2);
          } else {
            _failSubscribe(message2);
          }
        }
        function _subscribeFailure(message2) {
          _failSubscribe(message2);
        }
        function _failUnsubscribe(message2) {
          _handleCallback(message2);
          _notifyListeners("/meta/unsubscribe", message2);
          _notifyListeners("/meta/unsuccessful", message2);
        }
        function _unsubscribeResponse(message2) {
          if (message2.successful) {
            _handleCallback(message2);
            _notifyListeners("/meta/unsubscribe", message2);
          } else {
            _failUnsubscribe(message2);
          }
        }
        function _unsubscribeFailure(message2) {
          _failUnsubscribe(message2);
        }
        function _failMessage(message2) {
          if (!_handleRemoteCall(message2)) {
            _handleCallback(message2);
            _notifyListeners("/meta/publish", message2);
            _notifyListeners("/meta/unsuccessful", message2);
          }
        }
        function _messageResponse(message2) {
          if (message2.data !== void 0) {
            if (!_handleRemoteCall(message2)) {
              _notifyListeners(message2.channel, message2);
              if (_handshakeMessages > 0) {
                --_handshakeMessages;
                if (_handshakeMessages === 0) {
                  _cometd._debug("Processed last handshake-delivered message");
                  _delayedConnect(0);
                }
              }
            }
          } else {
            if (message2.successful === void 0) {
              _cometd._warn("Unknown Bayeux Message", message2);
            } else {
              if (message2.successful) {
                _handleCallback(message2);
                _notifyListeners("/meta/publish", message2);
              } else {
                _failMessage(message2);
              }
            }
          }
        }
        function _messageFailure(failure) {
          _failMessage(failure);
        }
        function _receive(message2) {
          _unconnectTime = 0;
          message2 = _applyIncomingExtensions(message2);
          if (message2 === void 0 || message2 === null) {
            return;
          }
          _updateAdvice(message2.advice);
          var channel = message2.channel;
          switch (channel) {
            case "/meta/handshake":
              _handshakeResponse(message2);
              break;
            case "/meta/connect":
              _connectResponse(message2);
              break;
            case "/meta/disconnect":
              _disconnectResponse(message2);
              break;
            case "/meta/subscribe":
              _subscribeResponse(message2);
              break;
            case "/meta/unsubscribe":
              _unsubscribeResponse(message2);
              break;
            default:
              _messageResponse(message2);
              break;
          }
        }
        this.receive = _receive;
        _handleMessages = function(rcvdMessages) {
          _cometd._debug("Received", rcvdMessages);
          for (var i2 = 0; i2 < rcvdMessages.length; ++i2) {
            var message2 = rcvdMessages[i2];
            _receive(message2);
          }
        };
        _handleFailure = function(conduit, messages, failure) {
          _cometd._debug("handleFailure", conduit, messages, failure);
          failure.transport = conduit;
          for (var i2 = 0; i2 < messages.length; ++i2) {
            var message2 = messages[i2];
            var failureMessage = {
              id: message2.id,
              successful: false,
              channel: message2.channel,
              failure
            };
            failure.message = message2;
            switch (message2.channel) {
              case "/meta/handshake":
                _handshakeFailure(failureMessage);
                break;
              case "/meta/connect":
                _connectFailure(failureMessage);
                break;
              case "/meta/disconnect":
                _disconnectFailure(failureMessage);
                break;
              case "/meta/subscribe":
                failureMessage.subscription = message2.subscription;
                _subscribeFailure(failureMessage);
                break;
              case "/meta/unsubscribe":
                failureMessage.subscription = message2.subscription;
                _unsubscribeFailure(failureMessage);
                break;
              default:
                _messageFailure(failureMessage);
                break;
            }
          }
        };
        function _hasSubscriptions(channel) {
          var subscriptions = _listeners[channel];
          if (subscriptions) {
            for (var id2 in subscriptions) {
              if (subscriptions.hasOwnProperty(id2)) {
                if (subscriptions[id2]) {
                  return true;
                }
              }
            }
          }
          return false;
        }
        function _resolveScopedCallback(scope, callback) {
          var delegate = {
            scope,
            method: callback
          };
          if (_isFunction(scope)) {
            delegate.scope = void 0;
            delegate.method = scope;
          } else {
            if (_isString(callback)) {
              if (!scope) {
                throw "Invalid scope " + scope;
              }
              delegate.method = scope[callback];
              if (!_isFunction(delegate.method)) {
                throw "Invalid callback " + callback + " for scope " + scope;
              }
            } else if (!_isFunction(callback)) {
              throw "Invalid callback " + callback;
            }
          }
          return delegate;
        }
        function _addListener(channel, scope, callback, isListener) {
          var delegate = _resolveScopedCallback(scope, callback);
          _cometd._debug("Adding", isListener ? "listener" : "subscription", "on", channel, "with scope", delegate.scope, "and callback", delegate.method);
          var id2 = ++_listenerId;
          var subscription = {
            id: id2,
            channel,
            scope: delegate.scope,
            callback: delegate.method,
            listener: isListener
          };
          var subscriptions = _listeners[channel];
          if (!subscriptions) {
            subscriptions = {};
            _listeners[channel] = subscriptions;
          }
          subscriptions[id2] = subscription;
          _cometd._debug("Added", isListener ? "listener" : "subscription", subscription);
          return subscription;
        }
        this.registerTransport = function(type2, transport, index2) {
          var result = _transports.add(type2, transport, index2);
          if (result) {
            this._debug("Registered transport", type2);
            if (_isFunction(transport.registered)) {
              transport.registered(type2, this);
            }
          }
          return result;
        };
        this.unregisterTransport = function(type2) {
          var transport = _transports.remove(type2);
          if (transport !== null) {
            this._debug("Unregistered transport", type2);
            if (_isFunction(transport.unregistered)) {
              transport.unregistered();
            }
          }
          return transport;
        };
        this.unregisterTransports = function() {
          _transports.clear();
        };
        this.getTransportTypes = function() {
          return _transports.getTransportTypes();
        };
        this.findTransport = function(name3) {
          return _transports.find(name3);
        };
        this.getTransportRegistry = function() {
          return _transports;
        };
        this.configure = function(configuration2) {
          _configure.call(this, configuration2);
        };
        this.init = function(configuration2, handshakeProps) {
          this.configure(configuration2);
          this.handshake(handshakeProps);
        };
        this.handshake = function(handshakeProps, handshakeCallback) {
          if (_status !== "disconnected") {
            throw "Illegal state: handshaken";
          }
          _handshake(handshakeProps, handshakeCallback);
        };
        this.disconnect = function(disconnectProps, disconnectCallback) {
          if (_isDisconnected()) {
            return;
          }
          if (_isFunction(disconnectProps)) {
            disconnectCallback = disconnectProps;
            disconnectProps = void 0;
          }
          var bayeuxMessage = {
            id: _nextMessageId(),
            channel: "/meta/disconnect"
          };
          var message2 = this._mixin(false, {}, disconnectProps, bayeuxMessage);
          _cometd._putCallback(message2.id, disconnectCallback);
          _setStatus("disconnecting");
          _send([message2], false, "disconnect");
        };
        this.startBatch = function() {
          _startBatch();
        };
        this.endBatch = function() {
          _endBatch();
        };
        this.batch = function(scope, callback) {
          var delegate = _resolveScopedCallback(scope, callback);
          this.startBatch();
          try {
            delegate.method.call(delegate.scope);
            this.endBatch();
          } catch (x) {
            this._info("Exception during execution of batch", x);
            this.endBatch();
            throw x;
          }
        };
        this.addListener = function(channel, scope, callback) {
          if (arguments.length < 2) {
            throw "Illegal arguments number: required 2, got " + arguments.length;
          }
          if (!_isString(channel)) {
            throw "Illegal argument type: channel must be a string";
          }
          return _addListener(channel, scope, callback, true);
        };
        this.removeListener = function(subscription) {
          if (!subscription || !subscription.channel || !("id" in subscription)) {
            throw "Invalid argument: expected subscription, not " + subscription;
          }
          _removeListener(subscription);
        };
        this.clearListeners = function() {
          _listeners = {};
        };
        this.subscribe = function(channel, scope, callback, subscribeProps, subscribeCallback) {
          if (arguments.length < 2) {
            throw "Illegal arguments number: required 2, got " + arguments.length;
          }
          if (!_isString(channel)) {
            throw "Illegal argument type: channel must be a string";
          }
          if (_isDisconnected()) {
            throw "Illegal state: disconnected";
          }
          if (_isFunction(scope)) {
            subscribeCallback = subscribeProps;
            subscribeProps = callback;
            callback = scope;
            scope = void 0;
          }
          if (_isFunction(subscribeProps)) {
            subscribeCallback = subscribeProps;
            subscribeProps = void 0;
          }
          var send = !_hasSubscriptions(channel);
          var subscription = _addListener(channel, scope, callback, false);
          if (send) {
            var bayeuxMessage = {
              id: _nextMessageId(),
              channel: "/meta/subscribe",
              subscription: channel
            };
            var message2 = this._mixin(false, {}, subscribeProps, bayeuxMessage);
            _cometd._putCallback(message2.id, subscribeCallback);
            _queueSend(message2);
          }
          return subscription;
        };
        this.unsubscribe = function(subscription, unsubscribeProps, unsubscribeCallback) {
          if (arguments.length < 1) {
            throw "Illegal arguments number: required 1, got " + arguments.length;
          }
          if (_isDisconnected()) {
            throw "Illegal state: disconnected";
          }
          if (_isFunction(unsubscribeProps)) {
            unsubscribeCallback = unsubscribeProps;
            unsubscribeProps = void 0;
          }
          this.removeListener(subscription);
          var channel = subscription.channel;
          if (!_hasSubscriptions(channel)) {
            var bayeuxMessage = {
              id: _nextMessageId(),
              channel: "/meta/unsubscribe",
              subscription: channel
            };
            var message2 = this._mixin(false, {}, unsubscribeProps, bayeuxMessage);
            _cometd._putCallback(message2.id, unsubscribeCallback);
            _queueSend(message2);
          }
        };
        this.resubscribe = function(subscription, subscribeProps) {
          _removeSubscription(subscription);
          if (subscription) {
            return this.subscribe(subscription.channel, subscription.scope, subscription.callback, subscribeProps);
          }
          return void 0;
        };
        this.clearSubscriptions = function() {
          _clearSubscriptions();
        };
        this.publish = function(channel, content, publishProps, publishCallback) {
          if (arguments.length < 1) {
            throw "Illegal arguments number: required 1, got " + arguments.length;
          }
          if (!_isString(channel)) {
            throw "Illegal argument type: channel must be a string";
          }
          if (/^\/meta\//.test(channel)) {
            throw "Illegal argument: cannot publish to meta channels";
          }
          if (_isDisconnected()) {
            throw "Illegal state: disconnected";
          }
          if (_isFunction(content)) {
            publishCallback = content;
            content = {};
            publishProps = void 0;
          } else if (_isFunction(publishProps)) {
            publishCallback = publishProps;
            publishProps = void 0;
          }
          var bayeuxMessage = {
            id: _nextMessageId(),
            channel,
            data: content
          };
          var message2 = this._mixin(false, {}, publishProps, bayeuxMessage);
          _cometd._putCallback(message2.id, publishCallback);
          _queueSend(message2);
        };
        this.publishBinary = function(channel, data, last2, meta, callback) {
          if (_isFunction(data)) {
            callback = data;
            data = new ArrayBuffer(0);
            last2 = true;
            meta = void 0;
          } else if (_isFunction(last2)) {
            callback = last2;
            last2 = true;
            meta = void 0;
          } else if (_isFunction(meta)) {
            callback = meta;
            meta = void 0;
          }
          var content = {
            meta,
            data,
            last: last2
          };
          var ext = {
            ext: {
              binary: {}
            }
          };
          this.publish(channel, content, ext, callback);
        };
        this.remoteCall = function(target2, content, timeout, callProps, callback) {
          if (arguments.length < 1) {
            throw "Illegal arguments number: required 1, got " + arguments.length;
          }
          if (!_isString(target2)) {
            throw "Illegal argument type: target must be a string";
          }
          if (_isDisconnected()) {
            throw "Illegal state: disconnected";
          }
          if (_isFunction(content)) {
            callback = content;
            content = {};
            timeout = _config.maxNetworkDelay;
            callProps = void 0;
          } else if (_isFunction(timeout)) {
            callback = timeout;
            timeout = _config.maxNetworkDelay;
            callProps = void 0;
          } else if (_isFunction(callProps)) {
            callback = callProps;
            callProps = void 0;
          }
          if (typeof timeout !== "number") {
            throw "Illegal argument type: timeout must be a number";
          }
          if (!target2.match(/^\//)) {
            target2 = "/" + target2;
          }
          var channel = "/service" + target2;
          var bayeuxMessage = {
            id: _nextMessageId(),
            channel,
            data: content
          };
          var message2 = this._mixin(false, {}, callProps, bayeuxMessage);
          var context = {
            callback
          };
          if (timeout > 0) {
            context.timeout = _cometd.setTimeout(function() {
              _cometd._debug("Timing out remote call", message2, "after", timeout, "ms");
              _failMessage({
                id: message2.id,
                error: "406::timeout",
                successful: false,
                failure: {
                  message: message2,
                  reason: "Remote Call Timeout"
                }
              });
            }, timeout);
            _cometd._debug("Scheduled remote call timeout", message2, "in", timeout, "ms");
          }
          _remoteCalls[message2.id] = context;
          _queueSend(message2);
        };
        this.remoteCallBinary = function(target2, data, last2, meta, timeout, callback) {
          if (_isFunction(data)) {
            callback = data;
            data = new ArrayBuffer(0);
            last2 = true;
            meta = void 0;
            timeout = _config.maxNetworkDelay;
          } else if (_isFunction(last2)) {
            callback = last2;
            last2 = true;
            meta = void 0;
            timeout = _config.maxNetworkDelay;
          } else if (_isFunction(meta)) {
            callback = meta;
            meta = void 0;
            timeout = _config.maxNetworkDelay;
          } else if (_isFunction(timeout)) {
            callback = timeout;
            timeout = _config.maxNetworkDelay;
          }
          var content = {
            meta,
            data,
            last: last2
          };
          var ext = {
            ext: {
              binary: {}
            }
          };
          this.remoteCall(target2, content, timeout, ext, callback);
        };
        this.getStatus = function() {
          return _status;
        };
        this.isDisconnected = _isDisconnected;
        this.setBackoffIncrement = function(period2) {
          _config.backoffIncrement = period2;
        };
        this.getBackoffIncrement = function() {
          return _config.backoffIncrement;
        };
        this.getBackoffPeriod = function() {
          return _backoff;
        };
        this.increaseBackoffPeriod = function() {
          return _increaseBackoff();
        };
        this.resetBackoffPeriod = function() {
          _resetBackoff();
        };
        this.setLogLevel = function(level) {
          _config.logLevel = level;
        };
        this.registerExtension = function(name3, extension) {
          if (arguments.length < 2) {
            throw "Illegal arguments number: required 2, got " + arguments.length;
          }
          if (!_isString(name3)) {
            throw "Illegal argument type: extension name must be a string";
          }
          var existing = false;
          for (var i2 = 0; i2 < _extensions.length; ++i2) {
            var existingExtension = _extensions[i2];
            if (existingExtension.name === name3) {
              existing = true;
              break;
            }
          }
          if (!existing) {
            _extensions.push({
              name: name3,
              extension
            });
            this._debug("Registered extension", name3);
            if (_isFunction(extension.registered)) {
              extension.registered(name3, this);
            }
            return true;
          } else {
            this._info("Could not register extension with name", name3, "since another extension with the same name already exists");
            return false;
          }
        };
        this.unregisterExtension = function(name3) {
          if (!_isString(name3)) {
            throw "Illegal argument type: extension name must be a string";
          }
          var unregistered = false;
          for (var i2 = 0; i2 < _extensions.length; ++i2) {
            var extension = _extensions[i2];
            if (extension.name === name3) {
              _extensions.splice(i2, 1);
              unregistered = true;
              this._debug("Unregistered extension", name3);
              var ext = extension.extension;
              if (_isFunction(ext.unregistered)) {
                ext.unregistered();
              }
              break;
            }
          }
          return unregistered;
        };
        this.getExtension = function(name3) {
          for (var i2 = 0; i2 < _extensions.length; ++i2) {
            var extension = _extensions[i2];
            if (extension.name === name3) {
              return extension.extension;
            }
          }
          return null;
        };
        this.getName = function() {
          return _name;
        };
        this.getClientId = function() {
          return _clientId;
        };
        this.getURL = function() {
          if (_transport) {
            var url2 = _transport.getURL();
            if (url2) {
              return url2;
            }
            url2 = _config.urls[_transport.getType()];
            if (url2) {
              return url2;
            }
          }
          return _config.url;
        };
        this.getTransport = function() {
          return _transport;
        };
        this.getConfiguration = function() {
          return this._mixin(true, {}, _config);
        };
        this.getAdvice = function() {
          return this._mixin(true, {}, _advice);
        };
        this.setTimeout = function(funktion, delay) {
          return _scheduler.setTimeout(function() {
            try {
              _cometd._debug("Invoking timed function", funktion);
              funktion();
            } catch (x) {
              _cometd._debug("Exception invoking timed function", funktion, x);
            }
          }, delay);
        };
        this.clearTimeout = function(id2) {
          _scheduler.clearTimeout(id2);
        };
        if (window.WebSocket) {
          this.registerTransport("websocket", new WebSocketTransport());
        }
        this.registerTransport("long-polling", new LongPollingTransport());
        this.registerTransport("callback-polling", new CallbackPollingTransport());
      };
      var _z85EncodeTable = [
        "0",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "a",
        "b",
        "c",
        "d",
        "e",
        "f",
        "g",
        "h",
        "i",
        "j",
        "k",
        "l",
        "m",
        "n",
        "o",
        "p",
        "q",
        "r",
        "s",
        "t",
        "u",
        "v",
        "w",
        "x",
        "y",
        "z",
        "A",
        "B",
        "C",
        "D",
        "E",
        "F",
        "G",
        "H",
        "I",
        "J",
        "K",
        "L",
        "M",
        "N",
        "O",
        "P",
        "Q",
        "R",
        "S",
        "T",
        "U",
        "V",
        "W",
        "X",
        "Y",
        "Z",
        ".",
        "-",
        ":",
        "+",
        "=",
        "^",
        "!",
        "/",
        "*",
        "?",
        "&",
        "<",
        ">",
        "(",
        ")",
        "[",
        "]",
        "{",
        "}",
        "@",
        "%",
        "$",
        "#"
      ];
      var _z85DecodeTable = [
        0,
        68,
        0,
        84,
        83,
        82,
        72,
        0,
        75,
        76,
        70,
        65,
        0,
        63,
        62,
        69,
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        64,
        0,
        73,
        66,
        74,
        71,
        81,
        36,
        37,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        46,
        47,
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        56,
        57,
        58,
        59,
        60,
        61,
        77,
        0,
        78,
        67,
        0,
        0,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        27,
        28,
        29,
        30,
        31,
        32,
        33,
        34,
        35,
        79,
        0,
        80,
        0,
        0
      ];
      var Z85 = {
        encode: function(bytes) {
          var buffer = null;
          if (bytes instanceof ArrayBuffer) {
            buffer = bytes;
          } else if (bytes.buffer instanceof ArrayBuffer) {
            buffer = bytes.buffer;
          } else if (Array.isArray(bytes)) {
            buffer = new Uint8Array(bytes).buffer;
          }
          if (buffer == null) {
            throw "Cannot Z85 encode " + bytes;
          }
          var length = buffer.byteLength;
          var remainder = length % 4;
          var padding = 4 - (remainder === 0 ? 4 : remainder);
          var view = new DataView(buffer);
          var result = "";
          var value2 = 0;
          for (var i2 = 0; i2 < length + padding; ++i2) {
            var isPadding = i2 >= length;
            value2 = value2 * 256 + (isPadding ? 0 : view.getUint8(i2));
            if ((i2 + 1) % 4 === 0) {
              var divisor = 85 * 85 * 85 * 85;
              for (var j = 5; j > 0; --j) {
                if (!isPadding || j > padding) {
                  var code = Math.floor(value2 / divisor) % 85;
                  result += _z85EncodeTable[code];
                }
                divisor /= 85;
              }
              value2 = 0;
            }
          }
          return result;
        },
        decode: function(string) {
          var remainder = string.length % 5;
          var padding = 5 - (remainder === 0 ? 5 : remainder);
          for (var p = 0; p < padding; ++p) {
            string += _z85EncodeTable[_z85EncodeTable.length - 1];
          }
          var length = string.length;
          var buffer = new ArrayBuffer(length * 4 / 5 - padding);
          var view = new DataView(buffer);
          var value2 = 0;
          var charIdx = 0;
          var byteIdx = 0;
          for (var i2 = 0; i2 < length; ++i2) {
            var code = string.charCodeAt(charIdx++) - 32;
            value2 = value2 * 85 + _z85DecodeTable[code];
            if (charIdx % 5 === 0) {
              var divisor = 256 * 256 * 256;
              while (divisor >= 1) {
                if (byteIdx < view.byteLength) {
                  view.setUint8(byteIdx++, Math.floor(value2 / divisor) % 256);
                }
                divisor /= 256;
              }
              value2 = 0;
            }
          }
          return buffer;
        }
      };
      return {
        CometD,
        Transport,
        RequestTransport,
        LongPollingTransport,
        CallbackPollingTransport,
        WebSocketTransport,
        Utils,
        Z85
      };
    });
  })(cometd$1);
  return cometd$1.exports;
}
var browser$1;
var hasRequiredBrowser$1;
function requireBrowser$1() {
  if (hasRequiredBrowser$1) return browser$1;
  hasRequiredBrowser$1 = 1;
  const lib = requireCometd();
  browser$1 = {
    CometD: lib.CometD,
    default: lib
  };
  return browser$1;
}
var browserExports$1 = requireBrowser$1();
var MetaChannel;
(function(MetaChannel2) {
  MetaChannel2["HANDSHAKE"] = "/meta/handshake";
  MetaChannel2["CONNECT"] = "/meta/connect";
  MetaChannel2["SUBSCRIBE"] = "/meta/subscribe";
  MetaChannel2["UNSUBSCRIBE"] = "/meta/unsubscribe";
})(MetaChannel || (MetaChannel = {}));
class Realtime {
  /**
   * Allows to set up a realtime (websocket or long-polling) connection to the platform.
   * @param client The fetch client instance to use
   * @param url The URL to connect to
   * @param handshakeCallback A function which is called on succeeded or failed handshake
   */
  constructor(client, url2 = "/notification/realtime", handshakeCallback) {
    this.client = client;
    this.url = url2;
    this.metaHandshake = (msg) => {
      if (!msg.successful) {
        throw new Error("Handshake failed");
      }
    };
    this.cometd = new browserExports$1.CometD({});
    this.cometd.websocketEnabled = true;
    this.cometd.addListener(MetaChannel.HANDSHAKE, handshakeCallback || this.metaHandshake);
  }
  /**
   * Subscribes to a realtime channel to listen for data.
   * @param channel The channel to connect to
   * @param callback A function to call when data is received
   */
  subscribe(channel, callback) {
    this.checkConnection();
    return this.cometd.subscribe(channel, callback);
  }
  /**
   * Cancels the listening to a channel.
   * @param subscription The subscription object returned by subscribe()
   */
  unsubscribe(subscription) {
    return this.cometd.unsubscribe(subscription);
  }
  /**
   * Allows to listen to Cometd handshake to find out if e.g. the connection was reestablished.
   */
  addHandshakeListener(callback) {
    return this.cometd.addListener(MetaChannel.HANDSHAKE, callback);
  }
  /**
   * Allows to listen to Cometd connection to e.g. detect when connection was lost.
   */
  addConnectListener(callback) {
    return this.cometd.addListener(MetaChannel.CONNECT, callback);
  }
  /**
   * Removes the subscription obtained with a call to `addHandshakeListener` or `addConnectListener`.
   */
  removeListener(subscriptionHandle) {
    return this.cometd.removeListener(subscriptionHandle);
  }
  /**
   * Resubscribes as necessary in case of a re-handshake.
   */
  resubscribe(subscriptionHandle) {
    return this.cometd.resubscribe(subscriptionHandle);
  }
  /**
   * Disconnects the current connection.
   */
  disconnect(disconnectCallback = void 0) {
    this.cometd.disconnect(disconnectCallback);
  }
  /**
   * Returns true if the CometD instance is disconnected or disconnecting.
   */
  isDisconnected() {
    return this.cometd.isDisconnected();
  }
  checkConnection() {
    const { cometd: cometd2, client, url: url2 } = this;
    if (cometd2.isDisconnected()) {
      const { headers } = client.getFetchOptions();
      const config = {
        url: client.getUrl(url2),
        requestHeaders: headers
      };
      cometd2.configure(config);
      this.handshake(client.getCometdHandshake());
    }
  }
  handshake(config) {
    this.cometd.handshake(config, void 0);
  }
}
class EventService extends Service {
  constructor() {
    super(...arguments);
    this.baseUrl = "event";
    this.listUrl = "events";
    this.propertyName = "events";
    this.channel = "/events/*";
  }
  /**
   * Gets the details of a specific event.
   *
   * @param {string|number|IIdentified} entityOrId Entity or Id of the entity.
   *
   * @returns Response wrapped in [[IResult]]
   *
   * **Example**
   * ```typescript
   *
   *    const eventId: number = 1;
   *
   *    (async () => {
   *      const {data, res} = await eventService.detail(eventId);
   *   })();
   * ```
   */
  detail(entityOrId) {
    const _super = Object.create(null, {
      detail: { get: () => super.detail }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.detail.call(this, entityOrId);
    });
  }
  /**
   * Creates a new event.
   *
   * @param {IEvent} entity Event object with mandantory fragments.
   *
   * @returns Response wrapped in [[IResult]]
   *
   * **Example**
   * ```typescript
   *
   *  const mandantoryObject: IEvent = {
   *    source: device,
   *    text: 'I am an Event!',
   *    time: '2018-05-02T10:08:00Z',
   *    type: 'device-type-here',
   *  };
   *
   *  (async () => {
   *    const {data, res} = await eventService.create(mandantoryObject);
   *  })();
   * ```
   */
  create(entity) {
    const _super = Object.create(null, {
      create: { get: () => super.create }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.create.call(this, entity);
    });
  }
  /**
   * Updates event data.
   *
   * @param {Partial<IEvent>} entity Event is partially updatable.
   *
   * @returns Response wrapped in [[IResult]]
   *
   * **Example**
   * ```typescript
   *
   *  const partialUpdateObject: Partial<IEvent> = {
   *    source: device,
   *    text: 'Changed Event!'
   *  };
   *
   *  (async () => {
   *    const {data, res} = await eventService.update(partialUpdateObject);
   *  })();
   * ```
   */
  update(entity) {
    const _super = Object.create(null, {
      update: { get: () => super.update }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.update.call(this, entity);
    });
  }
  /**
   * Gets the list of events filtered by parameters.
   *
   * @returns Response wrapped in [[IResultList]]
   *
   * @param {object} filter Object containing filters for querying events.
   *
   * **Example**
   * ```typescript
   *
   *  const filter: object = {
   *     pageSize: 100,
   *     withTotalPages: true
   *   };
   *
   *   (async () => {
   *     const {data, res, paging} = await eventService.list(filter);
   *   })();
   * ```
   */
  list(filter2 = {}) {
    const _super = Object.create(null, {
      list: { get: () => super.list }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.list.call(this, filter2);
    });
  }
  /**
   * Removes an event with given id.
   *
   * @returns Response wrapped in [[IResult]]
   *
   * @param {string | number | IIdentified} entityOrId entity or id of the event.
   *
   * **Example**
   * ```typescript
   *
   *  const eventId: number = 1;
   *
   *   (async () => {
   *     const {data, res} = await eventService.delete(eventId);
   *     // data will be null
   *   })();
   * ```
   */
  delete(entityOrId) {
    const _super = Object.create(null, {
      delete: { get: () => super.delete }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.delete.call(this, entityOrId);
    });
  }
}
var browser;
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser;
  hasRequiredBrowser = 1;
  browser = typeof self == "object" ? self.FormData : window.FormData;
  return browser;
}
var browserExports = requireBrowser();
const FormData$1 = /* @__PURE__ */ getDefaultExportFromCjs(browserExports);
class InventoryBinaryService extends Service {
  constructor() {
    super(...arguments);
    this.baseUrl = "inventory";
    this.listUrl = "binaries";
    this.propertyName = "managedObjects";
  }
  /**
   * Uploads a file and creates a managed object with its metadata.
   * @param file A file to be uploaded.
   * @param managedObject An object containing metadata about the file.
   * Note that you can specify `fileType` and `fileName` in case `file` does not define them
   * but these two properties will be removed from `managedObject` before saving.
   */
  create(file2, managedObject = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      const method = "POST";
      const url2 = this.listUrl;
      const body = new FormData$1();
      let fileName;
      let fileType;
      if (managedObject.fileName) {
        fileName = managedObject.fileName;
        delete managedObject.fileName;
      }
      if (managedObject.fileType) {
        fileType = managedObject.fileType;
        delete managedObject.fileType;
      }
      if (!fileName) {
        fileName = "bin";
      }
      if (typeof File !== "undefined" && file2 instanceof File) {
        fileName = file2.name;
        fileType = file2.type;
      }
      if (!managedObject.name) {
        managedObject.name = fileName;
      }
      if (!managedObject.type) {
        managedObject.type = fileType || "c8y_upload";
      }
      body.append("file", file2, fileName);
      body.append("object", JSON.stringify(managedObject));
      const headers = {
        accept: "application/json"
      };
      const res = yield this.fetch(url2, { method, body, headers });
      const data = yield res.json();
      return { res, data };
    });
  }
  list(filter2 = {}) {
    const _super = Object.create(null, {
      list: { get: () => super.list }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.list.call(this, filter2);
    });
  }
  delete(managedObjectOrId) {
    const _super = Object.create(null, {
      delete: { get: () => super.delete }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.delete.call(this, managedObjectOrId);
    });
  }
  download(managedObjectOrId, init) {
    return __awaiter(this, void 0, void 0, function* () {
      const url2 = this.getDetailUrl(managedObjectOrId);
      return yield this.fetch(url2, init);
    });
  }
  /**
   * Uploads a file and creates a managed object with its metadata. What's more, it invokes an upload progress callback.
   * @param file A file to be uploaded.
   * @param managedObject An object containing metadata about the file.
   * @param onProgress Event handler for progress update, invoked while the browser is uploading the file.
   */
  createWithProgress(file2, onProgress, managedObject = {}) {
    const url2 = `/${this.baseUrl}/${this.listUrl}`;
    const method = "POST";
    const body = new FormData$1();
    let fileName;
    let fileType;
    if (managedObject.fileName) {
      fileName = managedObject.fileName;
      delete managedObject.fileName;
    }
    if (managedObject.fileType) {
      fileType = managedObject.fileType;
      delete managedObject.fileType;
    }
    if (!fileName) {
      fileName = "bin";
    }
    if (typeof File !== "undefined" && file2 instanceof File) {
      fileName = file2.name;
      fileType = file2.type;
    }
    if (!managedObject.name) {
      managedObject.name = fileName;
    }
    if (!managedObject.type) {
      managedObject.type = fileType || "c8y_upload";
    }
    body.append("file", file2, fileName);
    body.append("object", JSON.stringify(managedObject));
    let bodyHeaders;
    if (typeof body.getHeaders === "function") {
      bodyHeaders = body.getHeaders();
    }
    const headers = this.client.getFetchOptions().headers;
    Object.assign(headers, {
      accept: "application/json"
    }, bodyHeaders);
    const xhr = new XMLHttpRequest();
    xhr.open(method, url2, true);
    for (const key in headers) {
      if (headers.hasOwnProperty(key)) {
        xhr.setRequestHeader(key, headers[key]);
      }
    }
    xhr.upload.addEventListener("progress", onProgress);
    let xhrBody;
    if (typeof body.getBuffer === "function") {
      xhrBody = body.getBuffer();
    } else {
      xhrBody = body;
    }
    xhr.send(xhrBody);
    return xhr;
  }
  getXMLHttpResponse(xhr) {
    return new Promise((res, rej) => {
      xhr.addEventListener("loadend", () => {
        xhr.readyState === 4 && (xhr.status === 200 || xhr.status === 201) ? res(JSON.parse(xhr.responseText)) : rej(xhr.responseText ? { data: JSON.parse(xhr.responseText) } : "Could not upload file.");
      });
    });
  }
  /**
   * Gets binary managed object's id from its download or self URL.
   *
   * @param {string} url URL string.
   *
   * @returns {number} Binary managed object's id.
   *
   * **Example**
   * ```typescript
   *
   *   const id = InventoryBinaryService.getIdFromUrl('http://mytenant.cumulocity.com/inventory/binaries/12345');
   * ```
   */
  getIdFromUrl(url2) {
    if (!!url2) {
      const regexp = new RegExp("\\/inventory\\/binaries\\/(\\d+)|\\/inventory\\/managedObjects\\/(\\d+)");
      const matches = url2.match(regexp);
      return matches && (matches[1] || matches[2]);
    }
  }
}
var ChildType$1;
(function(ChildType2) {
  ChildType2["ASSETS"] = "childAssets";
  ChildType2["DEVICES"] = "childDevices";
  ChildType2["ADDITIONS"] = "childAdditions";
})(ChildType$1 || (ChildType$1 = {}));
class InventoryService extends Service {
  constructor(client, realtime2) {
    super(client, realtime2);
    this.baseUrl = "inventory";
    this.listUrl = "managedObjects";
    this.propertyName = "managedObjects";
    this.channel = "/managedobjects/*";
    this.inventoriesQueryParamName = "query";
    this.devicesQueryParamName = "q";
    this.queriesUtil = new QueriesUtil();
    this.binary = new InventoryBinaryService(client);
  }
  /**
   * Gets the details of managed object
   *
   * @param {IdReference} managedObjectOrId ManagedObject or Id of the ManagedObject.
   * @param {object} filter Filter object.
   *
   * @returns Response wrapped in [[IResult]]
   *
   * **Example**
   * ```typescript
   *
   *    const managedObjId: number = 1;
   *    const filter = { withChildren: false };
   *
   *    (async () => {
   *      const {data, res} = await inventoryService.detail(managedObjId, filter);
   *   })();
   * ```
   */
  detail(managedObjectOrId, filter2 = {}) {
    const _super = Object.create(null, {
      detail: { get: () => super.detail }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.detail.call(this, managedObjectOrId, filter2);
    });
  }
  /**
   * Creates a new managed object.
   *
   * @param {Partial<IManagedObject>} managedObject
   *
   * @returns Response wrapped in [[IResult]]
   *
   * **Example**
   * ```typescript
   *
   *  const partialManagedObj: Partial<IManagedObject> = {
   *    customFragment: 'yourData'
   *  };
   *
   *  (async () => {
   *    const {data, res} = await inventoryService.create(partialManagedObj);
   *  })();
   * ```
   */
  create(managedObject) {
    const _super = Object.create(null, {
      create: { get: () => super.create }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.create.call(this, managedObject);
    });
  }
  /**
   * Updates managed object data.
   *
   * @param {Partial<IManagedObject>} managedObject Managed object is partially updatable.
   *
   * @returns Response wrapped in [[IResult]]
   *
   * **Example**
   * ```typescript
   *
   *  const partialUpdateObject: Partial<IManagedObject> = {
   *    customFragment: 'Changed data',
   *    name: 'Name'
   *  };
   *
   *  (async () => {
   *    const {data, res} = await inventoryService.update(partialUpdateObject);
   *  })();
   * ```
   */
  update(managedObject) {
    const _super = Object.create(null, {
      update: { get: () => super.update }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.update.call(this, managedObject);
    });
  }
  /**
   * Gets the list of managed objects filtered by parameters.
   *
   * @returns Response wrapped in [[IResultList]]
   *
   * @param {object} filter Object containing filters for querying managed objects.
   *
   * **Example**
   * ```typescript
   *
   *  const filter: object = {
   *     pageSize: 100,
   *     withTotalPages: true
   *   };
   *
   *   (async () => {
   *     const {data, res, paging} = await inventoryService.list(filter);
   *   })();
   * ```
   */
  list(filter2 = {}) {
    const _super = Object.create(null, {
      list: { get: () => super.list }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.list.call(this, filter2);
    });
  }
  /**
   * Gets total count of managed objects filtered by parameters.
   *
   * @returns Response wrapped in [[IResultList]]
   *
   * @param {object} filter Object containing filters for querying managed objects.
   *
   * **Example**
   * ```typescript
   *
   *  const filter: object = {
   *     type: 'c8y_MQTTDevice'
   *   };
   *
   *   (async () => {
   *     const {data, res} = await inventoryService.count(filter);
   *   })();
   * ```
   */
  count(filter2 = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      const url2 = `${this.listUrl}/count`;
      const res = yield this.fetch(url2, this.changeFetchOptions({ params: filter2 }, url2));
      const data = yield res.json();
      return { res, data };
    });
  }
  /**
   * Gets the list of all managed objects filtered and sorted by given query.
   *
   * @returns Response wrapped in [[IResultList]]
   *
   * @param {object} filter Object containing filters for querying managed objects.
   *
   * **Example**
   * ```typescript
   *
   *  const filter: object = {
   *     pageSize: 100,
   *     withTotalPages: true
   *   };
   *
   *  const query = {
   *      name: 'MY-NAM*'
   *  }
   *
   *   (async () => {
   *     const {data, res, paging} = await inventoryService.listQuery(query, filter);
   *   })();
   * ```
   */
  listQuery(query, filter2 = {}) {
    const _super = Object.create(null, {
      list: { get: () => super.list }
    });
    return __awaiter(this, void 0, void 0, function* () {
      filter2[this.inventoriesQueryParamName] = this.queriesUtil.buildQuery(query);
      return _super.list.call(this, filter2);
    });
  }
  /**
   * Gets the list of all devices filtered and sorted by given query.
   *
   * @returns Response wrapped in [[IResultList]]
   *
   * @param {object} filter Object containing filters for querying devices.
   *
   * **Example**
   * ```typescript
   *
   *  const filter: object = {
   *     pageSize: 100,
   *     withTotalPages: true
   *   };
   *
   *  const query = {
   *      name: 'MY-NAM*'
   *  }
   *
   *   (async () => {
   *     const {data, res, paging} = await inventoryService.listQueryDevices(query, filter);
   *   })();
   * ```
   */
  listQueryDevices(query, filter2 = {}) {
    const _super = Object.create(null, {
      list: { get: () => super.list }
    });
    return __awaiter(this, void 0, void 0, function* () {
      filter2[this.devicesQueryParamName] = this.queriesUtil.buildQuery(query);
      return _super.list.call(this, filter2);
    });
  }
  /**
   * Removes managed object with given id.
   *
   * @returns Response wrapped in [[IResult]]
   *
   * @param {IdReference} managedObjectOrId ManagedObject or Id of the ManagedObject.
   * @param {object} params Additional query params.
   *
   * **Example**
   * ```typescript
   *
   *   const managedObjectId: number = 1;
   *   const params: any = {
   *     cascade: true
   *   }
   *
   *    (async () => {
   *      const {data, res} = await inventoryService.delete(managedObjectId, params);
   *   })();
   * ```
   */
  delete(managedObjectOrId, params = {}) {
    const _super = Object.create(null, {
      delete: { get: () => super.delete }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.delete.call(this, managedObjectOrId, params);
    });
  }
  /**
   * Gets a list of child additions from a given managed object (parent)
   *
   * @returns Response wrapped in [[IResultList]]
   *
   * @param {IdReference} parentReference
   * @param {object} filter
   *
   * **Example**
   * ```typescript
   *    const parentReferenceId: IdReference = 1;
   *
   *    const filter: object = {
   *      pageSize: 100,
   *      withTotalPages: true
   *    };
   *
   *    (async () => {
   *      const {data, res, paging} = await inventoryService.childAdditionsList(parentReferenceId, filter);
   *    })();
   * ```
   */
  childAdditionsList(parentReference, filter2 = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.listChildren(ChildType$1.ADDITIONS, parentReference, filter2);
    });
  }
  /**
   * Creates a new managed object as child addition to another managed object (parent)
   *
   * @returns Response wrapped in [[IResult]]
   *
   * @param {Partial<IManagedObject>} managedObject
   * @param {IdReference} parentReference
   *
   * **Example**
   * ```typescript
   *
   *    const mOAsChildAddition: Partial<IManagedObject> = {
   *      name: 'Child addition MO',
   *      type: 'new type',
   *      ...
   *    };
   *
   *    // This is the identifier of the managed object which should be the parent of
   *    // mOAsChildAddition, see above.
   *    const parentReferenceId: number = 1;
   *
   *    (async () => {
   *      const {data, res} = await inventoryService.childAdditionsCreate(mOAsChildAddition, parentReferenceId);
   *    })();
   * ```
   */
  childAdditionsCreate(managedObject, parentReference) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.createChild(ChildType$1.ADDITIONS, managedObject, parentReference);
    });
  }
  /**
   * Adds an existing managed object as child addition to another managed object (parent)
   *
   * @returns Response wrapped in [[IResult]]
   *
   * @param {IdReference} childReference
   * @param {IdReference} parentReference
   *
   * **Example**
   * ```typescript
   *
   *    const childRef: number = 2;
   *    const parentReferenceId: number = 1;
   *
   *    (async () => {
   *      const {data, res} = await inventoryService.childAdditionsCreate(childRef, parentReferenceId);
   *    })();
   * ```
   */
  childAdditionsAdd(childReference, parentReference) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.addChild(ChildType$1.ADDITIONS, childReference, parentReference);
    });
  }
  /**
   * Adds bulk of existing managed objects as child addition to another managed object (parent).
   *
   * @returns Response wrapped in array of [[IResult]]
   *
   * @param {IdReference[]} childReference List of existing managed objects IDs that should be added to another managed object (parent).
   * @param {IdReference} parentReference
   *
   * **Example**
   * ```typescript
   *
   *    const childAdditionsRefIds: string[] = ['2', '3'];
   *    const parentReferenceId: number = 1;
   *
   *    (async () => {
   *      const {data, res} = await inventoryService.childAdditionsBulkAdd(childAdditionsRefIds, parentReferenceId);
   *    })();
   * ```
   */
  childAdditionsBulkAdd(childReference, parentReference) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.addChildBulk(ChildType$1.ADDITIONS, childReference, parentReference);
    });
  }
  /**
   * Removes an existing managed object as child addition from another managed object (parent)
   *
   * @returns Response wrapped in [[IResult]]
   *
   * @param {IdReference} childReference
   * @param {IdReference} parentReference
   *
   * **Example**
   * ```typescript
   *
   *    const childRef: number = 2;
   *    const parentReferenceId: number = 1;
   *
   *    (async () => {
   *      const {data, res} = await inventoryService.childAdditionsRemove(childRef, parentReferenceId);
   *    })();
   * ```
   */
  childAdditionsRemove(childReference, parentReference) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.removeChild(ChildType$1.ADDITIONS, childReference, parentReference);
    });
  }
  /**
   * Gets a list of child assets from a given managed object (parent)
   *
   * @returns Response wrapped in [[IResultList]]
   *
   * @param {IdReference} parentReference
   * @param {object} filter
   *
   * **Example**
   * ```typescript
   *
   *    const parentReferenceId: IdReference = 1;
   *
   *    const filter: object = {
   *      pageSize: 100,
   *      withTotalPages: true
   *    };
   *
   *    (async () => {
   *      const {data, res, paging} = await inventoryService.childAssetsList(parentReferenceId, filter);
   *    })();
   * ```
   */
  childAssetsList(parentReference, filter2 = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.listChildren(ChildType$1.ASSETS, parentReference, filter2);
    });
  }
  /**
   * Creates a new managed object as child asset to another managed object (parent)
   *
   * @returns Response wrapped in [[IResult]]
   *
   * @param {Partial<IManagedObject>} managedObject
   * @param {IdReference} parentReference
   *
   * **Example**
   * ```typescript
   *
   *    const mOAsChildAsset: Partial<IManagedObject> = {
   *      name: 'Child asset MO',
   *      type: 'new type',
   *      ...
   *    };
   *
   *    // This is the identifier of the managed object which should be the parent of
   *    // mOAsChildAsset, see above.
   *    const parentReferenceId: number = 1;
   *
   *    (async () => {
   *      const {data, res} = await inventoryService.childAdditionsCreate(mOAsChildAddition, parentReferenceId);
   *    })();
   * ```
   */
  childAssetsCreate(managedObject, parentReference) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.createChild(ChildType$1.ASSETS, managedObject, parentReference);
    });
  }
  /**
   * Adds an existing managed object as child asset to another managed object (parent)
   *
   * @returns Response wrapped in [[IResult]]
   *
   * @param {IdReference} childReference
   * @param {IdReference} parentReference
   *
   * **Example**
   * ```typescript
   *
   *    const childRef: number = 2;
   *    const parentReferenceId: number = 1;
   *
   *    (async () => {
   *      const {data, res} = await inventoryService.childAssetsAdd(childRef, parentReferenceId);
   *    })();
   * ```
   */
  childAssetsAdd(childReference, parentReference) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.addChild(ChildType$1.ASSETS, childReference, parentReference);
    });
  }
  /**
   * Adds bulk of existing managed objects as child assets to another managed object (parent).
   *
   * @returns Response wrapped in array of [[IResult]]
   *
   * @param {IdReference[]} childReference List of existing managed objects IDs that should be added to another managed object (parent).
   * @param {IdReference} parentReference
   *
   * **Example**
   * ```typescript
   *
   *    const childAssetsRefIds: string[] = ['2', '3'];
   *    const parentReferenceId: number = 1;
   *
   *    (async () => {
   *      const {data, res} = await inventoryService.childAssetsBulkAdd(childAssetsRefIds, parentReferenceId);
   *    })();
   * ```
   */
  childAssetsBulkAdd(childReference, parentReference) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.addChildBulk(ChildType$1.ASSETS, childReference, parentReference);
    });
  }
  /**
   * Removes an existing managed object as child asset from another managed object (parent)
   *
   * @returns Response wrapped in [[IResult]]
   *
   * @param {IdReference} childReference
   * @param {IdReference} parentReference
   *
   * **Example**
   * ```typescript
   *
   *    const childRef: number = 2;
   *    const parentReferenceId: number = 1;
   *
   *    (async () => {
   *      const {data, res} = await inventoryService.childAssetsRemove(childRef, parentReferenceId);
   *    })();
   * ```
   */
  childAssetsRemove(childReference, parentReference) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.removeChild(ChildType$1.ASSETS, childReference, parentReference);
    });
  }
  /**
   * Gets a list of child devices from a given managed object (parent)
   *
   * @returns Response wrapped in [[IResultList]]
   *
   * @param {IdReference} parentReference
   * @param {object} filter
   *
   * **Example**
   * ```typescript
   *
   *    const parentReferenceId: IdReference = 1;
   *
   *    const filter: object = {
   *      pageSize: 100,
   *      withTotalPages: true
   *    };
   *
   *    (async () => {
   *      const {data, res, paging} = await inventoryService.childDevicesList(parentReferenceId, filter);
   *    })();
   * ```
   */
  childDevicesList(parentReference, filter2 = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.listChildren(ChildType$1.DEVICES, parentReference, filter2);
    });
  }
  /**
   * Creates a new managed object as child device to another managed object (parent)
   *
   * @returns Response wrapped in [[IResult]]
   *
   * @param {Partial<IManagedObject>} managedObject
   * @param {IdReference} parentReference
   *
   * **Example**
   * ```typescript
   *
   *    const mOAsChildDevice: Partial<IManagedObject> = {
   *      name: 'Child device MO',
   *      type: 'new type',
   *      ...
   *    };
   *
   *    // This is the identifier of the managed object which should be the parent of
   *    // mOAsChildDevice, see above.
   *    const parentReferenceId: number = 1;
   *
   *    (async () => {
   *      const {data, res} = await inventoryService.childDevicesCreate(mOAsChildDevice, parentReferenceId);
   *    })();
   * ```
   */
  childDevicesCreate(managedObject, parentReference) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.createChild(ChildType$1.DEVICES, managedObject, parentReference);
    });
  }
  /**
   * Adds an existing managed object as child device to another managed object (parent)
   *
   * @returns Response wrapped in [[IResult]]
   *
   * @param {IdReference} childReference
   * @param {IdReference} parentReference
   *
   * **Example**
   * ```typescript
   *
   *    const childRef: number = 2;
   *    const parentReferenceId: number = 1;
   *
   *    (async () => {
   *      const {data, res} = await inventoryService.childDevicesAdd(childRef, parentReferenceId);
   *    })();
   * ```
   */
  childDevicesAdd(childReference, parentReference) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.addChild(ChildType$1.DEVICES, childReference, parentReference);
    });
  }
  /**
   * Adds bulk of existing managed objects as child devices to another managed object (parent).
   *
   * @returns Response wrapped in array of [[IResult]]
   *
   * @param {IdReference[]} childReference List of existing managed objects IDs that should be added to another managed object (parent).
   * @param {IdReference} parentReference
   *
   * **Example**
   * ```typescript
   *
   *    const childDevicesRefIds: string[] = ['2', '3'];
   *    const parentReferenceId: number = 1;
   *
   *    (async () => {
   *      const {data, res} = await inventoryService.childDevicesBulkAdd(childDevicesRefIds, parentReferenceId);
   *    })();
   * ```
   */
  childDevicesBulkAdd(childReference, parentReference) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.addChildBulk(ChildType$1.DEVICES, childReference, parentReference);
    });
  }
  /**
   * Removes an existing managed object as child device from another managed object (parent)
   *
   * @returns Response wrapped in [[IResult]]
   *
   * @param {IdReference} childReference
   * @param {IdReference} parentReference
   *
   * **Example**
   * ```typescript
   *
   *    const childRef: number = 2;
   *    const parentReferenceId: number = 1;
   *
   *    (async () => {
   *      const {data, res} = await inventoryService.childDevicesRemove(childRef, parentReferenceId);
   *    })();
   * ```
   */
  childDevicesRemove(childReference, parentReference) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.removeChild(ChildType$1.DEVICES, childReference, parentReference);
    });
  }
  /**
   * Gets an array of measurement fragments supported by the specified managedObject.
   * e.g. ["c8y_Temperature", "c8y_Humidity"]
   *
   * @returns array of supported measurement fragments
   *
   * @param {IdReference} managedObjectOrId
   */
  getSupportedMeasurements(managedObjectOrId) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.getSupportedMeasurementDetails(managedObjectOrId, "supportedMeasurements");
    });
  }
  /**
   * Gets an array of measurement series supported by the specified managedObject.
   * e.g. ["c8y_Temperature.T", "c8y_Humidity.H"]
   *
   * @returns array of supported measurement series
   *
   * @param {IdReference} managedObjectOrId
   */
  getSupportedSeries(managedObjectOrId) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.getSupportedMeasurementDetails(managedObjectOrId, "supportedSeries");
    });
  }
  /**
   * Gets an array of measurement series and fragments supported by the specified managedObject.
   *
   * @returns array of supported measurement series and fragments
   *
   * @param {IdReference} managedObjectOrId
   */
  getMeasurementsAndSeries(managedObjectOrId) {
    return __awaiter(this, void 0, void 0, function* () {
      const [supportedMeasurements, supportedSeries] = yield Promise.all([
        this.getSupportedMeasurements(managedObjectOrId),
        this.getSupportedSeries(managedObjectOrId)
      ]);
      const sortedSupportedMeasurements = supportedMeasurements.sort((a, b) => b.length - a.length);
      return supportedSeries.map((s2) => {
        const fragment2 = sortedSupportedMeasurements.find((m) => s2.indexOf(`${m}.`) === 0);
        const series2 = s2.replace(`${fragment2}.`, "");
        return {
          fragment: fragment2,
          series: series2
        };
      }).filter((obj) => !!obj.fragment);
    });
  }
  /**
   * Gets a list of KPIs (data point library entries) matching a given managed object
   *
   * @returns Response wrapped in [[IResultList]]
   *
   * @param {IdReference} parentReference
   * @param {object} filter
   */
  assetKPIsList(parentReference, filter2 = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.listKPIs(parentReference, filter2);
    });
  }
  listKPIs(parentReference, filter2 = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      const headers = { accept: "application/json" };
      const url2 = this.getChildrenUrl("kpis", parentReference);
      const res = yield this.fetch(url2, this.changeFetchOptions({ headers, params: filter2 }, url2));
      const json = yield res.json();
      const data = json[this.propertyName];
      const paging = this.getPaging(json, filter2);
      return { res, data, paging };
    });
  }
  onBeforeUpdate(objWithId) {
    delete objWithId.lastUpdated;
    return objWithId;
  }
  onBeforeCreate(managedObject) {
    delete managedObject.id;
    delete managedObject.lastUpdated;
    return managedObject;
  }
  getChildrenUrl(type2, parentReference) {
    return `${this.getDetailUrl(parentReference)}/${type2}`;
  }
  getChildUrl(type2, childReference, parentReference) {
    const childId = this.getIdString(childReference);
    return `${this.getChildrenUrl(type2, parentReference)}/${childId}`;
  }
  listChildren(type2, parentReference, filter2 = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      const headers = { "content-type": "application/json" };
      const url2 = this.getChildrenUrl(type2, parentReference);
      const res = yield this.fetch(url2, { headers, params: filter2 });
      const json = yield res.json();
      const data = json.references.map((ref) => ref.managedObject);
      const paging = this.getPaging(json, filter2);
      paging.list = (pagingFilter) => this.listChildren(type2, parentReference, pagingFilter);
      return { res, data, paging };
    });
  }
  createChild(type2, managedObject, parentReference) {
    return __awaiter(this, void 0, void 0, function* () {
      const url2 = this.getChildrenUrl(type2, parentReference);
      const method = "POST";
      const body = JSON.stringify(this.onBeforeCreate(managedObject));
      const headers = { "content-type": this.mimeType("managedObject"), accept: "application/json" };
      const res = yield this.fetch(url2, { method, body, headers });
      const data = yield res.json();
      return { res, data };
    });
  }
  addChild(type2, childReference, parentReference) {
    return __awaiter(this, void 0, void 0, function* () {
      const url2 = this.getChildrenUrl(type2, parentReference);
      const method = "POST";
      const childId = this.getIdString(childReference);
      const body = JSON.stringify({ managedObject: { id: String(childId) } });
      const headers = {
        accept: "application/json",
        "content-type": this.mimeType("managedObjectReference")
      };
      const res = yield this.fetch(url2, { method, body, headers });
      let data = yield res.json();
      data = data.managedObject;
      return { res, data };
    });
  }
  addChildBulk(type2, childReferenceArray, parentReference) {
    return __awaiter(this, void 0, void 0, function* () {
      const url2 = this.getChildrenUrl(type2, parentReference);
      const method = "POST";
      const references = childReferenceArray.map((childId) => ({
        managedObject: {
          id: this.getIdString(childId)
        }
      }));
      const body = JSON.stringify({
        references
      });
      const headers = {
        accept: "application/json",
        "content-type": this.mimeType("managedObjectReferenceCollection")
      };
      const res = yield this.fetch(url2, { method, body, headers });
      const data = (yield res.json()).references;
      return { res, data: data.map((obj) => obj.managedObject) };
    });
  }
  removeChild(type2, childReference, parentReference) {
    return __awaiter(this, void 0, void 0, function* () {
      const childId = this.getIdString(childReference);
      const url2 = `${this.getChildrenUrl(type2, parentReference)}/${childId}`;
      const method = "DELETE";
      const headers = { accept: "application/json" };
      const res = yield this.fetch(url2, { method, headers });
      const data = null;
      return { res, data };
    });
  }
  getSupportedMeasurementDetails(managedObjectOrId, type2 = "supportedSeries") {
    return __awaiter(this, void 0, void 0, function* () {
      const url2 = `${this.getDetailUrl(managedObjectOrId)}/${type2}`;
      this.getIdString(managedObjectOrId);
      const headers = { accept: "application/json" };
      const res = yield this.fetch(url2, { headers });
      const data = yield res.json();
      return data.c8y_SupportedMeasurements || data.c8y_SupportedSeries;
    });
  }
}
class MeasurementService extends Service {
  constructor() {
    super(...arguments);
    this.baseUrl = "measurement";
    this.listUrl = "measurements";
    this.propertyName = "measurements";
    this.channel = "/measurements/*";
  }
  /**
   * Gets the details of selected measurement.
   *
   * @param {string|number|IIdentified} entityOrId Entity or Id of the entity.
   *
   * @returns Response wrapped in [[IResult]]
   *
   * @deprecated As of version 10.16.0.0 and the usage of the time series database,
   * reading a single measurement via id is not supported any more.
   *
   * **Example**
   * ```typescript
   *
   *    const measurementId: number = 1;
   *
   *    (async () => {
   *      const {data, res} = await measurementService.detail(measurementId);
   *   })();
   * ```
   */
  detail(entityOrId) {
    const _super = Object.create(null, {
      detail: { get: () => super.detail }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.detail.call(this, entityOrId);
    });
  }
  /**
   * Creates a new measurement.
   *
   * @param {Partial<IMeasurementCreate>} entity At least sourceId is mandantory.
   *
   * @returns Response wrapped in [[IResult]]
   *
   * **Example**
   * ```typescript
   *
   *  const mandantoryObject: Partial<IMeasurementCreate> = {
   *    sourceId: device.id,
   *    fragment: { series: { unit: '%', value: 51 } },
   *  };
   *
   *  (async () => {
   *    const {data, res} = await measurementService.create(mandantoryObject);
   *  })();
   * ```
   */
  create(entity) {
    const _super = Object.create(null, {
      create: { get: () => super.create }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.create.call(this, this.onBeforeCreate(entity));
    });
  }
  /**
   * Gets the list of measurements filtered by parameters.
   *
   * @returns Response wrapped in [[IResultList]]
   *
   * @param {object} filter Object containing filters for querying measurements.
   *
   * **Example**
   * ```typescript
   *
   *  const filter: object = {
   *     pageSize: 100,
   *     withTotalPages: true
   *   };
   *
   *   (async () => {
   *     const {data, res, paging} = await measurementService.list(filter);
   *   })();
   * ```
   */
  list(filter2 = {}) {
    const _super = Object.create(null, {
      list: { get: () => super.list }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.list.call(this, filter2);
    });
  }
  /**
   * Removes a measurement with given id.
   *
   * @returns Response wrapped in [[IResult]]
   *
   * @param {string | number | IIdentified} entityOrId
   *
   * @deprecated As of version 10.16.0.0 and the usage of the time series database,
   * deleting a single measurement via id is not supported any more.
   *
   * **Example**
   * ```typescript
   *
   *   const id: number = 1;
   *
   *    (async () => {
   *      const {data, res} = await measurementService.delete(id);
   *   })();
   * ```
   */
  delete(entityOrId) {
    const _super = Object.create(null, {
      delete: { get: () => super.delete }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.delete.call(this, entityOrId);
    });
  }
  /**
   * Gets the list of series in a measurement filtered by parameters.
   *
   * @returns Response wrapped in [[IResult]]
   *
   * @param {object} filter Object containing filters for querying measurements.
   *
   * **Example**
   * ```typescript
   *
   *  const filter: object = {
   *    dateFrom: '2018-02-06T10:43:55.077Z',
   *    dateTo: '2018-02-06T10:50:55.077Z',
   *    source: device.id
   *  };
   *
   *   (async () => {
   *     const {data, res} = await measurementService.listSeries(filter);
   *   })();
   * ```
   */
  listSeries(params) {
    return __awaiter(this, void 0, void 0, function* () {
      const url2 = `${this.baseUrl}/${this.listUrl}/series`;
      const res = yield this.client.fetch(url2, { params });
      const data = yield res.json();
      return { res, data };
    });
  }
  onBeforeCreate(entity) {
    if (!entity.time) {
      entity.time = (/* @__PURE__ */ new Date()).toISOString();
    }
    if (!entity.type) {
      entity.type = "c8y_Measurement";
    }
    if (entity.sourceId) {
      const { sourceId } = entity;
      delete entity.sourceId;
      if (!entity.source) {
        entity.source = {
          id: String(sourceId)
        };
      }
    }
    return entity;
  }
}
var aggregationType;
(function(aggregationType2) {
  aggregationType2["MINUTELY"] = "MINUTELY";
  aggregationType2["HOURLY"] = "HOURLY";
  aggregationType2["DAILY"] = "DAILY";
})(aggregationType || (aggregationType = {}));
class AlarmService extends Service {
  constructor() {
    super(...arguments);
    this.baseUrl = "alarm";
    this.listUrl = "alarms";
    this.propertyName = "alarms";
    this.channel = "/alarms/*";
  }
  /**
   * Gets the details of selected alarms.
   *
   * @param {string|number|IIdentified} entityOrId Entity or Id of the entity.
   *
   * @returns Response wrapped in [[IResult]]
   *
   * **Example**
   * ```typescript
   *
   *    const alarmId: number = 1;
   *
   *    (async () => {
   *      const {data, res} = await alarmService.detail(alarmId);
   *    })();
   * ```
   */
  detail(entityOrId) {
    const _super = Object.create(null, {
      detail: { get: () => super.detail }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.detail.call(this, entityOrId);
    });
  }
  /**
   * Creates a new alarm.
   *
   * @param {IAlarm} entity Alarm object with mandantory fragments.
   *
   * @returns Response wrapped in [[IResult]]
   *
   * **Example**
   * ```typescript
   *
   *  const mandantoryObject: IAlarm = {
   *    severity: Severity.CRITICAL,
   *    source: device,
   *    text: 'I am an Alarm!',
   *    time: '2018-05-02T10:08:00Z',
   *    type: 'device-type-here',
   *  };
   *
   *  (async () => {
   *    const {data, res} = await alarmService.create(mandantoryObject);
   *  })();
   * ```
   */
  create(entity) {
    const _super = Object.create(null, {
      create: { get: () => super.create }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.create.call(this, entity);
    });
  }
  /**
   * Updates alarm data.
   *
   * @param {Partial<IAlarm>} entity Partial alarm to update, must have `id`.
   *
   * @returns Response wrapped in [[IResult]]
   *
   * **Example**
   * ```typescript
   *
   *  const partialUpdateObject: Partial<IAlarm> = {
   *    id: 123,
   *    severity: Severity.MINOR,
   *    source: device,
   *    text: 'Changed Alarm!'
   *  };
   *
   *  (async () => {
   *    const {data, res} = await alarmService.update(partialUpdateObject);
   *  })();
   * ```
   */
  update(entity) {
    const _super = Object.create(null, {
      update: { get: () => super.update }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.update.call(this, entity);
    });
  }
  /**
   * Updates alarm data in bulk and with additional query filters.
   *
   * @param {Partial<IAlarm>} entity Partial alarm object.
   * @param {Record<string, string | number | boolean>} filters Additional query filters.
   *
   * @returns Response in form of { IFetchResponse }
   *
   * **Example**
   * ```typescript
   *
   * const partialUpdateObject: Partial<IAlarm> = {
   *   status: AlarmStatus.CLEARED
   * };
   *
   * const additionalFilters: Record<string, string | number | boolean> = {
   *   resolved: false,
   *   severity: Severity.MINOR
   * };
   *
   * (async () => {
   *   const response = await alarmService.updateBulk(partialUpdateObject, additionalFilters);
   * })();
   * ```
   * In this example, every unresolved alarm that has a severity of `Severity.MINOR` will be updated with a status of `AlarmStatus.CLEARED`.
   */
  updateBulk(entity, filters) {
    return __awaiter(this, void 0, void 0, function* () {
      const params = new URLSearchParams(Object.entries(filters).map(([key, val]) => [key, String(val)]));
      const url2 = this.getDetailUrl(entity).replace(/\/$/, "") + `?${params.toString()}`;
      const method = "PUT";
      const body = JSON.stringify(this.onBeforeUpdate(entity));
      const headers = { "content-type": "application/json", accept: "application/json" };
      return yield this.fetch(url2, this.changeFetchOptions({ method, body, headers }, url2));
    });
  }
  /**
   * Gets the list of alarms filtered by parameters.
   *
   * @returns Response wrapped in [[IResultList]]
   *
   * @param {AlarmQueryFilter} filter Filters to query alarms.
   *
   * **Example**
   * ```typescript
   *
   *  const filter: AlarmQueryFilter = {
   *     severity: Severity.MAJOR,
   *     pageSize: 100,
   *     withTotalPages: true
   *   };
   *
   *   (async () => {
   *     const {data, res, paging} = await alarmService.list(filter);
   *   })();
   * ```
   */
  list(filter2 = {}) {
    const _super = Object.create(null, {
      list: { get: () => super.list }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.list.call(this, filter2);
    });
  }
  /**
   * Gets the number of alarms based on the filter criteria.
   *
   * @returns Response wrapped in [[IResultList]]
   *
   * @param {AlarmQueryFilter} filter Filters to query alarms.
   *
   * **Example**
   * ```typescript
   *
   *  const filter: AlarmQueryFilter = {
   *     severity: Severity.MAJOR,
   *   };
   *
   *   (async () => {
   *     const {data, res} = await alarmService.count(filter);
   *   })();
   * ```
   */
  count(filter2 = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      const url2 = `${this.listUrl}/count`;
      const res = yield this.fetch(url2, this.changeFetchOptions({ params: filter2 }, url2));
      const data = yield res.json();
      return { res, data };
    });
  }
}
class OperationService extends Service {
  constructor() {
    super(...arguments);
    this.baseUrl = "devicecontrol";
    this.listUrl = "operations";
    this.propertyName = "operations";
  }
  /**
   * Gets the details of selected operation.
   *
   * @param {string|number|IIdentified} entityOrId Entity or Id of the entitytabs.service.ts.
   *
   * @returns Response wrapped in [[IResult]]
   *
   * **Example**
   * ```typescript
   *
   *    const operationId: number = 1;
   *
   *    (async () => {
   *      const {data, res} = await operationService.detail(operationId);
   *   })();
   * ```
   */
  detail(entityOrId) {
    const _super = Object.create(null, {
      detail: { get: () => super.detail }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.detail.call(this, entityOrId);
    });
  }
  /**
   * Creates a new operation.
   *
   * @param {IOperation} entity Operation object with mandantory fragments.
   *
   * @returns Response wrapped in [[IResult]]
   *
   * **Example**
   * ```typescript
   *
   *  const mandantoryObject: IOperation = {
   *    com_cumulocity_model_WebCamDevice: {
   *      name: 'take picture',
   *      parameters: {
   *         duration: '5s',
   *         quality: 'HD'
   *      }
   *    },
   *    deviceId: device.id,
   *  };
   *
   *  (async () => {
   *    const {data, res} = await operationService.create(mandantoryObject);
   *  })();
   * ```
   */
  create(entity) {
    const _super = Object.create(null, {
      create: { get: () => super.create }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.create.call(this, entity);
    });
  }
  /**
   * Updates operation data.
   *
   * @param {Partial<IOperation>} entity Operation is partially updatable.
   *
   * @returns Response wrapped in [[IResult]]
   *
   * **Example**
   * ```typescript
   *
   *  const partialUpdateObject: Partial<IOperation> = {
   *    com_cumulocity_model_WebCamDevice: {
   *      name: 'take picture',
   *      parameters: {
   *         duration: '2s',
   *         quality: 'HD',
   *         ratio: '16:9'
   *      }
   *    },
   *    deviceId: device.id,
   *  };
   *
   *  (async () => {
   *    const {data, res} = await operationService.update(partialUpdateObject);
   *  })();
   * ```
   */
  update(entity) {
    const _super = Object.create(null, {
      update: { get: () => super.update }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.update.call(this, entity);
    });
  }
  /**
   * Gets the list of operations filtered by parameters.
   *
   * @returns Response wrapped in [[IResultList]]
   *
   * @param {object} filter Object containing filters for querying operations.
   *
   * **Example**
   * ```typescript
   *
   *  const filter: object = {
   *     pageSize: 100,
   *     withTotalPages: true
   *   };
   *
   *   (async () => {
   *     const {data, res, paging} = await operationService.list(filter);
   *   })();
   * ```
   */
  list(filter2 = {}) {
    const _super = Object.create(null, {
      list: { get: () => super.list }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.list.call(this, filter2);
    });
  }
}
class OperationBulkService extends Service {
  constructor() {
    super(...arguments);
    this.baseUrl = "devicecontrol";
    this.listUrl = "bulkoperations";
    this.propertyName = "bulkOperations";
  }
  /**
   * Gets the details of selected bulk operation.
   *
   * @param {string|number|IIdentified} entityOrId Entity or Id of the entity.
   *
   * @returns Response wrapped in [[IResult]]
   *
   * **Example**
   * ```typescript
   *
   *    const bulkOperationId: number = 1;
   *
   *    (async () => {
   *      const {data, res} = await operationBulkService.detail(bulkOperationId);
   *   })();
   * ```
   */
  detail(operationOrId) {
    const _super = Object.create(null, {
      detail: { get: () => super.detail }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.detail.call(this, operationOrId);
    });
  }
  /**
   * Creates a new operation.
   *
   * @param {Partial<IOperationBulk>} operation Operation object with mandantory fragments.
   *
   * @returns Response wrapped in [[IResult]]
   *
   * **Example**
   * ```typescript
   *
   *  const mandantoryObject: Partial<IOperationBulk> = {
   *    creationRamp: 15,
   *    groupId: '149044',
   *    operationPrototype: {
   *      c8y_Restart: {},
   *      description: 'Restart device',
   *      deviceId: device.id,
   *      status: 'PENDING'
   *    },
   *     startDate: '2018-02-15T16:01:00.000Z'
   *  };
   *
   *  (async () => {
   *    const {data, res} = await operationBulkService.create(mandantoryObject);
   *  })();
   * ```
   */
  create(operation2) {
    const _super = Object.create(null, {
      create: { get: () => super.create }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.create.call(this, operation2);
    });
  }
  /**
   * Updates a new operation.
   *
   * @param {Partial<IOperationBulk>} operation Operation object.
   *
   * @returns Response wrapped in [[IResult]]
   *
   * **Example**
   * ```typescript
   *
   *  const updateObject: Partial<IOperationBulk> = {
   *    creationRamp: 15,
   *    groupId: '149044',
   *    operationPrototype: {
   *      c8y_Restart: {},
   *      description: 'Restart device',
   *      deviceId: device.id,
   *      status: 'PENDING'
   *    },
   *     startDate: '2018-02-15T16:01:00.000Z'
   *  };
   *
   *  (async () => {
   *    const {data, res} = await operationBulkService.update(updateObject);
   *  })();
   * ```
   */
  update(entity) {
    const _super = Object.create(null, {
      update: { get: () => super.update }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.update.call(this, entity);
    });
  }
  /**
   * Gets the list of bulk operations filtered by parameters.
   *
   * @returns Response wrapped in [[IResultList]]
   *
   * @param {object} filter Object containing filters for querying alarms.
   *
   * **Example**
   * ```typescript
   *
   *  const filter: object = {
   *     pageSize: 100,
   *     withTotalPages: true
   *   };
   *
   *   (async () => {
   *     const {data, res, paging} = await operationBulkService.list(filter);
   *   })();
   * ```
   */
  list(filter2 = {}) {
    const _super = Object.create(null, {
      list: { get: () => super.list }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.list.call(this, filter2);
    });
  }
  /**
   * Removes an bulk operation with given id.
   *
   * @returns Response wrapped in [[IResult]]
   *
   * @param {string | number | IIdentified):} operationOrId Operation object or id.
   *
   * **Example**
   * ```typescript
   *
   *   const id: number = 1;
   *
   *    (async () => {
   *      const {data, res} = await operationBulkService.delete(id);
   *   })();
   * ```
   */
  delete(operationOrId) {
    const _super = Object.create(null, {
      delete: { get: () => super.delete }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.delete.call(this, operationOrId);
    });
  }
}
const gettext = (t2) => t2;
var OperationBulkStatus;
(function(OperationBulkStatus2) {
  OperationBulkStatus2[OperationBulkStatus2["ACTIVE"] = gettext("ACTIVE")] = "ACTIVE";
  OperationBulkStatus2[OperationBulkStatus2["IN_PROGRESS"] = gettext("IN_PROGRESS")] = "IN_PROGRESS";
  OperationBulkStatus2[OperationBulkStatus2["COMPLETED"] = gettext("COMPLETED")] = "COMPLETED";
  OperationBulkStatus2[OperationBulkStatus2["DELETED"] = gettext("DELETED")] = "DELETED";
})(OperationBulkStatus || (OperationBulkStatus = {}));
var OperationBulkGeneralStatus;
(function(OperationBulkGeneralStatus2) {
  OperationBulkGeneralStatus2[OperationBulkGeneralStatus2["SCHEDULED"] = gettext("SCHEDULED")] = "SCHEDULED";
  OperationBulkGeneralStatus2[OperationBulkGeneralStatus2["EXECUTING"] = gettext("EXECUTING")] = "EXECUTING";
  OperationBulkGeneralStatus2[OperationBulkGeneralStatus2["EXECUTING_WITH_ERROR"] = gettext("EXECUTING_WITH_ERROR")] = "EXECUTING_WITH_ERROR";
  OperationBulkGeneralStatus2[OperationBulkGeneralStatus2["CANCELED"] = gettext("CANCELED")] = "CANCELED";
  OperationBulkGeneralStatus2[OperationBulkGeneralStatus2["FAILED"] = gettext("FAILED")] = "FAILED";
  OperationBulkGeneralStatus2[OperationBulkGeneralStatus2["SUCCESSFUL"] = gettext("SUCCESSFUL")] = "SUCCESSFUL";
  OperationBulkGeneralStatus2[OperationBulkGeneralStatus2["DELETED"] = gettext("DELETED")] = "DELETED";
  OperationBulkGeneralStatus2[OperationBulkGeneralStatus2["INCORRECT"] = gettext("INCORRECT")] = "INCORRECT";
})(OperationBulkGeneralStatus || (OperationBulkGeneralStatus = {}));
var OperationStatus;
(function(OperationStatus2) {
  OperationStatus2[OperationStatus2["PENDING"] = gettext("PENDING")] = "PENDING";
  OperationStatus2[OperationStatus2["EXECUTING"] = gettext("EXECUTING")] = "EXECUTING";
  OperationStatus2[OperationStatus2["SUCCESSFUL"] = gettext("SUCCESSFUL")] = "SUCCESSFUL";
  OperationStatus2[OperationStatus2["FAILED"] = gettext("FAILED")] = "FAILED";
})(OperationStatus || (OperationStatus = {}));
class TenantService extends Service {
  constructor() {
    super(...arguments);
    this.baseUrl = "tenant";
    this.listUrl = "tenants";
    this.currentTenantUrl = "currentTenant";
    this.propertyName = "tenants";
    this.fetchOptions = {
      method: "PUT",
      body: "{}",
      headers: { "content-type": "application/json", accept: "application/json" }
    };
  }
  /**
   * Get a representation of a tenant.
   *
   * @param {string|number|IIdentified} entityOrId Tenant's id or tenant object.
   *
   * @returns Returns promise object that is resolved with the IIdentified wrapped by IResult.
   *
   * **Example**
   * ```typescript
   *
   *    const tenantId: number = 1;
   *
   *    (async () => {
   *      const {data, res} = await tenantService.detail(tenantId);
   *   })();
   * ```
   *
   * Required role: ROLE_TENANT_MANAGEMENT_READ<br><br>
   * User password is never returned in GET response. Authentication mechanism is provided by another interface.
   */
  detail(entityOrId) {
    const _super = Object.create(null, {
      detail: { get: () => super.detail }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.detail.call(this, entityOrId);
    });
  }
  /**
   * Creates a new tenant.
   *
   * @param {IIdentified} entity Tenant object.
   *
   * @returns {IResult<IIdentified>} Returns promise object that is resolved with the details of newly created tenant.
   *
   * **Example**
   * ```typescript
   *
   *  const tenantObject = {
   *    id: "sample_tenant",
   *    company: "sample_company",
   *    domain: "sample_domain.com",
   *    contactName: "Mr. Doe",
   *    ...
   *  };
   *
   *  (async () => {
   *    const {data, res} = await tenantService.create(tenantObject);
   *  })();
   * ```
   *
   * Required role: ROLE_TENANT_MANAGEMENT_ADMIN or ROLE_TENANT_MANAGEMENT_CREATE<br><br>
   * Note that creating a tenant with adminName, adminPass and adminEmail, creates an admin user with these settings.
   * For the tenant id SQL keywords (e.g., select, cross, where) are not allowed.
   */
  create(entity) {
    const _super = Object.create(null, {
      create: { get: () => super.create }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.create.call(this, entity);
    });
  }
  /**
   * Updates tenant data.
   *
   * @param {IIdentified} entity Tenant is partially updatable.
   *
   * @returns {IResult<IIdentified>} Returns promise object that is resolved with the saved tenant object.
   *
   * **Example**
   * ```typescript
   *
   *  const partialUpdateObject: IIdentified = {
   *     adminName : "newAdmin"
   *     ...
   *   }
   *
   *  (async () => {
   *    const {data, res} = await tenantService.update(partialUpdateObject);
   *  })();
   * ```
   *
   * Required role: ROLE_TENANT_MANAGEMENT_ADMIN or ROLE_TENANT_MANAGEMENT_UPDATE<br><br>
   * Note that updating adminPass and adminEmail updates these settings in the admin user of the tenant.
   * Updating adminName has no effect.
   */
  update(entity) {
    const _super = Object.create(null, {
      update: { get: () => super.update }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.update.call(this, entity);
    });
  }
  /**
   * Gets the list of tenants filtered by parameters.
   *
   * @param {object} filter Object containing filters for querying tenants.
   *
   * @returns Returns promise object that is resolved with the IIdentified wrapped by IResultList.
   *
   * **Example**
   * ```typescript
   *
   *  const filter: object = {
   *     severity: Severity.MAJOR,
   *     pageSize: 100,
   *     withTotalPages: true
   *   };
   *
   *   (async () => {
   *     const {data, res, paging} = await tenantService.list(filter);
   *   })();
   * ```
   *
   * Required role: ROLE_TENANT_MANAGEMENT_READ
   */
  list(filter2 = {}) {
    const _super = Object.create(null, {
      list: { get: () => super.list }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.list.call(this, filter2);
    });
  }
  /**
   * Delete a representation of a tenant.
   *
   * @param {string|number|IIdentified} entityOrId Tenant's id or tenant object.
   *
   * @returns Returns promise object that is resolved with the IResult.
   *
   * **Example**
   * ```typescript
   *
   *    const tenantId: string = "uniqueTenantId";
   *
   *    (async () => {
   *      const {data, res} = await tenantService.delete(tenantId);
   *   })();
   * ```
   *
   * Required role: ROLE_TENANT_MANAGEMENT_ADMIN
   */
  delete(entityOrId) {
    const _super = Object.create(null, {
      delete: { get: () => super.delete }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.delete.call(this, entityOrId);
    });
  }
  current() {
    return __awaiter(this, void 0, void 0, function* () {
      const headers = { "content-type": "application/json" };
      const res = yield this.fetch(this.currentTenantUrl, { headers });
      const data = yield res.json();
      return { res, data };
    });
  }
  /**
   * enable support user for current tenant.
   *
   * @returns Returns promise object that is resolved with the IResult.
   *
   * **Example**
   * ```typescript
   *    (async () => {
   *      const {res} = await tenantService.enableSupportUser();
   *   })();
   * ```
   */
  enableSupportUser() {
    return __awaiter(this, void 0, void 0, function* () {
      const url2 = "support-user/enable";
      const res = yield this.fetch(url2, this.fetchOptions);
      return { res, data: null };
    });
  }
  /**
   * disable support user for current tenant.
   *
   * @returns Returns promise object that is resolved with the IResult.
   *
   * **Example**
   * ```typescript
   *    (async () => {
   *      const {res} = await tenantService.disableSupportUser();
   *   })();
   * ```
   */
  disableSupportUser() {
    return __awaiter(this, void 0, void 0, function* () {
      const url2 = "support-user/disable";
      const res = yield this.fetch(url2, this.fetchOptions);
      return { res, data: null };
    });
  }
  currentTenantType() {
    return __awaiter(this, void 0, void 0, function* () {
      const tenantData = yield this.current();
      if (tenantData.data.customProperties && tenantData.data.customProperties.tenantType === "TRIAL") {
        return "TRIAL";
      }
      return "REGULAR";
    });
  }
  /**
   * Returns two factor-authentication settings for given tenant.
   *
   * @param tenant The tenant object.
   *
   * @returns Promise which resolves with the object with TFA settings.
   *
   * **Example**
   * ```typescript
   *   (async () => {
   *     const currentTenant = (await tenantService.current()).data;
   *     const currentTenantTfaSettings = await tenantService.getTfaSettings(currentTenant);
   *
   *     const subtenant = (await tenantService.detail('t12345')).data;
   *     const subtenantTfaSettings = await tenantService.getTfaSettings(subtenant);
   *   })();
   * ```
   */
  getTfaSettings(tenant2) {
    return __awaiter(this, void 0, void 0, function* () {
      const entityOrId = this.getIdString(tenant2);
      const url2 = `tenants/${entityOrId}/tfa`;
      const res = yield this.fetch(url2);
      const tfaSettings = yield res.json();
      return tfaSettings;
    });
  }
  /**
   * Update TFA strategy for tenant.
   *
   * @param tenant The tenant object.
   * @param tfaStrategy The TFA strategy.
   *
   * @returns Returns promise object that is resolved with the IResult.
   *
   * **Example**
   * ```typescript
   *   (async () => {
   *     const currentTenant = (await tenantService.current()).data;
   *
   *     const res = await tenantService.updateTfaStrategy(currentTenant, TfaStrategy.TOTP);
   *   })();
   * ```
   */
  updateTfaStrategy(tenant2, tfaStrategy) {
    return __awaiter(this, void 0, void 0, function* () {
      const entityOrId = this.getIdString(tenant2);
      const url2 = `tenants/${entityOrId}/tfa`;
      const method = "PUT";
      const body = JSON.stringify({ strategy: tfaStrategy });
      const headers = { "content-type": "application/json", accept: "application/json" };
      const res = yield this.fetch(url2, { method, body, headers });
      return { res, data: null };
    });
  }
  /**
   * Subscribes a given application to a given tenant.
   *
   * @param tenant The tenant object.
   * @param application The application object.
   *
   * @returns Returns promise object that is resolved with the IResult.
   *
   * **Example**
   * ```typescript
   *     const newApp = {
   *        name: 'New application',
   *        type: 'HOSTED',
   *        key: 'new-app'
   *     };
   *
   *     const application = (await applicationService.create(newApp)).data;
   *     const currentTenant = (await tenantService.current()).data;
   *
   *     const {data, res} = await tenantService.subscribeApplication(currentTenant, application);
   *   })();
   * ```
   */
  subscribeApplication(tenant2, application2) {
    return __awaiter(this, void 0, void 0, function* () {
      const entityOrId = this.getIdString(tenant2);
      const applicationId = application2.id;
      const url2 = `tenants/${entityOrId}/applications`;
      const method = "POST";
      const body = JSON.stringify({
        application: {
          id: applicationId,
          self: application2.self
        }
      });
      const headers = { "content-type": this.mimeType("applicationReference") };
      const res = yield this.fetch(url2, this.changeFetchOptions({ method, body, headers }, url2));
      return { res, data: null };
    });
  }
  /**
   * Unsubscribes a given application from a given tenant.
   *
   * @param tenant The tenant object.
   * @param application The application object.
   *
   * @returns Returns promise object that is resolved with the IResult.
   *
   * **Example**
   * ```typescript
   *     const newApp = {
   *        name: 'New application',
   *        type: 'HOSTED',
   *        key: 'new-app'
   *     };
   *
   *     const application = (await applicationService.create(newApp)).data;
   *     const currentTenant = (await tenantService.current()).data;
   *     await tenantService.addApplication(currentTenant, application);
   *
   *     await tenantService.unsubscribeApplication(currentTenant, application);
   *   })();
   * ```
   */
  unsubscribeApplication(tenant2, application2) {
    return __awaiter(this, void 0, void 0, function* () {
      const entityOrId = this.getIdString(tenant2);
      const url2 = `tenants/${entityOrId}/applications/${application2.id}`;
      const method = "DELETE";
      const res = yield this.fetch(url2, this.changeFetchOptions({ method }, url2));
      return { res, data: null };
    });
  }
  getIdString(tenant2) {
    return tenant2.id || tenant2.name;
  }
  onBeforeCreate(obj) {
    return obj;
  }
}
var TenantStatus;
(function(TenantStatus2) {
  TenantStatus2[TenantStatus2["ACTIVE"] = gettext("ACTIVE")] = "ACTIVE";
  TenantStatus2[TenantStatus2["SUSPENDED"] = gettext("SUSPENDED")] = "SUSPENDED";
})(TenantStatus || (TenantStatus = {}));
var TfaStrategy;
(function(TfaStrategy2) {
  TfaStrategy2["TOTP"] = "TOTP";
  TfaStrategy2["SMS"] = "SMS";
})(TfaStrategy || (TfaStrategy = {}));
class UserInventoryRoleService extends Service {
  constructor(userUrl, client) {
    super(client);
    this.listUrl = `inventory`;
    this.currenUserUrl = `currentUser`;
    this.propertyName = "inventoryAssignments";
    this.baseUrl = `user/${userUrl}/roles`;
  }
  /**
   * Get a representation of a concrete current user's inventory role.
   *
   * @param {string|number|IUserInventoryRole} entityOrId inventory role id or inventory role object.
   *
   * @returns Returns promise object that is resolved with the IUserInventoryRole wrapped by IResult.
   *
   * **Example**
   * ```typescript
   *
   *    const inventoryRoleId: number = 1;
   *
   *    (async () => {
   *      const {data, res} = await userInventoryRoleService.detail(inventoryRoleId);
   *   })();
   * ```
   *
   * Required role: ROLE_TENANT_MANAGEMENT_READ<br><br>
   * User password is never returned in GET response. Authentication mechanism is provided by another interface.
   */
  detail(entityOrId) {
    const _super = Object.create(null, {
      detail: { get: () => super.detail }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.detail.call(this, entityOrId);
    });
  }
  /**
   * Assign inventory role to current user.
   *
   * @param {IUserInventoryRole} entity Inventory Role object.
   *
   * @returns Returns promise object that is resolved with the details of newly assigned inventory role.
   *
   * **Example**
   * ```typescript
   *
   *  const inventoryRoleObject: IUserInventoryRole = {
   *    ...
   *  };
   *
   *    (async () => {
   *      const {data, res} = await userInventoryRoleService.create(inventoryRoleObject);
   *   })();
   * ```
   */
  create(entity) {
    const _super = Object.create(null, {
      create: { get: () => super.create }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.create.call(this, entity);
    });
  }
  /**
   * Updates an inventory role.
   *
   * @param {Partial<IUserInventoryRole>} entity Inventory Role object.
   */
  update(entity) {
    const _super = Object.create(null, {
      update: { get: () => super.update }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.update.call(this, entity);
    });
  }
  /**
   * Gets the list the inventory roles applied to a current user.
   *
   * @param {object} filter Object containing filters for querying inventory roles.
   *
   * @returns Returns promise object that is resolved with the IUserInventoryRole wrapped by IResultList.
   *
   * **Example**
   * ```typescript
   *
   *  const filter: object = {
   *     severity: Severity.MAJOR,
   *     pageSize: 100,
   *     withTotalPages: true
   *   };
   *
   *   (async () => {
   *     const {data, res, paging} = await userInventoryRoleService.list(filter);
   *   })();
   * ```
   */
  list(filter2 = {}) {
    const _super = Object.create(null, {
      list: { get: () => super.list }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.list.call(this, filter2);
    });
  }
  /**
   * Unassign inventory role from current user
   *
   * @param {string|number|IIdentified} entityOrId Inventory Role id or Inventory Role object.
   *
   * @returns Returns promise object that is resolved with the IResult.
   *
   * **Example**
   * ```typescript
   *
   *    const inventoryRoleId: number = 1;
   *
   *    (async () => {
   *      const {data, res} = await userInventoryRoleService.delete(inventoryRoleId);
   *   })();
   * ```
   */
  delete(entityOrId) {
    const _super = Object.create(null, {
      delete: { get: () => super.delete }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.delete.call(this, entityOrId);
    });
  }
}
class UserService extends Service {
  constructor() {
    super(...arguments);
    this.baseUrl = "user";
    this.currentUserUrl = "currentUser";
    this.passwordResetUrl = "passwordReset";
    this.currentUserPhoneUrl = "currentUserPhone";
    this.verifyTFACodeUrl = "pin";
    this.totpCurrentUserURL = `${this.currentUserUrl}/totpSecret`;
    this.verifyTOTPCodeUrl = `${this.totpCurrentUserURL}/verify`;
    this.activateTOTPCodeUrl = `${this.totpCurrentUserURL}/activity`;
    this.revokeTOTPSecretUrl = "totpSecret/revoke";
    this.propertyName = "users";
  }
  get listUrl() {
    return `${this.client.tenant}/users`;
  }
  get newsletterEmailsUrl() {
    return `${this.client.tenant}/users/newsletterEmails`;
  }
  get currentUserPasswordUrl() {
    return `${this.currentUserUrl}/password`;
  }
  get revokeAllTokensUrl() {
    return `/logout/${this.client.tenant}/allUsers`;
  }
  /**
   * Gets the details of given user.
   *
   * @param {string | number | IUser} entityOrId User's id or user object.
   *
   * @returns Returns promise object that is resolved with the IUser wrapped by IResult.
   *
   * **Example**
   * ```typescript
   *
   *    const userId: number = 1;
   *
   *    (async () => {
   *      const {data, res} = await userService.detail(userId);
   *   })();
   * ```
   * User password is never returned in GET response. Authentication mechanism is provided by another interface.
   */
  detail(entityOrId) {
    const _super = Object.create(null, {
      detail: { get: () => super.detail }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.detail.call(this, entityOrId);
    });
  }
  /**
   * Creates a new user.
   *
   * @param {IUser} entity User object.
   *
   * @returns {IResult<IUser>} Returns promise object that is resolved with the details of newly created user.
   *
   * **Example**
   * ```typescript
   *
   *  const userObject: IUser = {
   *    userName: "newUser",
   *    password: "userPassword12!@"
   *  };
   *
   *  (async () => {
   *    const {data, res} = await userService.create(userObject);
   *  })();
   * ```
   */
  create(entity) {
    const _super = Object.create(null, {
      create: { get: () => super.create }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.create.call(this, entity);
    });
  }
  /**
   * Updates user data.
   *
   * @param {Partial<IUser>} entity User is partially updatable.
   *
   * @returns {IResult<IUserGroup>} Returns promise object that is resolved with the saved user object.
   *
   * **Example**
   * ```typescript
   *
   *  const partialUpdateObject: Partial<IUser> = {
   *     "id" : "myuser",
   *     "userName" : "newUserName",
   *     "email": "newUserEmail@example.com"
   *     ...
   *   }
   *
   *  (async () => {
   *    const {data, res} = await userService.update(partialUpdateObject);
   *  })();
   * ```
   * When user is updated with changed permissions or groups, suitable audit record is created with type
   * 'User' and activity 'User updated'.
   */
  update(entity) {
    const _super = Object.create(null, {
      update: { get: () => super.update }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.update.call(this, entity);
    });
  }
  /**
   * Gets the list of users filtered by parameters.
   *
   * @param {object} filter Object containing filters for querying users.
   *
   * @returns Returns promise object that is resolved with the IUser wrapped by IResultList.
   *
   * **Example**
   * ```typescript
   *
   *  const filter: object = {
   *     pageSize: 100,
   *     withTotalPages: true
   *   };
   *
   *   (async () => {
   *     const {data, res, paging} = await userService.list(filter);
   *   })();
   * ```
   */
  list(filter2 = {}) {
    const _super = Object.create(null, {
      list: { get: () => super.list }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.list.call(this, filter2);
    });
  }
  /**
   * Removes user.
   *
   * @param {number|IIdentified} entityOrId User's id or user object.
   *
   * @returns Returns promise object that is resolved with the IResult of null.
   *
   * **Example**
   * ```typescript
   *
   *    const userId: string = "uniqueUserId";
   *
   *    (async () => {
   *      const {data, res} = await userService.delete(userGroupId);
   *   })();
   * ```
   */
  delete(entityOrId) {
    const _super = Object.create(null, {
      delete: { get: () => super.delete }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.delete.call(this, entityOrId);
    });
  }
  /**
   * Create instance of User Inventory Role Service related with given User.
   *
   * @param {string|number|IUser} entityOrId User's id or user object.
   *
   * @returns Returns UserInventoryRoleService object that is related with given User.
   *
   * **Example**
   * ```typescript
   *
   *    const userId: string = "uniqueUserId";
   *
   *    const userInventoryRoleService = userService.inventoryAssignment(userGroupId);
   *    (async () => {
   *      const {data, res} = await userInventoryRoleService.create(...);
   *   })();
   * ```
   */
  inventoryAssignment(entityOrId) {
    return new UserInventoryRoleService(this.getDetailUrl(entityOrId), this.client);
  }
  /**
   * Gets user that is currently logged in.
   *
   * @returns Returns promise object that is resolved with the IUser wrapped by IResult.
   *
   * **Example**
   * ```typescript
   *
   *    (async () => {
   *      const {data, res} = await userService.current();
   *   })();
   * ```
   */
  current() {
    return __awaiter(this, void 0, void 0, function* () {
      const headers = {
        "content-type": "application/json",
        Accept: "application/vnd.com.nsn.cumulocity.user+json;"
      };
      const res = yield this.fetch(this.currentUserUrl, { headers });
      const data = yield res.json();
      return { res, data };
    });
  }
  /**
   * Gets user that is currently logged in with the list of all roles assigned.
   *
   * @returns Returns promise object that is resolved with the ICurrenUser wrapped by IResult.
   *
   * **Example**
   * ```typescript
   *
   *    (async () => {
   *      const {data, res} = await userService.currentWithEffectiveRoles();
   *   })();
   * ```
   */
  currentWithEffectiveRoles() {
    return __awaiter(this, void 0, void 0, function* () {
      const headers = {
        "content-type": "application/json",
        Accept: "application/vnd.com.nsn.cumulocity.currentUser+json;"
      };
      const res = yield this.fetch(this.currentUserUrl, { headers });
      const data = yield res.json();
      return { res, data };
    });
  }
  /**
   * Updates the current user
   *
   * @param {IUser} user The user object with the properties to be updated
   *
   * @return Returns promise object resolved with the IUser wrapped by IResult
   */
  updateCurrent(user) {
    return __awaiter(this, void 0, void 0, function* () {
      const mimeType = "application/vnd.com.nsn.cumulocity.user+json";
      const headers = { "content-type": mimeType, Accept: mimeType };
      const body = JSON.stringify(this.onBeforeUpdate(user));
      const res = yield this.fetch(this.currentUserUrl, { headers, body, method: "PUT" });
      const data = yield res.json();
      return { res, data };
    });
  }
  /**
   * Sends an email message with a link allowing user to reset their password.
   *
   * @param {string} email The email address to send the message to.
   * @param {string} tenantId The id of user's tenant (if cannot be inferred from URL).
   *
   * @returns Returns a request result object.
   *
   * **Example**
   * ```typescript
   *   const email = 'user@example.com';
   *   const tenantId = 't123456';
   *
   *   (async () => {
   *     const { res, data } = await userService.sendPasswordResetMail(email, tenantId);
   *   })();
   * ```
   */
  sendPasswordResetMail(email2, tenantId) {
    return __awaiter(this, void 0, void 0, function* () {
      const headers = { "content-type": "application/json", accept: "application/json" };
      const method = "POST";
      const url2 = this.passwordResetUrl;
      const params = tenantId ? { tenantId } : {};
      const body = JSON.stringify({ email: email2 });
      const res = yield this.fetch(url2, { headers, method, params, body });
      return { res, data: null };
    });
  }
  /**
   * Resets user's password to a new one.
   *
   * @param {IResetPassword} newPassword Object with token, user's email, new password and its strength indicator.
   * @param {string} tenantId The id of user's tenant (if cannot be inferred from URL).
   *
   * @returns Returns a request result object.
   *
   * **Example**
   * ```typescript
   *   const newPassword: IResetPassword = {
   *     token: '123123ASDAWERER@#!WEDS$@#!WADA#A#EA#EA#EA',
   *     email: 'user@example.com',
   *     newPassword: 'myNewPassword',
   *     passwordStrength: PasswordStrength.GREEN
   *   };
   *   const tenantId = 't123456';
   *
   *   (async () => {
   *     const { res, data } = await userService.resetPassword(newPassword, tenantId);
   *   })();
   * ```
   */
  resetPassword(newPassword, tenantId) {
    return __awaiter(this, void 0, void 0, function* () {
      const headers = { "content-type": "application/json", accept: "application/json" };
      const method = "PUT";
      const url2 = this.passwordResetUrl;
      const params = tenantId ? { tenantId } : {};
      const body = JSON.stringify(newPassword);
      const res = yield this.fetch(url2, { headers, method, params, body });
      return { res, data: null };
    });
  }
  /**
   * Verifies TFA code which is sent via SMS. If invoked with string '0', new TFA code will be sent.
   *
   * @param {string} pin The code to verify.
   *
   * @returns Returns a status object.
   *
   * **Example**
   * ```typescript
   *
   *    (async () => {
   *      const {data, res} = await userService.verifyTFACode('123123');
   *   })();
   * ```
   */
  verifyTFACode(pin) {
    return __awaiter(this, void 0, void 0, function* () {
      const method = "POST";
      const body = JSON.stringify({ pin });
      const headers = { "content-type": "application/json", accept: "application/json" };
      const res = yield this.fetch(this.verifyTFACodeUrl, { headers, body, method });
      return { res, data: null };
    });
  }
  /**
   * Verifies TFA code which is generated by a TOTP app.
   *
   * @param {string} code The code to verify.
   *
   * @returns Returns a status object.
   *
   * **Example**
   * ```typescript
   *
   *    (async () => {
   *      const {data, res} = await userService.verifyTotpCode('123123');
   *   })();
   * ```
   */
  verifyTotpCode(code) {
    return __awaiter(this, void 0, void 0, function* () {
      const method = "POST";
      const headers = { "content-type": "application/json" };
      const body = JSON.stringify({ code });
      const res = yield this.fetch(this.verifyTOTPCodeUrl, { headers, body, method });
      return { res, data: null };
    });
  }
  /**
   * Verifies TFA code which is generated by a TOTP app.
   *
   * @returns Returns a status object.
   *
   * **Example**
   * ```typescript
   *
   *    (async () => {
   *      const {data, res} = await userService.activateTotp();
   *   })();
   * ```
   */
  activateTotp() {
    return __awaiter(this, void 0, void 0, function* () {
      const method = "POST";
      const headers = { "content-type": "application/json" };
      const body = JSON.stringify({ isActive: true });
      const res = yield this.fetch(this.activateTOTPCodeUrl, { headers, body, method });
      return { res, data: null };
    });
  }
  /**
   * Checks if TOTP is activated and enforced.
   *
   * @returns Returns an object of ITotpStatus if it is active.
   *
   * **Example**
   * ```typescript
   *
   *    (async () => {
   *      const {data, res} = await userService.getActivityTotp();
   *      console.log(data.isActive);
   *   })();
   * ```
   */
  getActivityTotp() {
    return __awaiter(this, void 0, void 0, function* () {
      const method = "GET";
      const headers = { "content-type": "application/json" };
      const res = yield this.fetch(this.activateTOTPCodeUrl, { headers, method });
      const data = yield res.json();
      return { res, data };
    });
  }
  /**
   * Generates a secret which can be used to setup two-factor authentication with TOTP.
   *
   * @returns Returns the secret and an URL to a QR Code.
   *
   * **Example**
   * ```typescript
   *
   *    (async () => {
   *      const {data, res} = await userService.generateTotpSecret();
   *      console.log(secret);
   *   })();
   * ```
   */
  generateTotpSecret() {
    return __awaiter(this, void 0, void 0, function* () {
      const method = "POST";
      const headers = { "content-type": "application/json", accept: "application/json" };
      const res = yield this.fetch(this.totpCurrentUserURL, { headers, method });
      const data = yield res.json();
      return { res, data };
    });
  }
  /**
   * Revokes a specific user's TOTP secret.
   *
   * @param {IUser} user User whose TOTP secret to revoke.
   *
   * @returns Status object
   */
  totpRevokeSecret(user) {
    return __awaiter(this, void 0, void 0, function* () {
      const url2 = `${this.getDetailUrl(user)}/${this.revokeTOTPSecretUrl}`;
      const method = "DELETE";
      const headers = { accept: "application/json" };
      const res = yield this.fetch(url2, { headers, method });
      return { res, data: null };
    });
  }
  /**
   * Saves phone number for the current user.
   * @param phoneNumber Phone number to save.
   * @returns Server response and data with updated current user object.
   */
  savePhoneNumber(phoneNumber) {
    return __awaiter(this, void 0, void 0, function* () {
      const url2 = this.currentUserPhoneUrl;
      const options = {
        method: "PUT",
        headers: { "content-type": "application/json", accept: "application/json" },
        body: JSON.stringify({
          phone: phoneNumber
        })
      };
      const res = yield this.fetch(url2, options);
      const data = yield res.json();
      return { res, data };
    });
  }
  /**
   * Gets the list of emails of users subscribed for newsletter
   * on the current tenant and its subtenants.
   * @returns Server response and data with email addresses as plain text.
   */
  getNewsletterEmails() {
    return __awaiter(this, void 0, void 0, function* () {
      const url2 = this.newsletterEmailsUrl;
      const options = {
        method: "GET",
        headers: { accept: "text/plain" }
      };
      const res = yield this.fetch(url2, options);
      const data = yield res.text();
      return { res, data };
    });
  }
  /**
   * Changes password for user.
   *
   * @param {string | number | IUser} entityOrId User's id or user object.
   * @param {string} newPassword New user password.
   * @param {string} currentUserPassword The password of the currently logged user.
   *
   * @returns Returns a result object.
   */
  changeUserPassword(entityOrId, newPassword, currentUserPassword) {
    return __awaiter(this, void 0, void 0, function* () {
      const method = "PUT";
      const headers = { "content-type": "application/json" };
      const body = JSON.stringify({ newPassword, currentUserPassword });
      const res = yield this.fetch(this.changeUserPasswordUrl(entityOrId), { headers, body, method });
      return { res, data: null };
    });
  }
  /**
   * Changes password for current user.
   *
   * @param {string} newPassword New password for current user.
   * @param {string} currentUserPassword The password of the currently logged user.
   *
   * @returns Returns a result object. During this action if preferred login mode is OAI_SECURE new jwt cookie will be set.
   */
  changeCurrentUserPassword(newPassword, currentUserPassword) {
    return __awaiter(this, void 0, void 0, function* () {
      const method = "PUT";
      const headers = { "content-type": "application/json" };
      const body = JSON.stringify({ newPassword, currentUserPassword });
      const res = yield this.fetch(this.currentUserPasswordUrl, { headers, body, method });
      return { res, data: null };
    });
  }
  /**
   * Revoke tokens for all users. All users logged with "OAI-Secure" or "Single sign-on redirect" will be logged out.
   *
   * @returns Returns a result object.
   */
  revokeTokens() {
    return __awaiter(this, void 0, void 0, function* () {
      const method = "POST";
      const headers = { "content-type": "application/json" };
      const res = yield this.fetch(this.revokeAllTokensUrl, { headers, method });
      return { res, data: null };
    });
  }
  hasRole(user, roleId) {
    return this.hasRoleInUser(user, roleId) || this.hasRoleInGroups(user, roleId);
  }
  hasAllRoles(user, roleIds) {
    return roleIds.every((roleId) => this.hasRole(user, roleId));
  }
  hasAnyRole(user, roleIds) {
    return roleIds.some((roleId) => this.hasRole(user, roleId));
  }
  hasAnyGlobalRole(user, globalRoleIds) {
    return globalRoleIds.some((globalRoleId) => this.hasGlobalRoleInUser(user, globalRoleId));
  }
  isDeviceUser(user) {
    return user.id.match(/^device_/);
  }
  onBeforeUpdate(user) {
    const obj = Object.assign({}, user);
    delete obj.id;
    delete obj.userName;
    return obj;
  }
  getDetailUrl(entityOrId) {
    return `${this.listUrl}/${encodeURIComponent(this.getId(entityOrId))}`;
  }
  getId(entityOrId) {
    let id2;
    if (typeof entityOrId === "object" && entityOrId.id) {
      id2 = entityOrId.id;
    } else if (typeof entityOrId === "object" && entityOrId.userName) {
      id2 = entityOrId.userName;
    } else {
      id2 = entityOrId;
    }
    return String(id2);
  }
  hasRoleInUser(user, roleId) {
    const effectiveRoles = user.effectiveRoles || [];
    return this.hasRoleInReferences(user && user.roles && user.roles.references || [], roleId) || effectiveRoles.some(({ id: id2 }) => roleId === id2);
  }
  hasRoleInGroups(user, roleId) {
    const groupReferences = user && user.groups && user.groups.references || [];
    return groupReferences.some((groupRef) => this.hasRoleInReferences(groupRef.group.roles.references, roleId));
  }
  hasRoleInReferences(references, roleId) {
    return references.some((ref) => ref.role.id === roleId);
  }
  changeUserPasswordUrl(entityOrId) {
    return `${this.client.tenant}/users/${this.getId(entityOrId)}/password`;
  }
  hasGlobalRoleInUser(user, globalRoleId) {
    var _a;
    const groupReferencesIds = (((_a = user === null || user === void 0 ? void 0 : user.groups) === null || _a === void 0 ? void 0 : _a.references) || []).map((gR) => {
      var _a2;
      return (_a2 = gR === null || gR === void 0 ? void 0 : gR.group) === null || _a2 === void 0 ? void 0 : _a2.id;
    });
    return groupReferencesIds.some((id2) => id2 === globalRoleId);
  }
}
var PasswordStrength;
(function(PasswordStrength2) {
  PasswordStrength2["GREEN"] = "GREEN";
  PasswordStrength2["RED"] = "RED";
  PasswordStrength2["YELLOW"] = "YELLOW";
})(PasswordStrength || (PasswordStrength = {}));
class ApplicationBinaryService extends Service {
  constructor(client, applicationOrId) {
    super(client);
    this.listUrl = "binaries";
    this.propertyName = "attachments";
    this.baseUrl = `application/applications/${this.getIdString(applicationOrId)}`;
  }
  upload(binary, fileName, uploadParamsOverride) {
    return __awaiter(this, void 0, void 0, function* () {
      const url2 = (uploadParamsOverride === null || uploadParamsOverride === void 0 ? void 0 : uploadParamsOverride.listUrl) || this.listUrl;
      const method = "POST";
      const body = this.createBinaryRequestBody(binary, fileName, uploadParamsOverride);
      let bodyHeaders;
      if (typeof body.getHeaders === "function") {
        bodyHeaders = body.getHeaders();
      }
      const headers = Object.assign((uploadParamsOverride === null || uploadParamsOverride === void 0 ? void 0 : uploadParamsOverride.headers) || {
        Accept: "application/json"
      }, bodyHeaders);
      const res = yield this.fetch(url2, { method, body, headers });
      const data = yield res.json();
      return { res, data };
    });
  }
  uploadApplicationVersion(archive, version2, tags = []) {
    return this.upload(archive, archive.name, {
      listUrl: "versions",
      headers: {
        Accept: "application/vnd.com.nsn.cumulocity.applicationVersion+json;charset=UTF-8;ver=0.9"
      },
      bodyFileProperty: "applicationBinary",
      requestBody: {
        applicationVersion: Object.assign({ version: version2 }, (tags === null || tags === void 0 ? void 0 : tags.length) && { tags })
      }
    });
  }
  uploadWithProgressXhr(binary, onProgress, fileName, uploadParamsOverride) {
    const url2 = `/${this.baseUrl}/${(uploadParamsOverride === null || uploadParamsOverride === void 0 ? void 0 : uploadParamsOverride.listUrl) || this.listUrl}`;
    const method = "POST";
    const body = this.createBinaryRequestBody(binary, fileName, uploadParamsOverride);
    let bodyHeaders;
    if (typeof body.getHeaders === "function") {
      bodyHeaders = body.getHeaders();
    }
    const headers = this.client.getFetchOptions().headers;
    Object.assign(headers, (uploadParamsOverride === null || uploadParamsOverride === void 0 ? void 0 : uploadParamsOverride.headers) || {
      Accept: "application/json"
    });
    Object.assign(headers, bodyHeaders);
    const xhr = new XMLHttpRequest();
    xhr.open(method, url2, true);
    for (const key in headers) {
      if (headers.hasOwnProperty(key)) {
        xhr.setRequestHeader(key, headers[key]);
      }
    }
    xhr.upload.addEventListener("progress", onProgress);
    let xhrBody;
    if (typeof body.getBuffer === "function") {
      xhrBody = body.getBuffer();
    } else {
      xhrBody = body;
    }
    xhr.send(xhrBody);
    return xhr;
  }
  getXMLHttpResponse(xhr) {
    return new Promise((res, rej) => {
      xhr.addEventListener("loadend", () => {
        xhr.readyState === 4 && (xhr.status === 200 || xhr.status === 201) ? res(JSON.parse(xhr.responseText)) : rej(xhr.responseText ? { data: JSON.parse(xhr.responseText) } : "Could not upload file.");
      });
    });
  }
  list(filter2) {
    const _super = Object.create(null, {
      list: { get: () => super.list }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.list.call(this, filter2);
    });
  }
  delete(binaryOrId) {
    const _super = Object.create(null, {
      delete: { get: () => super.delete }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.delete.call(this, binaryOrId);
    });
  }
  listPlugins() {
    return __awaiter(this, void 0, void 0, function* () {
      const headers = { accept: "application/json" };
      const url2 = `${this.listUrl}/plugins`;
      const res = yield this.fetch(url2, { headers });
      const data = yield res.json();
      return { res, data };
    });
  }
  addPlugin(pluginName, pluginFile) {
    return __awaiter(this, void 0, void 0, function* () {
      const url2 = `${this.listUrl}/plugins/${encodeURIComponent(pluginName)}`;
      const method = "POST";
      const body = new FormData$1();
      const bufferOrStream = pluginFile instanceof ArrayBuffer ? Buffer.from(pluginFile) : pluginFile;
      body.append("file", bufferOrStream);
      const headers = {
        accept: "application/json"
      };
      const res = yield this.fetch(url2, { method, body, headers });
      const data = yield res.json();
      return { res, data };
    });
  }
  removePlugin(pluginName) {
    return __awaiter(this, void 0, void 0, function* () {
      const method = "DELETE";
      const headers = { accept: "application/json" };
      const url2 = `${this.listUrl}/plugins/${pluginName}`;
      const res = yield this.fetch(url2, { method, headers });
      const data = yield res.json();
      return { res, data };
    });
  }
  updateFiles(files) {
    return __awaiter(this, void 0, void 0, function* () {
      const url2 = `${this.listUrl}/files`;
      const method = "POST";
      const body = new FormData$1();
      files.forEach((file2) => {
        const bufferOrStream = file2.contents instanceof ArrayBuffer ? Buffer.from(file2.contents) : file2.contents;
        body.append(file2.path, bufferOrStream);
      });
      const headers = {
        accept: "application/json"
      };
      const res = yield this.fetch(url2, { method, body, headers });
      const data = yield res.json();
      return { res, data };
    });
  }
  downloadArchive(binaryId) {
    return __awaiter(this, void 0, void 0, function* () {
      const url2 = `${this.listUrl}/${binaryId}`;
      return yield this.fetch(url2);
    });
  }
  createBinaryRequestBody(binary, fileName, uploadParamsOverride) {
    const body = new FormData$1();
    const bufferOrStream = binary instanceof ArrayBuffer ? Buffer.from(binary) : binary;
    let uploadFileName = fileName;
    if (typeof File !== "undefined" && binary instanceof File) {
      uploadFileName = binary.name;
    }
    body.append((uploadParamsOverride === null || uploadParamsOverride === void 0 ? void 0 : uploadParamsOverride.bodyFileProperty) || "file", bufferOrStream, uploadFileName);
    body.append("fileName", uploadFileName);
    if (uploadParamsOverride === null || uploadParamsOverride === void 0 ? void 0 : uploadParamsOverride.requestBody) {
      for (const key in uploadParamsOverride.requestBody) {
        if (uploadParamsOverride.requestBody.hasOwnProperty(key)) {
          body.append(key, JSON.stringify(uploadParamsOverride.requestBody[key]));
        }
      }
    }
    return body;
  }
}
var ApplicationType;
(function(ApplicationType2) {
  ApplicationType2["EXTERNAL"] = "EXTERNAL";
  ApplicationType2["HOSTED"] = "HOSTED";
  ApplicationType2["MICROSERVICE"] = "MICROSERVICE";
  ApplicationType2["FEATURE"] = "FEATURE";
})(ApplicationType || (ApplicationType = {}));
class ApplicationService extends Service {
  constructor() {
    super(...arguments);
    this.baseUrl = "application";
    this.listUrl = "applications";
    this.propertyName = "applications";
    this.channel = "/applications/*";
  }
  /**
   * Creates a new application.
   *
   * @param {IIdentified} entity Application object.
   *
   * @returns Response wrapped in [[IResult]]
   *
   * **Example**
   * ```typescript
   *
   *  const newApp = {
   *    name: 'New application',
   *    type: 'EXTERNAL',
   *    key: 'new-app'
   *  };
   *
   *  (async () => {
   *    const {data, res} = await applicationService.create(newApp);
   *  })();
   * ```
   */
  create(entity) {
    const _super = Object.create(null, {
      create: { get: () => super.create }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.create.call(this, entity);
    });
  }
  /**
   * Clones a given application. The application name, key, and context-path will be
   * prefixed with `clone` and if necessary a number.
   * @param entity The application to clone.
   * @param version If a blueprint, you can define which version to clone. If not provided, it will always clone the latest version.
   * @returns The application entity.
   */
  clone(entity, version2) {
    return __awaiter(this, void 0, void 0, function* () {
      const url2 = `${this.getDetailUrl(entity)}/clone`;
      const method = "POST";
      const body = "";
      const headers = { "content-type": "application/json", accept: "application/json" };
      let params = void 0;
      if (version2) {
        params = { version: version2 };
      }
      const res = yield this.fetch(url2, { method, body, headers, params });
      const data = yield res.json();
      return { res, data };
    });
  }
  /**
   * Gets the list of existing applications filtered by parameters.
   *
   * @returns Response wrapped in [[IResultList]]
   *
   * @param {object} filter Object containing filters for querying applications.
   *
   * **Example**
   * ```typescript
   *
   *  const filter: object = {
   *     pageSize: 100,
   *     withTotalPages: true
   *   };
   *
   *   (async () => {
   *     const {data, res, paging} = await applicationService.list(filter);
   *   })();
   * ```
   */
  list(filter2 = {}) {
    const _super = Object.create(null, {
      list: { get: () => super.list }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.list.call(this, filter2);
    });
  }
  /**
   * Gets the list of all application versions.
   *
   * @param {string|number|IIdentified} entityOrId Entity or Id of the entity.
   *
   * @param {object} params Additional request parameters.
   *
   * @returns Returns list of all application versions.
   *
   * **Example**
   * ```typescript
   *
   *    const applicationId: number = 1;
   *
   *    (async () => {
   *      const {res, data} = await applicationService.listVersions(applicationId);
   *   })();
   * ```
   */
  listVersions(entityOrId, params = {}) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
      const id2 = this.getEntityId(entityOrId);
      const url2 = `${this.listUrl}/${id2}/versions`;
      const headers = { "content-type": "application/json" };
      try {
        const res = yield this.fetch(url2, { headers, params });
        const data = (_a = yield res.json()) === null || _a === void 0 ? void 0 : _a.applicationVersions;
        return { res, data };
      } catch (ex) {
        if (ex.res.status === 404) {
          const { data: appDetail, res } = yield this.detail(entityOrId);
          return { res, data: appDetail.applicationVersions };
        }
        throw ex;
      }
    });
  }
  /**
   * Gets the details of selected application.
   *
   * @param {string|number|IIdentified} entityOrId Entity or Id of the entity.
   *
   * @returns Response wrapped in [[IResult]]
   *
   * **Example**
   * ```typescript
   *
   *    const applicationId: number = 1;
   *
   *    (async () => {
   *      const {data, res} = await applicationService.detail(applicationId);
   *   })();
   * ```
   */
  detail(entityOrId) {
    const _super = Object.create(null, {
      detail: { get: () => super.detail }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.detail.call(this, entityOrId);
    });
  }
  /**
   * Updates existing application.
   * Make sure that you specifiy the application id within the update object.
   *
   * @param {IIdentified} entity Application object.
   *
   * @returns Response wrapped in [[IResult]]
   *
   * **Example**
   * ```typescript
   *
   *  const updateApp = {
   *    id: 38
   *    name: 'Updated application'
   *  };
   *
   *  (async () => {
   *    const {data, res} = await applicationService.update(updateApp);
   *  })();
   * ```
   */
  update(entity) {
    const _super = Object.create(null, {
      update: { get: () => super.update }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.update.call(this, entity);
    });
  }
  /**
   * Removes an application with given id.
   *
   * @returns Response wrapped in [[IResult]]
   *
   * @param {string | number | IIdentified} entityOrId entity or id of the application.
   *
   * **Example**
   * ```typescript
   *
   *  const removeApp: object = {
   *     id: 38
   *   };
   *
   *   (async () => {
   *     const {data, res} = await applicationService.delete(removeApp);
   *     // data will be null
   *   })();
   * ```
   */
  delete(entityOrId) {
    const _super = Object.create(null, {
      delete: { get: () => super.delete }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.delete.call(this, entityOrId);
    });
  }
  listByName(name2) {
    return __awaiter(this, void 0, void 0, function* () {
      const headers = { "content-type": "application/json" };
      const url2 = `applicationsByName/${encodeURIComponent(name2)}`;
      const res = yield this.fetch(url2, { headers });
      const json = yield res.json();
      const data = json[this.propertyName];
      return { res, data };
    });
  }
  listByTenant(tenantOrName, params = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      const headers = { "content-type": "application/json" };
      const tenantService = new TenantService(this.client);
      const tenantName = this.getIdString(tenantOrName || (yield tenantService.current()).data.name);
      const url2 = `applicationsByTenant/${encodeURIComponent(tenantName)}`;
      const res = yield this.fetch(url2, { headers, params });
      const json = yield res.json();
      const data = json[this.propertyName];
      return { res, data };
    });
  }
  listByOwner(tenantOrName, params = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      const headers = { "content-type": "application/json" };
      const tenantService = new TenantService(this.client);
      const tenantName = this.getIdString(tenantOrName || (yield tenantService.current()).data.name);
      const url2 = `applicationsByOwner/${encodeURIComponent(tenantName)}`;
      const res = yield this.fetch(url2, { headers, params });
      const json = yield res.json();
      const data = json[this.propertyName];
      return { res, data };
    });
  }
  listByUser(userOrId, params = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      const headers = { "content-type": "application/json" };
      const userService = new UserService(this.client);
      const userId = this.getIdString(userOrId || (yield userService.current()).data);
      const url2 = `applicationsByUser/${encodeURIComponent(userId)}`;
      const res = yield this.fetch(url2, { headers, params });
      const json = yield res.json();
      const data = json[this.propertyName];
      return { res, data };
    });
  }
  reactivateArchive(appId) {
    return __awaiter(this, void 0, void 0, function* () {
      const url2 = `${this.listUrl}/${appId}/refresh`;
      const method = "POST";
      const body = "";
      const headers = { "content-type": "application/json", accept: "application/json" };
      const res = yield this.fetch(url2, { method, body, headers });
      return { res, data: null };
    });
  }
  binary(application2) {
    return new ApplicationBinaryService(this.client, application2);
  }
  getHref(application2) {
    if (application2.type === ApplicationType.EXTERNAL) {
      return application2.externalUrl;
    }
    return `/apps/${application2.public ? "public/" : ""}${application2.contextPath}`;
  }
  /**
   * Checks if current user can access specified application.
   *
   * @returns Response wrapped in [[IResult]]
   *
   * @param {string | IApplication} application Application name or contextPath as a
   * string or Application object.
   *
   * **Example**
   * ```typescript
   *
   *  const checkApp: object = {
   *    name: 'myApplication'
   *  };
   *
   *  (async () => {
   *    const {data, res} = await applicationService.isAvailable(checkApp);
   *  })();
   * ```
   */
  isAvailable(application2) {
    return __awaiter(this, void 0, void 0, function* () {
      const { res, data } = yield this.listByUser(void 0, {
        dropOverwrittenApps: true,
        noPaging: true
      });
      const available = (data || []).some((availableApp) => typeof application2 === "string" ? availableApp.name === application2 || availableApp.contextPath === application2 : this.isMatch(availableApp, application2));
      return { data: available, res };
    });
  }
  /**
   * Gets instance details of the specified application (microservice).
   *
   * @param {string|number|IApplication} entityOrId Entity or Id of the application.
   *
   * @returns Response wrapped in [[IResultList]]
   *
   * **Example**
   * ```typescript
   *
   *    const applicationId: number = 1;
   *
   *    (async () => {
   *      const {data, res} = await applicationService.getStatusDetails(applicationId);
   *   })();
   * ```
   */
  getStatusDetails(entityOrId) {
    return __awaiter(this, void 0, void 0, function* () {
      const appId = this.getEntityId(entityOrId);
      const inventory = new InventoryService(this.client, this.realtime);
      return inventory.list({ type: `c8y_Application_${appId}` });
    });
  }
  /**
   * Extracts instance names of the provided IApplicationManagedObject.
   *
   * @param {IApplicationManagedObject} appStatusDetails Application details managedObject.
   *
   * @returns instance names
   *
   * **Example**
   * ```typescript
   *
   *    const applicationId: number = 1;
   *
   *    (async () => {
   *      const {data, res} = await applicationService.getStatusDetails(applicationId);
   *      const instances = data.map((appMO) => applicationService.getInstanceNames(appMO));
   *   })();
   * ```
   */
  getInstanceNames(appStatusDetails) {
    let instanceNames = new Array();
    if (appStatusDetails && appStatusDetails.c8y_Status && appStatusDetails.c8y_Status.instances) {
      instanceNames = Object.keys(appStatusDetails.c8y_Status.instances);
    }
    return instanceNames;
  }
  /**
   * Get log for a specific application instance.
   *
   * @param {string|number|IApplication} entityOrId Entity or Id of the application.
   *
   * @param {string} instanceName instance name of the application.
   *
   * @param {IApplicationInstanceLogRequestParams} params Object containing parameters for querying the log file.
   *
   * @returns Response wrapped in [[IResult]]
   *
   * **Example**
   * ```typescript
   *
   *    const applicationId: number = 1;
   *    const applicationInstanceName: string = 'apama-ctrl-1c-4g-scope-t123456789-deployment-abcdefghij-abcde';
   *
   *    (async () => {
   *      const {data, res} = await applicationService.getInstanceLog(applicationId, applicationInstanceName);
   *   })();
   * ```
   */
  getInstanceLog(entityOrId, instanceName, params) {
    return __awaiter(this, void 0, void 0, function* () {
      const url2 = `${this.getDetailUrl(entityOrId)}/logs/${instanceName}`;
      const headers = { accept: this.mimeType("applicationLogs") };
      const res = yield this.fetch(url2, { headers, params });
      const data = yield res.json();
      return { res, data };
    });
  }
  /**
   * Dynamic options are stored on the API in a specific `config: {}` object. They can
   * be used to configure the app dynamically.
   *
   * Note: To avoids conflicts with the default Config, it is recommended
   * to use a certain namespace.
   * @param entityOrId Entity or Id of the application.
   * @param config Configuration to be updated.
   * @returns Returns updated configuration.
   */
  updateApplicationConfig(entityOrId, config) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
      const id2 = this.getEntityId(entityOrId);
      const { data: app } = yield this.detail(id2);
      const currentConfig = (app === null || app === void 0 ? void 0 : app.config) || {};
      const newConfig = Object.assign(Object.assign({}, currentConfig), config);
      const updatedConfigApp = yield this.update({
        id: id2,
        config: newConfig
      });
      return (_a = yield updatedConfigApp) === null || _a === void 0 ? void 0 : _a.data;
    });
  }
  /**
   * Gets manifest (cumulocity.json file) of a given application.
   *
   * @param {IApplication} app Application entity.
   *
   * @param {string} app version
   *
   * @returns Application manifest object.
   */
  getAppManifest(app, version2) {
    return __awaiter(this, void 0, void 0, function* () {
      const date = /* @__PURE__ */ new Date();
      let result;
      if (!version2) {
        result = yield this.client.fetch(`/apps/${app.contextPath}/cumulocity.json?nocache=${date.getTime()}`);
      } else {
        result = yield this.client.fetch(`/apps/${app.contextPath}@${version2}/cumulocity.json?nocache=${date.getTime()}`);
      }
      if (result.status >= 400) {
        throw new Error(gettext("No Cumulocity IoT manifest found."));
      }
      const c8yJson = yield result.json();
      return c8yJson;
    });
  }
  /**
   * Updates manifest (cumulocity.json file) of a given application.
   *
   * @param {string|number|IApplication} entityOrId Entity or Id of the application.
   *
   * @param {any} manifestJSON Application manifest object to be stored.
   *
   * @returns Application manifest object.
   */
  storeAppManifest(entityOrId, manifestJSON) {
    return __awaiter(this, void 0, void 0, function* () {
      return yield this.binary(entityOrId).updateFiles([
        { path: "cumulocity.json", contents: JSON.stringify(manifestJSON) }
      ]);
    });
  }
  /**
   * Sets tags for specific application package version.
   *
   * @param {IApplication} app Application entity.
   *
   * @param {string} version Application package version which tags will be set.
   *
   * @param {string[]} tags Tags array to set on package version
   *
   * @returns Application version object.
   */
  setPackageVersionTag(app, version2, tags) {
    return __awaiter(this, void 0, void 0, function* () {
      const url2 = `${this.getDetailUrl(app)}/versions/${version2}`;
      const method = "PUT";
      const body = JSON.stringify({ tags });
      const headers = {
        accept: "application/vnd.com.nsn.cumulocity.applicationVersion+json;charset=UTF-8;ver=0.9",
        "content-type": "application/json"
      };
      const res = yield this.fetch(url2, { method, body, headers });
      const data = yield res.json();
      return { res, data };
    });
  }
  /**
   * Retrieves the manifest of the application behind the given context path.
   * @param contextPath
   */
  getManifestOfContextPath(contextPath) {
    return __awaiter(this, void 0, void 0, function* () {
      const url2 = `${this.getDetailUrl(contextPath)}/manifest`;
      const res = yield this.fetch(url2);
      const { application: application2 } = yield res.json();
      return {
        res,
        data: application2
      };
    });
  }
  /**
   * Removes package version.
   *
   * @param {IApplication} app Application entity.
   *
   * @param {IApplicationVersionDeleteParams} params Version or tag indication package to remove.
   *
   * @returns Request response.
   *
   * **Example**
   * ```typescript
   *
   *    const { res } = await applicationService.deleteVersionPackage(app, {version: '1.0.0'});
   *
   *    const { res } = await applicationService.deleteVersionPackage(app, {tag: 'next'});
   *
   * ```
   */
  deleteVersionPackage(app, params) {
    return __awaiter(this, void 0, void 0, function* () {
      const url2 = `${this.getDetailUrl(app)}/versions/`;
      const method = "DELETE";
      const res = yield this.fetch(url2, this.changeFetchOptions({ method, params }, url2));
      return { res, data: null };
    });
  }
  /**
   * Updates the availability of the given application to the provided value.
   *
   * @param {string|number|IApplication} entityOrId Entity or Id of the application.
   *
   * @param {any} availability The new application availability.
   *
   * @returns Updated application.
   */
  updateApplicationAvailability(entityOrId, availability2) {
    return __awaiter(this, void 0, void 0, function* () {
      const id2 = this.getEntityId(entityOrId);
      return yield this.update({
        id: id2,
        availability: availability2
      });
    });
  }
  isMatch(object, source2) {
    return Object.keys(source2).every((key) => {
      if (Array.isArray(object[key]) && Array.isArray(source2[key])) {
        return source2[key].every((el) => object[key].includes(el));
      } else if (typeof object[key] === "object" && object[key] !== null && typeof source2[key] === "object" && source2[key] !== null) {
        return this.isMatch(object[key], source2[key]);
      } else {
        return object[key] === source2[key];
      }
    });
  }
}
var InstanceStatus;
(function(InstanceStatus2) {
  InstanceStatus2["Up"] = "Up";
  InstanceStatus2["Unhealthy"] = "Unhealthy";
  InstanceStatus2["Down"] = "Down";
  InstanceStatus2["Unknown"] = "Unknown";
})(InstanceStatus || (InstanceStatus = {}));
var BillingMode;
(function(BillingMode2) {
  BillingMode2["SUBSCRIPTION"] = "SUBSCRIPTION";
  BillingMode2["RESOURCES"] = "RESOURCES";
})(BillingMode || (BillingMode = {}));
var Isolation;
(function(Isolation2) {
  Isolation2["PER_TENANT"] = "PER_TENANT";
  Isolation2["MULTI_TENANT"] = "MULTI_TENANT";
})(Isolation || (Isolation = {}));
var ApplicationAvailability;
(function(ApplicationAvailability2) {
  ApplicationAvailability2[ApplicationAvailability2["MARKET"] = gettext("MARKET")] = "MARKET";
  ApplicationAvailability2[ApplicationAvailability2["PRIVATE"] = gettext("PRIVATE")] = "PRIVATE";
  ApplicationAvailability2[ApplicationAvailability2["SHARED"] = gettext("SHARED")] = "SHARED";
})(ApplicationAvailability || (ApplicationAvailability = {}));
class SystemOptionsService extends Service {
  constructor() {
    super(...arguments);
    this.baseUrl = "tenant/system";
    this.listUrl = "options";
    this.propertyName = "options";
  }
  /**
   * Gets the details of given system option.
   *
   * @param {string|number|IIdentified} option System option object with mandantory fragments.
   *
   * @returns Response wrapped in [[IResult]]
   *
   * **Example**
   * ```typescript
   *
   *    const option: ISystemOption = {
   *      category: 'alarm.type.mapping',
   *      key: 'temp_to_high'
   *    };
   *
   *    (async () => {
   *      const {data, res} = await systemOptionsService.detail(option);
   *   })();
   * ```
   */
  detail(option) {
    const _super = Object.create(null, {
      detail: { get: () => super.detail }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.detail.call(this, option);
    });
  }
  /**
   * Gets the list of system options filtered by parameters.
   *
   * @returns Response wrapped in [[IResultList]]
   *
   * @param {object} filter Object containing filters for querying system options.
   *
   * **Example**
   * ```typescript
   *
   *  const filter: object = {
   *     pageSize: 100,
   *     withTotalPages: true
   *   };
   *
   *   (async () => {
   *     const {data, res, paging} = await systemOptionsService.list(filter);
   *   })();
   * ```
   */
  list(filter2 = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      const headers = { "content-type": "application/json" };
      const url2 = this.listUrl;
      const res = yield this.fetch(url2, { headers, params: filter2 });
      const json = yield res.json();
      const data = json[this.propertyName];
      return { res, data };
    });
  }
  getDetailUrl(option) {
    return `${this.listUrl}/${option.category}/${option.key}`;
  }
  onBeforeCreate(obj) {
    return obj;
  }
}
class TenantOptionsService extends Service {
  constructor() {
    super(...arguments);
    this.baseUrl = "tenant";
    this.listUrl = "options";
    this.propertyName = "options";
    this.securityOptionsCategories = ["password"];
    this.securityOptionsListUrl = "security-options";
    this.systemOptions = "system";
  }
  /**
   * Get a representation of a tenant's option.
   *
   * @param entity Tenant option object.
   * @param params Additional query parameters.
   *
   * @returns Returns promise object that is resolved with
   * the ITenantOption wrapped by IResult.
   *
   * **Example**
   * ```typescript
   * const option: ITenantOption = {
   *   category: 'access.control',
   *   key: 'allow.origin'
   * };
   * const params: ITenantOptionDetailParams = {
   *   evaluate: 'inherited'
   * };
   * (async () => {
   *   const { data, res } = await tenantService.detail(option);
   *   console.log('value inherited from parent tenant:', data.value);
   * })();
   * ```
   *
   * Required role: ROLE_OPTION_MANAGEMENT_READ
   */
  detail(entity, params = {}) {
    const _super = Object.create(null, {
      detail: { get: () => super.detail }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.detail.call(this, entity, params);
    });
  }
  /**
   * Creates a new tenant's option.
   *
   * @param {ITenantOption} entity Tenant's Option object.
   *
   * @returns {IResult<IIdentified>} Returns promise object that is resolved with
   * the details of newly created tenant option.
   *
   * **Example**
   * ```typescript
   *
   *  const tenantObject = {
   *    id: "sample_tenant",
   *    company: "sample_company",
   *    domain: "sample_domain.com",
   *    contactName: "Mr. Doe",
   *    ...
   *  };
   *
   *  (async () => {
   *    const {data, res} = await tenantService.create(tenantObject);
   *  })();
   * ```
   *
   * Required role: ROLE_OPTION_MANAGEMENT_ADMIN<br><br>
   * Options are category-key-value tuples, storing tenant configuration.Some categories of options
   * allow creation of new one, other are limited to predefined set of keys.<br><br>
   * Any option of any tenant can be defined as "non-editable" by "management" tenant. Afterwards, any PUT or DELETE
   * requests made on that option by the owner tenant, will result in 403 error (Unauthorized).
   */
  create(entity) {
    const _super = Object.create(null, {
      create: { get: () => super.create }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.create.call(this, entity);
    });
  }
  /**
   * Updates tenant's option data.
   *
   * @param {ITenantOption} entity Tenant option is partially updatable.
   *
   * @returns {IResult<ITenantOption>} Returns promise object that is resolved with the saved tenant option object.
   *
   * **Example**
   * ```typescript
   *
   *  const partialUpdateObject: IIdentified = {
   *     value : "http://developer.cumulocity.com"
   *     ...
   *   }
   *
   *  (async () => {
   *    const {data, res} = await tenantOptionsService.update(partialUpdateObject);
   *  })();
   * ```
   *
   * Required role: ROLE_OPTION_MANAGEMENT_ADMIN
   */
  update(entity) {
    const _super = Object.create(null, {
      update: { get: () => super.update }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.update.call(this, entity);
    });
  }
  /**
   * Gets the list of tenant's options filtered by parameters.
   *
   * @param {object} filter Object containing filters for querying tenant options.
   *
   * @returns {IResultList<ITenantOption>} Returns promise object that is resolved
   * with the ITenantOption wrapped by IResultList.
   *
   * **Example**
   * ```typescript
   *
   *  const filter: object = {
   *     severity: Severity.MAJOR,
   *     pageSize: 100,
   *     withTotalPages: true
   *   };
   *
   *   (async () => {
   *     const {data, res, paging} = await tenantOptionsService.list(filter);
   *   })();
   * ```
   *
   * Required role: ROLE_OPTION_MANAGEMENT_READ
   */
  list(filter2 = {}) {
    const _super = Object.create(null, {
      list: { get: () => super.list }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.list.call(this, filter2);
    });
  }
  /**
   * Delete a representation of a tenant's option.
   *
   * @param {string|number|IIdentified} entityOrId Tenant's option id or tenant's option object.
   *
   * @returns Returns promise object that is resolved with the IResult.
   *
   * **Example**
   * ```typescript
   *
   *    const tenantOptionId: string = "uniqueTenantId";
   *
   *    (async () => {
   *      const {data, res} = await tenantOptionsService.delete(tenantOptionId);
   *   })();
   * ```
   *
   * Required role: ROLE_TENANT_MANAGEMENT_ADMIN
   */
  delete(entityOrId) {
    const _super = Object.create(null, {
      delete: { get: () => super.delete }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.delete.call(this, entityOrId);
    });
  }
  getDetailUrl(entity) {
    const encodedCategory = encodeURIComponent(entity.category);
    const encodedKey = encodeURIComponent(entity.key);
    if (this.securityOptionsCategories.indexOf(entity.category) > -1) {
      return `${this.securityOptionsListUrl}/${encodedCategory}/${encodedKey}`;
    } else {
      return `${this.listUrl}/${encodedCategory}/${encodedKey}`;
    }
  }
  onBeforeCreate(obj) {
    return obj;
  }
}
class TenantSecurityOptionsService extends Service {
  constructor() {
    super(...arguments);
    this.baseUrl = "tenant";
    this.listUrl = "security-options";
    this.category = "password";
    this.propertyName = "options";
  }
  /**
   * Get a specific tenant's security option.
   *
   * @param {ITenantSecurityOption} Tenant's security option object with key value.
   *
   * @returns Returns promise object that is resolved with the ITenantSecurityOption wrapped by IResult.
   *
   * **Example**
   * ```typescript
   *
   *     const option: ITenantSecurityOption = {
   *        key: 'limit.validity'
   *      };
   *
   *    (async () => {
   *      const {data, res} = await tenantSecurityOptionsService.detail(option);
   *   })();
   * ```
   */
  detail(tenantSecurityOption) {
    const _super = Object.create(null, {
      detail: { get: () => super.detail }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.detail.call(this, tenantSecurityOption);
    });
  }
  getDetailUrl(tenantSecurityOption) {
    return `${this.listUrl}/${this.category}/${tenantSecurityOption.key}`;
  }
  onBeforeCreate(obj) {
    return obj;
  }
}
class TenantLoginOptionsService extends Service {
  constructor() {
    super(...arguments);
    this.baseUrl = "tenant";
    this.listUrl = "loginOptions";
    this.propertyName = "loginOptions";
  }
  /**
   * Gets the details of login option.
   *
   * @param entityIdentityOrId Login option's id or login option object.
   *
   * @returns Returns promise object that is resolved with the ITenantLoginOption wrapped by IResult.
   *
   * **Example**
   * ```typescript
   *
   *    const tenantLoginOptionId: string = 'uniqueTenantLoginOptionId';
   *
   *    (async () => {
   *      const {data, res} = await tenantLoginOptionsService.detail(tenantLoginOptionId);
   *   })();
   * ```
   */
  detail(entityIdentityOrId) {
    const _super = Object.create(null, {
      detail: { get: () => super.detail }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.detail.call(this, entityIdentityOrId);
    });
  }
  /**
   * Gets the list of tenant's login options filtered by parameters.
   *
   * @param filter Object containing filters for querying tenant's login options.
   *
   * @returns Returns promise object that is resolved with the ITenantLoginOption wrapped by IResultList.
   *
   * **Example**
   * ```typescript
   *
   *  const filter: object = {
   *     tenantId: '1111111'
   *   };
   *
   *   (async () => {
   *     const {data, res, paging} = await tenantLoginOptionsService.list(filter);
   *   })();
   * ```
   */
  list(filter2 = {}) {
    const _super = Object.create(null, {
      list: { get: () => super.list }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.list.call(this, filter2);
    });
  }
  /**
   * Gets the list of all tenant's login options for current tenant.
   *
   * @returns Returns promise object that is resolved with the ITenantLoginOption wrapped by IResultList.
   *
   * **Example**
   * ```typescript
   *
   *   (async () => {
   *     const {data, res, paging} = await tenantLoginOptionsService.listForCurrentTenant();
   *   })();
   * ```
   */
  listForCurrentTenant() {
    const _super = Object.create(null, {
      list: { get: () => super.list }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.list.call(this, { tenantId: this.client.tenant });
    });
  }
  /**
   * Gets the list of all tenant's login options for management tenant.
   *
   * @returns Returns promise object that is resolved with the ITenantLoginOption wrapped by IResultList.
   *
   * **Example**
   * ```typescript
   *
   *   (async () => {
   *     const {data, res, paging} = await tenantLoginOptionsService.listForManagement();
   *   })();
   * ```
   */
  listForManagement() {
    const _super = Object.create(null, {
      list: { get: () => super.list }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.list.call(this, { management: true });
    });
  }
  /**
   * Creates a new tenant login option.
   *
   * @param entity ITenantLoginOption object.
   *
   * @returns Returns promise object that is resolved with the details of newly created tenant login option.
   *
   * **Example**
   * ```typescript
   *
   *  const tenantLoginOption: ITenantLoginOption = {
   *    grantType: "PASSWORD",
   *    providerName: "Cumulocity",
   *    type: "BASIC",
   *    userManagementSource: "INTERNAL",
   *    visibleOnLoginPage: true
   *  };
   *
   *  (async () => {
   *    const {data, res} = await tenantLoginOptionsService.create(tenantLoginOption);
   *  })();
   * ```
   */
  create(entity) {
    const _super = Object.create(null, {
      create: { get: () => super.create }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.create.call(this, entity);
    });
  }
  /**
   * Updates tenant's login option data.
   *
   * @param entity ITenantLoginOption object.
   *
   * @returns Returns promise object that is resolved with the saved tenant's login option object.
   *
   * **Example**
   * ```typescript
   *
   *  const tenantLoginOption: ITenantLoginOption = {
   *    grantType: "PASSWORD",
   *    id: "2eff9a0b-e376-4ce8-a0f1-0a07cef8a8a1",
   *    providerName: "Cumulocity",
   *    type: "BASIC",
   *    userManagementSource: "INTERNAL",
   *    visibleOnLoginPage: true
   *  };
   *
   *  (async () => {
   *    const {data, res} = await tenantLoginOptionsService.update(tenantLoginOption);
   *  })();
   * ```
   */
  update(entity) {
    const _super = Object.create(null, {
      update: { get: () => super.update }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.update.call(this, entity);
    });
  }
  /**
   * Update tenant's login option data if id exists in object, otherwise create new entity.
   *
   * @param entity ITenantLoginOption object.
   *
   * @returns Returns promise object that is resolved with the saved tenant's login option object.
   *
   * **Example**
   * ```typescript
   *
   *  const tenantLoginOption: ITenantLoginOption = {
   *    grantType: "PASSWORD",
   *    id: "2eff9a0b-e376-4ce8-a0f1-0a07cef8a8a1",
   *    providerName: "Cumulocity",
   *    type: "BASIC",
   *    userManagementSource: "INTERNAL",
   *    visibleOnLoginPage: true
   *  };
   *
   *  (async () => {
   *    const {data, res} = await tenantLoginOptionsService.save(tenantLoginOption);
   *  })();
   * ```
   */
  save(entity) {
    return __awaiter(this, void 0, void 0, function* () {
      return entity.id ? this.update(entity) : this.create(entity);
    });
  }
  /**
   * Removes tenant's login option.
   *
   * @param entityOrId Tenant's login option's id or tenant's login option object.
   *
   * @returns Returns promise object that is resolved with the IResult of null.
   *
   * **Example**
   * ```typescript
   *
   *    const tenantLoginOptionId: string = 'uniqueTenantLoginOptionId';
   *
   *    (async () => {
   *      const {data, res} = await tenantLoginOptionsService.delete(tenantLoginOptionId);
   *   })();
   * ```
   */
  delete(entityOrId) {
    const _super = Object.create(null, {
      delete: { get: () => super.delete }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.delete.call(this, entityOrId);
    });
  }
}
var TenantLoginOptionType;
(function(TenantLoginOptionType2) {
  TenantLoginOptionType2["OAUTH2_INTERNAL"] = "OAUTH2_INTERNAL";
  TenantLoginOptionType2["OAUTH2"] = "OAUTH2";
  TenantLoginOptionType2["BASIC"] = "BASIC";
})(TenantLoginOptionType || (TenantLoginOptionType = {}));
var GrantType;
(function(GrantType2) {
  GrantType2["AUTHORIZATION_CODE"] = "AUTHORIZATION_CODE";
  GrantType2["PASSWORD"] = "PASSWORD";
})(GrantType || (GrantType = {}));
var UserManagementSource;
(function(UserManagementSource2) {
  UserManagementSource2["REMOTE"] = "REMOTE";
  UserManagementSource2["INTERNAL"] = "INTERNAL";
})(UserManagementSource || (UserManagementSource = {}));
class AuditService extends Service {
  constructor() {
    super(...arguments);
    this.baseUrl = "audit";
    this.listUrl = "auditRecords";
    this.propertyName = "auditRecords";
  }
  /**
   * Gets the details of selected audit record.
   *
   * @param {string|number|IAuditRecord} entityOrId Entity or Id of the entity.
   *
   * @returns Response wrapped in [[IResult]]
   *
   * **Example**
   * ```typescript
   *
   *    const auditId: number = 1;
   *
   *    (async () => {
   *      const {data, res} = await auditService.detail(auditId);
   *   })();
   * ```
   */
  detail(entityOrId) {
    const _super = Object.create(null, {
      detail: { get: () => super.detail }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.detail.call(this, entityOrId);
    });
  }
  /**
   * Creates a new audit record for a given source.
   *
   * @param {IAuditRecord} entity Audit record object with mandantory fragments.
   * IAuditRecord implements the [[IEvent]] interface.
   *
   * @returns Response wrapped in [[IResult]]
   *
   * **Example**
   * ```typescript
   *
   *  const mandantoryObject: IAuditRecord = {
   *    type: AuditRecordType.ALARM,
   *    time: '2018-05-02T10:08:00Z',
   *    severity: Severity.MAJOR,
   *    source: {id: 1}
   *  };
   *
   *  (async () => {
   *    const {data, res} = await auditService.create(mandantoryObject);
   *  })();
   * ```
   */
  create(entity) {
    const _super = Object.create(null, {
      create: { get: () => super.create }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.create.call(this, entity);
    });
  }
  /**
   * Gets the list of audit records filtered by parameters.
   *
   * @returns Response wrapped in [[IResultList]]
   *
   * @param {object} filter Object containing filters for querying audit records.
   *
   * **Example**
   * ```typescript
   *
   *  const filter: object = {
   *     severity: Severity.MAJOR,
   *     pageSize: 100,
   *     withTotalPages: true
   *   };
   *
   *   (async () => {
   *     const {data, res, paging} = await auditService.list(filter);
   *   })();
   * ```
   */
  list(filter2 = {}) {
    const _super = Object.create(null, {
      list: { get: () => super.list }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.list.call(this, filter2);
    });
  }
}
var AuditRecordType;
(function(AuditRecordType2) {
  AuditRecordType2["ALARM"] = "Alarm";
  AuditRecordType2["BULK_OPERATION"] = "BulkOperation";
  AuditRecordType2["CEP_MODULE"] = "CepModule";
  AuditRecordType2["EVENT"] = "Event";
  AuditRecordType2["INVENTORY"] = "Inventory";
  AuditRecordType2["INVENTORY_ROLE"] = "InventoryRole";
  AuditRecordType2["OPERATION"] = "Operation";
  AuditRecordType2["OPTION"] = "Option";
  AuditRecordType2["GROUP"] = "Group";
  AuditRecordType2["SMART_RULE"] = "SmartRule";
  AuditRecordType2["SYSTEM"] = "SYSTEM";
  AuditRecordType2["TENANT"] = "Tenant";
  AuditRecordType2["USER"] = "User";
})(AuditRecordType || (AuditRecordType = {}));
var ChangeType;
(function(ChangeType2) {
  ChangeType2[ChangeType2["ADDED"] = gettext("ADDED")] = "ADDED";
  ChangeType2[ChangeType2["REPLACED"] = gettext("REPLACED")] = "REPLACED";
  ChangeType2[ChangeType2["REMOVED"] = gettext("REMOVED")] = "REMOVED";
})(ChangeType || (ChangeType = {}));
class InventoryRoleService extends Service {
  constructor() {
    super(...arguments);
    this.baseUrl = "user";
    this.listUrl = "inventoryroles";
    this.propertyName = "roles";
  }
  /**
   * Gets the details of inventory role.
   *
   * @param {string|number|IIdentified} entityOrId Entity or Id of the entity.
   *
   * @returns Response wrapped in [[IResult]]
   *
   * **Example**
   * ```typescript
   *
   *    const inventoryRoleId: number = 1;
   *
   *    (async () => {
   *      const {data, res} = await inventoryRoleService.detail(inventoryRoleId);
   *   })();
   * ```
   */
  detail(entityOrId) {
    const _super = Object.create(null, {
      detail: { get: () => super.detail }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.detail.call(this, entityOrId);
    });
  }
  /**
   * Creates a new inventory role.
   *
   * @param {IIdentified} entity
   *
   * @returns Response wrapped in [[IResult]]
   *
   * **Example**
   * ```typescript
   *
   *  const newRole: IIdentified = {
   *    name: 'Custom role'
   *  };
   *
   *  (async () => {
   *    const {data, res} = await inventoryRoleService.create(newRole);
   *  })();
   * ```
   */
  create(entity) {
    const _super = Object.create(null, {
      create: { get: () => super.create }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.create.call(this, entity);
    });
  }
  /**
   * Updates inventory role data.
   *
   * @param {IIdentified} entity
   *
   * @returns Response wrapped in [[IResult]]
   *
   * **Example**
   * ```typescript
   *
   *  const updateObject: IIdentified = {
   *    id: 1,
   *    name: 'changed role'
   *  };
   *
   *  (async () => {
   *    const {data, res} = await inventoryRoleService.update(updateObject);
   *  })();
   * ```
   */
  update(entity) {
    const _super = Object.create(null, {
      update: { get: () => super.update }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.update.call(this, entity);
    });
  }
  /**
   * Gets the list of inventory roles filtered by parameters.
   *
   * @returns Response wrapped in [[IResultList]]
   *
   * @param {object} filter Object containing filters for querying alarms.
   *
   * **Example**
   * ```typescript
   *
   *  const filter: object = {
   *     pageSize: 100,
   *     withTotalPages: true
   *   };
   *
   *   (async () => {
   *     const {data, res, paging} = await inventoryRoleService.list(filter);
   *   })();
   * ```
   */
  list(filter2 = {}) {
    const _super = Object.create(null, {
      list: { get: () => super.list }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.list.call(this, filter2);
    });
  }
  /**
   * Removes an inventory role with given id.
   *
   * @returns Response wrapped in [[IResult]]
   *
   * @param {IExternalIdentity} identity Identity object with mandantory fragments.
   *
   * **Example**
   * ```typescript
   *
   *   const id: number = 1;
   *
   *    (async () => {
   *      const {data, res} = await identityService.delete(id);
   *   })();
   * ```
   */
  delete(entityOrId) {
    const _super = Object.create(null, {
      delete: { get: () => super.delete }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.delete.call(this, entityOrId);
    });
  }
}
var DeviceRegistrationStatus;
(function(DeviceRegistrationStatus2) {
  DeviceRegistrationStatus2[DeviceRegistrationStatus2["WAITING_FOR_CONNECTION"] = gettext("WAITING_FOR_CONNECTION")] = "WAITING_FOR_CONNECTION";
  DeviceRegistrationStatus2[DeviceRegistrationStatus2["PENDING_ACCEPTANCE"] = gettext("PENDING_ACCEPTANCE")] = "PENDING_ACCEPTANCE";
  DeviceRegistrationStatus2[DeviceRegistrationStatus2["ACCEPTED"] = gettext("ACCEPTED")] = "ACCEPTED";
  DeviceRegistrationStatus2[DeviceRegistrationStatus2["BLOCKED"] = gettext("BLOCKED")] = "BLOCKED";
})(DeviceRegistrationStatus || (DeviceRegistrationStatus = {}));
class DeviceRegistrationService extends Service {
  constructor() {
    super(...arguments);
    this.baseUrl = "devicecontrol";
    this.listUrl = "newDeviceRequests";
    this.propertyName = "newDeviceRequests";
  }
  /**
   * Gets the details of device registration.
   *
   * @param {string|number|IIdentified} entityOrId Entity or Id of the entity.
   *
   * @returns Response wrapped in [[IResult]]
   *
   * **Example**
   * ```typescript
   *
   *    const entityId: number = 1;
   *
   *    (async () => {
   *      const {data, res} = await deviceRegistrationService.detail(entityId);
   *    })();
   * ```
   */
  detail(entityOrId) {
    const _super = Object.create(null, {
      detail: { get: () => super.detail }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.detail.call(this, entityOrId);
    });
  }
  /**
   * Creates a new device registration.
   *
   * @param {IDeviceRegistrationCreate} entity Device registration object with mandantory fragments.
   *
   * @returns Response wrapped in [[IResult]]
   *
   * **Example**
   * ```typescript
   *
   *    const mandantoryObject: IDeviceRegistrationCreate = {
   *      id: 1,
   *    };
   *
   *    (async () => {
   *      const {data, res} = await deviceRegistrationService.create(mandantoryObject);
   *    })();
   * ```
   */
  create(entity) {
    const _super = Object.create(null, {
      create: { get: () => super.create }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.create.call(this, entity);
    });
  }
  /**
   * Gets the list of device registrations by parameters.
   *
   * @returns Response wrapped in [[IResultList]]
   *
   * @param {object} filter Object containing filters for querying registrations.
   *
   * **Example**
   * ```typescript
   *
   *   const filter: object = {
   *     pageSize: 100,
   *     withTotalPages: true
   *   };
   *
   *   (async () => {
   *     const {data, res, paging} = await deviceRegistrationService.list(filter);
   *   })();
   * ```
   */
  list(filter2 = {}) {
    const _super = Object.create(null, {
      list: { get: () => super.list }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.list.call(this, filter2);
    });
  }
  /**
   * Removes an registration with given id.
   *
   * @returns Response wrapped in [[IResult]]
   *
   * @param {string | number | IIdentified} entityOrId entity or id of the registration.
   *
   * **Example**
   * ```typescript
   *
   *   const id = 'abc';
   *
   *   (async () => {
   *     const {data, res} = await deviceRegistrationService.delete(id);
   *     // data will be null
   *   })();
   * ```
   */
  delete(entityOrId) {
    const _super = Object.create(null, {
      delete: { get: () => super.delete }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.delete.call(this, entityOrId);
    });
  }
  /**
   * Accepts the device registration for given id.
   *
   * @returns Response wrapped in [[IResult]]
   *
   * @param {string | number | IIdentified} entityOrId entity or id of registration.
   *
   * **Example**
   * ```typescript
   *
   *   const id = 'abc';
   *
   *   (async () => {
   *     const {data, res} = await deviceRegistrationService.accept(id);
   *   })();
   * ```
   */
  accept(entityOrId) {
    const _super = Object.create(null, {
      update: { get: () => super.update }
    });
    return __awaiter(this, void 0, void 0, function* () {
      const securityToken = this.getSecurityToken(entityOrId);
      let payload = {
        id: this.getIdString(entityOrId),
        status: DeviceRegistrationStatus.ACCEPTED
      };
      if (securityToken) {
        payload = Object.assign(Object.assign({}, payload), { securityToken });
      }
      return _super.update.call(this, payload);
    });
  }
  /**
   * Accepts the device registration for all registrations in pending acceptance.
   *
   * @returns Response wrapped in [[IResultList]]
   *
   * **Example**
   * ```typescript
   *
   *   (async () => {
   *     const {data, res} = await deviceRegistrationService.acceptAll();
   *   })();
   * ```
   */
  acceptAll() {
    const _super = Object.create(null, {
      fetch: { get: () => super.fetch }
    });
    return __awaiter(this, void 0, void 0, function* () {
      const res = yield _super.fetch.call(this, `${this.listUrl}/acceptAll`, { method: "POST" });
      const data = yield res.json();
      return { res, data };
    });
  }
  /**
   * Gets limitation information for registering devices to the platform
   *
   * @returns Response wrapped in [[IResult]]
   *
   * **Example**
   * ```typescript
   *
   *   (async () => {
   *     const {data, res} = await deviceRegistrationService.limit();
   *   })();
   * ```
   */
  limit() {
    const _super = Object.create(null, {
      fetch: { get: () => super.fetch }
    });
    return __awaiter(this, void 0, void 0, function* () {
      const res = yield _super.fetch.call(this, `${this.listUrl}/limit`);
      const data = yield res.json();
      return { res, data };
    });
  }
  /**
   * Bootstraps the device with given id.
   *
   * @param entityOrId entity or id of registration.
   * @param options for details see [[IDeviceBootstrapOptions]]
   *
   * **Example**
   * ```typescript
   *
   *   const id: 'abc';
   *   const options: IDeviceBootstrapOptions = {
   *     basicAuthToken: 'Basic dGVuYW50L3VzZXJuYW1lOnBhc3N3b3Jk',
   *     basicAuth: {
   *       user: 'username',
   *       pass: 'password'
   *     }
   *   };
   *
   *   (async () => {
   *     const {data, res} = await deviceRegistrationService.bootstrap(id, options);
   *   })();
   * ```
   */
  bootstrap(entityOrId, options) {
    return __awaiter(this, void 0, void 0, function* () {
      const id2 = this.getIdString(entityOrId);
      const securityToken = this.getSecurityToken(entityOrId);
      const body = securityToken ? JSON.stringify({ id: id2, securityToken }) : JSON.stringify({ id: id2 });
      const url2 = `${this.baseUrl}/deviceCredentials`;
      const { basicAuth } = options;
      let { basicAuthToken } = options;
      if (basicAuth) {
        const { user, pass } = basicAuth;
        basicAuthToken = btoa$1(`${user}:${pass}`);
      }
      const headers = {
        Authorization: `Basic ${basicAuthToken}`,
        accept: "application/json",
        "content-type": "application/json"
      };
      const method = "POST";
      const res = yield this.client.fetch(url2, { body, headers, method });
      const data = yield res.json();
      if (res.status > 400) {
        throw { res, data };
      }
      return { res, data };
    });
  }
  onBeforeCreate(entity) {
    return entity;
  }
  onBeforeUpdate(entity) {
    const noIdEntity = Object.assign({}, entity);
    delete noIdEntity.id;
    return noIdEntity;
  }
  getDetailUrl(entityOrId) {
    const id2 = encodeURIComponent(this.getEntityId(entityOrId));
    return `${this.listUrl}/${id2}`;
  }
  getSecurityToken(entity) {
    let securityToken;
    if (typeof entity === "object") {
      securityToken = entity.securityToken ? String(entity.securityToken) : void 0;
    }
    return securityToken;
  }
}
class DeviceRegistrationBulkService {
  /**
   * Instantiate class and assign client
   * @param {IFetchClient} client
   */
  constructor(client) {
    this.client = client;
  }
  /**
   * A new device registration as bulk.
   *
   * @param {Stream | Buffer} csv
   *
   * @returns Response wrapped in [[IResult]]
   *
   * **Example**
   * ```typescript
   *
   *  const csvString = `
   *  ID,CREDENTIALS,TENANT,TYPE,NAME,ICCID,IDTYPE,PATH,SHELL
   *  e2eDeviceRegistrationId,e2epassword123!,e2edocker,c8y_e2eDevice,e2eDevice,123456789,89456,e2eDeviceGroup,1
   *  900001,e2epassword123!,e2edocker,c8y_e2eDevice1,e2eDevice1,123456789,89456,e2eDeviceGroup,1
   *  900002,e2epassword123!,e2edocker,c8y_e2eDevice2,e2eDevice2,123456789,89456,e2eDeviceGroup,1`.trim();
   *
   *  const csvBuffer = Buffer.from(csvString):
   *
   *  (async () => {
   *    const {data, res} = await deviceRegistrationBulkService.create(csvBuffer);
   *  })();
   * ```
   */
  create(inputFile) {
    return __awaiter(this, void 0, void 0, function* () {
      let csv = inputFile;
      const url2 = "/devicecontrol/bulkNewDeviceRequests";
      const method = "POST";
      const body = new FormData$1();
      let fileName = "bulk-registration.csv";
      if (typeof File !== "undefined" && csv instanceof File) {
        fileName = csv.name;
        const checkPattern = /\.csv$/;
        if (csv.name.match(checkPattern)) {
          csv = new File([csv], csv.name, { type: "text/csv" });
        }
      }
      body.append("file", csv, fileName);
      const headers = {
        accept: "application/json"
      };
      const res = yield this.client.fetch(url2, { method, body, headers });
      const data = yield res.json();
      return { res, data };
    });
  }
}
var DeviceRegistrationSecurityMode;
(function(DeviceRegistrationSecurityMode2) {
  DeviceRegistrationSecurityMode2["REQUIRED"] = "REQUIRED";
  DeviceRegistrationSecurityMode2["OPTIONAL"] = "OPTIONAL";
  DeviceRegistrationSecurityMode2["IGNORED"] = "IGNORED";
})(DeviceRegistrationSecurityMode || (DeviceRegistrationSecurityMode = {}));
class UserRoleService extends Service {
  constructor() {
    super(...arguments);
    this.baseUrl = "user";
    this.listUrl = "roles";
    this.propertyName = "roles";
  }
  /**
   * Gets the details of given role.
   *
   * @param {string|number|IRole} entityOrId Roles's id or role object.
   *
   * @returns Returns promise object that is resolved with the IRole wrapped by IResult.
   *
   * **Example**
   * ```typescript
   *
   *    const roleId: number = 1;
   *
   *    (async () => {
   *      const {data, res} = await userRoleService.detail(roleId);
   *   })();
   * ```
   */
  detail(entityOrId) {
    const _super = Object.create(null, {
      detail: { get: () => super.detail }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.detail.call(this, entityOrId);
    });
  }
  /**
   * Gets the list of user roles filtered by parameters.
   *
   * @param {object} filter Object containing filters for querying roles.
   *
   * @returns Returns promise object that is resolved with the IRole wrapped by IResultList.
   *
   * **Example**
   * ```typescript
   *
   *  const filter: object = {
   *     severity: Severity.MAJOR,
   *     pageSize: 100,
   *     withTotalPages: true
   *   };
   *
   *   (async () => {
   *     const {data, res, paging} = await userRoleService.list(filter);
   *   })();
   * ```
   */
  list(filter2 = {}) {
    const _super = Object.create(null, {
      list: { get: () => super.list }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.list.call(this, filter2);
    });
  }
}
var ChildType;
(function(ChildType2) {
  ChildType2["ROLES"] = "roles";
  ChildType2["USERS"] = "users";
})(ChildType || (ChildType = {}));
class UserGroupService extends Service {
  constructor() {
    super(...arguments);
    this.baseUrl = "user";
    this.propertyName = "groups";
  }
  get listUrl() {
    return `${this.client.tenant}/groups`;
  }
  /**
   * Gets the details of given user group.
   *
   * @param {string|number|IUserGroup} entityOrId Group's id or role object.
   *
   * @returns Returns promise object that is resolved with the IUserGroup wrapped by IResult.
   *
   * **Example**
   * ```typescript
   *
   *    const groupId: number = 1;
   *
   *    (async () => {
   *      const {data, res} = await userGroupService.detail(roleId);
   *   })();
   * ```
   */
  detail(entityOrId) {
    const _super = Object.create(null, {
      detail: { get: () => super.detail }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.detail.call(this, entityOrId);
    });
  }
  /**
   * Creates a new user group.
   *
   * @param {IUserGroup} entity User Group object.
   *
   * @returns {IResult<IUserGroup>} Returns promise object that is resolved with
   * the details of newly created user group.
   *
   * **Example**
   * ```typescript
   *
   *  const userGroupObject: IUserGroup = {
   *    name: "new user group"
   *  };
   *
   *  (async () => {
   *    const {data, res} = await userGroupService.create(userGroupObject);
   *  })();
   * ```
   */
  create(entity) {
    const _super = Object.create(null, {
      create: { get: () => super.create }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.create.call(this, entity);
    });
  }
  /**
   * Updates user group data.
   *
   * @param {Partial<IUserGroup>} entity User group is partially updatable.
   *
   * @returns {IResult<IUserGroup>} Returns promise object that is resolved with the saved user group object.
   *
   * **Example**
   * ```typescript
   *
   *  const partialUpdateObject: Partial<IUserGroup> = {
   *     "id" : 1,
   *     "self" : "[URL to this resource]",
   *     "name" : "PlatformAdministrators",
   *     ...
   *   }
   *
   *  (async () => {
   *    const {data, res} = await userGroupService.update(partialUpdateObject);
   *  })();
   * ```
   */
  update(entity) {
    const _super = Object.create(null, {
      update: { get: () => super.update }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.update.call(this, entity);
    });
  }
  /**
   * Gets the list of user groups filtered by parameters.
   *
   * @param {object} filter Object containing filters for querying User Groups.
   *
   * @returns Returns promise object that is resolved with the IUserGroup wrapped by IResultList.
   *
   * **Example**
   * ```typescript
   *
   *  const filter: object = {
   *     severity: Severity.MAJOR,
   *     pageSize: 100,
   *     withTotalPages: true
   *   };
   *
   *   (async () => {
   *     const {data, res, paging} = await userGroupService.list(filter);
   *   })();
   * ```
   */
  list(filter2 = {}) {
    const _super = Object.create(null, {
      list: { get: () => super.list }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.list.call(this, filter2);
    });
  }
  /**
   * Removes user group.
   *
   * @param {number | IIdentified} entityOrId User group's id or user group object.
   *
   * @returns Returns promise object that is resolved with the IResult of null.
   *
   * **Example**
   * ```typescript
   *
   *    const userGroupId: number = 1;
   *
   *    (async () => {
   *      const {data, res} = await userGroupService.delete(userGroupId);
   *   })();
   * ```
   * When group is removed, suitable audit records are created with type 'User'
   * and activity 'User updated' with information that user has been removed from group.
   *
   * Please, note that the ADMINS and DEVICES groups can not be deleted.
   */
  delete(entityOrId) {
    const _super = Object.create(null, {
      delete: { get: () => super.delete }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.delete.call(this, entityOrId);
    });
  }
  /**
   * Assign role to user group.
   *
   * @param {string | number | Partial<IUserGroup>} entityOrId User group's id or user group object.
   * @param {string | Partial<ISource>} childEntityOrSelf Url to role resource or IRoleReference object.
   *
   * @returns Returns promise object that is resolved with the IRoleReference wrapped by IResult.
   *
   * **Example**
   * ```typescript
   *
   *    const userGroupId: number = 1;
   *    const roleResource: string = "[URL to the Role resource]";
   *
   *    (async () => {
   *      const {data, res} = await userGroupService.addRoleToGroup(userGroupId, roleResource);
   *   })();
   * ```
   * When role is assigned to user, suitable audit record is created with type 'User' and activity 'User updated'.
   */
  addRoleToGroup(entityOrId, childEntityOrSelf) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.addChild(ChildType.ROLES, entityOrId, childEntityOrSelf);
    });
  }
  /**
   * Unassign role from user
   *
   * @param {string | number | Partial<IUserGroup>} entityOrId User group's id or user group object.
   * @param {string | Partial<ISource>} childEntityOrSelf Url to user resource or IRoleReference object.
   *
   * @returns Returns promise object that is resolved with the IResult of null.
   *
   * **Example**
   * ```typescript
   *
   *    const userGroupId: number = 1;
   *    const userResource: string = "[URL to the Role resource]";
   *
   *    (async () => {
   *      const {data, res} = await userGroupService.removeRoleFromGroup(userGroupId, userResource);
   *   })();
   * ```
   */
  removeRoleFromGroup(entityOrId, childEntityOrSelf) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.removeChild(ChildType.ROLES, entityOrId, childEntityOrSelf);
    });
  }
  /**
   * Assign user to user group.
   *
   * @param {string | number | Partial<IUserGroup>} entityOrId User group's id or user group object.
   * @param {string | Partial<ISource>} childEntityOrSelf Url to user resource or IUserReference object.
   *
   * @returns Returns promise object that is resolved with the IUserReference wrapped by IResult.
   *
   * **Example**
   * ```typescript
   *
   *    const userGroupId: number = 1;
   *    const userResource: string = "[URL to the User resource]";
   *
   *    (async () => {
   *      const {data, res} = await userGroupService.addUserToGroup(userGroupId, userResource);
   *   })();
   * ```
   * When user is added to group, suitable audit record is created with type 'User' and activity 'User updated'.
   */
  addUserToGroup(entityOrId, childEntityOrSelf) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.addChild(ChildType.USERS, entityOrId, childEntityOrSelf);
    });
  }
  /**
   * Remove user from a group
   *
   * @param {string | number | Partial<IUserGroup>} entityOrId User group's id or user group object.
   * @param {string | Partial<ISource>} childEntityOrSelf Url to user resource or IUserReference object.
   *
   * @returns Returns promise object that is resolved with the IResult of null.
   *
   * **Example**
   * ```typescript
   *
   *    const userGroupId: number = 1;
   *    const userResource: string = "[URL to the User resource]";
   *
   *    (async () => {
   *      const {data, res} = await userGroupService.removeUserFromGroup(userGroupId, userResource);
   *   })();
   * ```
   * When user is removed from group, suitable audit record is created with type 'User' and activity 'User updated'.
   */
  removeUserFromGroup(entityOrId, childEntityOrSelf) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.removeChild(ChildType.USERS, entityOrId, childEntityOrSelf);
    });
  }
  getSelf(childReference) {
    if (typeof childReference === "object" && childReference.self) {
      return childReference.self;
    } else {
      return childReference;
    }
  }
  getChildUrl(type2, userGroupOrId) {
    return `${this.getDetailUrl(userGroupOrId)}/${type2}`;
  }
  getChildReferenceAsBody(type2, childReference) {
    const childSelf = this.getSelf(childReference);
    switch (type2) {
      case ChildType.ROLES:
        return JSON.stringify({ role: { self: String(childSelf) } });
      case ChildType.USERS:
        return JSON.stringify({ user: { self: String(childSelf) } });
    }
    throw new Error("UserGroupService -> getChild -> unsupported child type");
  }
  addChild(type2, userGroupOrId, childReference) {
    return __awaiter(this, void 0, void 0, function* () {
      const url2 = this.getChildUrl(type2, userGroupOrId);
      const method = "POST";
      const body = this.getChildReferenceAsBody(type2, childReference);
      const headers = {
        accept: "application/json",
        "content-type": "application/json"
      };
      const res = yield this.fetch(url2, { method, body, headers });
      let data = yield res.json();
      data = data.managedObject;
      return { res, data };
    });
  }
  removeChild(type2, userGroupOrId, childReference) {
    return __awaiter(this, void 0, void 0, function* () {
      const childId = this.getIdString(childReference);
      const url2 = `${this.getChildUrl(type2, userGroupOrId)}/${encodeURIComponent(String(childId))}`;
      const method = "DELETE";
      const headers = { accept: "application/json" };
      const res = yield this.fetch(url2, { method, headers });
      const data = null;
      return { res, data };
    });
  }
}
class IdentityService {
  constructor(client) {
    this.baseUrl = "identity";
    this.propertyName = "externalIds";
    this.client = client;
  }
  /**
   * Gets the list of identities filtered by parameters.
   *
   * @returns Response wrapped in [[IResultList]]
   *
   * @param {object} filter Object containing filters for querying identity.
   *
   * **Example**
   * ```typescript
   *
   *  const filter: object = {
   *     pageSize: 100,
   *     withTotalPages: true
   *   };
   *
   *   (async () => {
   *     const {data, res, paging} = await identityService.list(filter);
   *   })();
   * ```
   */
  list(managedObjectId) {
    return __awaiter(this, void 0, void 0, function* () {
      const headers = { accept: "application/json" };
      const url2 = this.getExternalIdsOfGlobalIdUrl(managedObjectId);
      const res = yield this.fetch(url2, { headers });
      const json = yield res.json();
      const data = json[this.propertyName];
      return { res, data };
    });
  }
  /**
   * Creates a new identity.
   *
   * @param {IExternalIdentity} identity Identity object with mandantory fragments.
   *
   * @returns Response wrapped in [[IResult]]
   *
   * **Example**
   * ```typescript
   *   const linkedManagedObjectId = '123';
   *   const identity: IExternalIdentity = {
   *      type: 'type',
   *      externalId: '1',
   *      managedObject: {
   *        id: linkedManagedObjectId
   *      }
   *    };
   *
   *    (async () => {
   *      const {data, res} = await identityService.create(identity);
   *   })();
   * ```
   */
  create(identity2) {
    return __awaiter(this, void 0, void 0, function* () {
      const headers = { "content-type": "application/json", accept: "application/json" };
      const method = "POST";
      const body = JSON.stringify(identity2);
      const url2 = this.getExternalIdsOfGlobalIdUrl(identity2.managedObject.id);
      const res = yield this.fetch(url2, { headers, method, body });
      const data = yield res.json();
      return { res, data };
    });
  }
  /**
   * Gets the details of an identity.
   *
   * @param {IExternalIdentity} identity Identity object with mandantory fragments.
   *
   * @returns Response wrapped in [[IResult]]
   *
   * **Example**
   * ```typescript
   *
   *    const identity: IExternalIdentity = {
   *      type: 'type',
   *      externalId: '1'
   *    };
   *
   *    (async () => {
   *      const {data, res} = await identityService.detail(identity);
   *   })();
   * ```
   */
  detail(identity2) {
    return __awaiter(this, void 0, void 0, function* () {
      const headers = { accept: "application/json" };
      const url2 = this.getExternalIdUrl(identity2);
      const res = yield this.fetch(url2, { headers });
      const data = yield res.json();
      return { res, data };
    });
  }
  /**
   * Removes an identity with given id.
   *
   * @returns Response wrapped in [[IResult]]
   *
   * @param {IExternalIdentity} identity Identity object with mandantory fragments.
   *
   * **Example**
   * ```typescript
   *
   *   const identity: IExternalIdentity = {
   *      type: 'type',
   *      externalId: '1'
   *    };
   *
   *    (async () => {
   *      const {data, res} = await identityService.delete(identity);
   *   })();
   * ```
   */
  delete(identity2) {
    return __awaiter(this, void 0, void 0, function* () {
      const headers = { accept: "application/json" };
      const method = "DELETE";
      const url2 = this.getExternalIdUrl(identity2);
      const res = yield this.fetch(url2, { headers, method });
      return { res, data: null };
    });
  }
  fetch(url2, init) {
    return __awaiter(this, void 0, void 0, function* () {
      const res = yield this.client.fetch(url2, init);
      if (res.status >= 400) {
        let data = null;
        try {
          data = yield res.json();
        } catch (ex) {
          try {
            data = yield res.text();
          } catch (ex2) {
          }
        }
        throw { res, data };
      }
      return res;
    });
  }
  getExternalIdsOfGlobalIdUrl(managedObjectId) {
    return `/${this.baseUrl}/globalIds/${managedObjectId}/externalIds`;
  }
  getExternalIdUrl(identity2) {
    return `/${this.baseUrl}/externalIds/${identity2.type}/${identity2.externalId}`;
  }
}
class SmartGroupsService extends Service {
  constructor(client) {
    super(client);
    this.baseUrl = "inventory";
    this.listUrl = "managedObjects";
    this.SMART_GROUP_TYPE = "c8y_DynamicGroup";
    this.SMART_GROUP_FRAGMENT_TYPE = "c8y_IsDynamicGroup";
    this.COLUMNS_CONFIG_FRAGMENT = "c8y_DeviceColumnsConfig";
    this.FILTER_CONFIG_FRAGMENT = "c8y_DeviceFilterConfig";
    this.QUERY_STRING_FRAGMENT = "c8y_DeviceQueryString";
  }
  /**
   * Gets the details of managed object
   *
   * @param {IdReference} entityOrId Entity or Id of the ManagedObject.
   * @param {object} filter Filter object.
   *
   * @returns Response wrapped in [[IResult]]
   *
   * ```typescript
   *
   *    const id: string = '1';
   *    const filter: any = { withChildren: false };
   *
   *    (async () => {
   *      const {data, res} = await smartGroupsService.detail(id, filter);
   *   })();
   * ```
   */
  detail(entityOrId, filter2 = {}) {
    const _super = Object.create(null, {
      detail: { get: () => super.detail }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.detail.call(this, entityOrId, filter2);
    });
  }
  /**
   * Creates a smart group managed object with columns configuration.
   *
   * @param {object} smartGroup Dynamic group managed object.
   * @param {object} deviceQueryString Columns configuration query string to filter the new group.
   * @param {object} configurableColumns Configurable columns definitions.
   * @param {object} filterConfig Columns filter configuration for the new group.
   *
   * @returns Response wrapped in [[IResult]]
   *
   * **Example**
   * ```typescript
   *
   *    const smartGroup = { name: 'newName', type: 'c8y_DynamicGroup', c8y_IsDynamicGroup: {} };
   *    const deviceQueryString = 'c8y_DeviceQueryString: "$filter=(name eq 'test*') $orderby=c8y_Hardware.model asc';
   *    const configurableColumns = [
   *        {headerName: 'Status', active: false, key: 'status'},
   *        {headerName: 'Name', active: true, key: 'name', filter: { externalFilterQuery: { name: { names: ['test*'] } } }},
   *        {headerName: 'Model', active: true, key: 'model'}
   *    ];
   *
   *    (async () => {
   *      await smartGroupsService.create({ smartGroup, deviceQueryString, configurableColumns });
   *   })();
   *
   *    Note: filterConfig has been removed as a default property to the input object.
   *    Now it is part of the configurable columns properties as it is shown above.
   *    You can still pass it as an optional parameter.
   *    ( const filterConfig = [{ name: { names: ['test*'] } }] )
   * ```
   */
  create(obj) {
    const _super = Object.create(null, {
      create: { get: () => super.create }
    });
    return __awaiter(this, void 0, void 0, function* () {
      const entity = Object.assign(Object.assign(Object.assign({}, obj.smartGroup), { [this.QUERY_STRING_FRAGMENT]: obj.deviceQueryString, [this.COLUMNS_CONFIG_FRAGMENT]: obj.configurableColumns }), obj.filterConfig && { [this.FILTER_CONFIG_FRAGMENT]: obj.filterConfig });
      return _super.create.call(this, entity);
    });
  }
  /**
   * Updates smart group managed object with given id.
   *
   * @param {Partial<IManagedObject>} mo Partial managed object of the smart group.
   *
   * @returns Response wrapped in [[IResult]]
   *
   * ```typescript
   *
   *    const smartGroup = { id: '1', name: 'newName' };
   *
   *    (async () => {
   *      await smartGroupsService.update(smartGroup);
   *   })();
   * ```
   */
  update(mo) {
    const _super = Object.create(null, {
      update: { get: () => super.update }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.update.call(this, mo);
    });
  }
  /**
   * Removes managed object with given id.
   *
   * @param {IManagedObject} group Managed object of the group.
   * @param {object} params Additional query params.
   *
   * @returns Response wrapped in [[IResult]]
   *
   * ```typescript
   *
   *   const group = { id: '1' } as IManagedObject;
   *   const params: any = {
   *     withChildren: false
   *   }
   *
   *    (async () => {
   *      await smartGroupsService.delete(group, params);
   *   })();
   * ```
   */
  delete(entityOrId, params = {}) {
    const _super = Object.create(null, {
      delete: { get: () => super.delete }
    });
    return __awaiter(this, void 0, void 0, function* () {
      const data = (yield this.detail(entityOrId, { withChildren: false })).data;
      return yield _super.delete.call(this, data, params);
    });
  }
  /**
   * Checks whether a given managed object is a smart group
   *
   * @param {IManagedObject} mo Managed object to check.
   *
   * @returns boolean
   *
   * ```typescript
   *
   *    const mo: IManagedObject = {id: 1, type: "c8y_DeviceGroup", c8y_IsDeviceGroup: {}} as IManagedObject;
   *
   *    (() => {
   *      const isSmartGroup = smartGroupsService.isSmartGroup(mo);
   *   })();
   * ```
   */
  isSmartGroup(mo) {
    const hasSmartGroupFragmentType = mo.hasOwnProperty(this.SMART_GROUP_FRAGMENT_TYPE);
    const isSmartGroupType = mo && mo.type === this.SMART_GROUP_TYPE;
    return hasSmartGroupFragmentType || isSmartGroupType;
  }
  getUrl(url2 = "") {
    const partialUrl = url2.replace(/^\/+/, "");
    const baseUrl = this.baseUrl.replace(/\/+$/, "");
    return `${baseUrl}/${partialUrl}`;
  }
}
class SmartRulesService extends Service {
  constructor(client) {
    super(client);
    this.baseUrl = "service/smartrule";
    this.rulesUrl = "smartrules";
    this.unupdatableFields = ["type", "cepModuleId", "creationTime", "lastUpdated"];
    this.applicationService = new ApplicationService(client);
  }
  /**
   * Checks if the smart rules microservice is subscribed and available to user.
   *
   * **Example**
   * ```typescript
   *
   *    (async () => {
   *      const isAvailable = await smartRulesService.isMicroserviceAvailable();
   *   })();
   * ```
   */
  isMicroserviceAvailable() {
    return __awaiter(this, void 0, void 0, function* () {
      if (this.microserviceAvailable === void 0) {
        this.microserviceAvailable = (yield this.applicationService.isAvailable(SmartRulesService.microserviceName)).data;
      }
      return this.microserviceAvailable;
    });
  }
  /**
   * Gets a list of smart rules for given managed object.
   *
   * @param {IdReference} entityOrId Entity or Id of the ManagedObject.
   *
   * @returns Response wrapped in [[IResult]]
   *
   * **Example**
   * ```typescript
   *
   *    const id: string = '1';
   *
   *    (async () => {
   *      const {data, res} = await smartRulesService.listByContext(id);
   *   })();
   * ```
   */
  listByContext(entityOrId) {
    return __awaiter(this, void 0, void 0, function* () {
      const url2 = this.contextRulesUrl(entityOrId);
      const res = yield this.fetch(url2, { method: "GET" });
      const rules = (yield res.json()).rules;
      return { res, data: rules };
    });
  }
  /**
   * Deactivates smart rule for given entities list.
   *
   * @param {Partial<IRule>} rule Smart rule managed object.
   * @param {IdReference[]} entitiesOrIdsList List of entities or Id of the ManagedObjects.
   *
   * @returns Response wrapped in [[IResult]]
   *
   * **Example**
   * ```typescript
   *
   *    const rule: IRule = {id: '1', enabledSources: ['2', '3'],...};
   *    const entityOrIdList: IdReference[] = ['2'];
   *    (async () => {
   *      const {data, res} = await smartRulesService.bulkDeactivateEnabledSources(rule, entityOrIdList);
   *   })();
   * ```
   */
  bulkDeactivateEnabledSources(rule, entitiesOrIdsList) {
    if (entitiesOrIdsList.length === 0) {
      return Promise.resolve({ res: null, data: null });
    }
    const { enabledSources } = rule;
    const newEnabledSources = this.disableEnabledSources(enabledSources, entitiesOrIdsList);
    const ruleCopy = Object.assign({}, rule);
    Object.assign(ruleCopy, { enabledSources: newEnabledSources });
    return this.update(ruleCopy);
  }
  /**
   * Updates smart rule.
   *
   * @param {Parial<IRule>} rule Smart rule managed object.
   *
   * @returns Response wrapped in [[IResult]]
   *
   * **Example**
   * ```typescript
   *
   *    const rule: IRule = {id: '1', enabledSources: ['2', '3'],...};
   *    (async () => {
   *      const {data, res} = await smartRulesService.updateSmartRule(rule);
   *   })();
   * ```
   */
  update(rule) {
    return __awaiter(this, void 0, void 0, function* () {
      const url2 = this.getSmartRulesUrl(rule);
      const method = "PUT";
      const body = JSON.stringify(this.removeUnclonableFields(rule, this.unupdatableFields));
      const headers = { "content-type": "application/json", accept: "application/json" };
      const res = yield this.fetch(url2, { method, body, headers });
      const data = yield res.json();
      return { res, data };
    });
  }
  disableEnabledSources(enabledSources = [], entityOrIdList) {
    return enabledSources.filter((id2) => !this.getListOfStringIds(entityOrIdList).includes(id2));
  }
  getListOfStringIds(entityOrIdList) {
    return entityOrIdList.map((entityOrId) => {
      if (typeof entityOrId === "object" && entityOrId.id) {
        return entityOrId.id.toString();
      }
      return entityOrId.toString();
    });
  }
  getSmartRulesUrl(rule) {
    const contextMoId = rule && rule.c8y_Context && rule.c8y_Context.id;
    let url2 = !!contextMoId ? this.contextRulesUrl(contextMoId) : this.rulesUrl;
    if (rule.id) {
      url2 = `${url2}/${rule.id}`;
    }
    return url2;
  }
  removeUnclonableFields(rule, fieldsToRemove) {
    const ruleCopy = Object.assign({}, rule);
    fieldsToRemove.forEach((f) => {
      delete ruleCopy[f];
    });
    return ruleCopy;
  }
  contextRulesUrl(entityOrId = {}) {
    if (typeof entityOrId === "object" && entityOrId.id) {
      return `managedObjects/${entityOrId.id}/smartrules`;
    }
    return `managedObjects/${entityOrId}/smartrules`;
  }
}
SmartRulesService.microserviceName = "smartrule";
class Client {
  /**
   * Authenticates the given user. Determines the tenant by itself via a call to tenant/currentTenant.
   *
   * **Example**
   * ```typescript
   *
   * let client: Client;
   * (async () => {
   *  client = await Client.authenticate({
   *    user: 'testuser',
   *    password: 'password1337!'
   *  }, 'https://acme.cumulocity.com');
   *
   *  //you have access to the client api now
   *  const { data, paging, res }); =  await client.inventory.list({ pageSize: 100 });
   * })();
   * ```
   */
  static authenticate(credentials, baseUrl) {
    return __awaiter(this, void 0, void 0, function* () {
      const auth = new BasicAuth(credentials);
      const clientCore = new FetchClient(auth, baseUrl);
      const tenantName = yield this.getCurrentTenant(clientCore);
      const client = new Client(auth, baseUrl);
      client.core.tenant = tenantName;
      return client;
    });
  }
  /**
   * Authenticates the given user via OAuth Internal. Determines the tenant by itself via a call to tenant/currentTenant.
   * Login call goes to `/tenant/oauth/token` and the retrieved token will be added in the `Authorization` header to subsequent requests.
   *
   * **Example**
   * ```typescript
   *
   * let client: Client;
   * (async () => {
   *  client = await Client.authenticateViaOAuthInternal({
   *    user: 'testuser',
   *    password: 'password1337!'
   *  }, 'https://acme.cumulocity.com');
   *
   *  //you have access to the client api now
   *  const { data, paging, res }); =  await client.inventory.list({ pageSize: 100 });
   * })();
   * ```
   */
  static authenticateViaOAuthInternal(credentials, baseUrl) {
    return __awaiter(this, void 0, void 0, function* () {
      const token = yield this.loginViaOAuthInternal(credentials, true, baseUrl);
      const auth = new BearerAuth(token);
      const clientCore = new FetchClient(auth, baseUrl);
      const tenantName = credentials.tenant || (yield this.getCurrentTenant(clientCore));
      const client = new Client(auth, baseUrl);
      client.core.tenant = tenantName;
      return client;
    });
  }
  /**
   * Authenticates the given user via OAuth Internal. Determines the tenant by itself via a call to tenant/currentTenant.
   * Login call goes to `/tenant/oauth` and the retrieved token will be attached as a Cookie in browser environments to subsequent requests (using 'CookieAuth').
   * In none browser environments (e.g. nodejs) the retrieved token will be added in the `Authorization` header to subsequent requests (using 'NodeJSCookieAuth').
   *
   * **Example**
   * ```typescript
   *
   * let client: Client;
   * (async () => {
   *  client = await Client.authenticateViaOAuthInternalCookie({
   *    user: 'testuser',
   *    password: 'password1337!'
   *  }, 'https://acme.cumulocity.com');
   *
   *  //you have access to the client api now
   *  const { data, paging, res }); =  await client.inventory.list({ pageSize: 100 });
   * })();
   * ```
   */
  static authenticateViaOAuthInternalCookie(credentials, baseUrl) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.loginViaOAuthInternal(credentials, false, baseUrl);
      let auth;
      if (typeof document === "undefined") {
        auth = new NodeJSCookieAuth(response);
      } else {
        auth = new CookieAuth();
      }
      const clientCore = new FetchClient(auth, baseUrl);
      const tenantName = credentials.tenant || (yield this.getCurrentTenant(clientCore));
      const client = new Client(auth, baseUrl);
      client.core.tenant = tenantName;
      return client;
    });
  }
  /**
   * Allows to use http to register a device on the platform.
   *
   * **Deprecated** Please use MQTT to bootstrap a device.
   */
  static deviceBootstrap(options) {
    return __awaiter(this, void 0, void 0, function* () {
      const { deviceId, timeout, baseUrl, basicAuthToken } = options;
      let { expire } = options;
      if (timeout && !expire) {
        expire = Date.now() + timeout;
      }
      const clientCore = new FetchClient(void 0, baseUrl);
      const deviceRegistration = new DeviceRegistrationService(clientCore);
      let client;
      try {
        const { data } = yield deviceRegistration.bootstrap(deviceId, { basicAuthToken });
        const { username: username2, password: password2, tenantId } = data;
        const auth = new BasicAuth({ user: username2, tenant: tenantId, password: password2 });
        client = new Client(auth, baseUrl);
        client.core.tenant = tenantId;
      } catch (error2) {
        const retry = (!expire || Date.now() < expire) && error2.res.status === 404;
        if (retry) {
          return Client.deviceBootstrap(Object.assign({ expire }, options));
        } else {
          throw error2;
        }
      }
      return client;
    });
  }
  /**
   * Retrieves microservice credentials for the subscribed tenants
   * using provided bootstrap credentials
   *
   * **Example**
   * ```typescript
   *
   * (async () => {
   *  const subscriptions = await Client.getMicroserviceSubscriptions({
   *    tenant: process.env.C8Y_BOOTSTRAP_TENANT,
   *    user: process.env.C8Y_BOOTSTRAP_USER,
   *    password: process.env.C8Y_BOOTSTRAP_PASSWORD
   *  }, process.env.C8Y_BASEURL);
   *
   *  const clients = subscriptions.map(subscription => new Client(new BasicAuth(subscription), process.env.C8Y_BASEURL));
   *  // you have access to the client api now
   *  const promiseArray = clients.map(client => client.options.tenant.detail({
   *    category: process.env.APPLICATION_KEY,
   *    key: 'someSetting'
   *  }));
   * })();
   * ```
   */
  static getMicroserviceSubscriptions(bootstrapCredentials, baseUrl) {
    return __awaiter(this, void 0, void 0, function* () {
      const microserviceSubscriptionsEndpoint = "/application/currentApplication/subscriptions";
      const clientCore = new FetchClient(new BasicAuth(bootstrapCredentials), baseUrl);
      const res = yield clientCore.fetch(microserviceSubscriptionsEndpoint);
      const { users } = yield res.json();
      return users.map(({ tenant: tenant2, name: name2, password: password2 }) => {
        return {
          tenant: tenant2,
          user: name2,
          password: password2
        };
      });
    });
  }
  static loginViaOAuthInternal(credentials, bearerAuth = true, baseUrl) {
    return __awaiter(this, void 0, void 0, function* () {
      const auth = new BasicAuth(credentials);
      const clientCore = new FetchClient(auth, baseUrl);
      let url2 = "/tenant/oauth";
      if (bearerAuth) {
        url2 += `/token`;
      }
      if (credentials.tenant) {
        url2 += `?tenant_id=${credentials.tenant}`;
      }
      const params = new URLSearchParams({
        grant_type: "PASSWORD",
        username: credentials.user,
        password: credentials.password,
        tfa_code: credentials.tfa
      });
      const res = yield clientCore.fetch(url2, {
        method: "POST",
        body: params.toString(),
        headers: {
          "content-type": "application/x-www-form-urlencoded;charset=UTF-8"
        }
      });
      if (res.status !== 200) {
        throw { res };
      }
      if (bearerAuth) {
        const body = yield res.json();
        return body["access_token"];
      }
      return res;
    });
  }
  static getCurrentTenant(fetchClient) {
    return __awaiter(this, void 0, void 0, function* () {
      const tenantService = new TenantService(fetchClient);
      const { data: tenant2 } = yield tenantService.current();
      return tenant2.name;
    });
  }
  /**
   * Initializes a new Client, which allows to request data from the API. Differently
   * to Client.authenticate([...]) it needs a tenant given and does not verify if the
   * login is correct.
   *
   * **Example**
   * ```typescript
   *
   * const auth = new BasicAuth({
   *   user: 'youruser',
   *   password: 'yourpassword',
   *   tenant: 'acme'
   * }); // use CookieAuth() if your platform uses oauth (only in browser!)
   *
   * const baseUrl = 'https://acme.cumulocity.com';
   * const client = new Client(auth, baseUrl);
   * (async () => {
   *   const { data, paging, res }); =  await client.inventory.list({ pageSize: 100 });
   * })();
   * ```
   *
   * @param auth The Authentication strategy to use (e.g. new BasicAuth())
   * @param baseUrl The URL to request (optional in browser, mandatory in node)
   */
  constructor(auth, baseUrl) {
    const client = new FetchClient(auth, baseUrl);
    this.realtime = new Realtime(client);
    this.alarm = new AlarmService(client, this.realtime);
    this.application = new ApplicationService(client, this.realtime);
    this.audit = new AuditService(client);
    this.core = client;
    this.deviceRegistration = new DeviceRegistrationService(client);
    this.deviceRegistrationBulk = new DeviceRegistrationBulkService(client);
    this.event = new EventService(client, this.realtime);
    this.inventory = new InventoryService(client, this.realtime);
    this.inventoryBinary = new InventoryBinaryService(client);
    this.inventoryRole = new InventoryRoleService(client);
    this.measurement = new MeasurementService(client, this.realtime);
    this.operation = new OperationService(client);
    this.operationBulk = new OperationBulkService(client);
    this.options = {
      security: new TenantSecurityOptionsService(client),
      system: new SystemOptionsService(client),
      login: new TenantLoginOptionsService(client),
      tenant: new TenantOptionsService(client)
    };
    this.role = new InventoryRoleService(client);
    this.tenant = new TenantService(client);
    this.user = new UserService(client);
    this.userGroup = new UserGroupService(client);
    this.userRole = new UserRoleService(client);
    this.identity = new IdentityService(client);
    this.smartGroups = new SmartGroupsService(client);
    this.smartRules = new SmartRulesService(client);
  }
  /**
   * Allows to change the current Authentication
   * @param auth The new Authentication information.
   */
  setAuth(auth) {
    this.core.setAuth(auth);
    this.realtime.disconnect();
  }
}
const AuthContext = createContext();
const TOKEN_KEY = "_tcy8";
const AuthProvider = ({ children }) => {
  const { toast } = useToast();
  const { t: t2 } = useTranslation();
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [loginMode, setLoginMode] = useState(void 0);
  const [loading, setLoading] = useState(true);
  const [applications, setApplications] = useState(null);
  const tenant2 = useRef(void 0);
  const loginOption = useRef(void 0);
  const currentUser = useRef(null);
  const client = useRef(new Client());
  const fetchClient = useRef(new FetchClient());
  const basicAuth = new BasicAuth();
  const cookieAuth = new CookieAuth();
  const resetPassword = async ({ email: email2 }) => {
    fetch("/user/passwordReset", {
      method: "POST",
      body: JSON.stringify({ email: email2 }),
      headers: {
        "Content-Type": "application/json"
      }
    }).then(() => {
      toast({
        title: t2(
          "Password reset request has been sent. Please check your email."
        ),
        duration: 3e3,
        variant: "success"
      });
    }).catch(() => {
      toast({
        title: t2("Somethings wrong"),
        duration: 3e3,
        variant: "destructive"
      });
    });
    logout2();
  };
  const checkCredential = async (loginClient, auto2) => {
    let result = true;
    const loginResult = await loginClient.tenant.current().then((res) => res).catch((err) => err);
    if (loginResult.res.status >= 400) {
      if (loginResult.res.status === 401) {
        if (!auto2) {
          toast({
            title: t2("Invalid credentials"),
            duration: 3e3,
            variant: "destructive"
          });
        }
      } else {
        toast({
          title: t2("Somethings wrong"),
          duration: 3e3,
          variant: "destructive"
        });
      }
      setIsAuthenticated(false);
      result = false;
    }
    return { result, detail: loginResult };
  };
  const getAppByUser = async () => {
    const res = await client.current.application.listByUser(
      currentUser.current,
      {
        dropOverwrittenApps: true,
        noPaging: true
      }
    );
    setApplications(res);
  };
  const getLoginOption = async (client2) => {
    try {
      const result = await client2.current.options.login.list();
      const currentMode = result.data.filter(
        (d) => d.visibleOnLoginPage === true
      );
      loginOption.current = currentMode[0];
      setLoginMode(currentMode[0].type);
      tenant2.current = parsingTenantId(currentMode[0].self);
    } catch {
      setLoginMode("BASIC");
    }
  };
  const getUserData = async () => {
    const currentUserResult = await client.current.user.current();
    currentUser.current = currentUserResult.data;
  };
  const autoLogin = async (loginMode2) => {
    setLoading(true);
    let auth;
    if (loginMode2 === "BASIC") {
      const storedAuth = { token: getToken() };
      basicAuth.updateCredentials(storedAuth);
      auth = basicAuth;
    } else {
      auth = cookieAuth;
    }
    const loginClient = new Client(auth);
    const { result } = await checkCredential(loginClient, true);
    if (result) {
      setClient(auth);
      await postLoginProcess();
    }
    setLoading(false);
  };
  const login = async ({ tenantId, user, password: password2, rememberMe }) => {
    const credential = {
      tenant: tenant2.current ?? tenantId,
      user,
      password: password2
    };
    const token = basicAuth.updateCredentials(credential);
    const loginClient = new Client(basicAuth);
    const { result } = await checkCredential(loginClient, false);
    if (!result) return;
    let auth;
    if (loginMode === "BASIC") {
      storeToken(token, rememberMe);
      auth = basicAuth;
    } else if (loginMode === "OAUTH2_INTERNAL") {
      await Client.loginViaOAuthInternal(credential, false);
      clearStorage();
      basicAuth.logout();
      auth = cookieAuth;
    }
    setClient(auth);
    await postLoginProcess();
  };
  const postLoginProcess = async () => {
    await getUserData();
    getAppByUser();
    setIsAuthenticated(true);
  };
  const logout2 = () => {
    setLoading(true);
    setIsAuthenticated(false);
    tenant2.current = loginOption.current ? tenant2.current : void 0;
    basicAuth.logout();
    cookieAuth.logout();
    setClient();
    clearStorage();
    setLoading(false);
  };
  const setClient = (auth) => {
    client.current = new Client(auth);
    fetchClient.current = new FetchClient(auth);
  };
  const getToken = () => {
    return localStorage.getItem(TOKEN_KEY) || sessionStorage.getItem(TOKEN_KEY);
  };
  const storeToken = (token, rememberMe) => {
    if (rememberMe) {
      localStorage.setItem(TOKEN_KEY, token);
    } else {
      sessionStorage.setItem(TOKEN_KEY, token);
    }
  };
  const clearStorage = () => {
    localStorage.removeItem(TOKEN_KEY);
    sessionStorage.removeItem(TOKEN_KEY);
  };
  const parsingTenantId = (url2) => {
    const urlObj = new URL(url2);
    const hostname = urlObj.hostname;
    const tenantId = hostname.split(".")[0];
    return tenantId;
  };
  useEffect(() => {
    getLoginOption(client);
  }, [isAuthenticated]);
  useEffect(() => {
    if (loginMode) {
      autoLogin(loginMode);
    }
  }, [loginMode]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    AuthContext.Provider,
    {
      value: {
        isAuthenticated,
        loginOption,
        login,
        logout: logout2,
        resetPassword,
        currentUser: currentUser.current,
        client: client.current,
        fetchClient: fetchClient.current,
        tenant: tenant2.current,
        applications
      },
      children: loading ? /* @__PURE__ */ jsxRuntimeExports.jsx(Loading, { fullScreen: true }) : children
    }
  );
};
const useAuth = () => {
  return useContext(AuthContext);
};
const TOAST_LIMIT = 1;
const TOAST_REMOVE_DELAY = 1e6;
let count$5 = 0;
const generateId = () => {
  count$5 = (count$5 + 1) % Number.MAX_SAFE_INTEGER;
  return count$5.toString();
};
const toastTimeouts = /* @__PURE__ */ new Map();
const addToRemoveQueue = (toastId) => {
  if (toastTimeouts.has(toastId)) {
    return;
  }
  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId);
    dispatchAction({
      type: "REMOVE_TOAST",
      toastId
    });
  }, TOAST_REMOVE_DELAY);
  toastTimeouts.set(toastId, timeout);
};
const reducer = (state, action) => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT)
      };
    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map(
          (t2) => t2.id === action.toast.id ? { ...t2, ...action.toast } : t2
        )
      };
    case "DISMISS_TOAST": {
      const { toastId } = action;
      if (toastId) {
        addToRemoveQueue(toastId);
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id);
        });
      }
      return {
        ...state,
        toasts: state.toasts.map(
          (t2) => t2.id === toastId || toastId === void 0 ? {
            ...t2,
            open: false
          } : t2
        )
      };
    }
    case "REMOVE_TOAST":
      if (action.toastId === void 0) {
        return {
          ...state,
          toasts: []
        };
      }
      return {
        ...state,
        toasts: state.toasts.filter((t2) => t2.id !== action.toastId)
      };
  }
};
const listeners = [];
let memoryState = { toasts: [] };
const dispatchAction = (action) => {
  memoryState = reducer(memoryState, action);
  listeners.forEach((listener) => listener(memoryState));
};
const createToast = (props) => {
  const id2 = generateId();
  const update = (props2) => dispatchAction({
    type: "UPDATE_TOAST",
    toast: { ...props2, id: id2 }
  });
  const dismiss = () => dispatchAction({ type: "DISMISS_TOAST", toastId: id2 });
  dispatchAction({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id: id2,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss();
      }
    }
  });
  return {
    id: id2,
    dismiss,
    update
  };
};
function useToast() {
  const [state, setState] = useState(memoryState);
  const dismiss = (toastId) => dispatchAction({ type: "DISMISS_TOAST", toastId });
  useEffect(() => {
    listeners.push(setState);
    return () => {
      const index2 = listeners.indexOf(setState);
      if (index2 > -1) {
        listeners.splice(index2, 1);
      }
    };
  }, [state]);
  return {
    ...state,
    toast: createToast,
    dismiss
  };
}
const useTranslation = () => {
  const { t: originalT, ...rest } = useTranslation$1();
  const t2 = (key, options = {}) => {
    const lowerCaseKey = typeof key === "string" ? key.toLowerCase() : key;
    let translation = originalT(lowerCaseKey, options);
    if (translation === lowerCaseKey) {
      translation = key;
    }
    if (options.format === "uppercase") {
      return translation.toUpperCase();
    }
    if (options.format === "lowercase") {
      return translation.toLowerCase();
    }
    return translation;
  };
  return { t: t2, ...rest };
};
const useCustomMutation = ({
  mutationFn,
  queryKey,
  successMessage,
  errorMessage,
  onSuccess,
  onSettled,
  onError,
  ...options
}) => {
  const queryClient = useQueryClient();
  const { toast } = useToast();
  const { t: t2 } = useTranslation();
  const { mutate } = useMutation({
    mutationFn,
    onSuccess: (data, variables) => {
      queryClient.invalidateQueries({ queryKey });
      if (onSuccess) {
        onSuccess(data, variables);
      }
      if (successMessage) {
        toast({
          title: typeof successMessage === "function" ? t2(successMessage(variables)) : t2(successMessage),
          duration: 3e3,
          variant: "success"
        });
      }
    },
    onError: (error2, variables) => {
      if (onError) {
        onError(error2, variables);
      }
      if (errorMessage) {
        toast({
          title: typeof errorMessage === "function" ? t2(errorMessage(variables)) : t2(errorMessage),
          duration: 3e3,
          variant: "destructive"
        });
      }
    },
    onSettled,
    ...options
  });
  return mutate;
};
const DarkContext = createContext();
const DarkProvider = ({ children }) => {
  const [dark, setDark] = useState(
    JSON.parse(localStorage.getItem("dark")) ?? true
  );
  const toggleTheme = () => {
    const value2 = !dark;
    setDark(value2);
    localStorage.setItem("dark", JSON.stringify(value2));
  };
  useEffect(() => {
    if (dark) {
      document.documentElement.classList.add("dark");
    } else {
      document.documentElement.classList.remove("dark");
    }
  }, [dark]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    DarkContext.Provider,
    {
      value: {
        dark,
        toggleTheme
      },
      children
    }
  );
};
const useDark = () => {
  return useContext(DarkContext);
};
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal || freeSelf || Function("return this")();
var Symbol$1 = root.Symbol;
var objectProto$e = Object.prototype;
var hasOwnProperty$b = objectProto$e.hasOwnProperty;
var nativeObjectToString$1 = objectProto$e.toString;
var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
function getRawTag(value2) {
  var isOwn = hasOwnProperty$b.call(value2, symToStringTag$1), tag = value2[symToStringTag$1];
  try {
    value2[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString$1.call(value2);
  if (unmasked) {
    if (isOwn) {
      value2[symToStringTag$1] = tag;
    } else {
      delete value2[symToStringTag$1];
    }
  }
  return result;
}
var objectProto$d = Object.prototype;
var nativeObjectToString = objectProto$d.toString;
function objectToString(value2) {
  return nativeObjectToString.call(value2);
}
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
function baseGetTag(value2) {
  if (value2 == null) {
    return value2 === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value2) ? getRawTag(value2) : objectToString(value2);
}
function isObjectLike(value2) {
  return value2 != null && typeof value2 == "object";
}
var symbolTag$3 = "[object Symbol]";
function isSymbol(value2) {
  return typeof value2 == "symbol" || isObjectLike(value2) && baseGetTag(value2) == symbolTag$3;
}
function arrayMap(array, iteratee) {
  var index2 = -1, length = array == null ? 0 : array.length, result = Array(length);
  while (++index2 < length) {
    result[index2] = iteratee(array[index2], index2, array);
  }
  return result;
}
var isArray = Array.isArray;
var symbolProto$2 = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto$2 ? symbolProto$2.toString : void 0;
function baseToString(value2) {
  if (typeof value2 == "string") {
    return value2;
  }
  if (isArray(value2)) {
    return arrayMap(value2, baseToString) + "";
  }
  if (isSymbol(value2)) {
    return symbolToString ? symbolToString.call(value2) : "";
  }
  var result = value2 + "";
  return result == "0" && 1 / value2 == -Infinity ? "-0" : result;
}
var reWhitespace = /\s/;
function trimmedEndIndex(string) {
  var index2 = string.length;
  while (index2-- && reWhitespace.test(string.charAt(index2))) {
  }
  return index2;
}
var reTrimStart = /^\s+/;
function baseTrim(string) {
  return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
}
function isObject$2(value2) {
  var type2 = typeof value2;
  return value2 != null && (type2 == "object" || type2 == "function");
}
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber(value2) {
  if (typeof value2 == "number") {
    return value2;
  }
  if (isSymbol(value2)) {
    return NAN;
  }
  if (isObject$2(value2)) {
    var other = typeof value2.valueOf == "function" ? value2.valueOf() : value2;
    value2 = isObject$2(other) ? other + "" : other;
  }
  if (typeof value2 != "string") {
    return value2 === 0 ? value2 : +value2;
  }
  value2 = baseTrim(value2);
  var isBinary = reIsBinary.test(value2);
  return isBinary || reIsOctal.test(value2) ? freeParseInt(value2.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value2) ? NAN : +value2;
}
var INFINITY$1 = 1 / 0, MAX_INTEGER = 17976931348623157e292;
function toFinite(value2) {
  if (!value2) {
    return value2 === 0 ? value2 : 0;
  }
  value2 = toNumber(value2);
  if (value2 === INFINITY$1 || value2 === -Infinity) {
    var sign = value2 < 0 ? -1 : 1;
    return sign * MAX_INTEGER;
  }
  return value2 === value2 ? value2 : 0;
}
function toInteger(value2) {
  var result = toFinite(value2), remainder = result % 1;
  return result === result ? remainder ? result - remainder : result : 0;
}
function identity(value2) {
  return value2;
}
var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$1(value2) {
  if (!isObject$2(value2)) {
    return false;
  }
  var tag = baseGetTag(value2);
  return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
}
var coreJsData = root["__core-js_shared__"];
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var funcProto$1 = Function.prototype;
var funcToString$1 = funcProto$1.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$1.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto = Function.prototype, objectProto$c = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$a = objectProto$c.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString.call(hasOwnProperty$a).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(value2) {
  if (!isObject$2(value2) || isMasked(value2)) {
    return false;
  }
  var pattern = isFunction$1(value2) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value2));
}
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
function getNative(object, key) {
  var value2 = getValue(object, key);
  return baseIsNative(value2) ? value2 : void 0;
}
var WeakMap$1 = getNative(root, "WeakMap");
var objectCreate = Object.create;
var baseCreate = /* @__PURE__ */ function() {
  function object() {
  }
  return function(proto) {
    if (!isObject$2(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object();
    object.prototype = void 0;
    return result;
  };
}();
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
function noop$1() {
}
var HOT_COUNT = 800, HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut(func) {
  var count2 = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count2 >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count2 = 0;
    }
    return func.apply(void 0, arguments);
  };
}
function constant(value2) {
  return function() {
    return value2;
  };
}
var defineProperty = function() {
  try {
    var func = getNative(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e) {
  }
}();
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant(string),
    "writable": true
  });
};
var setToString = shortOut(baseSetToString);
function arrayEach(array, iteratee) {
  var index2 = -1, length = array == null ? 0 : array.length;
  while (++index2 < length) {
    if (iteratee(array[index2], index2, array) === false) {
      break;
    }
  }
  return array;
}
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length, index2 = fromIndex + -1;
  while (++index2 < length) {
    if (predicate(array[index2], index2, array)) {
      return index2;
    }
  }
  return -1;
}
function baseIsNaN(value2) {
  return value2 !== value2;
}
function strictIndexOf(array, value2, fromIndex) {
  var index2 = fromIndex - 1, length = array.length;
  while (++index2 < length) {
    if (array[index2] === value2) {
      return index2;
    }
  }
  return -1;
}
function baseIndexOf(array, value2, fromIndex) {
  return value2 === value2 ? strictIndexOf(array, value2, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
}
function arrayIncludes(array, value2) {
  var length = array == null ? 0 : array.length;
  return !!length && baseIndexOf(array, value2, 0) > -1;
}
var MAX_SAFE_INTEGER$1 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value2, length) {
  var type2 = typeof value2;
  length = length == null ? MAX_SAFE_INTEGER$1 : length;
  return !!length && (type2 == "number" || type2 != "symbol" && reIsUint.test(value2)) && (value2 > -1 && value2 % 1 == 0 && value2 < length);
}
function baseAssignValue(object, key, value2) {
  if (key == "__proto__" && defineProperty) {
    defineProperty(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value2,
      "writable": true
    });
  } else {
    object[key] = value2;
  }
}
function eq(value2, other) {
  return value2 === other || value2 !== value2 && other !== other;
}
var objectProto$b = Object.prototype;
var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
function assignValue(object, key, value2) {
  var objValue = object[key];
  if (!(hasOwnProperty$9.call(object, key) && eq(objValue, value2)) || value2 === void 0 && !(key in object)) {
    baseAssignValue(object, key, value2);
  }
}
var nativeMax$1 = Math.max;
function overRest(func, start2, transform) {
  start2 = nativeMax$1(start2 === void 0 ? func.length - 1 : start2, 0);
  return function() {
    var args = arguments, index2 = -1, length = nativeMax$1(args.length - start2, 0), array = Array(length);
    while (++index2 < length) {
      array[index2] = args[start2 + index2];
    }
    index2 = -1;
    var otherArgs = Array(start2 + 1);
    while (++index2 < start2) {
      otherArgs[index2] = args[index2];
    }
    otherArgs[start2] = transform(array);
    return apply(func, this, otherArgs);
  };
}
function baseRest(func, start2) {
  return setToString(overRest(func, start2, identity), func + "");
}
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength$1(value2) {
  return typeof value2 == "number" && value2 > -1 && value2 % 1 == 0 && value2 <= MAX_SAFE_INTEGER;
}
function isArrayLike(value2) {
  return value2 != null && isLength$1(value2.length) && !isFunction$1(value2);
}
function isIterateeCall(value2, index2, object) {
  if (!isObject$2(object)) {
    return false;
  }
  var type2 = typeof index2;
  if (type2 == "number" ? isArrayLike(object) && isIndex(index2, object.length) : type2 == "string" && index2 in object) {
    return eq(object[index2], value2);
  }
  return false;
}
var objectProto$a = Object.prototype;
function isPrototype(value2) {
  var Ctor = value2 && value2.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$a;
  return value2 === proto;
}
function baseTimes(n2, iteratee) {
  var index2 = -1, result = Array(n2);
  while (++index2 < n2) {
    result[index2] = iteratee(index2);
  }
  return result;
}
var argsTag$3 = "[object Arguments]";
function baseIsArguments(value2) {
  return isObjectLike(value2) && baseGetTag(value2) == argsTag$3;
}
var objectProto$9 = Object.prototype;
var hasOwnProperty$8 = objectProto$9.hasOwnProperty;
var propertyIsEnumerable$1 = objectProto$9.propertyIsEnumerable;
var isArguments = baseIsArguments(/* @__PURE__ */ function() {
  return arguments;
}()) ? baseIsArguments : function(value2) {
  return isObjectLike(value2) && hasOwnProperty$8.call(value2, "callee") && !propertyIsEnumerable$1.call(value2, "callee");
};
function stubFalse() {
  return false;
}
var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
var Buffer$2 = moduleExports$2 ? root.Buffer : void 0;
var nativeIsBuffer = Buffer$2 ? Buffer$2.isBuffer : void 0;
var isBuffer = nativeIsBuffer || stubFalse;
var argsTag$2 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$3 = "[object Boolean]", dateTag$3 = "[object Date]", errorTag$2 = "[object Error]", funcTag$1 = "[object Function]", mapTag$5 = "[object Map]", numberTag$3 = "[object Number]", objectTag$3 = "[object Object]", regexpTag$3 = "[object RegExp]", setTag$5 = "[object Set]", stringTag$3 = "[object String]", weakMapTag$2 = "[object WeakMap]";
var arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$3] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$2] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$5] = typedArrayTags[numberTag$3] = typedArrayTags[objectTag$3] = typedArrayTags[regexpTag$3] = typedArrayTags[setTag$5] = typedArrayTags[stringTag$3] = typedArrayTags[weakMapTag$2] = false;
function baseIsTypedArray(value2) {
  return isObjectLike(value2) && isLength$1(value2.length) && !!typedArrayTags[baseGetTag(value2)];
}
function baseUnary(func) {
  return function(value2) {
    return func(value2);
  };
}
var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
var freeProcess = moduleExports$1 && freeGlobal.process;
var nodeUtil = function() {
  try {
    var types = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
    if (types) {
      return types;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e) {
  }
}();
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
var objectProto$8 = Object.prototype;
var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
function arrayLikeKeys(value2, inherited) {
  var isArr = isArray(value2), isArg = !isArr && isArguments(value2), isBuff = !isArr && !isArg && isBuffer(value2), isType = !isArr && !isArg && !isBuff && isTypedArray(value2), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value2.length, String) : [], length = result.length;
  for (var key in value2) {
    if (hasOwnProperty$7.call(value2, key) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var nativeKeys = overArg(Object.keys, Object);
var objectProto$7 = Object.prototype;
var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$6.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
function isKey(value2, object) {
  if (isArray(value2)) {
    return false;
  }
  var type2 = typeof value2;
  if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value2 == null || isSymbol(value2)) {
    return true;
  }
  return reIsPlainProp.test(value2) || !reIsDeepProp.test(value2) || object != null && value2 in Object(object);
}
var nativeCreate = getNative(Object, "create");
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
var objectProto$6 = Object.prototype;
var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED$2 ? void 0 : result;
  }
  return hasOwnProperty$5.call(data, key) ? data[key] : void 0;
}
var objectProto$5 = Object.prototype;
var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== void 0 : hasOwnProperty$4.call(data, key);
}
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet(key, value2) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value2 === void 0 ? HASH_UNDEFINED$1 : value2;
  return this;
}
function Hash(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear;
Hash.prototype["delete"] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index2, 1);
  }
  --this.size;
  return true;
}
function listCacheGet(key) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  return index2 < 0 ? void 0 : data[index2][1];
}
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}
function listCacheSet(key, value2) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  if (index2 < 0) {
    ++this.size;
    data.push([key, value2]);
  } else {
    data[index2][1] = value2;
  }
  return this;
}
function ListCache(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype["delete"] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
var Map$1 = getNative(root, "Map");
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$1 || ListCache)(),
    "string": new Hash()
  };
}
function isKeyable(value2) {
  var type2 = typeof value2;
  return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value2 !== "__proto__" : value2 === null;
}
function getMapData(map2, key) {
  var data = map2.__data__;
  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
function mapCacheDelete(key) {
  var result = getMapData(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}
function mapCacheSet(key, value2) {
  var data = getMapData(this, key), size2 = data.size;
  data.set(key, value2);
  this.size += data.size == size2 ? 0 : 1;
  return this;
}
function MapCache(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype["delete"] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
var FUNC_ERROR_TEXT = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
}
memoize.Cache = MapCache;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });
  var cache = result.cache;
  return result;
}
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName, function(match2, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match2);
  });
  return result;
});
function toString$1(value2) {
  return value2 == null ? "" : baseToString(value2);
}
function castPath(value2, object) {
  if (isArray(value2)) {
    return value2;
  }
  return isKey(value2, object) ? [value2] : stringToPath(toString$1(value2));
}
function toKey(value2) {
  if (typeof value2 == "string" || isSymbol(value2)) {
    return value2;
  }
  var result = value2 + "";
  return result == "0" && 1 / value2 == -Infinity ? "-0" : result;
}
function baseGet(object, path2) {
  path2 = castPath(path2, object);
  var index2 = 0, length = path2.length;
  while (object != null && index2 < length) {
    object = object[toKey(path2[index2++])];
  }
  return index2 && index2 == length ? object : void 0;
}
function get$1(object, path2, defaultValue) {
  var result = object == null ? void 0 : baseGet(object, path2);
  return result === void 0 ? defaultValue : result;
}
function arrayPush(array, values) {
  var index2 = -1, length = values.length, offset2 = array.length;
  while (++index2 < length) {
    array[offset2 + index2] = values[index2];
  }
  return array;
}
var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : void 0;
function isFlattenable(value2) {
  return isArray(value2) || isArguments(value2) || !!(spreadableSymbol && value2 && value2[spreadableSymbol]);
}
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index2 = -1, length = array.length;
  predicate || (predicate = isFlattenable);
  result || (result = []);
  while (++index2 < length) {
    var value2 = array[index2];
    if (predicate(value2)) {
      {
        arrayPush(result, value2);
      }
    } else {
      result[result.length] = value2;
    }
  }
  return result;
}
var getPrototype = overArg(Object.getPrototypeOf, Object);
function baseSlice(array, start2, end2) {
  var index2 = -1, length = array.length;
  if (start2 < 0) {
    start2 = -start2 > length ? 0 : length + start2;
  }
  end2 = end2 > length ? length : end2;
  if (end2 < 0) {
    end2 += length;
  }
  length = start2 > end2 ? 0 : end2 - start2 >>> 0;
  start2 >>>= 0;
  var result = Array(length);
  while (++index2 < length) {
    result[index2] = array[index2 + start2];
  }
  return result;
}
function castSlice(array, start2, end2) {
  var length = array.length;
  end2 = end2 === void 0 ? length : end2;
  return !start2 && end2 >= length ? array : baseSlice(array, start2, end2);
}
var rsAstralRange$1 = "\\ud800-\\udfff", rsComboMarksRange$1 = "\\u0300-\\u036f", reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$1 = "\\u20d0-\\u20ff", rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1, rsVarRange$1 = "\\ufe0e\\ufe0f";
var rsZWJ$1 = "\\u200d";
var reHasUnicode = RegExp("[" + rsZWJ$1 + rsAstralRange$1 + rsComboRange$1 + rsVarRange$1 + "]");
function hasUnicode(string) {
  return reHasUnicode.test(string);
}
function asciiToArray(string) {
  return string.split("");
}
var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsVarRange = "\\ufe0e\\ufe0f";
var rsAstral = "[" + rsAstralRange + "]", rsCombo = "[" + rsComboRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ = "\\u200d";
var reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
function unicodeToArray(string) {
  return string.match(reUnicode) || [];
}
function stringToArray(string) {
  return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
}
function createCaseFirst(methodName) {
  return function(string) {
    string = toString$1(string);
    var strSymbols = hasUnicode(string) ? stringToArray(string) : void 0;
    var chr = strSymbols ? strSymbols[0] : string.charAt(0);
    var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
    return chr[methodName]() + trailing;
  };
}
var upperFirst = createCaseFirst("toUpperCase");
function capitalize$1(string) {
  return upperFirst(toString$1(string).toLowerCase());
}
function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}
function stackDelete(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
function stackGet(key) {
  return this.__data__.get(key);
}
function stackHas(key) {
  return this.__data__.has(key);
}
var LARGE_ARRAY_SIZE$1 = 200;
function stackSet(key, value2) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE$1 - 1) {
      pairs.push([key, value2]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value2);
  this.size = data.size;
  return this;
}
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}
Stack.prototype.clear = stackClear;
Stack.prototype["delete"] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer$1 = moduleExports ? root.Buffer : void 0;
Buffer$1 ? Buffer$1.allocUnsafe : void 0;
function cloneBuffer(buffer, isDeep) {
  {
    return buffer.slice();
  }
}
function arrayFilter(array, predicate) {
  var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index2 < length) {
    var value2 = array[index2];
    if (predicate(value2, index2, array)) {
      result[resIndex++] = value2;
    }
  }
  return result;
}
function stubArray() {
  return [];
}
var objectProto$4 = Object.prototype;
var propertyIsEnumerable = objectProto$4.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}
var DataView$1 = getNative(root, "DataView");
var Promise$1 = getNative(root, "Promise");
var Set$1 = getNative(root, "Set");
var mapTag$4 = "[object Map]", objectTag$2 = "[object Object]", promiseTag = "[object Promise]", setTag$4 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
var dataViewTag$3 = "[object DataView]";
var dataViewCtorString = toSource(DataView$1), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$1);
var getTag = baseGetTag;
if (DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag$3 || Map$1 && getTag(new Map$1()) != mapTag$4 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$4 || WeakMap$1 && getTag(new WeakMap$1()) != weakMapTag$1) {
  getTag = function(value2) {
    var result = baseGetTag(value2), Ctor = result == objectTag$2 ? value2.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag$3;
        case mapCtorString:
          return mapTag$4;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag$4;
        case weakMapCtorString:
          return weakMapTag$1;
      }
    }
    return result;
  };
}
var objectProto$3 = Object.prototype;
var hasOwnProperty$3 = objectProto$3.hasOwnProperty;
function initCloneArray(array) {
  var length = array.length, result = new array.constructor(length);
  if (length && typeof array[0] == "string" && hasOwnProperty$3.call(array, "index")) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}
var Uint8Array$1 = root.Uint8Array;
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
  return result;
}
function cloneDataView(dataView, isDeep) {
  var buffer = cloneArrayBuffer(dataView.buffer);
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var reFlags = /\w*$/;
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}
var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : void 0;
function cloneSymbol(symbol) {
  return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
}
function cloneTypedArray(typedArray, isDeep) {
  var buffer = cloneArrayBuffer(typedArray.buffer);
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", mapTag$3 = "[object Map]", numberTag$2 = "[object Number]", regexpTag$2 = "[object RegExp]", setTag$3 = "[object Set]", stringTag$2 = "[object String]", symbolTag$2 = "[object Symbol]";
var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag$2:
      return cloneArrayBuffer(object);
    case boolTag$2:
    case dateTag$2:
      return new Ctor(+object);
    case dataViewTag$2:
      return cloneDataView(object);
    case float32Tag$1:
    case float64Tag$1:
    case int8Tag$1:
    case int16Tag$1:
    case int32Tag$1:
    case uint8Tag$1:
    case uint8ClampedTag$1:
    case uint16Tag$1:
    case uint32Tag$1:
      return cloneTypedArray(object);
    case mapTag$3:
      return new Ctor();
    case numberTag$2:
    case stringTag$2:
      return new Ctor(object);
    case regexpTag$2:
      return cloneRegExp(object);
    case setTag$3:
      return new Ctor();
    case symbolTag$2:
      return cloneSymbol(object);
  }
}
function initCloneObject(object) {
  return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
}
var mapTag$2 = "[object Map]";
function baseIsMap(value2) {
  return isObjectLike(value2) && getTag(value2) == mapTag$2;
}
var nodeIsMap = nodeUtil && nodeUtil.isMap;
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
var setTag$2 = "[object Set]";
function baseIsSet(value2) {
  return isObjectLike(value2) && getTag(value2) == setTag$2;
}
var nodeIsSet = nodeUtil && nodeUtil.isSet;
var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag$1 = "[object Map]", numberTag$1 = "[object Number]", objectTag$1 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$1 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]", weakMapTag = "[object WeakMap]";
var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag$1] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$1] = cloneableTags[dataViewTag$1] = cloneableTags[boolTag$1] = cloneableTags[dateTag$1] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag$1] = cloneableTags[numberTag$1] = cloneableTags[objectTag$1] = cloneableTags[regexpTag$1] = cloneableTags[setTag$1] = cloneableTags[stringTag$1] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag$1] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
function baseClone(value2, bitmask, customizer, key, object, stack) {
  var result;
  if (result !== void 0) {
    return result;
  }
  if (!isObject$2(value2)) {
    return value2;
  }
  var isArr = isArray(value2);
  if (isArr) {
    result = initCloneArray(value2);
  } else {
    var tag = getTag(value2), isFunc = tag == funcTag || tag == genTag;
    if (isBuffer(value2)) {
      return cloneBuffer(value2);
    }
    if (tag == objectTag$1 || tag == argsTag$1 || isFunc && !object) {
      result = isFunc ? {} : initCloneObject(value2);
    } else {
      if (!cloneableTags[tag]) {
        return object ? value2 : {};
      }
      result = initCloneByTag(value2, tag);
    }
  }
  stack || (stack = new Stack());
  var stacked = stack.get(value2);
  if (stacked) {
    return stacked;
  }
  stack.set(value2, result);
  if (isSet(value2)) {
    value2.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value2, stack));
    });
  } else if (isMap(value2)) {
    value2.forEach(function(subValue, key2) {
      result.set(key2, baseClone(subValue, bitmask, customizer, key2, value2, stack));
    });
  }
  var keysFunc = getAllKeys;
  var props = isArr ? void 0 : keysFunc(value2);
  arrayEach(props || value2, function(subValue, key2) {
    if (props) {
      key2 = subValue;
      subValue = value2[key2];
    }
    assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value2, stack));
  });
  return result;
}
var CLONE_DEEP_FLAG = 1, CLONE_SYMBOLS_FLAG = 4;
function cloneDeep(value2) {
  return baseClone(value2, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd(value2) {
  this.__data__.set(value2, HASH_UNDEFINED);
  return this;
}
function setCacheHas(value2) {
  return this.__data__.has(value2);
}
function SetCache(values) {
  var index2 = -1, length = values == null ? 0 : values.length;
  this.__data__ = new MapCache();
  while (++index2 < length) {
    this.add(values[index2]);
  }
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
function arraySome(array, predicate) {
  var index2 = -1, length = array == null ? 0 : array.length;
  while (++index2 < length) {
    if (predicate(array[index2], index2, array)) {
      return true;
    }
  }
  return false;
}
function cacheHas(cache, key) {
  return cache.has(key);
}
var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
  stack.set(array, other);
  stack.set(other, array);
  while (++index2 < arrLength) {
    var arrValue = array[index2], othValue = other[index2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome(other, function(othValue2, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array);
  stack["delete"](other);
  return result;
}
function mapToArray(map2) {
  var index2 = -1, result = Array(map2.size);
  map2.forEach(function(value2, key) {
    result[++index2] = [key, value2];
  });
  return result;
}
function setToArray(set2) {
  var index2 = -1, result = Array(set2.size);
  set2.forEach(function(value2) {
    result[++index2] = value2;
  });
  return result;
}
var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;
    case arrayBufferTag:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))) {
        return false;
      }
      return true;
    case boolTag:
    case dateTag:
    case numberTag:
      return eq(+object, +other);
    case errorTag:
      return object.name == other.name && object.message == other.message;
    case regexpTag:
    case stringTag:
      return object == other + "";
    case mapTag:
      var convert = mapToArray;
    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
      convert || (convert = setToArray);
      if (object.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG$2;
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object);
      return result;
    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}
var COMPARE_PARTIAL_FLAG$3 = 1;
var objectProto$2 = Object.prototype;
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index2 = objLength;
  while (index2--) {
    var key = objProps[index2];
    if (!(isPartial ? key in other : hasOwnProperty$2.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;
  while (++index2 < objLength) {
    key = objProps[index2];
    var objValue = object[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object);
  stack["delete"](other);
  return result;
}
var COMPARE_PARTIAL_FLAG$2 = 1;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
var objectProto$1 = Object.prototype;
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;
  var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack());
    return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
    var objIsWrapped = objIsObj && hasOwnProperty$1.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$1.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}
function baseIsEqual(value2, other, bitmask, customizer, stack) {
  if (value2 === other) {
    return true;
  }
  if (value2 == null || other == null || !isObjectLike(value2) && !isObjectLike(other)) {
    return value2 !== value2 && other !== other;
  }
  return baseIsEqualDeep(value2, other, bitmask, customizer, baseIsEqual, stack);
}
var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
function baseIsMatch(object, source2, matchData, customizer) {
  var index2 = matchData.length, length = index2;
  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index2--) {
    var data = matchData[index2];
    if (data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }
  while (++index2 < length) {
    data = matchData[index2];
    var key = data[0], objValue = object[key], srcValue = data[1];
    if (data[2]) {
      if (objValue === void 0 && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack();
      var result;
      if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) {
        return false;
      }
    }
  }
  return true;
}
function isStrictComparable(value2) {
  return value2 === value2 && !isObject$2(value2);
}
function getMatchData(object) {
  var result = keys(object), length = result.length;
  while (length--) {
    var key = result[length], value2 = object[key];
    result[length] = [key, value2, isStrictComparable(value2)];
  }
  return result;
}
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
  };
}
function baseMatches(source2) {
  var matchData = getMatchData(source2);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source2 || baseIsMatch(object, source2, matchData);
  };
}
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}
function hasPath(object, path2, hasFunc) {
  path2 = castPath(path2, object);
  var index2 = -1, length = path2.length, result = false;
  while (++index2 < length) {
    var key = toKey(path2[index2]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index2 != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength$1(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
}
function hasIn(object, path2) {
  return object != null && hasPath(object, path2, baseHasIn);
}
var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
function baseMatchesProperty(path2, srcValue) {
  if (isKey(path2) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path2), srcValue);
  }
  return function(object) {
    var objValue = get$1(object, path2);
    return objValue === void 0 && objValue === srcValue ? hasIn(object, path2) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}
function baseProperty(key) {
  return function(object) {
    return object == null ? void 0 : object[key];
  };
}
function basePropertyDeep(path2) {
  return function(object) {
    return baseGet(object, path2);
  };
}
function property$2(path2) {
  return isKey(path2) ? baseProperty(toKey(path2)) : basePropertyDeep(path2);
}
function baseIteratee(value2) {
  if (typeof value2 == "function") {
    return value2;
  }
  if (value2 == null) {
    return identity;
  }
  if (typeof value2 == "object") {
    return isArray(value2) ? baseMatchesProperty(value2[0], value2[1]) : baseMatches(value2);
  }
  return property$2(value2);
}
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index2 = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
    while (length--) {
      var key = props[++index2];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var baseFor = createBaseFor();
function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length, index2 = -1, iterable = Object(collection);
    while (++index2 < length) {
      if (iteratee(iterable[index2], index2, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}
var baseEach = createBaseEach(baseForOwn);
function arrayIncludesWith(array, value2, comparator) {
  var index2 = -1, length = array == null ? 0 : array.length;
  while (++index2 < length) {
    if (comparator(value2, array[index2])) {
      return true;
    }
  }
  return false;
}
function createFind(findIndexFunc) {
  return function(collection, predicate, fromIndex) {
    var iterable = Object(collection);
    if (!isArrayLike(collection)) {
      var iteratee = baseIteratee(predicate);
      collection = keys(collection);
      predicate = function(key) {
        return iteratee(iterable[key], key, iterable);
      };
    }
    var index2 = findIndexFunc(collection, predicate, fromIndex);
    return index2 > -1 ? iterable[iteratee ? collection[index2] : index2] : void 0;
  };
}
var nativeMax = Math.max;
function findIndex(array, predicate, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
  if (index2 < 0) {
    index2 = nativeMax(length + index2, 0);
  }
  return baseFindIndex(array, baseIteratee(predicate), index2);
}
var find = createFind(findIndex);
function baseMap(collection, iteratee) {
  var index2 = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
  baseEach(collection, function(value2, key, collection2) {
    result[++index2] = iteratee(value2, key, collection2);
  });
  return result;
}
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
function baseHas(object, key) {
  return object != null && hasOwnProperty.call(object, key);
}
function has$1(object, path2) {
  return object != null && hasPath(object, path2, baseHas);
}
function isEqual(value2, other) {
  return baseIsEqual(value2, other);
}
function isUndefined(value2) {
  return value2 === void 0;
}
function baseSet(object, path2, value2, customizer) {
  if (!isObject$2(object)) {
    return object;
  }
  path2 = castPath(path2, object);
  var index2 = -1, length = path2.length, lastIndex = length - 1, nested = object;
  while (nested != null && ++index2 < length) {
    var key = toKey(path2[index2]), newValue = value2;
    if (key === "__proto__" || key === "constructor" || key === "prototype") {
      return object;
    }
    if (index2 != lastIndex) {
      var objValue = nested[key];
      newValue = void 0;
      if (newValue === void 0) {
        newValue = isObject$2(objValue) ? objValue : isIndex(path2[index2 + 1]) ? [] : {};
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}
function baseSortBy(array, comparer) {
  var length = array.length;
  array.sort(comparer);
  while (length--) {
    array[length] = array[length].value;
  }
  return array;
}
function compareAscending(value2, other) {
  if (value2 !== other) {
    var valIsDefined = value2 !== void 0, valIsNull = value2 === null, valIsReflexive = value2 === value2, valIsSymbol = isSymbol(value2);
    var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
    if (!othIsNull && !othIsSymbol && !valIsSymbol && value2 > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
      return 1;
    }
    if (!valIsNull && !valIsSymbol && !othIsSymbol && value2 < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
      return -1;
    }
  }
  return 0;
}
function compareMultiple(object, other, orders) {
  var index2 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
  while (++index2 < length) {
    var result = compareAscending(objCriteria[index2], othCriteria[index2]);
    if (result) {
      if (index2 >= ordersLength) {
        return result;
      }
      var order2 = orders[index2];
      return result * (order2 == "desc" ? -1 : 1);
    }
  }
  return object.index - other.index;
}
function baseOrderBy(collection, iteratees, orders) {
  if (iteratees.length) {
    iteratees = arrayMap(iteratees, function(iteratee) {
      if (isArray(iteratee)) {
        return function(value2) {
          return baseGet(value2, iteratee.length === 1 ? iteratee[0] : iteratee);
        };
      }
      return iteratee;
    });
  } else {
    iteratees = [identity];
  }
  var index2 = -1;
  iteratees = arrayMap(iteratees, baseUnary(baseIteratee));
  var result = baseMap(collection, function(value2, key, collection2) {
    var criteria = arrayMap(iteratees, function(iteratee) {
      return iteratee(value2);
    });
    return { "criteria": criteria, "index": ++index2, "value": value2 };
  });
  return baseSortBy(result, function(object, other) {
    return compareMultiple(object, other, orders);
  });
}
function orderBy(collection, iteratees, orders, guard) {
  if (collection == null) {
    return [];
  }
  if (!isArray(iteratees)) {
    iteratees = iteratees == null ? [] : [iteratees];
  }
  orders = orders;
  if (!isArray(orders)) {
    orders = orders == null ? [] : [orders];
  }
  return baseOrderBy(collection, iteratees, orders);
}
function set(object, path2, value2) {
  return object == null ? object : baseSet(object, path2, value2);
}
var sortBy = baseRest(function(collection, iteratees) {
  if (collection == null) {
    return [];
  }
  var length = iteratees.length;
  if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
    iteratees = [];
  } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
    iteratees = [iteratees[0]];
  }
  return baseOrderBy(collection, baseFlatten(iteratees), []);
});
var INFINITY = 1 / 0;
var createSet = !(Set$1 && 1 / setToArray(new Set$1([, -0]))[1] == INFINITY) ? noop$1 : function(values) {
  return new Set$1(values);
};
var LARGE_ARRAY_SIZE = 200;
function baseUniq(array, iteratee, comparator) {
  var index2 = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith;
  } else if (length >= LARGE_ARRAY_SIZE) {
    var set2 = createSet(array);
    if (set2) {
      return setToArray(set2);
    }
    isCommon = false;
    includes = cacheHas;
    seen = new SetCache();
  } else {
    seen = result;
  }
  outer:
    while (++index2 < length) {
      var value2 = array[index2], computed = value2;
      value2 = comparator || value2 !== 0 ? value2 : 0;
      if (isCommon && computed === computed) {
        var seenIndex = seen.length;
        while (seenIndex--) {
          if (seen[seenIndex] === computed) {
            continue outer;
          }
        }
        result.push(value2);
      } else if (!includes(seen, computed, comparator)) {
        if (seen !== result) {
          seen.push(computed);
        }
        result.push(value2);
      }
    }
  return result;
}
function uniqWith(array, comparator) {
  comparator = typeof comparator == "function" ? comparator : void 0;
  return array && array.length ? baseUniq(array, void 0, comparator) : [];
}
const useDeviceTree = ({ managedObject = null, onlyGroup = false }) => {
  const {
    getInventory,
    getChildAssetsList,
    getChildDevicesList,
    homeDeviceInventory,
    homeGroupInventory
  } = useApi();
  const loadData = async ({ managedObject: managedObject2, onlyGroup: onlyGroup2 }) => {
    try {
      let inventory = [];
      if (Array.isArray(managedObject2)) {
        inventory = [...managedObject2];
      } else {
        if (managedObject2 && typeof managedObject2 === "object") {
          inventory = await fetchInventory(managedObject2);
        } else {
          inventory = onlyGroup2 ? [...await homeGroupInventory()] : [
            ...await homeGroupInventory(),
            ...await homeDeviceInventory()
          ];
        }
      }
      const sortedInventory = sortBy(inventory, ["c8y_IsDeviceGroup", "name"]);
      return sortedInventory;
    } catch (error2) {
      throw new Error(`Error fetch data:, ${error2}`);
    }
  };
  const fetchInventory = async (managedObject2, onlyGroup2) => {
    var _a, _b;
    let assets2 = [];
    let devices = [];
    if (((_a = managedObject2 == null ? void 0 : managedObject2.childAssets) == null ? void 0 : _a.references.length) > 0) {
      assets2 = await getChildAssetsList(managedObject2.id).then(
        async (assetList) => {
          const result = await Promise.allSettled(
            assetList.map(
              async (asset2) => asset2.u5s_IsDevice ? await getInventory(asset2.id).then((res) => res.data) : asset2
            )
          );
          return result.map((res) => res.value);
        }
      );
    }
    if (((_b = managedObject2 == null ? void 0 : managedObject2.childDevices) == null ? void 0 : _b.references.length) > 0) {
      devices = await getChildDevicesList(managedObject2.id);
    }
    return [...assets2, ...devices].map((item) => ({
      ...item,
      deviceParents: {
        references: [
          {
            managedObject: {
              name: managedObject2.name,
              id: managedObject2.id
            }
          }
        ]
      }
    }));
  };
  const { data: deviceList } = useSuspenseQuery({
    queryKey: ["deviceTree", managedObject == null ? void 0 : managedObject.id, onlyGroup],
    queryFn: () => loadData({ managedObject, onlyGroup }),
    keepPreviousData: true,
    staleTime: 3e5
  });
  const usePrefetchDeviceTree = ({
    managedObject: managedObject2 = null,
    onlyGroup: onlyGroup2 = false
  }) => {
    const queryClient = useQueryClient();
    const prefetch = () => queryClient.prefetchQuery({
      queryKey: ["deviceTree", managedObject2 == null ? void 0 : managedObject2.id, onlyGroup2],
      queryFn: () => loadData({ managedObject: managedObject2, onlyGroup: onlyGroup2 })
    });
    return { prefetch };
  };
  return { deviceList, usePrefetchDeviceTree };
};
const useDeviceInventory = (sourceId, options) => {
  const { homeDeviceInventory, homeGroupInventory, getInventory } = useApi();
  return useQuery({
    queryKey: ["device", sourceId ? sourceId : "root"],
    queryFn: async () => {
      if (sourceId) {
        try {
          const res = await getInventory(sourceId);
          return res || [];
        } catch (error2) {
          return [];
        }
      }
      try {
        const [group2, device2] = await Promise.all([
          homeGroupInventory(),
          homeDeviceInventory()
        ]);
        return [...device2 || [], ...group2 || []];
      } catch (error2) {
        return [];
      }
    },
    ...options
  });
};
const useIntersectionObserver = ({
  hasNextPage,
  fetchNextPage,
  isFetching,
  threshold: threshold2 = 0.1
}) => {
  const observerTarget = useRef(null);
  const IntersectionObserverCallback = (entries) => {
    if (entries[0].isIntersecting && hasNextPage && !isFetching) {
      fetchNextPage();
    }
  };
  useEffect(() => {
    if (!observerTarget.current) return;
    const observer = new IntersectionObserver(IntersectionObserverCallback, {
      threshold: threshold2
    });
    observer.observe(observerTarget.current);
    return () => {
      if (observerTarget.current) observer.unobserve(observerTarget.current);
    };
  }, [fetchNextPage, threshold2, hasNextPage]);
  return { observerTarget };
};
const useInventoryContext = (sourceId) => {
  const { getInventory } = useApi();
  const { data: context } = useSuspenseQuery({
    queryKey: ["device", sourceId],
    queryFn: () => getInventory(sourceId),
    staleTime: Infinity,
    select: (res) => res.data
  });
  return context;
};
const useRoutingContext = () => {
  var _a, _b;
  const { dashboardId: paramDashboardId, groupId, deviceId } = useParams();
  const { pathname } = useLocation();
  const { getInventoryByFragmentType } = useApi();
  const appName = "dashboard";
  const category = groupId ? "group" : deviceId ? "device" : null;
  const sourceId = groupId || deviceId || null;
  const staticRoute = sourceId === null ? pathname === "/" ? `home-${appName}` : pathname.split("/")[1] : null;
  const { data } = useSuspenseQuery({
    queryKey: [staticRoute],
    queryFn: async () => {
      if (!staticRoute) return null;
      return await getInventoryByFragmentType(
        `u5s_Dashboard!name!${staticRoute}`,
        1
      );
    }
  });
  const dashboardId = staticRoute ? (_b = (_a = data == null ? void 0 : data.data) == null ? void 0 : _a[0]) == null ? void 0 : _b.id : paramDashboardId;
  const subCategory = pathname.split("/")[3];
  return { dashboardId, category, subCategory, sourceId, appName };
};
const useTransitionNavigate = () => {
  const navigate = useNavigate();
  const goTo = (to, replace = false) => {
    startTransition(() => navigate(to, { replace }));
  };
  return { goTo };
};
const UltivisDeviceContext = createContext();
class u5sClass {
  constructor(type2) {
    this.type = type2;
    this.infoList = [];
    this.idSet = /* @__PURE__ */ new Set();
    this.groupMap = /* @__PURE__ */ new Map();
  }
}
const UltivisDeviceProvider = ({ children }) => {
  const [device2, setDevice] = useState(new u5sClass("u5s_IsDevice"));
  const [parent, setParent] = useState(new u5sClass("u5s_IsParent"));
  const { getInventoryByFragmentType, realtimeSub, realtimeUnSub } = useApi();
  useEffect(() => {
    const subscribe = async () => {
      await getAllData(device2, setDevice);
      await getAllData(parent, setParent);
      const subscription = realtimeSub(
        "/managedobjects/*",
        (res) => subscribeLogic(res, device2, setDevice, parent, setParent)
      );
      return () => {
        realtimeUnSub(subscription);
      };
    };
    subscribe();
  }, []);
  const getAllData = async (target2, setTarget) => {
    const pageSize = 2e3;
    const totalCount = await getInventoryByFragmentType(target2.type, 1).then(
      (res) => res.paging.totalPages
    );
    const totalRequestList = Array.from({
      length: Math.ceil(totalCount / pageSize)
    });
    const totalRequest = await Promise.allSettled(
      totalRequestList.map(
        (_, i2) => getInventoryByFragmentType(target2.type, pageSize, i2 + 1).then(
          (res) => res.data
        )
      )
    );
    target2.infoList = totalRequest.flatMap((req) => req.value);
    setGroupMap(target2);
    setTarget({ ...target2 });
  };
  const setGroupMap = (target2) => {
    target2.infoList.forEach((info) => {
      target2.idSet.add(info.id);
      info.assetParents.references.forEach(({ managedObject: { id: id2 } }) => {
        target2.groupMap.set(
          id2,
          target2.groupMap.get(id2) ? target2.groupMap.get(id2).add(info.id) : /* @__PURE__ */ new Set([info.id])
        );
      });
    });
  };
  const subscribeLogic = (res, device22, setDevice2, parent2, setParent2) => {
    const { data, realtimeAction } = res.data;
    if (has$1(data, device22.type)) {
      if (realtimeAction !== "DELETE") return;
      getAllData(device22, setDevice2);
    } else if (has$1(data, parent2.type)) {
      if (realtimeAction !== "DELETE") return;
      getAllData(parent2, setParent2);
    } else if (has$1(data, "c8y_IsDeviceGroup")) {
      updateLogic(data, device22, setDevice2);
      updateLogic(data, parent2, setParent2);
    }
  };
  const updateLogic = (data, target2, setTarget) => {
    const { id: id2 } = data;
    const u5sList = data.childAssets.references.filter(
      ({ managedObject: { id: id22 } }) => target2.idSet.has(id22)
    );
    const assignedGroup = target2.groupMap.get(id2);
    if (u5sList.length === 0 && !assignedGroup) return;
    if (assignedGroup) {
      const isExisted = u5sList.every((device22) => assignedGroup.has(device22.id));
      if (!isExisted) return;
    }
    getAllData(target2, setTarget);
  };
  const getDeviceList = () => device2.infoList;
  const getTotalDeviceCount = () => device2.infoList.length;
  const getDeviceIdList = () => [...device2.idSet];
  const getDeviceById = (id2) => device2.infoList.filter(({ id: deviceId }) => deviceId === id2)[0];
  const getDeviceListForGroup = (groupId) => {
    const getMap = device2.groupMap.get(groupId) ?? [];
    return [...getMap];
  };
  const isUltivisDevice = (id2) => device2.idSet.has(id2);
  const isDeviceAssignedGroup = (deviceId, groupId) => {
    var _a;
    return !!((_a = device2.groupMap.get(groupId)) == null ? void 0 : _a.has(deviceId)) || false;
  };
  const getParentList = () => parent.infoList;
  const getTotalParentCount = () => parent.infoList.length;
  const getParentIdList = () => [...parent.idSet];
  const getParentById = (id2) => parent.infoList.filter(({ id: parentId }) => parentId === id2)[0];
  const getParentListForGroup = (groupId) => {
    const getMap = parent.groupMap.get(groupId) ?? [];
    return [...getMap];
  };
  const isUltivisParent = (id2) => parent.idSet.has(id2);
  const isParentAssignedGroup = (parentId, groupId) => {
    var _a;
    return !!((_a = parent.groupMap.get(groupId)) == null ? void 0 : _a.has(parentId)) || false;
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    UltivisDeviceContext.Provider,
    {
      value: {
        getDeviceList,
        getTotalDeviceCount,
        getDeviceIdList,
        getDeviceById,
        getDeviceListForGroup,
        isUltivisDevice,
        isDeviceAssignedGroup,
        getParentList,
        getTotalParentCount,
        getParentIdList,
        getParentById,
        getParentListForGroup,
        isUltivisParent,
        isParentAssignedGroup
      },
      children
    }
  );
};
const useUltivisDeviceContext = () => {
  return useContext(UltivisDeviceContext);
};
const useUltivisLogic = () => {
  const { getDeviceById } = useUltivisDeviceContext();
  const ultivisLogic = (key, dataList, u5sOrigin) => {
    switch (u5sOrigin) {
      case null:
        return dataList.map((item) => {
          return { ...item, original: item[key] };
        });
      case "parent":
        return dataList.reduce((acc, item) => {
          if (!item[key].includes("|"))
            acc.push({ ...item, original: item[key] });
          return acc;
        }, []);
      default:
        return dataList.reduce((acc, item) => {
          const [source2, originalKey] = item[key].split("|");
          if (source2 === u5sOrigin)
            acc.push({ ...item, original: originalKey });
          return acc;
        }, []);
    }
  };
  const methods = {
    dataTypeProperty: {
      datapoints: "fragment",
      events: "type",
      alarms: "type"
    },
    measurementLogic: (supportedMeasurementList, u5sOrigin) => ultivisLogic("fragment", supportedMeasurementList, u5sOrigin),
    eventAlarmLogic: (typeList, u5sOrigin) => ultivisLogic("type", typeList, u5sOrigin),
    customFragmentLogic: (fragmentType, fragment2, u5sOrigin) => {
      switch (u5sOrigin) {
        case null:
        case "parent":
          return { [fragmentType]: fragment2, original: fragment2 };
        default:
          return {
            [fragmentType]: `${u5sOrigin}|${fragment2}`,
            original: fragment2
          };
      }
    },
    u5sOriginLogic: (managedObject) => {
      if (!managedObject) return;
      const { id: id2, name: name2, u5s_IsParent, u5s_IsDevice } = managedObject;
      const origin2 = { id: id2, name: name2 };
      let target2, u5sOrigin;
      if (u5s_IsDevice) {
        const parent = getDeviceById(id2).deviceParents.references[0].managedObject;
        target2 = { id: parent.id, name: parent.name };
        u5sOrigin = id2;
      } else {
        target2 = { id: id2, name: name2 };
        u5sOrigin = u5s_IsParent ? "parent" : null;
      }
      return { target: target2, u5sOrigin, origin: origin2 };
    },
    u5sTargetLogic: (originalProperty, context) => {
      const { target: target2, origin: origin2 } = methods.u5sOriginLogic(context);
      let newProperty = { ...originalProperty };
      set(newProperty, "__target", target2);
      if (has$1(newProperty, "fragment") && has$1(newProperty, "series")) {
        set(
          newProperty,
          "fragment",
          `${origin2.id}|${originalProperty.__original.fragment}`
        );
      } else {
        set(
          newProperty,
          "type",
          `${origin2.id}|${originalProperty.__original.type}`
        );
      }
      return newProperty;
    },
    u5sPropertyLogic: (originalProperty, context, targetPath) => {
      const { target: target2, origin: origin2 } = methods.u5sOriginLogic(context);
      let newProperty = { ...originalProperty };
      let [_, dataProperty, targetFragment] = get$1(
        newProperty,
        targetPath
      ).split(".");
      let newTargetPath = `${origin2.id}.${dataProperty}.${targetFragment}`;
      if (newProperty.computed === true && targetFragment.includes("|")) {
        const [_2, fragment2] = targetFragment.split("|");
        newTargetPath = `${target2.id}.${dataProperty}.${target2.id}|${fragment2}`;
      }
      set(newProperty, targetPath, newTargetPath);
      return newProperty;
    },
    getParsedPropertyList: (propertyList, dataType) => {
      return propertyList.map((property2) => {
        const targetProperty = methods.dataTypeProperty[dataType];
        return {
          ...property2,
          [targetProperty]: property2[targetProperty].includes("|") ? property2[targetProperty].split("|")[1] : property2[targetProperty]
        };
      });
    },
    //      
    deviceTypeDashboardForData: (dataList, context) => {
      if (has$1(context, "c8y_IsDevice")) {
        return dataList == null ? void 0 : dataList.map((data) => {
          data.__target = {
            name: context.name,
            id: context.id
          };
          return data;
        });
      } else if (has$1(context, "u5s_IsParent") || has$1(context, "u5s_IsDevice")) {
        return dataList == null ? void 0 : dataList.map((data) => methods.u5sTargetLogic(data, context));
      } else {
        return dataList;
      }
    },
    // propertyList (assetProperty, assetTable, svg)
    // NOTE :  
    deviceTypeDashboardForProperty: (propertyList, context, path2 = "targetPath") => {
      if (has$1(context, "c8y_IsDevice") || has$1(context, "u5s_IsParent") || has$1(context, "u5s_IsDevice")) {
        return propertyList == null ? void 0 : propertyList.map(
          (property2) => methods.u5sPropertyLogic(property2, context, path2)
        );
      } else {
        return propertyList;
      }
    }
  };
  return methods;
};
const encodeAuth = ({ tenant: tenant2, user, password: password2 }) => btoa(`${tenant2}/${user}:${password2}`);
const setBasicAuth = ({ tenant: tenant2, user, password: password2 }) => sessionStorage.setItem("_tcy8", encodeAuth({ tenant: tenant2, user, password: password2 }));
function r$2(e) {
  var t2, f, n2 = "";
  if ("string" == typeof e || "number" == typeof e) n2 += e;
  else if ("object" == typeof e) if (Array.isArray(e)) {
    var o2 = e.length;
    for (t2 = 0; t2 < o2; t2++) e[t2] && (f = r$2(e[t2])) && (n2 && (n2 += " "), n2 += f);
  } else for (f in e) e[f] && (n2 && (n2 += " "), n2 += f);
  return n2;
}
function clsx$2() {
  for (var e, t2, f = 0, n2 = "", o2 = arguments.length; f < o2; f++) (e = arguments[f]) && (t2 = r$2(e)) && (n2 && (n2 += " "), n2 += t2);
  return n2;
}
const CLASS_PART_SEPARATOR = "-";
const createClassGroupUtils = (config) => {
  const classMap = createClassMap(config);
  const {
    conflictingClassGroups,
    conflictingClassGroupModifiers
  } = config;
  const getClassGroupId = (className) => {
    const classParts = className.split(CLASS_PART_SEPARATOR);
    if (classParts[0] === "" && classParts.length !== 1) {
      classParts.shift();
    }
    return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className);
  };
  const getConflictingClassGroupIds = (classGroupId, hasPostfixModifier) => {
    const conflicts = conflictingClassGroups[classGroupId] || [];
    if (hasPostfixModifier && conflictingClassGroupModifiers[classGroupId]) {
      return [...conflicts, ...conflictingClassGroupModifiers[classGroupId]];
    }
    return conflicts;
  };
  return {
    getClassGroupId,
    getConflictingClassGroupIds
  };
};
const getGroupRecursive = (classParts, classPartObject) => {
  var _a;
  if (classParts.length === 0) {
    return classPartObject.classGroupId;
  }
  const currentClassPart = classParts[0];
  const nextClassPartObject = classPartObject.nextPart.get(currentClassPart);
  const classGroupFromNextClassPart = nextClassPartObject ? getGroupRecursive(classParts.slice(1), nextClassPartObject) : void 0;
  if (classGroupFromNextClassPart) {
    return classGroupFromNextClassPart;
  }
  if (classPartObject.validators.length === 0) {
    return void 0;
  }
  const classRest = classParts.join(CLASS_PART_SEPARATOR);
  return (_a = classPartObject.validators.find(({
    validator
  }) => validator(classRest))) == null ? void 0 : _a.classGroupId;
};
const arbitraryPropertyRegex = /^\[(.+)\]$/;
const getGroupIdForArbitraryProperty = (className) => {
  if (arbitraryPropertyRegex.test(className)) {
    const arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className)[1];
    const property2 = arbitraryPropertyClassName == null ? void 0 : arbitraryPropertyClassName.substring(0, arbitraryPropertyClassName.indexOf(":"));
    if (property2) {
      return "arbitrary.." + property2;
    }
  }
};
const createClassMap = (config) => {
  const {
    theme,
    prefix
  } = config;
  const classMap = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  const prefixedClassGroupEntries = getPrefixedClassGroupEntries(Object.entries(config.classGroups), prefix);
  prefixedClassGroupEntries.forEach(([classGroupId, classGroup]) => {
    processClassesRecursively(classGroup, classMap, classGroupId, theme);
  });
  return classMap;
};
const processClassesRecursively = (classGroup, classPartObject, classGroupId, theme) => {
  classGroup.forEach((classDefinition) => {
    if (typeof classDefinition === "string") {
      const classPartObjectToEdit = classDefinition === "" ? classPartObject : getPart(classPartObject, classDefinition);
      classPartObjectToEdit.classGroupId = classGroupId;
      return;
    }
    if (typeof classDefinition === "function") {
      if (isThemeGetter(classDefinition)) {
        processClassesRecursively(classDefinition(theme), classPartObject, classGroupId, theme);
        return;
      }
      classPartObject.validators.push({
        validator: classDefinition,
        classGroupId
      });
      return;
    }
    Object.entries(classDefinition).forEach(([key, classGroup2]) => {
      processClassesRecursively(classGroup2, getPart(classPartObject, key), classGroupId, theme);
    });
  });
};
const getPart = (classPartObject, path2) => {
  let currentClassPartObject = classPartObject;
  path2.split(CLASS_PART_SEPARATOR).forEach((pathPart) => {
    if (!currentClassPartObject.nextPart.has(pathPart)) {
      currentClassPartObject.nextPart.set(pathPart, {
        nextPart: /* @__PURE__ */ new Map(),
        validators: []
      });
    }
    currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);
  });
  return currentClassPartObject;
};
const isThemeGetter = (func) => func.isThemeGetter;
const getPrefixedClassGroupEntries = (classGroupEntries, prefix) => {
  if (!prefix) {
    return classGroupEntries;
  }
  return classGroupEntries.map(([classGroupId, classGroup]) => {
    const prefixedClassGroup = classGroup.map((classDefinition) => {
      if (typeof classDefinition === "string") {
        return prefix + classDefinition;
      }
      if (typeof classDefinition === "object") {
        return Object.fromEntries(Object.entries(classDefinition).map(([key, value2]) => [prefix + key, value2]));
      }
      return classDefinition;
    });
    return [classGroupId, prefixedClassGroup];
  });
};
const createLruCache = (maxCacheSize) => {
  if (maxCacheSize < 1) {
    return {
      get: () => void 0,
      set: () => {
      }
    };
  }
  let cacheSize = 0;
  let cache = /* @__PURE__ */ new Map();
  let previousCache = /* @__PURE__ */ new Map();
  const update = (key, value2) => {
    cache.set(key, value2);
    cacheSize++;
    if (cacheSize > maxCacheSize) {
      cacheSize = 0;
      previousCache = cache;
      cache = /* @__PURE__ */ new Map();
    }
  };
  return {
    get(key) {
      let value2 = cache.get(key);
      if (value2 !== void 0) {
        return value2;
      }
      if ((value2 = previousCache.get(key)) !== void 0) {
        update(key, value2);
        return value2;
      }
    },
    set(key, value2) {
      if (cache.has(key)) {
        cache.set(key, value2);
      } else {
        update(key, value2);
      }
    }
  };
};
const IMPORTANT_MODIFIER = "!";
const createParseClassName = (config) => {
  const {
    separator,
    experimentalParseClassName
  } = config;
  const isSeparatorSingleCharacter = separator.length === 1;
  const firstSeparatorCharacter = separator[0];
  const separatorLength = separator.length;
  const parseClassName = (className) => {
    const modifiers = [];
    let bracketDepth = 0;
    let modifierStart = 0;
    let postfixModifierPosition;
    for (let index2 = 0; index2 < className.length; index2++) {
      let currentCharacter = className[index2];
      if (bracketDepth === 0) {
        if (currentCharacter === firstSeparatorCharacter && (isSeparatorSingleCharacter || className.slice(index2, index2 + separatorLength) === separator)) {
          modifiers.push(className.slice(modifierStart, index2));
          modifierStart = index2 + separatorLength;
          continue;
        }
        if (currentCharacter === "/") {
          postfixModifierPosition = index2;
          continue;
        }
      }
      if (currentCharacter === "[") {
        bracketDepth++;
      } else if (currentCharacter === "]") {
        bracketDepth--;
      }
    }
    const baseClassNameWithImportantModifier = modifiers.length === 0 ? className : className.substring(modifierStart);
    const hasImportantModifier = baseClassNameWithImportantModifier.startsWith(IMPORTANT_MODIFIER);
    const baseClassName = hasImportantModifier ? baseClassNameWithImportantModifier.substring(1) : baseClassNameWithImportantModifier;
    const maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : void 0;
    return {
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    };
  };
  if (experimentalParseClassName) {
    return (className) => experimentalParseClassName({
      className,
      parseClassName
    });
  }
  return parseClassName;
};
const sortModifiers = (modifiers) => {
  if (modifiers.length <= 1) {
    return modifiers;
  }
  const sortedModifiers = [];
  let unsortedModifiers = [];
  modifiers.forEach((modifier) => {
    const isArbitraryVariant = modifier[0] === "[";
    if (isArbitraryVariant) {
      sortedModifiers.push(...unsortedModifiers.sort(), modifier);
      unsortedModifiers = [];
    } else {
      unsortedModifiers.push(modifier);
    }
  });
  sortedModifiers.push(...unsortedModifiers.sort());
  return sortedModifiers;
};
const createConfigUtils = (config) => ({
  cache: createLruCache(config.cacheSize),
  parseClassName: createParseClassName(config),
  ...createClassGroupUtils(config)
});
const SPLIT_CLASSES_REGEX = /\s+/;
const mergeClassList = (classList, configUtils) => {
  const {
    parseClassName,
    getClassGroupId,
    getConflictingClassGroupIds
  } = configUtils;
  const classGroupsInConflict = [];
  const classNames = classList.trim().split(SPLIT_CLASSES_REGEX);
  let result = "";
  for (let index2 = classNames.length - 1; index2 >= 0; index2 -= 1) {
    const originalClassName = classNames[index2];
    const {
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    } = parseClassName(originalClassName);
    let hasPostfixModifier = Boolean(maybePostfixModifierPosition);
    let classGroupId = getClassGroupId(hasPostfixModifier ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);
    if (!classGroupId) {
      if (!hasPostfixModifier) {
        result = originalClassName + (result.length > 0 ? " " + result : result);
        continue;
      }
      classGroupId = getClassGroupId(baseClassName);
      if (!classGroupId) {
        result = originalClassName + (result.length > 0 ? " " + result : result);
        continue;
      }
      hasPostfixModifier = false;
    }
    const variantModifier = sortModifiers(modifiers).join(":");
    const modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;
    const classId = modifierId + classGroupId;
    if (classGroupsInConflict.includes(classId)) {
      continue;
    }
    classGroupsInConflict.push(classId);
    const conflictGroups = getConflictingClassGroupIds(classGroupId, hasPostfixModifier);
    for (let i2 = 0; i2 < conflictGroups.length; ++i2) {
      const group2 = conflictGroups[i2];
      classGroupsInConflict.push(modifierId + group2);
    }
    result = originalClassName + (result.length > 0 ? " " + result : result);
  }
  return result;
};
function twJoin() {
  let index2 = 0;
  let argument;
  let resolvedValue;
  let string = "";
  while (index2 < arguments.length) {
    if (argument = arguments[index2++]) {
      if (resolvedValue = toValue(argument)) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
}
const toValue = (mix) => {
  if (typeof mix === "string") {
    return mix;
  }
  let resolvedValue;
  let string = "";
  for (let k = 0; k < mix.length; k++) {
    if (mix[k]) {
      if (resolvedValue = toValue(mix[k])) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
};
function createTailwindMerge(createConfigFirst, ...createConfigRest) {
  let configUtils;
  let cacheGet;
  let cacheSet;
  let functionToCall = initTailwindMerge;
  function initTailwindMerge(classList) {
    const config = createConfigRest.reduce((previousConfig, createConfigCurrent) => createConfigCurrent(previousConfig), createConfigFirst());
    configUtils = createConfigUtils(config);
    cacheGet = configUtils.cache.get;
    cacheSet = configUtils.cache.set;
    functionToCall = tailwindMerge;
    return tailwindMerge(classList);
  }
  function tailwindMerge(classList) {
    const cachedResult = cacheGet(classList);
    if (cachedResult) {
      return cachedResult;
    }
    const result = mergeClassList(classList, configUtils);
    cacheSet(classList, result);
    return result;
  }
  return function callTailwindMerge() {
    return functionToCall(twJoin.apply(null, arguments));
  };
}
const fromTheme = (key) => {
  const themeGetter = (theme) => theme[key] || [];
  themeGetter.isThemeGetter = true;
  return themeGetter;
};
const arbitraryValueRegex = /^\[(?:([a-z-]+):)?(.+)\]$/i;
const fractionRegex = /^\d+\/\d+$/;
const stringLengths = /* @__PURE__ */ new Set(["px", "full", "screen"]);
const tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/;
const lengthUnitRegex = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/;
const colorFunctionRegex = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/;
const shadowRegex = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
const imageRegex = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
const isLength = (value2) => isNumber$1(value2) || stringLengths.has(value2) || fractionRegex.test(value2);
const isArbitraryLength = (value2) => getIsArbitraryValue(value2, "length", isLengthOnly);
const isNumber$1 = (value2) => Boolean(value2) && !Number.isNaN(Number(value2));
const isArbitraryNumber = (value2) => getIsArbitraryValue(value2, "number", isNumber$1);
const isInteger = (value2) => Boolean(value2) && Number.isInteger(Number(value2));
const isPercent = (value2) => value2.endsWith("%") && isNumber$1(value2.slice(0, -1));
const isArbitraryValue = (value2) => arbitraryValueRegex.test(value2);
const isTshirtSize = (value2) => tshirtUnitRegex.test(value2);
const sizeLabels = /* @__PURE__ */ new Set(["length", "size", "percentage"]);
const isArbitrarySize = (value2) => getIsArbitraryValue(value2, sizeLabels, isNever);
const isArbitraryPosition = (value2) => getIsArbitraryValue(value2, "position", isNever);
const imageLabels = /* @__PURE__ */ new Set(["image", "url"]);
const isArbitraryImage = (value2) => getIsArbitraryValue(value2, imageLabels, isImage);
const isArbitraryShadow = (value2) => getIsArbitraryValue(value2, "", isShadow);
const isAny = () => true;
const getIsArbitraryValue = (value2, label2, testValue) => {
  const result = arbitraryValueRegex.exec(value2);
  if (result) {
    if (result[1]) {
      return typeof label2 === "string" ? result[1] === label2 : label2.has(result[1]);
    }
    return testValue(result[2]);
  }
  return false;
};
const isLengthOnly = (value2) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  lengthUnitRegex.test(value2) && !colorFunctionRegex.test(value2)
);
const isNever = () => false;
const isShadow = (value2) => shadowRegex.test(value2);
const isImage = (value2) => imageRegex.test(value2);
const getDefaultConfig = () => {
  const colors = fromTheme("colors");
  const spacing = fromTheme("spacing");
  const blur = fromTheme("blur");
  const brightness = fromTheme("brightness");
  const borderColor = fromTheme("borderColor");
  const borderRadius = fromTheme("borderRadius");
  const borderSpacing = fromTheme("borderSpacing");
  const borderWidth = fromTheme("borderWidth");
  const contrast = fromTheme("contrast");
  const grayscale = fromTheme("grayscale");
  const hueRotate = fromTheme("hueRotate");
  const invert = fromTheme("invert");
  const gap = fromTheme("gap");
  const gradientColorStops = fromTheme("gradientColorStops");
  const gradientColorStopPositions = fromTheme("gradientColorStopPositions");
  const inset = fromTheme("inset");
  const margin = fromTheme("margin");
  const opacity = fromTheme("opacity");
  const padding = fromTheme("padding");
  const saturate = fromTheme("saturate");
  const scale = fromTheme("scale");
  const sepia = fromTheme("sepia");
  const skew = fromTheme("skew");
  const space = fromTheme("space");
  const translate2 = fromTheme("translate");
  const getOverscroll = () => ["auto", "contain", "none"];
  const getOverflow = () => ["auto", "hidden", "clip", "visible", "scroll"];
  const getSpacingWithAutoAndArbitrary = () => ["auto", isArbitraryValue, spacing];
  const getSpacingWithArbitrary = () => [isArbitraryValue, spacing];
  const getLengthWithEmptyAndArbitrary = () => ["", isLength, isArbitraryLength];
  const getNumberWithAutoAndArbitrary = () => ["auto", isNumber$1, isArbitraryValue];
  const getPositions = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"];
  const getLineStyles = () => ["solid", "dashed", "dotted", "double", "none"];
  const getBlendModes = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"];
  const getAlign = () => ["start", "end", "center", "between", "around", "evenly", "stretch"];
  const getZeroAndEmpty = () => ["", "0", isArbitraryValue];
  const getBreaks = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"];
  const getNumberAndArbitrary = () => [isNumber$1, isArbitraryValue];
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [isAny],
      spacing: [isLength, isArbitraryLength],
      blur: ["none", "", isTshirtSize, isArbitraryValue],
      brightness: getNumberAndArbitrary(),
      borderColor: [colors],
      borderRadius: ["none", "", "full", isTshirtSize, isArbitraryValue],
      borderSpacing: getSpacingWithArbitrary(),
      borderWidth: getLengthWithEmptyAndArbitrary(),
      contrast: getNumberAndArbitrary(),
      grayscale: getZeroAndEmpty(),
      hueRotate: getNumberAndArbitrary(),
      invert: getZeroAndEmpty(),
      gap: getSpacingWithArbitrary(),
      gradientColorStops: [colors],
      gradientColorStopPositions: [isPercent, isArbitraryLength],
      inset: getSpacingWithAutoAndArbitrary(),
      margin: getSpacingWithAutoAndArbitrary(),
      opacity: getNumberAndArbitrary(),
      padding: getSpacingWithArbitrary(),
      saturate: getNumberAndArbitrary(),
      scale: getNumberAndArbitrary(),
      sepia: getZeroAndEmpty(),
      skew: getNumberAndArbitrary(),
      space: getSpacingWithArbitrary(),
      translate: getSpacingWithArbitrary()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", isArbitraryValue]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [isTshirtSize]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": getBreaks()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": getBreaks()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...getPositions(), isArbitraryValue]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: getOverflow()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": getOverflow()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": getOverflow()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: getOverscroll()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": getOverscroll()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": getOverscroll()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [inset]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [inset]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [inset]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [inset]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [inset]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [inset]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [inset]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [inset]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [inset]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", isInteger, isArbitraryValue]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: getSpacingWithAutoAndArbitrary()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", isArbitraryValue]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: getZeroAndEmpty()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: getZeroAndEmpty()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", isInteger, isArbitraryValue]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [isAny]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", isInteger, isArbitraryValue]
        }, isArbitraryValue]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [isAny]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [isInteger, isArbitraryValue]
        }, isArbitraryValue]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", isArbitraryValue]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", isArbitraryValue]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [gap]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [gap]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [gap]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal", ...getAlign()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...getAlign(), "baseline"]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [...getAlign(), "baseline"]
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [padding]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [padding]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [padding]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [padding]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [padding]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [padding]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [padding]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [padding]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [padding]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [margin]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [margin]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [margin]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [margin]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [margin]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [margin]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [margin]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [margin]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [margin]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [space]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [space]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", isArbitraryValue, spacing]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [isArbitraryValue, spacing, "min", "max", "fit"]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [isArbitraryValue, spacing, "none", "full", "min", "max", "fit", "prose", {
          screen: [isTshirtSize]
        }, isTshirtSize]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [isArbitraryValue, spacing, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": [isArbitraryValue, spacing, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [isArbitraryValue, spacing, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */
      size: [{
        size: [isArbitraryValue, spacing, "auto", "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", isTshirtSize, isArbitraryLength]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", isArbitraryNumber]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [isAny]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", isArbitraryValue]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", isNumber$1, isArbitraryNumber]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", isLength, isArbitraryValue]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", isArbitraryValue]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", isArbitraryValue]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [colors]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [opacity]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [colors]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [opacity]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...getLineStyles(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", isLength, isArbitraryLength]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", isLength, isArbitraryValue]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [colors]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: getSpacingWithArbitrary()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", isArbitraryValue]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", isArbitraryValue]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [opacity]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...getPositions(), isArbitraryPosition]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", isArbitrarySize]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, isArbitraryImage]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [colors]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [gradientColorStops]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [gradientColorStops]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [gradientColorStops]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [borderRadius]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [borderRadius]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [borderRadius]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [borderRadius]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [borderRadius]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [borderRadius]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [borderRadius]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [borderRadius]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [borderRadius]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [borderRadius]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [borderRadius]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [borderRadius]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [borderRadius]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [borderRadius]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [borderRadius]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [borderWidth]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [borderWidth]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [borderWidth]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [borderWidth]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [borderWidth]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [borderWidth]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [borderWidth]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [borderWidth]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [borderWidth]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [opacity]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...getLineStyles(), "hidden"]
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [borderWidth]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [borderWidth]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [opacity]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: getLineStyles()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [borderColor]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [borderColor]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [borderColor]
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": [borderColor]
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": [borderColor]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [borderColor]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [borderColor]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [borderColor]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [borderColor]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [borderColor]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: ["", ...getLineStyles()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [isLength, isArbitraryValue]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [isLength, isArbitraryLength]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [colors]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: getLengthWithEmptyAndArbitrary()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [colors]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [opacity]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [isLength, isArbitraryLength]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [colors]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", isTshirtSize, isArbitraryShadow]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [isAny]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [opacity]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...getBlendModes(), "plus-lighter", "plus-darker"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": getBlendModes()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [blur]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [brightness]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [contrast]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", isTshirtSize, isArbitraryValue]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [grayscale]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [hueRotate]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [invert]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [saturate]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [sepia]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [blur]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [brightness]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [contrast]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [grayscale]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [hueRotate]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [invert]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [opacity]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [saturate]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [sepia]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [borderSpacing]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [borderSpacing]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [borderSpacing]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", isArbitraryValue]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: getNumberAndArbitrary()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", isArbitraryValue]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: getNumberAndArbitrary()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", isArbitraryValue]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [scale]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [scale]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [scale]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [isInteger, isArbitraryValue]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [translate2]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [translate2]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [skew]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [skew]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", isArbitraryValue]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", colors]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", isArbitraryValue]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [colors]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", isArbitraryValue]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [colors, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [isLength, isArbitraryLength, isArbitraryNumber]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [colors, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
};
const twMerge = /* @__PURE__ */ createTailwindMerge(getDefaultConfig);
function cn(...inputs) {
  return twMerge(clsx$2(inputs));
}
const deviceTypeDashboardForDevice = (config, context) => {
  if (has$1(context, "u5s_IsParent") || has$1(context, "c8y_IsDevice")) {
    return {
      ...config,
      device: {
        id: context.id,
        name: context.name
      }
    };
  } else if (has$1(context, "u5s_IsDevice")) {
    const managedObject = context.deviceParents.references[0].managedObject;
    return {
      ...config,
      device: {
        name: managedObject.name,
        id: managedObject.id
      }
    };
  }
  return config;
};
const isSameDatapoint = (d1, d2) => {
  return (d1 == null ? void 0 : d1.fragment) === (d2 == null ? void 0 : d2.fragment) && (d1 == null ? void 0 : d1.series) === (d2 == null ? void 0 : d2.series) && (d1 == null ? void 0 : d1.__target.id) === (d2 == null ? void 0 : d2.__target.id);
};
const getActiveData = (dataList) => {
  return (dataList == null ? void 0 : dataList.filter((data) => data.__active)) ?? [];
};
const getDatapointsFromLocal = (id2, category, withActive = false) => {
  const datapoints2 = JSON.parse(
    localStorage.getItem(`datapoints_${category}_${id2}`) || "[]"
  );
  return withActive ? datapoints2 : datapoints2 == null ? void 0 : datapoints2.map((datapoint) => {
    datapoint.__active = false;
    return datapoint;
  });
};
const setDatapointsToLocal = (id2, category, newDataPoints) => {
  const datapoints2 = newDataPoints.map((datapoint) => {
    if (Object.prototype.hasOwnProperty.call(datapoint, "yAxisType")) {
      const { yAxisType, ...data } = datapoint;
      return yAxisType ? { yAxisType, ...data } : data;
    } else {
      const { ...data } = datapoint;
      return data;
    }
  });
  localStorage.setItem(
    `datapoints_${category}_${id2}`,
    JSON.stringify(datapoints2)
  );
};
const getTypesFromLocal = (id2, category, dataType) => {
  var _a;
  const typeList = (_a = JSON.parse(
    localStorage.getItem(`${dataType}_${category}_${id2}`) || "[]"
  )) == null ? void 0 : _a.map((type2) => {
    type2.__active = false;
    return type2;
  });
  return typeList;
};
const setTypesToLocal = (id2, category, dataType, newTypeList) => {
  const typeList = newTypeList.map((type2) => {
    const { ...data } = type2;
    return data;
  });
  localStorage.setItem(
    `${dataType}_${category}_${id2}`,
    JSON.stringify(typeList)
  );
};
const isSameType = (t1, t2) => {
  return t1.type === t2.type;
};
const isSameId = (t1, t2) => {
  return t1.id === t2.id;
};
const translate = (text2, appName) => {
  return text2.replace("{{ appName }}", appName);
};
const getAppName = (appNameOrApp) => {
  const appName = getFirstDefined([
    get$1(appNameOrApp, "name"),
    get$1(appNameOrApp, "contextPath"),
    typeof appNameOrApp === "string" ? appNameOrApp : void 0,
    "<no name>"
  ]);
  return humanize(appName);
};
const getFirstDefined = (values) => {
  return find(values, (val) => !isUndefined(val));
};
const isPublicApp = (appNameOrApp) => {
  return Boolean(get$1(appNameOrApp, "public"));
};
const humanize = (str = "") => {
  const result = str.replace(/_/g, " ").split("");
  result[0] = (result[0] || "").toUpperCase();
  return result.join("");
};
const humanizeAppName = (appNameOrApp) => {
  if (!appNameOrApp) {
    return "";
  }
  const appName = getAppName(appNameOrApp);
  if (isPublicApp(appNameOrApp)) {
    return translate("{{ appName }} (public)", appName);
  }
  return appName;
};
const isString$1 = (obj) => typeof obj === "string";
const defer = () => {
  let res;
  let rej;
  const promise = new Promise((resolve, reject) => {
    res = resolve;
    rej = reject;
  });
  promise.resolve = res;
  promise.reject = rej;
  return promise;
};
const makeString = (object) => {
  if (object == null) return "";
  return "" + object;
};
const copy = (a, s2, t2) => {
  a.forEach((m) => {
    if (s2[m]) t2[m] = s2[m];
  });
};
const lastOfPathSeparatorRegExp = /###/g;
const cleanKey = (key) => key && key.indexOf("###") > -1 ? key.replace(lastOfPathSeparatorRegExp, ".") : key;
const canNotTraverseDeeper = (object) => !object || isString$1(object);
const getLastOfPath = (object, path2, Empty) => {
  const stack = !isString$1(path2) ? path2 : path2.split(".");
  let stackIndex = 0;
  while (stackIndex < stack.length - 1) {
    if (canNotTraverseDeeper(object)) return {};
    const key = cleanKey(stack[stackIndex]);
    if (!object[key] && Empty) object[key] = new Empty();
    if (Object.prototype.hasOwnProperty.call(object, key)) {
      object = object[key];
    } else {
      object = {};
    }
    ++stackIndex;
  }
  if (canNotTraverseDeeper(object)) return {};
  return {
    obj: object,
    k: cleanKey(stack[stackIndex])
  };
};
const setPath = (object, path2, newValue) => {
  const {
    obj,
    k
  } = getLastOfPath(object, path2, Object);
  if (obj !== void 0 || path2.length === 1) {
    obj[k] = newValue;
    return;
  }
  let e = path2[path2.length - 1];
  let p = path2.slice(0, path2.length - 1);
  let last2 = getLastOfPath(object, p, Object);
  while (last2.obj === void 0 && p.length) {
    e = `${p[p.length - 1]}.${e}`;
    p = p.slice(0, p.length - 1);
    last2 = getLastOfPath(object, p, Object);
    if (last2 && last2.obj && typeof last2.obj[`${last2.k}.${e}`] !== "undefined") {
      last2.obj = void 0;
    }
  }
  last2.obj[`${last2.k}.${e}`] = newValue;
};
const pushPath = (object, path2, newValue, concat) => {
  const {
    obj,
    k
  } = getLastOfPath(object, path2, Object);
  obj[k] = obj[k] || [];
  obj[k].push(newValue);
};
const getPath = (object, path2) => {
  const {
    obj,
    k
  } = getLastOfPath(object, path2);
  if (!obj) return void 0;
  return obj[k];
};
const getPathWithDefaults = (data, defaultData, key) => {
  const value2 = getPath(data, key);
  if (value2 !== void 0) {
    return value2;
  }
  return getPath(defaultData, key);
};
const deepExtend = (target2, source2, overwrite) => {
  for (const prop in source2) {
    if (prop !== "__proto__" && prop !== "constructor") {
      if (prop in target2) {
        if (isString$1(target2[prop]) || target2[prop] instanceof String || isString$1(source2[prop]) || source2[prop] instanceof String) {
          if (overwrite) target2[prop] = source2[prop];
        } else {
          deepExtend(target2[prop], source2[prop], overwrite);
        }
      } else {
        target2[prop] = source2[prop];
      }
    }
  }
  return target2;
};
const regexEscape = (str) => str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
var _entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
const escape = (data) => {
  if (isString$1(data)) {
    return data.replace(/[&<>"'\/]/g, (s2) => _entityMap[s2]);
  }
  return data;
};
class RegExpCache {
  constructor(capacity) {
    this.capacity = capacity;
    this.regExpMap = /* @__PURE__ */ new Map();
    this.regExpQueue = [];
  }
  getRegExp(pattern) {
    const regExpFromCache = this.regExpMap.get(pattern);
    if (regExpFromCache !== void 0) {
      return regExpFromCache;
    }
    const regExpNew = new RegExp(pattern);
    if (this.regExpQueue.length === this.capacity) {
      this.regExpMap.delete(this.regExpQueue.shift());
    }
    this.regExpMap.set(pattern, regExpNew);
    this.regExpQueue.push(pattern);
    return regExpNew;
  }
}
const chars = [" ", ",", "?", "!", ";"];
const looksLikeObjectPathRegExpCache = new RegExpCache(20);
const looksLikeObjectPath = (key, nsSeparator, keySeparator) => {
  nsSeparator = nsSeparator || "";
  keySeparator = keySeparator || "";
  const possibleChars = chars.filter((c) => nsSeparator.indexOf(c) < 0 && keySeparator.indexOf(c) < 0);
  if (possibleChars.length === 0) return true;
  const r2 = looksLikeObjectPathRegExpCache.getRegExp(`(${possibleChars.map((c) => c === "?" ? "\\?" : c).join("|")})`);
  let matched = !r2.test(key);
  if (!matched) {
    const ki = key.indexOf(keySeparator);
    if (ki > 0 && !r2.test(key.substring(0, ki))) {
      matched = true;
    }
  }
  return matched;
};
const deepFind = function(obj, path2) {
  let keySeparator = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (!obj) return void 0;
  if (obj[path2]) return obj[path2];
  const tokens = path2.split(keySeparator);
  let current2 = obj;
  for (let i2 = 0; i2 < tokens.length; ) {
    if (!current2 || typeof current2 !== "object") {
      return void 0;
    }
    let next;
    let nextPath = "";
    for (let j = i2; j < tokens.length; ++j) {
      if (j !== i2) {
        nextPath += keySeparator;
      }
      nextPath += tokens[j];
      next = current2[nextPath];
      if (next !== void 0) {
        if (["string", "number", "boolean"].indexOf(typeof next) > -1 && j < tokens.length - 1) {
          continue;
        }
        i2 += j - i2 + 1;
        break;
      }
    }
    current2 = next;
  }
  return current2;
};
const getCleanedCode = (code) => code && code.replace("_", "-");
const consoleLogger = {
  type: "logger",
  log(args) {
    this.output("log", args);
  },
  warn(args) {
    this.output("warn", args);
  },
  error(args) {
    this.output("error", args);
  },
  output(type2, args) {
    if (console && console[type2]) console[type2].apply(console, args);
  }
};
class Logger {
  constructor(concreteLogger) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.init(concreteLogger, options);
  }
  init(concreteLogger) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.prefix = options.prefix || "i18next:";
    this.logger = concreteLogger || consoleLogger;
    this.options = options;
    this.debug = options.debug;
  }
  log() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return this.forward(args, "log", "", true);
  }
  warn() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return this.forward(args, "warn", "", true);
  }
  error() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    return this.forward(args, "error", "");
  }
  deprecate() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    return this.forward(args, "warn", "WARNING DEPRECATED: ", true);
  }
  forward(args, lvl, prefix, debugOnly) {
    if (debugOnly && !this.debug) return null;
    if (isString$1(args[0])) args[0] = `${prefix}${this.prefix} ${args[0]}`;
    return this.logger[lvl](args);
  }
  create(moduleName) {
    return new Logger(this.logger, {
      ...{
        prefix: `${this.prefix}:${moduleName}:`
      },
      ...this.options
    });
  }
  clone(options) {
    options = options || this.options;
    options.prefix = options.prefix || this.prefix;
    return new Logger(this.logger, options);
  }
}
var baseLogger = new Logger();
class EventEmitter {
  constructor() {
    this.observers = {};
  }
  on(events2, listener) {
    events2.split(" ").forEach((event) => {
      if (!this.observers[event]) this.observers[event] = /* @__PURE__ */ new Map();
      const numListeners = this.observers[event].get(listener) || 0;
      this.observers[event].set(listener, numListeners + 1);
    });
    return this;
  }
  off(event, listener) {
    if (!this.observers[event]) return;
    if (!listener) {
      delete this.observers[event];
      return;
    }
    this.observers[event].delete(listener);
  }
  emit(event) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    if (this.observers[event]) {
      const cloned = Array.from(this.observers[event].entries());
      cloned.forEach((_ref) => {
        let [observer, numTimesAdded] = _ref;
        for (let i2 = 0; i2 < numTimesAdded; i2++) {
          observer(...args);
        }
      });
    }
    if (this.observers["*"]) {
      const cloned = Array.from(this.observers["*"].entries());
      cloned.forEach((_ref2) => {
        let [observer, numTimesAdded] = _ref2;
        for (let i2 = 0; i2 < numTimesAdded; i2++) {
          observer.apply(observer, [event, ...args]);
        }
      });
    }
  }
}
class ResourceStore extends EventEmitter {
  constructor(data) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    super();
    this.data = data || {};
    this.options = options;
    if (this.options.keySeparator === void 0) {
      this.options.keySeparator = ".";
    }
    if (this.options.ignoreJSONStructure === void 0) {
      this.options.ignoreJSONStructure = true;
    }
  }
  addNamespaces(ns) {
    if (this.options.ns.indexOf(ns) < 0) {
      this.options.ns.push(ns);
    }
  }
  removeNamespaces(ns) {
    const index2 = this.options.ns.indexOf(ns);
    if (index2 > -1) {
      this.options.ns.splice(index2, 1);
    }
  }
  getResource(lng, ns, key) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    const ignoreJSONStructure = options.ignoreJSONStructure !== void 0 ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;
    let path2;
    if (lng.indexOf(".") > -1) {
      path2 = lng.split(".");
    } else {
      path2 = [lng, ns];
      if (key) {
        if (Array.isArray(key)) {
          path2.push(...key);
        } else if (isString$1(key) && keySeparator) {
          path2.push(...key.split(keySeparator));
        } else {
          path2.push(key);
        }
      }
    }
    const result = getPath(this.data, path2);
    if (!result && !ns && !key && lng.indexOf(".") > -1) {
      lng = path2[0];
      ns = path2[1];
      key = path2.slice(2).join(".");
    }
    if (result || !ignoreJSONStructure || !isString$1(key)) return result;
    return deepFind(this.data && this.data[lng] && this.data[lng][ns], key, keySeparator);
  }
  addResource(lng, ns, key, value2) {
    let options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
      silent: false
    };
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    let path2 = [lng, ns];
    if (key) path2 = path2.concat(keySeparator ? key.split(keySeparator) : key);
    if (lng.indexOf(".") > -1) {
      path2 = lng.split(".");
      value2 = ns;
      ns = path2[1];
    }
    this.addNamespaces(ns);
    setPath(this.data, path2, value2);
    if (!options.silent) this.emit("added", lng, ns, key, value2);
  }
  addResources(lng, ns, resources) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
      silent: false
    };
    for (const m in resources) {
      if (isString$1(resources[m]) || Array.isArray(resources[m])) this.addResource(lng, ns, m, resources[m], {
        silent: true
      });
    }
    if (!options.silent) this.emit("added", lng, ns, resources);
  }
  addResourceBundle(lng, ns, resources, deep, overwrite) {
    let options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
      silent: false,
      skipCopy: false
    };
    let path2 = [lng, ns];
    if (lng.indexOf(".") > -1) {
      path2 = lng.split(".");
      deep = resources;
      resources = ns;
      ns = path2[1];
    }
    this.addNamespaces(ns);
    let pack = getPath(this.data, path2) || {};
    if (!options.skipCopy) resources = JSON.parse(JSON.stringify(resources));
    if (deep) {
      deepExtend(pack, resources, overwrite);
    } else {
      pack = {
        ...pack,
        ...resources
      };
    }
    setPath(this.data, path2, pack);
    if (!options.silent) this.emit("added", lng, ns, resources);
  }
  removeResourceBundle(lng, ns) {
    if (this.hasResourceBundle(lng, ns)) {
      delete this.data[lng][ns];
    }
    this.removeNamespaces(ns);
    this.emit("removed", lng, ns);
  }
  hasResourceBundle(lng, ns) {
    return this.getResource(lng, ns) !== void 0;
  }
  getResourceBundle(lng, ns) {
    if (!ns) ns = this.options.defaultNS;
    if (this.options.compatibilityAPI === "v1") return {
      ...{},
      ...this.getResource(lng, ns)
    };
    return this.getResource(lng, ns);
  }
  getDataByLanguage(lng) {
    return this.data[lng];
  }
  hasLanguageSomeTranslations(lng) {
    const data = this.getDataByLanguage(lng);
    const n2 = data && Object.keys(data) || [];
    return !!n2.find((v) => data[v] && Object.keys(data[v]).length > 0);
  }
  toJSON() {
    return this.data;
  }
}
var postProcessor = {
  processors: {},
  addPostProcessor(module2) {
    this.processors[module2.name] = module2;
  },
  handle(processors, value2, key, options, translator) {
    processors.forEach((processor) => {
      if (this.processors[processor]) value2 = this.processors[processor].process(value2, key, options, translator);
    });
    return value2;
  }
};
const checkedLoadedFor = {};
class Translator extends EventEmitter {
  constructor(services) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super();
    copy(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], services, this);
    this.options = options;
    if (this.options.keySeparator === void 0) {
      this.options.keySeparator = ".";
    }
    this.logger = baseLogger.create("translator");
  }
  changeLanguage(lng) {
    if (lng) this.language = lng;
  }
  exists(key) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    };
    if (key === void 0 || key === null) {
      return false;
    }
    const resolved = this.resolve(key, options);
    return resolved && resolved.res !== void 0;
  }
  extractFromKey(key, options) {
    let nsSeparator = options.nsSeparator !== void 0 ? options.nsSeparator : this.options.nsSeparator;
    if (nsSeparator === void 0) nsSeparator = ":";
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    let namespaces = options.ns || this.options.defaultNS || [];
    const wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;
    const seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !options.keySeparator && !this.options.userDefinedNsSeparator && !options.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);
    if (wouldCheckForNsInKey && !seemsNaturalLanguage) {
      const m = key.match(this.interpolator.nestingRegexp);
      if (m && m.length > 0) {
        return {
          key,
          namespaces: isString$1(namespaces) ? [namespaces] : namespaces
        };
      }
      const parts = key.split(nsSeparator);
      if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();
      key = parts.join(keySeparator);
    }
    return {
      key,
      namespaces: isString$1(namespaces) ? [namespaces] : namespaces
    };
  }
  translate(keys2, options, lastKey) {
    if (typeof options !== "object" && this.options.overloadTranslationOptionHandler) {
      options = this.options.overloadTranslationOptionHandler(arguments);
    }
    if (typeof options === "object") options = {
      ...options
    };
    if (!options) options = {};
    if (keys2 === void 0 || keys2 === null) return "";
    if (!Array.isArray(keys2)) keys2 = [String(keys2)];
    const returnDetails = options.returnDetails !== void 0 ? options.returnDetails : this.options.returnDetails;
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    const {
      key,
      namespaces
    } = this.extractFromKey(keys2[keys2.length - 1], options);
    const namespace = namespaces[namespaces.length - 1];
    const lng = options.lng || this.language;
    const appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
    if (lng && lng.toLowerCase() === "cimode") {
      if (appendNamespaceToCIMode) {
        const nsSeparator = options.nsSeparator || this.options.nsSeparator;
        if (returnDetails) {
          return {
            res: `${namespace}${nsSeparator}${key}`,
            usedKey: key,
            exactUsedKey: key,
            usedLng: lng,
            usedNS: namespace,
            usedParams: this.getUsedParamsDetails(options)
          };
        }
        return `${namespace}${nsSeparator}${key}`;
      }
      if (returnDetails) {
        return {
          res: key,
          usedKey: key,
          exactUsedKey: key,
          usedLng: lng,
          usedNS: namespace,
          usedParams: this.getUsedParamsDetails(options)
        };
      }
      return key;
    }
    const resolved = this.resolve(keys2, options);
    let res = resolved && resolved.res;
    const resUsedKey = resolved && resolved.usedKey || key;
    const resExactUsedKey = resolved && resolved.exactUsedKey || key;
    const resType = Object.prototype.toString.apply(res);
    const noObject = ["[object Number]", "[object Function]", "[object RegExp]"];
    const joinArrays = options.joinArrays !== void 0 ? options.joinArrays : this.options.joinArrays;
    const handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
    const handleAsObject = !isString$1(res) && typeof res !== "boolean" && typeof res !== "number";
    if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(isString$1(joinArrays) && Array.isArray(res))) {
      if (!options.returnObjects && !this.options.returnObjects) {
        if (!this.options.returnedObjectHandler) {
          this.logger.warn("accessing an object - but returnObjects options is not enabled!");
        }
        const r2 = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, {
          ...options,
          ns: namespaces
        }) : `key '${key} (${this.language})' returned an object instead of string.`;
        if (returnDetails) {
          resolved.res = r2;
          resolved.usedParams = this.getUsedParamsDetails(options);
          return resolved;
        }
        return r2;
      }
      if (keySeparator) {
        const resTypeIsArray = Array.isArray(res);
        const copy2 = resTypeIsArray ? [] : {};
        const newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
        for (const m in res) {
          if (Object.prototype.hasOwnProperty.call(res, m)) {
            const deepKey = `${newKeyToUse}${keySeparator}${m}`;
            copy2[m] = this.translate(deepKey, {
              ...options,
              ...{
                joinArrays: false,
                ns: namespaces
              }
            });
            if (copy2[m] === deepKey) copy2[m] = res[m];
          }
        }
        res = copy2;
      }
    } else if (handleAsObjectInI18nFormat && isString$1(joinArrays) && Array.isArray(res)) {
      res = res.join(joinArrays);
      if (res) res = this.extendTranslation(res, keys2, options, lastKey);
    } else {
      let usedDefault = false;
      let usedKey = false;
      const needsPluralHandling = options.count !== void 0 && !isString$1(options.count);
      const hasDefaultValue = Translator.hasDefaultValue(options);
      const defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, options) : "";
      const defaultValueSuffixOrdinalFallback = options.ordinal && needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, {
        ordinal: false
      }) : "";
      const needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && this.pluralResolver.shouldUseIntlApi();
      const defaultValue = needsZeroSuffixLookup && options[`defaultValue${this.options.pluralSeparator}zero`] || options[`defaultValue${defaultValueSuffix}`] || options[`defaultValue${defaultValueSuffixOrdinalFallback}`] || options.defaultValue;
      if (!this.isValidLookup(res) && hasDefaultValue) {
        usedDefault = true;
        res = defaultValue;
      }
      if (!this.isValidLookup(res)) {
        usedKey = true;
        res = key;
      }
      const missingKeyNoValueFallbackToKey = options.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;
      const resForMissing = missingKeyNoValueFallbackToKey && usedKey ? void 0 : res;
      const updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
      if (usedKey || usedDefault || updateMissing) {
        this.logger.log(updateMissing ? "updateKey" : "missingKey", lng, namespace, key, updateMissing ? defaultValue : res);
        if (keySeparator) {
          const fk = this.resolve(key, {
            ...options,
            keySeparator: false
          });
          if (fk && fk.res) this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
        }
        let lngs = [];
        const fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);
        if (this.options.saveMissingTo === "fallback" && fallbackLngs && fallbackLngs[0]) {
          for (let i2 = 0; i2 < fallbackLngs.length; i2++) {
            lngs.push(fallbackLngs[i2]);
          }
        } else if (this.options.saveMissingTo === "all") {
          lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);
        } else {
          lngs.push(options.lng || this.language);
        }
        const send = (l, k, specificDefaultValue) => {
          const defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;
          if (this.options.missingKeyHandler) {
            this.options.missingKeyHandler(l, namespace, k, defaultForMissing, updateMissing, options);
          } else if (this.backendConnector && this.backendConnector.saveMissing) {
            this.backendConnector.saveMissing(l, namespace, k, defaultForMissing, updateMissing, options);
          }
          this.emit("missingKey", l, namespace, k, res);
        };
        if (this.options.saveMissing) {
          if (this.options.saveMissingPlurals && needsPluralHandling) {
            lngs.forEach((language) => {
              const suffixes = this.pluralResolver.getSuffixes(language, options);
              if (needsZeroSuffixLookup && options[`defaultValue${this.options.pluralSeparator}zero`] && suffixes.indexOf(`${this.options.pluralSeparator}zero`) < 0) {
                suffixes.push(`${this.options.pluralSeparator}zero`);
              }
              suffixes.forEach((suffix) => {
                send([language], key + suffix, options[`defaultValue${suffix}`] || defaultValue);
              });
            });
          } else {
            send(lngs, key, defaultValue);
          }
        }
      }
      res = this.extendTranslation(res, keys2, options, resolved, lastKey);
      if (usedKey && res === key && this.options.appendNamespaceToMissingKey) res = `${namespace}:${key}`;
      if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {
        if (this.options.compatibilityAPI !== "v1") {
          res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${namespace}:${key}` : key, usedDefault ? res : void 0);
        } else {
          res = this.options.parseMissingKeyHandler(res);
        }
      }
    }
    if (returnDetails) {
      resolved.res = res;
      resolved.usedParams = this.getUsedParamsDetails(options);
      return resolved;
    }
    return res;
  }
  extendTranslation(res, key, options, resolved, lastKey) {
    var _this = this;
    if (this.i18nFormat && this.i18nFormat.parse) {
      res = this.i18nFormat.parse(res, {
        ...this.options.interpolation.defaultVariables,
        ...options
      }, options.lng || this.language || resolved.usedLng, resolved.usedNS, resolved.usedKey, {
        resolved
      });
    } else if (!options.skipInterpolation) {
      if (options.interpolation) this.interpolator.init({
        ...options,
        ...{
          interpolation: {
            ...this.options.interpolation,
            ...options.interpolation
          }
        }
      });
      const skipOnVariables = isString$1(res) && (options && options.interpolation && options.interpolation.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
      let nestBef;
      if (skipOnVariables) {
        const nb = res.match(this.interpolator.nestingRegexp);
        nestBef = nb && nb.length;
      }
      let data = options.replace && !isString$1(options.replace) ? options.replace : options;
      if (this.options.interpolation.defaultVariables) data = {
        ...this.options.interpolation.defaultVariables,
        ...data
      };
      res = this.interpolator.interpolate(res, data, options.lng || this.language || resolved.usedLng, options);
      if (skipOnVariables) {
        const na = res.match(this.interpolator.nestingRegexp);
        const nestAft = na && na.length;
        if (nestBef < nestAft) options.nest = false;
      }
      if (!options.lng && this.options.compatibilityAPI !== "v1" && resolved && resolved.res) options.lng = this.language || resolved.usedLng;
      if (options.nest !== false) res = this.interpolator.nest(res, function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        if (lastKey && lastKey[0] === args[0] && !options.context) {
          _this.logger.warn(`It seems you are nesting recursively key: ${args[0]} in key: ${key[0]}`);
          return null;
        }
        return _this.translate(...args, key);
      }, options);
      if (options.interpolation) this.interpolator.reset();
    }
    const postProcess = options.postProcess || this.options.postProcess;
    const postProcessorNames = isString$1(postProcess) ? [postProcess] : postProcess;
    if (res !== void 0 && res !== null && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false) {
      res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? {
        i18nResolved: {
          ...resolved,
          usedParams: this.getUsedParamsDetails(options)
        },
        ...options
      } : options, this);
    }
    return res;
  }
  resolve(keys2) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let found;
    let usedKey;
    let exactUsedKey;
    let usedLng;
    let usedNS;
    if (isString$1(keys2)) keys2 = [keys2];
    keys2.forEach((k) => {
      if (this.isValidLookup(found)) return;
      const extracted = this.extractFromKey(k, options);
      const key = extracted.key;
      usedKey = key;
      let namespaces = extracted.namespaces;
      if (this.options.fallbackNS) namespaces = namespaces.concat(this.options.fallbackNS);
      const needsPluralHandling = options.count !== void 0 && !isString$1(options.count);
      const needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && this.pluralResolver.shouldUseIntlApi();
      const needsContextHandling = options.context !== void 0 && (isString$1(options.context) || typeof options.context === "number") && options.context !== "";
      const codes = options.lngs ? options.lngs : this.languageUtils.toResolveHierarchy(options.lng || this.language, options.fallbackLng);
      namespaces.forEach((ns) => {
        if (this.isValidLookup(found)) return;
        usedNS = ns;
        if (!checkedLoadedFor[`${codes[0]}-${ns}`] && this.utils && this.utils.hasLoadedNamespace && !this.utils.hasLoadedNamespace(usedNS)) {
          checkedLoadedFor[`${codes[0]}-${ns}`] = true;
          this.logger.warn(`key "${usedKey}" for languages "${codes.join(", ")}" won't get resolved as namespace "${usedNS}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
        }
        codes.forEach((code) => {
          if (this.isValidLookup(found)) return;
          usedLng = code;
          const finalKeys = [key];
          if (this.i18nFormat && this.i18nFormat.addLookupKeys) {
            this.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options);
          } else {
            let pluralSuffix;
            if (needsPluralHandling) pluralSuffix = this.pluralResolver.getSuffix(code, options.count, options);
            const zeroSuffix = `${this.options.pluralSeparator}zero`;
            const ordinalPrefix = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
            if (needsPluralHandling) {
              finalKeys.push(key + pluralSuffix);
              if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                finalKeys.push(key + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
              }
              if (needsZeroSuffixLookup) {
                finalKeys.push(key + zeroSuffix);
              }
            }
            if (needsContextHandling) {
              const contextKey = `${key}${this.options.contextSeparator}${options.context}`;
              finalKeys.push(contextKey);
              if (needsPluralHandling) {
                finalKeys.push(contextKey + pluralSuffix);
                if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                  finalKeys.push(contextKey + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
                }
                if (needsZeroSuffixLookup) {
                  finalKeys.push(contextKey + zeroSuffix);
                }
              }
            }
          }
          let possibleKey;
          while (possibleKey = finalKeys.pop()) {
            if (!this.isValidLookup(found)) {
              exactUsedKey = possibleKey;
              found = this.getResource(code, ns, possibleKey, options);
            }
          }
        });
      });
    });
    return {
      res: found,
      usedKey,
      exactUsedKey,
      usedLng,
      usedNS
    };
  }
  isValidLookup(res) {
    return res !== void 0 && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === "");
  }
  getResource(code, ns, key) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    if (this.i18nFormat && this.i18nFormat.getResource) return this.i18nFormat.getResource(code, ns, key, options);
    return this.resourceStore.getResource(code, ns, key, options);
  }
  getUsedParamsDetails() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const optionsKeys = ["defaultValue", "ordinal", "context", "replace", "lng", "lngs", "fallbackLng", "ns", "keySeparator", "nsSeparator", "returnObjects", "returnDetails", "joinArrays", "postProcess", "interpolation"];
    const useOptionsReplaceForData = options.replace && !isString$1(options.replace);
    let data = useOptionsReplaceForData ? options.replace : options;
    if (useOptionsReplaceForData && typeof options.count !== "undefined") {
      data.count = options.count;
    }
    if (this.options.interpolation.defaultVariables) {
      data = {
        ...this.options.interpolation.defaultVariables,
        ...data
      };
    }
    if (!useOptionsReplaceForData) {
      data = {
        ...data
      };
      for (const key of optionsKeys) {
        delete data[key];
      }
    }
    return data;
  }
  static hasDefaultValue(options) {
    const prefix = "defaultValue";
    for (const option in options) {
      if (Object.prototype.hasOwnProperty.call(options, option) && prefix === option.substring(0, prefix.length) && void 0 !== options[option]) {
        return true;
      }
    }
    return false;
  }
}
const capitalize = (string) => string.charAt(0).toUpperCase() + string.slice(1);
class LanguageUtil {
  constructor(options) {
    this.options = options;
    this.supportedLngs = this.options.supportedLngs || false;
    this.logger = baseLogger.create("languageUtils");
  }
  getScriptPartFromCode(code) {
    code = getCleanedCode(code);
    if (!code || code.indexOf("-") < 0) return null;
    const p = code.split("-");
    if (p.length === 2) return null;
    p.pop();
    if (p[p.length - 1].toLowerCase() === "x") return null;
    return this.formatLanguageCode(p.join("-"));
  }
  getLanguagePartFromCode(code) {
    code = getCleanedCode(code);
    if (!code || code.indexOf("-") < 0) return code;
    const p = code.split("-");
    return this.formatLanguageCode(p[0]);
  }
  formatLanguageCode(code) {
    if (isString$1(code) && code.indexOf("-") > -1) {
      if (typeof Intl !== "undefined" && typeof Intl.getCanonicalLocales !== "undefined") {
        try {
          let formattedCode = Intl.getCanonicalLocales(code)[0];
          if (formattedCode && this.options.lowerCaseLng) {
            formattedCode = formattedCode.toLowerCase();
          }
          if (formattedCode) return formattedCode;
        } catch (e) {
        }
      }
      const specialCases = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
      let p = code.split("-");
      if (this.options.lowerCaseLng) {
        p = p.map((part) => part.toLowerCase());
      } else if (p.length === 2) {
        p[0] = p[0].toLowerCase();
        p[1] = p[1].toUpperCase();
        if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());
      } else if (p.length === 3) {
        p[0] = p[0].toLowerCase();
        if (p[1].length === 2) p[1] = p[1].toUpperCase();
        if (p[0] !== "sgn" && p[2].length === 2) p[2] = p[2].toUpperCase();
        if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());
        if (specialCases.indexOf(p[2].toLowerCase()) > -1) p[2] = capitalize(p[2].toLowerCase());
      }
      return p.join("-");
    }
    return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
  }
  isSupportedCode(code) {
    if (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) {
      code = this.getLanguagePartFromCode(code);
    }
    return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;
  }
  getBestMatchFromCodes(codes) {
    if (!codes) return null;
    let found;
    codes.forEach((code) => {
      if (found) return;
      const cleanedLng = this.formatLanguageCode(code);
      if (!this.options.supportedLngs || this.isSupportedCode(cleanedLng)) found = cleanedLng;
    });
    if (!found && this.options.supportedLngs) {
      codes.forEach((code) => {
        if (found) return;
        const lngOnly = this.getLanguagePartFromCode(code);
        if (this.isSupportedCode(lngOnly)) return found = lngOnly;
        found = this.options.supportedLngs.find((supportedLng) => {
          if (supportedLng === lngOnly) return supportedLng;
          if (supportedLng.indexOf("-") < 0 && lngOnly.indexOf("-") < 0) return;
          if (supportedLng.indexOf("-") > 0 && lngOnly.indexOf("-") < 0 && supportedLng.substring(0, supportedLng.indexOf("-")) === lngOnly) return supportedLng;
          if (supportedLng.indexOf(lngOnly) === 0 && lngOnly.length > 1) return supportedLng;
        });
      });
    }
    if (!found) found = this.getFallbackCodes(this.options.fallbackLng)[0];
    return found;
  }
  getFallbackCodes(fallbacks, code) {
    if (!fallbacks) return [];
    if (typeof fallbacks === "function") fallbacks = fallbacks(code);
    if (isString$1(fallbacks)) fallbacks = [fallbacks];
    if (Array.isArray(fallbacks)) return fallbacks;
    if (!code) return fallbacks.default || [];
    let found = fallbacks[code];
    if (!found) found = fallbacks[this.getScriptPartFromCode(code)];
    if (!found) found = fallbacks[this.formatLanguageCode(code)];
    if (!found) found = fallbacks[this.getLanguagePartFromCode(code)];
    if (!found) found = fallbacks.default;
    return found || [];
  }
  toResolveHierarchy(code, fallbackCode) {
    const fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);
    const codes = [];
    const addCode = (c) => {
      if (!c) return;
      if (this.isSupportedCode(c)) {
        codes.push(c);
      } else {
        this.logger.warn(`rejecting language code not found in supportedLngs: ${c}`);
      }
    };
    if (isString$1(code) && (code.indexOf("-") > -1 || code.indexOf("_") > -1)) {
      if (this.options.load !== "languageOnly") addCode(this.formatLanguageCode(code));
      if (this.options.load !== "languageOnly" && this.options.load !== "currentOnly") addCode(this.getScriptPartFromCode(code));
      if (this.options.load !== "currentOnly") addCode(this.getLanguagePartFromCode(code));
    } else if (isString$1(code)) {
      addCode(this.formatLanguageCode(code));
    }
    fallbackCodes.forEach((fc) => {
      if (codes.indexOf(fc) < 0) addCode(this.formatLanguageCode(fc));
    });
    return codes;
  }
}
let sets = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he", "iw"],
  nr: [1, 2, 20, 21],
  fc: 22
}];
let _rulesPluralsTypes = {
  1: (n2) => Number(n2 > 1),
  2: (n2) => Number(n2 != 1),
  3: (n2) => 0,
  4: (n2) => Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 % 10 >= 2 && n2 % 10 <= 4 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2),
  5: (n2) => Number(n2 == 0 ? 0 : n2 == 1 ? 1 : n2 == 2 ? 2 : n2 % 100 >= 3 && n2 % 100 <= 10 ? 3 : n2 % 100 >= 11 ? 4 : 5),
  6: (n2) => Number(n2 == 1 ? 0 : n2 >= 2 && n2 <= 4 ? 1 : 2),
  7: (n2) => Number(n2 == 1 ? 0 : n2 % 10 >= 2 && n2 % 10 <= 4 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2),
  8: (n2) => Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 != 8 && n2 != 11 ? 2 : 3),
  9: (n2) => Number(n2 >= 2),
  10: (n2) => Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 < 7 ? 2 : n2 < 11 ? 3 : 4),
  11: (n2) => Number(n2 == 1 || n2 == 11 ? 0 : n2 == 2 || n2 == 12 ? 1 : n2 > 2 && n2 < 20 ? 2 : 3),
  12: (n2) => Number(n2 % 10 != 1 || n2 % 100 == 11),
  13: (n2) => Number(n2 !== 0),
  14: (n2) => Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 == 3 ? 2 : 3),
  15: (n2) => Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 % 10 >= 2 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2),
  16: (n2) => Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 !== 0 ? 1 : 2),
  17: (n2) => Number(n2 == 1 || n2 % 10 == 1 && n2 % 100 != 11 ? 0 : 1),
  18: (n2) => Number(n2 == 0 ? 0 : n2 == 1 ? 1 : 2),
  19: (n2) => Number(n2 == 1 ? 0 : n2 == 0 || n2 % 100 > 1 && n2 % 100 < 11 ? 1 : n2 % 100 > 10 && n2 % 100 < 20 ? 2 : 3),
  20: (n2) => Number(n2 == 1 ? 0 : n2 == 0 || n2 % 100 > 0 && n2 % 100 < 20 ? 1 : 2),
  21: (n2) => Number(n2 % 100 == 1 ? 1 : n2 % 100 == 2 ? 2 : n2 % 100 == 3 || n2 % 100 == 4 ? 3 : 0),
  22: (n2) => Number(n2 == 1 ? 0 : n2 == 2 ? 1 : (n2 < 0 || n2 > 10) && n2 % 10 == 0 ? 2 : 3)
};
const nonIntlVersions = ["v1", "v2", "v3"];
const intlVersions = ["v4"];
const suffixesOrder = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};
const createRules = () => {
  const rules = {};
  sets.forEach((set2) => {
    set2.lngs.forEach((l) => {
      rules[l] = {
        numbers: set2.nr,
        plurals: _rulesPluralsTypes[set2.fc]
      };
    });
  });
  return rules;
};
class PluralResolver {
  constructor(languageUtils) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.languageUtils = languageUtils;
    this.options = options;
    this.logger = baseLogger.create("pluralResolver");
    if ((!this.options.compatibilityJSON || intlVersions.includes(this.options.compatibilityJSON)) && (typeof Intl === "undefined" || !Intl.PluralRules)) {
      this.options.compatibilityJSON = "v3";
      this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.");
    }
    this.rules = createRules();
    this.pluralRulesCache = {};
  }
  addRule(lng, obj) {
    this.rules[lng] = obj;
  }
  clearCache() {
    this.pluralRulesCache = {};
  }
  getRule(code) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (this.shouldUseIntlApi()) {
      const cleanedCode = getCleanedCode(code === "dev" ? "en" : code);
      const type2 = options.ordinal ? "ordinal" : "cardinal";
      const cacheKey = JSON.stringify({
        cleanedCode,
        type: type2
      });
      if (cacheKey in this.pluralRulesCache) {
        return this.pluralRulesCache[cacheKey];
      }
      let rule;
      try {
        rule = new Intl.PluralRules(cleanedCode, {
          type: type2
        });
      } catch (err) {
        if (!code.match(/-|_/)) return;
        const lngPart = this.languageUtils.getLanguagePartFromCode(code);
        rule = this.getRule(lngPart, options);
      }
      this.pluralRulesCache[cacheKey] = rule;
      return rule;
    }
    return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];
  }
  needsPlural(code) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const rule = this.getRule(code, options);
    if (this.shouldUseIntlApi()) {
      return rule && rule.resolvedOptions().pluralCategories.length > 1;
    }
    return rule && rule.numbers.length > 1;
  }
  getPluralFormsOfKey(code, key) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return this.getSuffixes(code, options).map((suffix) => `${key}${suffix}`);
  }
  getSuffixes(code) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const rule = this.getRule(code, options);
    if (!rule) {
      return [];
    }
    if (this.shouldUseIntlApi()) {
      return rule.resolvedOptions().pluralCategories.sort((pluralCategory1, pluralCategory2) => suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2]).map((pluralCategory) => `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ""}${pluralCategory}`);
    }
    return rule.numbers.map((number) => this.getSuffix(code, number, options));
  }
  getSuffix(code, count2) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const rule = this.getRule(code, options);
    if (rule) {
      if (this.shouldUseIntlApi()) {
        return `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ""}${rule.select(count2)}`;
      }
      return this.getSuffixRetroCompatible(rule, count2);
    }
    this.logger.warn(`no plural rule found for: ${code}`);
    return "";
  }
  getSuffixRetroCompatible(rule, count2) {
    const idx = rule.noAbs ? rule.plurals(count2) : rule.plurals(Math.abs(count2));
    let suffix = rule.numbers[idx];
    if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
      if (suffix === 2) {
        suffix = "plural";
      } else if (suffix === 1) {
        suffix = "";
      }
    }
    const returnSuffix = () => this.options.prepend && suffix.toString() ? this.options.prepend + suffix.toString() : suffix.toString();
    if (this.options.compatibilityJSON === "v1") {
      if (suffix === 1) return "";
      if (typeof suffix === "number") return `_plural_${suffix.toString()}`;
      return returnSuffix();
    } else if (this.options.compatibilityJSON === "v2") {
      return returnSuffix();
    } else if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
      return returnSuffix();
    }
    return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
  }
  shouldUseIntlApi() {
    return !nonIntlVersions.includes(this.options.compatibilityJSON);
  }
}
const deepFindWithDefaults = function(data, defaultData, key) {
  let keySeparator = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : ".";
  let ignoreJSONStructure = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
  let path2 = getPathWithDefaults(data, defaultData, key);
  if (!path2 && ignoreJSONStructure && isString$1(key)) {
    path2 = deepFind(data, key, keySeparator);
    if (path2 === void 0) path2 = deepFind(defaultData, key, keySeparator);
  }
  return path2;
};
const regexSafe = (val) => val.replace(/\$/g, "$$$$");
class Interpolator {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = baseLogger.create("interpolator");
    this.options = options;
    this.format = options.interpolation && options.interpolation.format || ((value2) => value2);
    this.init(options);
  }
  init() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!options.interpolation) options.interpolation = {
      escapeValue: true
    };
    const {
      escape: escape$1,
      escapeValue,
      useRawValueToEscape,
      prefix,
      prefixEscaped,
      suffix,
      suffixEscaped,
      formatSeparator,
      unescapeSuffix,
      unescapePrefix,
      nestingPrefix,
      nestingPrefixEscaped,
      nestingSuffix,
      nestingSuffixEscaped,
      nestingOptionsSeparator,
      maxReplaces,
      alwaysFormat
    } = options.interpolation;
    this.escape = escape$1 !== void 0 ? escape$1 : escape;
    this.escapeValue = escapeValue !== void 0 ? escapeValue : true;
    this.useRawValueToEscape = useRawValueToEscape !== void 0 ? useRawValueToEscape : false;
    this.prefix = prefix ? regexEscape(prefix) : prefixEscaped || "{{";
    this.suffix = suffix ? regexEscape(suffix) : suffixEscaped || "}}";
    this.formatSeparator = formatSeparator || ",";
    this.unescapePrefix = unescapeSuffix ? "" : unescapePrefix || "-";
    this.unescapeSuffix = this.unescapePrefix ? "" : unescapeSuffix || "";
    this.nestingPrefix = nestingPrefix ? regexEscape(nestingPrefix) : nestingPrefixEscaped || regexEscape("$t(");
    this.nestingSuffix = nestingSuffix ? regexEscape(nestingSuffix) : nestingSuffixEscaped || regexEscape(")");
    this.nestingOptionsSeparator = nestingOptionsSeparator || ",";
    this.maxReplaces = maxReplaces || 1e3;
    this.alwaysFormat = alwaysFormat !== void 0 ? alwaysFormat : false;
    this.resetRegExp();
  }
  reset() {
    if (this.options) this.init(this.options);
  }
  resetRegExp() {
    const getOrResetRegExp = (existingRegExp, pattern) => {
      if (existingRegExp && existingRegExp.source === pattern) {
        existingRegExp.lastIndex = 0;
        return existingRegExp;
      }
      return new RegExp(pattern, "g");
    };
    this.regexp = getOrResetRegExp(this.regexp, `${this.prefix}(.+?)${this.suffix}`);
    this.regexpUnescape = getOrResetRegExp(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`);
    this.nestingRegexp = getOrResetRegExp(this.nestingRegexp, `${this.nestingPrefix}(.+?)${this.nestingSuffix}`);
  }
  interpolate(str, data, lng, options) {
    let match2;
    let value2;
    let replaces;
    const defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
    const handleFormat = (key) => {
      if (key.indexOf(this.formatSeparator) < 0) {
        const path2 = deepFindWithDefaults(data, defaultData, key, this.options.keySeparator, this.options.ignoreJSONStructure);
        return this.alwaysFormat ? this.format(path2, void 0, lng, {
          ...options,
          ...data,
          interpolationkey: key
        }) : path2;
      }
      const p = key.split(this.formatSeparator);
      const k = p.shift().trim();
      const f = p.join(this.formatSeparator).trim();
      return this.format(deepFindWithDefaults(data, defaultData, k, this.options.keySeparator, this.options.ignoreJSONStructure), f, lng, {
        ...options,
        ...data,
        interpolationkey: k
      });
    };
    this.resetRegExp();
    const missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;
    const skipOnVariables = options && options.interpolation && options.interpolation.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
    const todos = [{
      regex: this.regexpUnescape,
      safeValue: (val) => regexSafe(val)
    }, {
      regex: this.regexp,
      safeValue: (val) => this.escapeValue ? regexSafe(this.escape(val)) : regexSafe(val)
    }];
    todos.forEach((todo) => {
      replaces = 0;
      while (match2 = todo.regex.exec(str)) {
        const matchedVar = match2[1].trim();
        value2 = handleFormat(matchedVar);
        if (value2 === void 0) {
          if (typeof missingInterpolationHandler === "function") {
            const temp = missingInterpolationHandler(str, match2, options);
            value2 = isString$1(temp) ? temp : "";
          } else if (options && Object.prototype.hasOwnProperty.call(options, matchedVar)) {
            value2 = "";
          } else if (skipOnVariables) {
            value2 = match2[0];
            continue;
          } else {
            this.logger.warn(`missed to pass in variable ${matchedVar} for interpolating ${str}`);
            value2 = "";
          }
        } else if (!isString$1(value2) && !this.useRawValueToEscape) {
          value2 = makeString(value2);
        }
        const safeValue = todo.safeValue(value2);
        str = str.replace(match2[0], safeValue);
        if (skipOnVariables) {
          todo.regex.lastIndex += value2.length;
          todo.regex.lastIndex -= match2[0].length;
        } else {
          todo.regex.lastIndex = 0;
        }
        replaces++;
        if (replaces >= this.maxReplaces) {
          break;
        }
      }
    });
    return str;
  }
  nest(str, fc) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let match2;
    let value2;
    let clonedOptions;
    const handleHasOptions = (key, inheritedOptions) => {
      const sep = this.nestingOptionsSeparator;
      if (key.indexOf(sep) < 0) return key;
      const c = key.split(new RegExp(`${sep}[ ]*{`));
      let optionsString = `{${c[1]}`;
      key = c[0];
      optionsString = this.interpolate(optionsString, clonedOptions);
      const matchedSingleQuotes = optionsString.match(/'/g);
      const matchedDoubleQuotes = optionsString.match(/"/g);
      if (matchedSingleQuotes && matchedSingleQuotes.length % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {
        optionsString = optionsString.replace(/'/g, '"');
      }
      try {
        clonedOptions = JSON.parse(optionsString);
        if (inheritedOptions) clonedOptions = {
          ...inheritedOptions,
          ...clonedOptions
        };
      } catch (e) {
        this.logger.warn(`failed parsing options string in nesting for key ${key}`, e);
        return `${key}${sep}${optionsString}`;
      }
      if (clonedOptions.defaultValue && clonedOptions.defaultValue.indexOf(this.prefix) > -1) delete clonedOptions.defaultValue;
      return key;
    };
    while (match2 = this.nestingRegexp.exec(str)) {
      let formatters2 = [];
      clonedOptions = {
        ...options
      };
      clonedOptions = clonedOptions.replace && !isString$1(clonedOptions.replace) ? clonedOptions.replace : clonedOptions;
      clonedOptions.applyPostProcessor = false;
      delete clonedOptions.defaultValue;
      let doReduce = false;
      if (match2[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match2[1])) {
        const r2 = match2[1].split(this.formatSeparator).map((elem) => elem.trim());
        match2[1] = r2.shift();
        formatters2 = r2;
        doReduce = true;
      }
      value2 = fc(handleHasOptions.call(this, match2[1].trim(), clonedOptions), clonedOptions);
      if (value2 && match2[0] === str && !isString$1(value2)) return value2;
      if (!isString$1(value2)) value2 = makeString(value2);
      if (!value2) {
        this.logger.warn(`missed to resolve ${match2[1]} for nesting ${str}`);
        value2 = "";
      }
      if (doReduce) {
        value2 = formatters2.reduce((v, f) => this.format(v, f, options.lng, {
          ...options,
          interpolationkey: match2[1].trim()
        }), value2.trim());
      }
      str = str.replace(match2[0], value2);
      this.regexp.lastIndex = 0;
    }
    return str;
  }
}
const parseFormatStr = (formatStr) => {
  let formatName = formatStr.toLowerCase().trim();
  const formatOptions = {};
  if (formatStr.indexOf("(") > -1) {
    const p = formatStr.split("(");
    formatName = p[0].toLowerCase().trim();
    const optStr = p[1].substring(0, p[1].length - 1);
    if (formatName === "currency" && optStr.indexOf(":") < 0) {
      if (!formatOptions.currency) formatOptions.currency = optStr.trim();
    } else if (formatName === "relativetime" && optStr.indexOf(":") < 0) {
      if (!formatOptions.range) formatOptions.range = optStr.trim();
    } else {
      const opts = optStr.split(";");
      opts.forEach((opt) => {
        if (opt) {
          const [key, ...rest] = opt.split(":");
          const val = rest.join(":").trim().replace(/^'+|'+$/g, "");
          const trimmedKey = key.trim();
          if (!formatOptions[trimmedKey]) formatOptions[trimmedKey] = val;
          if (val === "false") formatOptions[trimmedKey] = false;
          if (val === "true") formatOptions[trimmedKey] = true;
          if (!isNaN(val)) formatOptions[trimmedKey] = parseInt(val, 10);
        }
      });
    }
  }
  return {
    formatName,
    formatOptions
  };
};
const createCachedFormatter = (fn) => {
  const cache = {};
  return (val, lng, options) => {
    let optForCache = options;
    if (options && options.interpolationkey && options.formatParams && options.formatParams[options.interpolationkey] && options[options.interpolationkey]) {
      optForCache = {
        ...optForCache,
        [options.interpolationkey]: void 0
      };
    }
    const key = lng + JSON.stringify(optForCache);
    let formatter = cache[key];
    if (!formatter) {
      formatter = fn(getCleanedCode(lng), options);
      cache[key] = formatter;
    }
    return formatter(val);
  };
};
class Formatter {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = baseLogger.create("formatter");
    this.options = options;
    this.formats = {
      number: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.NumberFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val);
      }),
      currency: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.NumberFormat(lng, {
          ...opt,
          style: "currency"
        });
        return (val) => formatter.format(val);
      }),
      datetime: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.DateTimeFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val);
      }),
      relativetime: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.RelativeTimeFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val, opt.range || "day");
      }),
      list: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.ListFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val);
      })
    };
    this.init(options);
  }
  init(services) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    };
    this.formatSeparator = options.interpolation.formatSeparator || ",";
  }
  add(name2, fc) {
    this.formats[name2.toLowerCase().trim()] = fc;
  }
  addCached(name2, fc) {
    this.formats[name2.toLowerCase().trim()] = createCachedFormatter(fc);
  }
  format(value2, format2, lng) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const formats = format2.split(this.formatSeparator);
    if (formats.length > 1 && formats[0].indexOf("(") > 1 && formats[0].indexOf(")") < 0 && formats.find((f) => f.indexOf(")") > -1)) {
      const lastIndex = formats.findIndex((f) => f.indexOf(")") > -1);
      formats[0] = [formats[0], ...formats.splice(1, lastIndex)].join(this.formatSeparator);
    }
    const result = formats.reduce((mem, f) => {
      const {
        formatName,
        formatOptions
      } = parseFormatStr(f);
      if (this.formats[formatName]) {
        let formatted = mem;
        try {
          const valOptions = options && options.formatParams && options.formatParams[options.interpolationkey] || {};
          const l = valOptions.locale || valOptions.lng || options.locale || options.lng || lng;
          formatted = this.formats[formatName](mem, l, {
            ...formatOptions,
            ...options,
            ...valOptions
          });
        } catch (error2) {
          this.logger.warn(error2);
        }
        return formatted;
      } else {
        this.logger.warn(`there was no format function for ${formatName}`);
      }
      return mem;
    }, value2);
    return result;
  }
}
const removePending = (q, name2) => {
  if (q.pending[name2] !== void 0) {
    delete q.pending[name2];
    q.pendingCount--;
  }
};
class Connector extends EventEmitter {
  constructor(backend2, store, services) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    super();
    this.backend = backend2;
    this.store = store;
    this.services = services;
    this.languageUtils = services.languageUtils;
    this.options = options;
    this.logger = baseLogger.create("backendConnector");
    this.waitingReads = [];
    this.maxParallelReads = options.maxParallelReads || 10;
    this.readingCalls = 0;
    this.maxRetries = options.maxRetries >= 0 ? options.maxRetries : 5;
    this.retryTimeout = options.retryTimeout >= 1 ? options.retryTimeout : 350;
    this.state = {};
    this.queue = [];
    if (this.backend && this.backend.init) {
      this.backend.init(services, options.backend, options);
    }
  }
  queueLoad(languages, namespaces, options, callback) {
    const toLoad = {};
    const pending = {};
    const toLoadLanguages = {};
    const toLoadNamespaces = {};
    languages.forEach((lng) => {
      let hasAllNamespaces = true;
      namespaces.forEach((ns) => {
        const name2 = `${lng}|${ns}`;
        if (!options.reload && this.store.hasResourceBundle(lng, ns)) {
          this.state[name2] = 2;
        } else if (this.state[name2] < 0) ;
        else if (this.state[name2] === 1) {
          if (pending[name2] === void 0) pending[name2] = true;
        } else {
          this.state[name2] = 1;
          hasAllNamespaces = false;
          if (pending[name2] === void 0) pending[name2] = true;
          if (toLoad[name2] === void 0) toLoad[name2] = true;
          if (toLoadNamespaces[ns] === void 0) toLoadNamespaces[ns] = true;
        }
      });
      if (!hasAllNamespaces) toLoadLanguages[lng] = true;
    });
    if (Object.keys(toLoad).length || Object.keys(pending).length) {
      this.queue.push({
        pending,
        pendingCount: Object.keys(pending).length,
        loaded: {},
        errors: [],
        callback
      });
    }
    return {
      toLoad: Object.keys(toLoad),
      pending: Object.keys(pending),
      toLoadLanguages: Object.keys(toLoadLanguages),
      toLoadNamespaces: Object.keys(toLoadNamespaces)
    };
  }
  loaded(name2, err, data) {
    const s2 = name2.split("|");
    const lng = s2[0];
    const ns = s2[1];
    if (err) this.emit("failedLoading", lng, ns, err);
    if (!err && data) {
      this.store.addResourceBundle(lng, ns, data, void 0, void 0, {
        skipCopy: true
      });
    }
    this.state[name2] = err ? -1 : 2;
    if (err && data) this.state[name2] = 0;
    const loaded = {};
    this.queue.forEach((q) => {
      pushPath(q.loaded, [lng], ns);
      removePending(q, name2);
      if (err) q.errors.push(err);
      if (q.pendingCount === 0 && !q.done) {
        Object.keys(q.loaded).forEach((l) => {
          if (!loaded[l]) loaded[l] = {};
          const loadedKeys = q.loaded[l];
          if (loadedKeys.length) {
            loadedKeys.forEach((n2) => {
              if (loaded[l][n2] === void 0) loaded[l][n2] = true;
            });
          }
        });
        q.done = true;
        if (q.errors.length) {
          q.callback(q.errors);
        } else {
          q.callback();
        }
      }
    });
    this.emit("loaded", loaded);
    this.queue = this.queue.filter((q) => !q.done);
  }
  read(lng, ns, fcName) {
    let tried = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
    let wait = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout;
    let callback = arguments.length > 5 ? arguments[5] : void 0;
    if (!lng.length) return callback(null, {});
    if (this.readingCalls >= this.maxParallelReads) {
      this.waitingReads.push({
        lng,
        ns,
        fcName,
        tried,
        wait,
        callback
      });
      return;
    }
    this.readingCalls++;
    const resolver = (err, data) => {
      this.readingCalls--;
      if (this.waitingReads.length > 0) {
        const next = this.waitingReads.shift();
        this.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);
      }
      if (err && data && tried < this.maxRetries) {
        setTimeout(() => {
          this.read.call(this, lng, ns, fcName, tried + 1, wait * 2, callback);
        }, wait);
        return;
      }
      callback(err, data);
    };
    const fc = this.backend[fcName].bind(this.backend);
    if (fc.length === 2) {
      try {
        const r2 = fc(lng, ns);
        if (r2 && typeof r2.then === "function") {
          r2.then((data) => resolver(null, data)).catch(resolver);
        } else {
          resolver(null, r2);
        }
      } catch (err) {
        resolver(err);
      }
      return;
    }
    return fc(lng, ns, resolver);
  }
  prepareLoading(languages, namespaces) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let callback = arguments.length > 3 ? arguments[3] : void 0;
    if (!this.backend) {
      this.logger.warn("No backend was added via i18next.use. Will not load resources.");
      return callback && callback();
    }
    if (isString$1(languages)) languages = this.languageUtils.toResolveHierarchy(languages);
    if (isString$1(namespaces)) namespaces = [namespaces];
    const toLoad = this.queueLoad(languages, namespaces, options, callback);
    if (!toLoad.toLoad.length) {
      if (!toLoad.pending.length) callback();
      return null;
    }
    toLoad.toLoad.forEach((name2) => {
      this.loadOne(name2);
    });
  }
  load(languages, namespaces, callback) {
    this.prepareLoading(languages, namespaces, {}, callback);
  }
  reload(languages, namespaces, callback) {
    this.prepareLoading(languages, namespaces, {
      reload: true
    }, callback);
  }
  loadOne(name2) {
    let prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    const s2 = name2.split("|");
    const lng = s2[0];
    const ns = s2[1];
    this.read(lng, ns, "read", void 0, void 0, (err, data) => {
      if (err) this.logger.warn(`${prefix}loading namespace ${ns} for language ${lng} failed`, err);
      if (!err && data) this.logger.log(`${prefix}loaded namespace ${ns} for language ${lng}`, data);
      this.loaded(name2, err, data);
    });
  }
  saveMissing(languages, namespace, key, fallbackValue, isUpdate) {
    let options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
    let clb = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : () => {
    };
    if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {
      this.logger.warn(`did not save key "${key}" as the namespace "${namespace}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
      return;
    }
    if (key === void 0 || key === null || key === "") return;
    if (this.backend && this.backend.create) {
      const opts = {
        ...options,
        isUpdate
      };
      const fc = this.backend.create.bind(this.backend);
      if (fc.length < 6) {
        try {
          let r2;
          if (fc.length === 5) {
            r2 = fc(languages, namespace, key, fallbackValue, opts);
          } else {
            r2 = fc(languages, namespace, key, fallbackValue);
          }
          if (r2 && typeof r2.then === "function") {
            r2.then((data) => clb(null, data)).catch(clb);
          } else {
            clb(null, r2);
          }
        } catch (err) {
          clb(err);
        }
      } else {
        fc(languages, namespace, key, fallbackValue, clb, opts);
      }
    }
    if (!languages || !languages[0]) return;
    this.store.addResource(languages[0], namespace, key, fallbackValue);
  }
}
const get = () => ({
  debug: false,
  initImmediate: true,
  ns: ["translation"],
  defaultNS: ["translation"],
  fallbackLng: ["dev"],
  fallbackNS: false,
  supportedLngs: false,
  nonExplicitSupportedLngs: false,
  load: "all",
  preload: false,
  simplifyPluralSuffix: true,
  keySeparator: ".",
  nsSeparator: ":",
  pluralSeparator: "_",
  contextSeparator: "_",
  partialBundledLanguages: false,
  saveMissing: false,
  updateMissing: false,
  saveMissingTo: "fallback",
  saveMissingPlurals: true,
  missingKeyHandler: false,
  missingInterpolationHandler: false,
  postProcess: false,
  postProcessPassResolved: false,
  returnNull: false,
  returnEmptyString: true,
  returnObjects: false,
  joinArrays: false,
  returnedObjectHandler: false,
  parseMissingKeyHandler: false,
  appendNamespaceToMissingKey: false,
  appendNamespaceToCIMode: false,
  overloadTranslationOptionHandler: (args) => {
    let ret = {};
    if (typeof args[1] === "object") ret = args[1];
    if (isString$1(args[1])) ret.defaultValue = args[1];
    if (isString$1(args[2])) ret.tDescription = args[2];
    if (typeof args[2] === "object" || typeof args[3] === "object") {
      const options = args[3] || args[2];
      Object.keys(options).forEach((key) => {
        ret[key] = options[key];
      });
    }
    return ret;
  },
  interpolation: {
    escapeValue: true,
    format: (value2) => value2,
    prefix: "{{",
    suffix: "}}",
    formatSeparator: ",",
    unescapePrefix: "-",
    nestingPrefix: "$t(",
    nestingSuffix: ")",
    nestingOptionsSeparator: ",",
    maxReplaces: 1e3,
    skipOnVariables: true
  }
});
const transformOptions = (options) => {
  if (isString$1(options.ns)) options.ns = [options.ns];
  if (isString$1(options.fallbackLng)) options.fallbackLng = [options.fallbackLng];
  if (isString$1(options.fallbackNS)) options.fallbackNS = [options.fallbackNS];
  if (options.supportedLngs && options.supportedLngs.indexOf("cimode") < 0) {
    options.supportedLngs = options.supportedLngs.concat(["cimode"]);
  }
  return options;
};
const noop = () => {
};
const bindMemberFunctions = (inst) => {
  const mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));
  mems.forEach((mem) => {
    if (typeof inst[mem] === "function") {
      inst[mem] = inst[mem].bind(inst);
    }
  });
};
class I18n extends EventEmitter {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 ? arguments[1] : void 0;
    super();
    this.options = transformOptions(options);
    this.services = {};
    this.logger = baseLogger;
    this.modules = {
      external: []
    };
    bindMemberFunctions(this);
    if (callback && !this.isInitialized && !options.isClone) {
      if (!this.options.initImmediate) {
        this.init(options, callback);
        return this;
      }
      setTimeout(() => {
        this.init(options, callback);
      }, 0);
    }
  }
  init() {
    var _this = this;
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 ? arguments[1] : void 0;
    this.isInitializing = true;
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    if (!options.defaultNS && options.defaultNS !== false && options.ns) {
      if (isString$1(options.ns)) {
        options.defaultNS = options.ns;
      } else if (options.ns.indexOf("translation") < 0) {
        options.defaultNS = options.ns[0];
      }
    }
    const defOpts = get();
    this.options = {
      ...defOpts,
      ...this.options,
      ...transformOptions(options)
    };
    if (this.options.compatibilityAPI !== "v1") {
      this.options.interpolation = {
        ...defOpts.interpolation,
        ...this.options.interpolation
      };
    }
    if (options.keySeparator !== void 0) {
      this.options.userDefinedKeySeparator = options.keySeparator;
    }
    if (options.nsSeparator !== void 0) {
      this.options.userDefinedNsSeparator = options.nsSeparator;
    }
    const createClassOnDemand = (ClassOrObject) => {
      if (!ClassOrObject) return null;
      if (typeof ClassOrObject === "function") return new ClassOrObject();
      return ClassOrObject;
    };
    if (!this.options.isClone) {
      if (this.modules.logger) {
        baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
      } else {
        baseLogger.init(null, this.options);
      }
      let formatter;
      if (this.modules.formatter) {
        formatter = this.modules.formatter;
      } else if (typeof Intl !== "undefined") {
        formatter = Formatter;
      }
      const lu = new LanguageUtil(this.options);
      this.store = new ResourceStore(this.options.resources, this.options);
      const s2 = this.services;
      s2.logger = baseLogger;
      s2.resourceStore = this.store;
      s2.languageUtils = lu;
      s2.pluralResolver = new PluralResolver(lu, {
        prepend: this.options.pluralSeparator,
        compatibilityJSON: this.options.compatibilityJSON,
        simplifyPluralSuffix: this.options.simplifyPluralSuffix
      });
      if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {
        s2.formatter = createClassOnDemand(formatter);
        s2.formatter.init(s2, this.options);
        this.options.interpolation.format = s2.formatter.format.bind(s2.formatter);
      }
      s2.interpolator = new Interpolator(this.options);
      s2.utils = {
        hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
      };
      s2.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s2.resourceStore, s2, this.options);
      s2.backendConnector.on("*", function(event) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        _this.emit(event, ...args);
      });
      if (this.modules.languageDetector) {
        s2.languageDetector = createClassOnDemand(this.modules.languageDetector);
        if (s2.languageDetector.init) s2.languageDetector.init(s2, this.options.detection, this.options);
      }
      if (this.modules.i18nFormat) {
        s2.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
        if (s2.i18nFormat.init) s2.i18nFormat.init(this);
      }
      this.translator = new Translator(this.services, this.options);
      this.translator.on("*", function(event) {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }
        _this.emit(event, ...args);
      });
      this.modules.external.forEach((m) => {
        if (m.init) m.init(this);
      });
    }
    this.format = this.options.interpolation.format;
    if (!callback) callback = noop;
    if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
      const codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
      if (codes.length > 0 && codes[0] !== "dev") this.options.lng = codes[0];
    }
    if (!this.services.languageDetector && !this.options.lng) {
      this.logger.warn("init: no languageDetector is used and no lng is defined");
    }
    const storeApi = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
    storeApi.forEach((fcName) => {
      this[fcName] = function() {
        return _this.store[fcName](...arguments);
      };
    });
    const storeApiChained = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
    storeApiChained.forEach((fcName) => {
      this[fcName] = function() {
        _this.store[fcName](...arguments);
        return _this;
      };
    });
    const deferred = defer();
    const load = () => {
      const finish = (err, t2) => {
        this.isInitializing = false;
        if (this.isInitialized && !this.initializedStoreOnce) this.logger.warn("init: i18next is already initialized. You should call init just once!");
        this.isInitialized = true;
        if (!this.options.isClone) this.logger.log("initialized", this.options);
        this.emit("initialized", this.options);
        deferred.resolve(t2);
        callback(err, t2);
      };
      if (this.languages && this.options.compatibilityAPI !== "v1" && !this.isInitialized) return finish(null, this.t.bind(this));
      this.changeLanguage(this.options.lng, finish);
    };
    if (this.options.resources || !this.options.initImmediate) {
      load();
    } else {
      setTimeout(load, 0);
    }
    return deferred;
  }
  loadResources(language) {
    let callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop;
    let usedCallback = callback;
    const usedLng = isString$1(language) ? language : this.language;
    if (typeof language === "function") usedCallback = language;
    if (!this.options.resources || this.options.partialBundledLanguages) {
      if (usedLng && usedLng.toLowerCase() === "cimode" && (!this.options.preload || this.options.preload.length === 0)) return usedCallback();
      const toLoad = [];
      const append = (lng) => {
        if (!lng) return;
        if (lng === "cimode") return;
        const lngs = this.services.languageUtils.toResolveHierarchy(lng);
        lngs.forEach((l) => {
          if (l === "cimode") return;
          if (toLoad.indexOf(l) < 0) toLoad.push(l);
        });
      };
      if (!usedLng) {
        const fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        fallbacks.forEach((l) => append(l));
      } else {
        append(usedLng);
      }
      if (this.options.preload) {
        this.options.preload.forEach((l) => append(l));
      }
      this.services.backendConnector.load(toLoad, this.options.ns, (e) => {
        if (!e && !this.resolvedLanguage && this.language) this.setResolvedLanguage(this.language);
        usedCallback(e);
      });
    } else {
      usedCallback(null);
    }
  }
  reloadResources(lngs, ns, callback) {
    const deferred = defer();
    if (typeof lngs === "function") {
      callback = lngs;
      lngs = void 0;
    }
    if (typeof ns === "function") {
      callback = ns;
      ns = void 0;
    }
    if (!lngs) lngs = this.languages;
    if (!ns) ns = this.options.ns;
    if (!callback) callback = noop;
    this.services.backendConnector.reload(lngs, ns, (err) => {
      deferred.resolve();
      callback(err);
    });
    return deferred;
  }
  use(module2) {
    if (!module2) throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
    if (!module2.type) throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
    if (module2.type === "backend") {
      this.modules.backend = module2;
    }
    if (module2.type === "logger" || module2.log && module2.warn && module2.error) {
      this.modules.logger = module2;
    }
    if (module2.type === "languageDetector") {
      this.modules.languageDetector = module2;
    }
    if (module2.type === "i18nFormat") {
      this.modules.i18nFormat = module2;
    }
    if (module2.type === "postProcessor") {
      postProcessor.addPostProcessor(module2);
    }
    if (module2.type === "formatter") {
      this.modules.formatter = module2;
    }
    if (module2.type === "3rdParty") {
      this.modules.external.push(module2);
    }
    return this;
  }
  setResolvedLanguage(l) {
    if (!l || !this.languages) return;
    if (["cimode", "dev"].indexOf(l) > -1) return;
    for (let li = 0; li < this.languages.length; li++) {
      const lngInLngs = this.languages[li];
      if (["cimode", "dev"].indexOf(lngInLngs) > -1) continue;
      if (this.store.hasLanguageSomeTranslations(lngInLngs)) {
        this.resolvedLanguage = lngInLngs;
        break;
      }
    }
  }
  changeLanguage(lng, callback) {
    var _this2 = this;
    this.isLanguageChangingTo = lng;
    const deferred = defer();
    this.emit("languageChanging", lng);
    const setLngProps = (l) => {
      this.language = l;
      this.languages = this.services.languageUtils.toResolveHierarchy(l);
      this.resolvedLanguage = void 0;
      this.setResolvedLanguage(l);
    };
    const done = (err, l) => {
      if (l) {
        setLngProps(l);
        this.translator.changeLanguage(l);
        this.isLanguageChangingTo = void 0;
        this.emit("languageChanged", l);
        this.logger.log("languageChanged", l);
      } else {
        this.isLanguageChangingTo = void 0;
      }
      deferred.resolve(function() {
        return _this2.t(...arguments);
      });
      if (callback) callback(err, function() {
        return _this2.t(...arguments);
      });
    };
    const setLng = (lngs) => {
      if (!lng && !lngs && this.services.languageDetector) lngs = [];
      const l = isString$1(lngs) ? lngs : this.services.languageUtils.getBestMatchFromCodes(lngs);
      if (l) {
        if (!this.language) {
          setLngProps(l);
        }
        if (!this.translator.language) this.translator.changeLanguage(l);
        if (this.services.languageDetector && this.services.languageDetector.cacheUserLanguage) this.services.languageDetector.cacheUserLanguage(l);
      }
      this.loadResources(l, (err) => {
        done(err, l);
      });
    };
    if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
      setLng(this.services.languageDetector.detect());
    } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
      if (this.services.languageDetector.detect.length === 0) {
        this.services.languageDetector.detect().then(setLng);
      } else {
        this.services.languageDetector.detect(setLng);
      }
    } else {
      setLng(lng);
    }
    return deferred;
  }
  getFixedT(lng, ns, keyPrefix) {
    var _this3 = this;
    const fixedT = function(key, opts) {
      let options;
      if (typeof opts !== "object") {
        for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
          rest[_key3 - 2] = arguments[_key3];
        }
        options = _this3.options.overloadTranslationOptionHandler([key, opts].concat(rest));
      } else {
        options = {
          ...opts
        };
      }
      options.lng = options.lng || fixedT.lng;
      options.lngs = options.lngs || fixedT.lngs;
      options.ns = options.ns || fixedT.ns;
      if (options.keyPrefix !== "") options.keyPrefix = options.keyPrefix || keyPrefix || fixedT.keyPrefix;
      const keySeparator = _this3.options.keySeparator || ".";
      let resultKey;
      if (options.keyPrefix && Array.isArray(key)) {
        resultKey = key.map((k) => `${options.keyPrefix}${keySeparator}${k}`);
      } else {
        resultKey = options.keyPrefix ? `${options.keyPrefix}${keySeparator}${key}` : key;
      }
      return _this3.t(resultKey, options);
    };
    if (isString$1(lng)) {
      fixedT.lng = lng;
    } else {
      fixedT.lngs = lng;
    }
    fixedT.ns = ns;
    fixedT.keyPrefix = keyPrefix;
    return fixedT;
  }
  t() {
    return this.translator && this.translator.translate(...arguments);
  }
  exists() {
    return this.translator && this.translator.exists(...arguments);
  }
  setDefaultNamespace(ns) {
    this.options.defaultNS = ns;
  }
  hasLoadedNamespace(ns) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!this.isInitialized) {
      this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages);
      return false;
    }
    if (!this.languages || !this.languages.length) {
      this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages);
      return false;
    }
    const lng = options.lng || this.resolvedLanguage || this.languages[0];
    const fallbackLng = this.options ? this.options.fallbackLng : false;
    const lastLng = this.languages[this.languages.length - 1];
    if (lng.toLowerCase() === "cimode") return true;
    const loadNotPending = (l, n2) => {
      const loadState = this.services.backendConnector.state[`${l}|${n2}`];
      return loadState === -1 || loadState === 0 || loadState === 2;
    };
    if (options.precheck) {
      const preResult = options.precheck(this, loadNotPending);
      if (preResult !== void 0) return preResult;
    }
    if (this.hasResourceBundle(lng, ns)) return true;
    if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages) return true;
    if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;
    return false;
  }
  loadNamespaces(ns, callback) {
    const deferred = defer();
    if (!this.options.ns) {
      if (callback) callback();
      return Promise.resolve();
    }
    if (isString$1(ns)) ns = [ns];
    ns.forEach((n2) => {
      if (this.options.ns.indexOf(n2) < 0) this.options.ns.push(n2);
    });
    this.loadResources((err) => {
      deferred.resolve();
      if (callback) callback(err);
    });
    return deferred;
  }
  loadLanguages(lngs, callback) {
    const deferred = defer();
    if (isString$1(lngs)) lngs = [lngs];
    const preloaded = this.options.preload || [];
    const newLngs = lngs.filter((lng) => preloaded.indexOf(lng) < 0 && this.services.languageUtils.isSupportedCode(lng));
    if (!newLngs.length) {
      if (callback) callback();
      return Promise.resolve();
    }
    this.options.preload = preloaded.concat(newLngs);
    this.loadResources((err) => {
      deferred.resolve();
      if (callback) callback(err);
    });
    return deferred;
  }
  dir(lng) {
    if (!lng) lng = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language);
    if (!lng) return "rtl";
    const rtlLngs = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"];
    const languageUtils = this.services && this.services.languageUtils || new LanguageUtil(get());
    return rtlLngs.indexOf(languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
  }
  static createInstance() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 ? arguments[1] : void 0;
    return new I18n(options, callback);
  }
  cloneInstance() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop;
    const forkResourceStore = options.forkResourceStore;
    if (forkResourceStore) delete options.forkResourceStore;
    const mergedOptions = {
      ...this.options,
      ...options,
      ...{
        isClone: true
      }
    };
    const clone = new I18n(mergedOptions);
    if (options.debug !== void 0 || options.prefix !== void 0) {
      clone.logger = clone.logger.clone(options);
    }
    const membersToCopy = ["store", "services", "language"];
    membersToCopy.forEach((m) => {
      clone[m] = this[m];
    });
    clone.services = {
      ...this.services
    };
    clone.services.utils = {
      hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
    };
    if (forkResourceStore) {
      clone.store = new ResourceStore(this.store.data, mergedOptions);
      clone.services.resourceStore = clone.store;
    }
    clone.translator = new Translator(clone.services, mergedOptions);
    clone.translator.on("*", function(event) {
      for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        args[_key4 - 1] = arguments[_key4];
      }
      clone.emit(event, ...args);
    });
    clone.init(mergedOptions, callback);
    clone.translator.options = mergedOptions;
    clone.translator.backendConnector.services.utils = {
      hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
    };
    return clone;
  }
  toJSON() {
    return {
      options: this.options,
      store: this.store,
      language: this.language,
      languages: this.languages,
      resolvedLanguage: this.resolvedLanguage
    };
  }
}
const instance = I18n.createInstance();
instance.createInstance = I18n.createInstance;
instance.createInstance;
instance.dir;
instance.init;
instance.loadResources;
instance.reloadResources;
instance.use;
instance.changeLanguage;
instance.getFixedT;
instance.t;
instance.exists;
instance.setDefaultNamespace;
instance.hasLoadedNamespace;
instance.loadNamespaces;
instance.loadLanguages;
function _typeof$2(o2) {
  "@babel/helpers - typeof";
  return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof$2(o2);
}
function hasXMLHttpRequest() {
  return typeof XMLHttpRequest === "function" || (typeof XMLHttpRequest === "undefined" ? "undefined" : _typeof$2(XMLHttpRequest)) === "object";
}
function isPromise(maybePromise) {
  return !!maybePromise && typeof maybePromise.then === "function";
}
function makePromise(maybePromise) {
  if (isPromise(maybePromise)) {
    return maybePromise;
  }
  return Promise.resolve(maybePromise);
}
function commonjsRequire(path2) {
  throw new Error('Could not dynamically require "' + path2 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var getFetch$1 = { exports: {} };
var hasRequiredGetFetch;
function requireGetFetch() {
  if (hasRequiredGetFetch) return getFetch$1.exports;
  hasRequiredGetFetch = 1;
  (function(module2, exports2) {
    var fetchApi2;
    if (typeof fetch === "function") {
      if (typeof commonjsGlobal !== "undefined" && commonjsGlobal.fetch) {
        fetchApi2 = commonjsGlobal.fetch;
      } else if (typeof window !== "undefined" && window.fetch) {
        fetchApi2 = window.fetch;
      } else {
        fetchApi2 = fetch;
      }
    }
    if (typeof commonjsRequire !== "undefined" && typeof window === "undefined") {
      var f = fetchApi2 || requireBrowserPonyfill();
      if (f.default) f = f.default;
      exports2.default = f;
      module2.exports = exports2.default;
    }
  })(getFetch$1, getFetch$1.exports);
  return getFetch$1.exports;
}
var getFetchExports = requireGetFetch();
const getFetch = /* @__PURE__ */ getDefaultExportFromCjs(getFetchExports);
const fetchNode = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: getFetch
}, [getFetchExports]);
function ownKeys$1(e, r2) {
  var t2 = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread$1(e) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$1(Object(t2), true).forEach(function(r3) {
      _defineProperty$1(e, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys$1(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e;
}
function _defineProperty$1(e, r2, t2) {
  return (r2 = _toPropertyKey$1(r2)) in e ? Object.defineProperty(e, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r2] = t2, e;
}
function _toPropertyKey$1(t2) {
  var i2 = _toPrimitive$1(t2, "string");
  return "symbol" == _typeof$1(i2) ? i2 : i2 + "";
}
function _toPrimitive$1(t2, r2) {
  if ("object" != _typeof$1(t2) || !t2) return t2;
  var e = t2[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t2, r2 || "default");
    if ("object" != _typeof$1(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _typeof$1(o2) {
  "@babel/helpers - typeof";
  return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof$1(o2);
}
var fetchApi;
if (typeof fetch === "function") {
  if (typeof global !== "undefined" && global.fetch) {
    fetchApi = global.fetch;
  } else if (typeof window !== "undefined" && window.fetch) {
    fetchApi = window.fetch;
  } else {
    fetchApi = fetch;
  }
}
var XmlHttpRequestApi;
if (hasXMLHttpRequest()) {
  if (typeof global !== "undefined" && global.XMLHttpRequest) {
    XmlHttpRequestApi = global.XMLHttpRequest;
  } else if (typeof window !== "undefined" && window.XMLHttpRequest) {
    XmlHttpRequestApi = window.XMLHttpRequest;
  }
}
var ActiveXObjectApi;
if (typeof ActiveXObject === "function") {
  if (typeof global !== "undefined" && global.ActiveXObject) {
    ActiveXObjectApi = global.ActiveXObject;
  } else if (typeof window !== "undefined" && window.ActiveXObject) {
    ActiveXObjectApi = window.ActiveXObject;
  }
}
if (!fetchApi && fetchNode && !XmlHttpRequestApi && !ActiveXObjectApi) fetchApi = getFetch || fetchNode;
if (typeof fetchApi !== "function") fetchApi = void 0;
var addQueryString = function addQueryString2(url2, params) {
  if (params && _typeof$1(params) === "object") {
    var queryString = "";
    for (var paramName in params) {
      queryString += "&" + encodeURIComponent(paramName) + "=" + encodeURIComponent(params[paramName]);
    }
    if (!queryString) return url2;
    url2 = url2 + (url2.indexOf("?") !== -1 ? "&" : "?") + queryString.slice(1);
  }
  return url2;
};
var fetchIt = function fetchIt2(url2, fetchOptions, callback, altFetch) {
  var resolver = function resolver2(response) {
    if (!response.ok) return callback(response.statusText || "Error", {
      status: response.status
    });
    response.text().then(function(data) {
      callback(null, {
        status: response.status,
        data
      });
    }).catch(callback);
  };
  if (altFetch) {
    var altResponse = altFetch(url2, fetchOptions);
    if (altResponse instanceof Promise) {
      altResponse.then(resolver).catch(callback);
      return;
    }
  }
  if (typeof fetch === "function") {
    fetch(url2, fetchOptions).then(resolver).catch(callback);
  } else {
    fetchApi(url2, fetchOptions).then(resolver).catch(callback);
  }
};
var omitFetchOptions = false;
var requestWithFetch = function requestWithFetch2(options, url2, payload, callback) {
  if (options.queryStringParams) {
    url2 = addQueryString(url2, options.queryStringParams);
  }
  var headers = _objectSpread$1({}, typeof options.customHeaders === "function" ? options.customHeaders() : options.customHeaders);
  if (typeof window === "undefined" && typeof global !== "undefined" && typeof global.process !== "undefined" && global.process.versions && global.process.versions.node) {
    headers["User-Agent"] = "i18next-http-backend (node/".concat(global.process.version, "; ").concat(global.process.platform, " ").concat(global.process.arch, ")");
  }
  if (payload) headers["Content-Type"] = "application/json";
  var reqOptions = typeof options.requestOptions === "function" ? options.requestOptions(payload) : options.requestOptions;
  var fetchOptions = _objectSpread$1({
    method: payload ? "POST" : "GET",
    body: payload ? options.stringify(payload) : void 0,
    headers
  }, omitFetchOptions ? {} : reqOptions);
  var altFetch = typeof options.alternateFetch === "function" && options.alternateFetch.length >= 1 ? options.alternateFetch : void 0;
  try {
    fetchIt(url2, fetchOptions, callback, altFetch);
  } catch (e) {
    if (!reqOptions || Object.keys(reqOptions).length === 0 || !e.message || e.message.indexOf("not implemented") < 0) {
      return callback(e);
    }
    try {
      Object.keys(reqOptions).forEach(function(opt) {
        delete fetchOptions[opt];
      });
      fetchIt(url2, fetchOptions, callback, altFetch);
      omitFetchOptions = true;
    } catch (err) {
      callback(err);
    }
  }
};
var requestWithXmlHttpRequest = function requestWithXmlHttpRequest2(options, url2, payload, callback) {
  if (payload && _typeof$1(payload) === "object") {
    payload = addQueryString("", payload).slice(1);
  }
  if (options.queryStringParams) {
    url2 = addQueryString(url2, options.queryStringParams);
  }
  try {
    var x;
    if (XmlHttpRequestApi) {
      x = new XmlHttpRequestApi();
    } else {
      x = new ActiveXObjectApi("MSXML2.XMLHTTP.3.0");
    }
    x.open(payload ? "POST" : "GET", url2, 1);
    if (!options.crossDomain) {
      x.setRequestHeader("X-Requested-With", "XMLHttpRequest");
    }
    x.withCredentials = !!options.withCredentials;
    if (payload) {
      x.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
    }
    if (x.overrideMimeType) {
      x.overrideMimeType("application/json");
    }
    var h = options.customHeaders;
    h = typeof h === "function" ? h() : h;
    if (h) {
      for (var i2 in h) {
        x.setRequestHeader(i2, h[i2]);
      }
    }
    x.onreadystatechange = function() {
      x.readyState > 3 && callback(x.status >= 400 ? x.statusText : null, {
        status: x.status,
        data: x.responseText
      });
    };
    x.send(payload);
  } catch (e) {
    console && console.log(e);
  }
};
var request = function request2(options, url2, payload, callback) {
  if (typeof payload === "function") {
    callback = payload;
    payload = void 0;
  }
  callback = callback || function() {
  };
  if (fetchApi && url2.indexOf("file:") !== 0) {
    return requestWithFetch(options, url2, payload, callback);
  }
  if (hasXMLHttpRequest() || typeof ActiveXObject === "function") {
    return requestWithXmlHttpRequest(options, url2, payload, callback);
  }
  callback(new Error("No fetch and no xhr implementation found!"));
};
function _typeof(o2) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof(o2);
}
function ownKeys(e, r2) {
  var t2 = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread(e) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys(Object(t2), true).forEach(function(r3) {
      _defineProperty(e, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e;
}
function _classCallCheck(a, n2) {
  if (!(a instanceof n2)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(e, r2) {
  for (var t2 = 0; t2 < r2.length; t2++) {
    var o2 = r2[t2];
    o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e, _toPropertyKey(o2.key), o2);
  }
}
function _createClass(e, r2, t2) {
  return _defineProperties(e.prototype, r2), Object.defineProperty(e, "prototype", { writable: false }), e;
}
function _defineProperty(e, r2, t2) {
  return (r2 = _toPropertyKey(r2)) in e ? Object.defineProperty(e, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r2] = t2, e;
}
function _toPropertyKey(t2) {
  var i2 = _toPrimitive(t2, "string");
  return "symbol" == _typeof(i2) ? i2 : i2 + "";
}
function _toPrimitive(t2, r2) {
  if ("object" != _typeof(t2) || !t2) return t2;
  var e = t2[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t2, r2);
    if ("object" != _typeof(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t2);
}
var getDefaults$1 = function getDefaults() {
  return {
    loadPath: "/locales/{{lng}}/{{ns}}.json",
    addPath: "/locales/add/{{lng}}/{{ns}}",
    parse: function parse2(data) {
      return JSON.parse(data);
    },
    stringify: JSON.stringify,
    parsePayload: function parsePayload(namespace, key, fallbackValue) {
      return _defineProperty({}, key, fallbackValue || "");
    },
    parseLoadPayload: function parseLoadPayload(languages, namespaces) {
      return void 0;
    },
    request,
    reloadInterval: typeof window !== "undefined" ? false : 60 * 60 * 1e3,
    customHeaders: {},
    queryStringParams: {},
    crossDomain: false,
    withCredentials: false,
    overrideMimeType: false,
    requestOptions: {
      mode: "cors",
      credentials: "same-origin",
      cache: "default"
    }
  };
};
var Backend = function() {
  function Backend2(services) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var allOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    _classCallCheck(this, Backend2);
    this.services = services;
    this.options = options;
    this.allOptions = allOptions;
    this.type = "backend";
    this.init(services, options, allOptions);
  }
  return _createClass(Backend2, [{
    key: "init",
    value: function init(services) {
      var _this = this;
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var allOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      this.services = services;
      this.options = _objectSpread(_objectSpread(_objectSpread({}, getDefaults$1()), this.options || {}), options);
      this.allOptions = allOptions;
      if (this.services && this.options.reloadInterval) {
        var timer = setInterval(function() {
          return _this.reload();
        }, this.options.reloadInterval);
        if (_typeof(timer) === "object" && typeof timer.unref === "function") timer.unref();
      }
    }
  }, {
    key: "readMulti",
    value: function readMulti(languages, namespaces, callback) {
      this._readAny(languages, languages, namespaces, namespaces, callback);
    }
  }, {
    key: "read",
    value: function read(language, namespace, callback) {
      this._readAny([language], language, [namespace], namespace, callback);
    }
  }, {
    key: "_readAny",
    value: function _readAny(languages, loadUrlLanguages, namespaces, loadUrlNamespaces, callback) {
      var _this2 = this;
      var loadPath = this.options.loadPath;
      if (typeof this.options.loadPath === "function") {
        loadPath = this.options.loadPath(languages, namespaces);
      }
      loadPath = makePromise(loadPath);
      loadPath.then(function(resolvedLoadPath) {
        if (!resolvedLoadPath) return callback(null, {});
        var url2 = _this2.services.interpolator.interpolate(resolvedLoadPath, {
          lng: languages.join("+"),
          ns: namespaces.join("+")
        });
        _this2.loadUrl(url2, callback, loadUrlLanguages, loadUrlNamespaces);
      });
    }
  }, {
    key: "loadUrl",
    value: function loadUrl(url2, callback, languages, namespaces) {
      var _this3 = this;
      var lng = typeof languages === "string" ? [languages] : languages;
      var ns = typeof namespaces === "string" ? [namespaces] : namespaces;
      var payload = this.options.parseLoadPayload(lng, ns);
      this.options.request(this.options, url2, payload, function(err, res) {
        if (res && (res.status >= 500 && res.status < 600 || !res.status)) return callback("failed loading " + url2 + "; status code: " + res.status, true);
        if (res && res.status >= 400 && res.status < 500) return callback("failed loading " + url2 + "; status code: " + res.status, false);
        if (!res && err && err.message) {
          var errorMessage = err.message.toLowerCase();
          var isNetworkError = ["failed", "fetch", "network", "load"].find(function(term) {
            return errorMessage.indexOf(term) > -1;
          });
          if (isNetworkError) {
            return callback("failed loading " + url2 + ": " + err.message, true);
          }
        }
        if (err) return callback(err, false);
        var ret, parseErr;
        try {
          if (typeof res.data === "string") {
            ret = _this3.options.parse(res.data, languages, namespaces);
          } else {
            ret = res.data;
          }
        } catch (e) {
          parseErr = "failed parsing " + url2 + " to json";
        }
        if (parseErr) return callback(parseErr, false);
        callback(null, ret);
      });
    }
  }, {
    key: "create",
    value: function create2(languages, namespace, key, fallbackValue, callback) {
      var _this4 = this;
      if (!this.options.addPath) return;
      if (typeof languages === "string") languages = [languages];
      var payload = this.options.parsePayload(namespace, key, fallbackValue);
      var finished = 0;
      var dataArray = [];
      var resArray = [];
      languages.forEach(function(lng) {
        var addPath = _this4.options.addPath;
        if (typeof _this4.options.addPath === "function") {
          addPath = _this4.options.addPath(lng, namespace);
        }
        var url2 = _this4.services.interpolator.interpolate(addPath, {
          lng,
          ns: namespace
        });
        _this4.options.request(_this4.options, url2, payload, function(data, res) {
          finished += 1;
          dataArray.push(data);
          resArray.push(res);
          if (finished === languages.length) {
            if (typeof callback === "function") callback(dataArray, resArray);
          }
        });
      });
    }
  }, {
    key: "reload",
    value: function reload2() {
      var _this5 = this;
      var _this$services = this.services, backendConnector = _this$services.backendConnector, languageUtils = _this$services.languageUtils, logger = _this$services.logger;
      var currentLanguage = backendConnector.language;
      if (currentLanguage && currentLanguage.toLowerCase() === "cimode") return;
      var toLoad = [];
      var append = function append2(lng) {
        var lngs = languageUtils.toResolveHierarchy(lng);
        lngs.forEach(function(l) {
          if (toLoad.indexOf(l) < 0) toLoad.push(l);
        });
      };
      append(currentLanguage);
      if (this.allOptions.preload) this.allOptions.preload.forEach(function(l) {
        return append(l);
      });
      toLoad.forEach(function(lng) {
        _this5.allOptions.ns.forEach(function(ns) {
          backendConnector.read(lng, ns, "read", null, null, function(err, data) {
            if (err) logger.warn("loading namespace ".concat(ns, " for language ").concat(lng, " failed"), err);
            if (!err && data) logger.log("loaded namespace ".concat(ns, " for language ").concat(lng), data);
            backendConnector.loaded("".concat(lng, "|").concat(ns), err, data);
          });
        });
      });
    }
  }]);
}();
Backend.type = "backend";
const {
  slice,
  forEach
} = [];
function defaults(obj) {
  forEach.call(slice.call(arguments, 1), (source2) => {
    if (source2) {
      for (const prop in source2) {
        if (obj[prop] === void 0) obj[prop] = source2[prop];
      }
    }
  });
  return obj;
}
const fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
const serializeCookie = function(name2, val) {
  let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
    path: "/"
  };
  const opt = options;
  const value2 = encodeURIComponent(val);
  let str = `${name2}=${value2}`;
  if (opt.maxAge > 0) {
    const maxAge = opt.maxAge - 0;
    if (Number.isNaN(maxAge)) throw new Error("maxAge should be a Number");
    str += `; Max-Age=${Math.floor(maxAge)}`;
  }
  if (opt.domain) {
    if (!fieldContentRegExp.test(opt.domain)) {
      throw new TypeError("option domain is invalid");
    }
    str += `; Domain=${opt.domain}`;
  }
  if (opt.path) {
    if (!fieldContentRegExp.test(opt.path)) {
      throw new TypeError("option path is invalid");
    }
    str += `; Path=${opt.path}`;
  }
  if (opt.expires) {
    if (typeof opt.expires.toUTCString !== "function") {
      throw new TypeError("option expires is invalid");
    }
    str += `; Expires=${opt.expires.toUTCString()}`;
  }
  if (opt.httpOnly) str += "; HttpOnly";
  if (opt.secure) str += "; Secure";
  if (opt.sameSite) {
    const sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
    switch (sameSite) {
      case true:
        str += "; SameSite=Strict";
        break;
      case "lax":
        str += "; SameSite=Lax";
        break;
      case "strict":
        str += "; SameSite=Strict";
        break;
      case "none":
        str += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return str;
};
const cookie = {
  create(name2, value2, minutes2, domain) {
    let cookieOptions = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
      path: "/",
      sameSite: "strict"
    };
    if (minutes2) {
      cookieOptions.expires = /* @__PURE__ */ new Date();
      cookieOptions.expires.setTime(cookieOptions.expires.getTime() + minutes2 * 60 * 1e3);
    }
    if (domain) cookieOptions.domain = domain;
    document.cookie = serializeCookie(name2, encodeURIComponent(value2), cookieOptions);
  },
  read(name2) {
    const nameEQ = `${name2}=`;
    const ca = document.cookie.split(";");
    for (let i2 = 0; i2 < ca.length; i2++) {
      let c = ca[i2];
      while (c.charAt(0) === " ") c = c.substring(1, c.length);
      if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
    }
    return null;
  },
  remove(name2) {
    this.create(name2, "", -1);
  }
};
var cookie$1 = {
  name: "cookie",
  // Deconstruct the options object and extract the lookupCookie property
  lookup(_ref) {
    let {
      lookupCookie
    } = _ref;
    if (lookupCookie && typeof document !== "undefined") {
      return cookie.read(lookupCookie) || void 0;
    }
    return void 0;
  },
  // Deconstruct the options object and extract the lookupCookie, cookieMinutes, cookieDomain, and cookieOptions properties
  cacheUserLanguage(lng, _ref2) {
    let {
      lookupCookie,
      cookieMinutes,
      cookieDomain,
      cookieOptions
    } = _ref2;
    if (lookupCookie && typeof document !== "undefined") {
      cookie.create(lookupCookie, lng, cookieMinutes, cookieDomain, cookieOptions);
    }
  }
};
var querystring = {
  name: "querystring",
  // Deconstruct the options object and extract the lookupQuerystring property
  lookup(_ref) {
    var _a;
    let {
      lookupQuerystring
    } = _ref;
    let found;
    if (typeof window !== "undefined") {
      let {
        search
      } = window.location;
      if (!window.location.search && ((_a = window.location.hash) == null ? void 0 : _a.indexOf("?")) > -1) {
        search = window.location.hash.substring(window.location.hash.indexOf("?"));
      }
      const query = search.substring(1);
      const params = query.split("&");
      for (let i2 = 0; i2 < params.length; i2++) {
        const pos = params[i2].indexOf("=");
        if (pos > 0) {
          const key = params[i2].substring(0, pos);
          if (key === lookupQuerystring) {
            found = params[i2].substring(pos + 1);
          }
        }
      }
    }
    return found;
  }
};
let hasLocalStorageSupport = null;
const localStorageAvailable = () => {
  if (hasLocalStorageSupport !== null) return hasLocalStorageSupport;
  try {
    hasLocalStorageSupport = window !== "undefined" && window.localStorage !== null;
    const testKey = "i18next.translate.boo";
    window.localStorage.setItem(testKey, "foo");
    window.localStorage.removeItem(testKey);
  } catch (e) {
    hasLocalStorageSupport = false;
  }
  return hasLocalStorageSupport;
};
var localStorage$1 = {
  name: "localStorage",
  // Deconstruct the options object and extract the lookupLocalStorage property
  lookup(_ref) {
    let {
      lookupLocalStorage
    } = _ref;
    if (lookupLocalStorage && localStorageAvailable()) {
      return window.localStorage.getItem(lookupLocalStorage) || void 0;
    }
    return void 0;
  },
  // Deconstruct the options object and extract the lookupLocalStorage property
  cacheUserLanguage(lng, _ref2) {
    let {
      lookupLocalStorage
    } = _ref2;
    if (lookupLocalStorage && localStorageAvailable()) {
      window.localStorage.setItem(lookupLocalStorage, lng);
    }
  }
};
let hasSessionStorageSupport = null;
const sessionStorageAvailable = () => {
  if (hasSessionStorageSupport !== null) return hasSessionStorageSupport;
  try {
    hasSessionStorageSupport = window !== "undefined" && window.sessionStorage !== null;
    const testKey = "i18next.translate.boo";
    window.sessionStorage.setItem(testKey, "foo");
    window.sessionStorage.removeItem(testKey);
  } catch (e) {
    hasSessionStorageSupport = false;
  }
  return hasSessionStorageSupport;
};
var sessionStorage$1 = {
  name: "sessionStorage",
  lookup(_ref) {
    let {
      lookupSessionStorage
    } = _ref;
    if (lookupSessionStorage && sessionStorageAvailable()) {
      return window.sessionStorage.getItem(lookupSessionStorage) || void 0;
    }
    return void 0;
  },
  cacheUserLanguage(lng, _ref2) {
    let {
      lookupSessionStorage
    } = _ref2;
    if (lookupSessionStorage && sessionStorageAvailable()) {
      window.sessionStorage.setItem(lookupSessionStorage, lng);
    }
  }
};
var navigator$1 = {
  name: "navigator",
  lookup(options) {
    const found = [];
    if (typeof navigator !== "undefined") {
      const {
        languages,
        userLanguage,
        language
      } = navigator;
      if (languages) {
        for (let i2 = 0; i2 < languages.length; i2++) {
          found.push(languages[i2]);
        }
      }
      if (userLanguage) {
        found.push(userLanguage);
      }
      if (language) {
        found.push(language);
      }
    }
    return found.length > 0 ? found : void 0;
  }
};
var htmlTag = {
  name: "htmlTag",
  // Deconstruct the options object and extract the htmlTag property
  lookup(_ref) {
    let {
      htmlTag: htmlTag2
    } = _ref;
    let found;
    const internalHtmlTag = htmlTag2 || (typeof document !== "undefined" ? document.documentElement : null);
    if (internalHtmlTag && typeof internalHtmlTag.getAttribute === "function") {
      found = internalHtmlTag.getAttribute("lang");
    }
    return found;
  }
};
var path$2 = {
  name: "path",
  // Deconstruct the options object and extract the lookupFromPathIndex property
  lookup(_ref) {
    var _a;
    let {
      lookupFromPathIndex
    } = _ref;
    if (typeof window === "undefined") return void 0;
    const language = window.location.pathname.match(/\/([a-zA-Z-]*)/g);
    if (!Array.isArray(language)) return void 0;
    const index2 = typeof lookupFromPathIndex === "number" ? lookupFromPathIndex : 0;
    return (_a = language[index2]) == null ? void 0 : _a.replace("/", "");
  }
};
var subdomain = {
  name: "subdomain",
  lookup(_ref) {
    var _a, _b;
    let {
      lookupFromSubdomainIndex
    } = _ref;
    const internalLookupFromSubdomainIndex = typeof lookupFromSubdomainIndex === "number" ? lookupFromSubdomainIndex + 1 : 1;
    const language = typeof window !== "undefined" && ((_b = (_a = window.location) == null ? void 0 : _a.hostname) == null ? void 0 : _b.match(/^(\w{2,5})\.(([a-z0-9-]{1,63}\.[a-z]{2,6})|localhost)/i));
    if (!language) return void 0;
    return language[internalLookupFromSubdomainIndex];
  }
};
let canCookies = false;
try {
  document.cookie;
  canCookies = true;
} catch (e) {
}
const order = ["querystring", "cookie", "localStorage", "sessionStorage", "navigator", "htmlTag"];
if (!canCookies) order.splice(1, 1);
const getDefaults2 = () => ({
  order,
  lookupQuerystring: "lng",
  lookupCookie: "i18next",
  lookupLocalStorage: "i18nextLng",
  lookupSessionStorage: "i18nextLng",
  // cache user language
  caches: ["localStorage"],
  excludeCacheFor: ["cimode"],
  // cookieMinutes: 10,
  // cookieDomain: 'myDomain'
  convertDetectedLanguage: (l) => l
});
class Browser {
  constructor(services) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.type = "languageDetector";
    this.detectors = {};
    this.init(services, options);
  }
  init() {
    let services = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      languageUtils: {}
    };
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let i18nOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    this.services = services;
    this.options = defaults(options, this.options || {}, getDefaults2());
    if (typeof this.options.convertDetectedLanguage === "string" && this.options.convertDetectedLanguage.indexOf("15897") > -1) {
      this.options.convertDetectedLanguage = (l) => l.replace("-", "_");
    }
    if (this.options.lookupFromUrlIndex) this.options.lookupFromPathIndex = this.options.lookupFromUrlIndex;
    this.i18nOptions = i18nOptions;
    this.addDetector(cookie$1);
    this.addDetector(querystring);
    this.addDetector(localStorage$1);
    this.addDetector(sessionStorage$1);
    this.addDetector(navigator$1);
    this.addDetector(htmlTag);
    this.addDetector(path$2);
    this.addDetector(subdomain);
  }
  addDetector(detector) {
    this.detectors[detector.name] = detector;
    return this;
  }
  detect() {
    let detectionOrder = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.options.order;
    let detected = [];
    detectionOrder.forEach((detectorName) => {
      if (this.detectors[detectorName]) {
        let lookup = this.detectors[detectorName].lookup(this.options);
        if (lookup && typeof lookup === "string") lookup = [lookup];
        if (lookup) detected = detected.concat(lookup);
      }
    });
    detected = detected.map((d) => this.options.convertDetectedLanguage(d));
    if (this.services && this.services.languageUtils && this.services.languageUtils.getBestMatchFromCodes) return detected;
    return detected.length > 0 ? detected[0] : null;
  }
  cacheUserLanguage(lng) {
    let caches = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.options.caches;
    if (!caches) return;
    if (this.options.excludeCacheFor && this.options.excludeCacheFor.indexOf(lng) > -1) return;
    caches.forEach((cacheName) => {
      if (this.detectors[cacheName]) this.detectors[cacheName].cacheUserLanguage(lng, this.options);
    });
  }
}
Browser.type = "languageDetector";
instance.use(Backend).use(Browser).use(initReactI18next).init({
  fallbackLng: "en",
  debug: false,
  interpolation: {
    escapeValue: false,
    format: (value2, format2, lng) => {
      if (format2 === "uppercase") return value2.toUpperCase();
      if (format2 === "lowercase") return value2.toLowercase();
      return value2;
    }
  },
  keySeparator: false,
  nsSeparator: false,
  lowerCaseLng: true
});
function addLanguagePack(language, namespace, resources) {
  instance.addResourceBundle(language, namespace, resources, true, true);
}
const computedTypeList = ["alarm", "event", "measurement"];
const getApiMap = (propertyList, path2 = "targetPath") => {
  return propertyList.reduce((acc, cur) => {
    const targetPath = get$1(cur, path2);
    if (targetPath) set(acc, targetPath, "");
    return acc;
  }, {});
};
const getComputedType = (field) => {
  return computedTypeList.filter(
    (type2) => field == null ? void 0 : field.path.toLowerCase().includes(type2)
  )[0];
};
const getTargetPath = (field, source2, pathWithSource = true) => {
  const computedDetail2 = field == null ? void 0 : field.computedDetail;
  const apiType = computedDetail2 ? field == null ? void 0 : field.path : "managedObject";
  if (apiType !== "managedObject" && computedDetail2 === void 0) return;
  let target2;
  if (apiType === "alarmsStatusCheck") {
    const targetSourceAndType = computedDetail2.detail.map((item) => `${item.__target.id}.${apiType}.${item.type}`).join(",");
    return targetSourceAndType;
  }
  if (apiType === "managedObject") {
    switch (field == null ? void 0 : field.path) {
      case "lastDeviceMessage":
        target2 = "c8y_Availability.lastMessage";
        break;
      case "childDevicesCount":
        target2 = "childDevices.references";
        break;
      case "childAssetsCount":
        target2 = "childAssets.references";
        break;
      case "configurationSnapshot":
        target2 = "c8y_UploadConfigFile";
        break;
      default:
        target2 = field == null ? void 0 : field.path;
    }
  } else if (apiType === "lastMeasurement") {
    target2 = `${computedDetail2.detail[0].fragment}=>${computedDetail2.detail[0].series}`;
  } else {
    target2 = `${computedDetail2.detail[0].type}`;
  }
  if (!source2) return `${apiType}.${target2}`;
  if (pathWithSource) {
    const targetSource = apiType === "managedObject" ? source2 : computedDetail2.detail[0].__target.id;
    return `${targetSource}.${apiType}.${target2}`;
  }
  return `${apiType}.${target2}`;
};
const widgetManager = {
  widgets: {},
  // Object to store registered widgets
  schemas: {},
  // Object to store widget schemas
  /**
   * Registers a single widget with its information.
   *
   * @function register
   * @param {Object} widgetInfo - The information about the widget to be registered.
   * @param {string} widgetInfo.id - The unique identifier for the widget.
   * @param {string} widgetInfo.label - The display label for the widget.
   * @param {Object} [widgetInfo.schema] - The schema associated with the widget.
   * @throws Will throw an error if the widget ID is missing or already registered.
   */
  register: (widgetInfo) => {
    const { id: id2, label: label2 } = widgetInfo;
    if (!id2) {
      throw new Error(`Widget "${label2}" has no id.`);
    }
    if (widgetManager.widgets[id2]) {
      throw new Error(`Widget "${id2}" is already registered.`);
    }
    widgetManager.widgets[id2] = widgetInfo;
  },
  /**
   * Registers a list of widgets.
   *
   * @function registerList
   * @param {Object[]} widgetInfos - An array of widget information objects to register.
   */
  registerList: (widgetInfos) => {
    widgetInfos.forEach((widgetInfo) => widgetManager.register(widgetInfo));
  },
  /**
   * Retrieves the schema of a specific widget by its ID.
   *
   * @function getSchema
   * @param {string} widgetId - The unique identifier of the widget.
   * @returns {Object|null} - The schema of the widget, or `null` if the widget is not found.
   */
  getSchema: (widgetId) => {
    return widgetManager.schemas[widgetId];
  },
  /**
   * Loads a widget and its schema by ID.
   *
   * @function load
   * @param {string} widgetId - The unique identifier of the widget to load.
   * @returns {Object} - The information of the loaded widget.
   * @throws Will throw an error if the widget is not found.
   */
  load: (widgetId) => {
    const widgetInfo = widgetManager.widgets[widgetId];
    if (!widgetInfo) {
      throw new Error(`Widget "${widgetId}" not found.`);
    }
    widgetManager.schemas[widgetId] = widgetInfo.schema;
    return widgetInfo;
  },
  /**
   * Lists all registered widget IDs in sorted order.
   *
   * @function list
   * @returns {string[]} - An array of widget IDs.
   */
  list: () => {
    return Object.keys(widgetManager.widgets).sort();
  }
};
const useUpdatedConfig = (config, context) => {
  return useMemo(() => deviceTypeDashboardForDevice(config, context), [config]);
};
const useUpdateForTypeDashboard = (dataList, context) => {
  const { deviceTypeDashboardForData } = useUltivisLogic();
  return useMemo(() => {
    return deviceTypeDashboardForData(dataList, context);
  }, [dataList]);
};
const useWidgetSize = ({ widgetRef }) => {
  const [width, setWidth] = useState(null);
  const [height, setHeight] = useState(null);
  useEffect(() => {
    const updateSize = (entries) => {
      const { width: width2, height: height2 } = entries[0].contentRect;
      setWidth(width2);
      setHeight(height2);
    };
    const resizeObserver = new ResizeObserver(updateSize);
    if (widgetRef.current) {
      resizeObserver.observe(widgetRef.current);
    }
    return () => {
      if (widgetRef.current) {
        resizeObserver.unobserve(widgetRef.current);
      }
    };
  }, [widgetRef]);
  return { width, height };
};
const LoadingSpinner = () => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "absolute left-1/2 top-1/2 flex -translate-x-1/2 -translate-y-1/2 transform flex-col items-center gap-y-2 sm:flex-row sm:gap-y-0", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        "aria-hidden": "true",
        className: "text-gray-200 dark:text-gray-600 h-10 w-10 animate-spin fill-primary",
        viewBox: "0 0 100 101",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M100 50.5908C100 78.2051 77.6142 100.591 50 100.591C22.3858 100.591 0 78.2051 0 50.5908C0 22.9766 22.3858 0.59082 50 0.59082C77.6142 0.59082 100 22.9766 100 50.5908ZM9.08144 50.5908C9.08144 73.1895 27.4013 91.5094 50 91.5094C72.5987 91.5094 90.9186 73.1895 90.9186 50.5908C90.9186 27.9921 72.5987 9.67226 50 9.67226C27.4013 9.67226 9.08144 27.9921 9.08144 50.5908Z",
              fill: "currentColor"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M93.9676 39.0409C96.393 38.4038 97.8624 35.9116 97.0079 33.5539C95.2932 28.8227 92.871 24.3692 89.8167 20.348C85.8452 15.1192 80.8826 10.7238 75.2124 7.41289C69.5422 4.10194 63.2754 1.94025 56.7698 1.05124C51.7666 0.367541 46.6976 0.446843 41.7345 1.27873C39.2613 1.69328 37.813 4.19778 38.4501 6.62326C39.0873 9.04874 41.5694 10.4717 44.0505 10.1071C47.8511 9.54855 51.7191 9.52689 55.5402 10.0491C60.8642 10.7766 65.9928 12.5457 70.6331 15.2552C75.2735 17.9648 79.3347 21.5619 82.5849 25.841C84.9175 28.9121 86.7997 32.2913 88.1811 35.8758C89.083 38.2158 91.5421 39.6781 93.9676 39.0409Z",
              fill: "currentFill"
            }
          )
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "pl-2 text-sm", children: t2("Loading...") })
  ] });
};
const LoadingDots = () => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex", children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "animate-inifinite m-0.5 inline-block h-2.5 w-2.5 animate-pulse rounded-full bg-primary animate-delay-[120ms] animate-duration-[750ms] animate-ease-out" }),
  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "animate-inifinite m-0.5 inline-block h-2.5 w-2.5 animate-pulse rounded-full bg-primary animate-delay-[240ms] animate-duration-[750ms] animate-ease-out" }),
  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "animate-inifinite m-0.5 inline-block h-2.5 w-2.5 animate-pulse rounded-full bg-primary animate-delay-[360ms] animate-duration-[750ms] animate-ease-out" })
] });
const Loading = ({ fullScreen = false, spinner = true }) => {
  const LoadingComponent = spinner ? /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSpinner, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingDots, {});
  return fullScreen ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative h-screen w-screen", children: LoadingComponent }) : LoadingComponent;
};
const SvgAlarm = (props) => /* @__PURE__ */ React.createElement("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("path", { d: "M18 8C18 6.4087 17.3679 4.88258 16.2426 3.75736C15.1174 2.63214 13.5913 2 12 2C10.4087 2 8.88258 2.63214 7.75736 3.75736C6.63214 4.88258 6 6.4087 6 8C6 15 3 17 3 17H21C21 17 18 15 18 8Z", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M15 20C14.6951 20.6083 14.2575 21.1132 13.731 21.4642C13.2045 21.8153 12.6076 22 12 22C11.3924 22 10.7955 21.8153 10.269 21.4642C9.74247 21.1132 9.30487 20.6083 9 20", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }));
const SvgAlarmBreakdownPurple = (props) => /* @__PURE__ */ React.createElement("svg", { width: 64, height: 64, viewBox: "0 0 64 64", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("g", { id: "ic_64/ic64_alarm_breakdown_purple", clipPath: "url(#clip0_2280_4218)" }, /* @__PURE__ */ React.createElement("circle", { id: "Ellipse 1", cx: 32, cy: 32, r: 32, fill: "#9F47F5", fillOpacity: 0.12 }), /* @__PURE__ */ React.createElement("g", { id: "fi:minus-circle" }, /* @__PURE__ */ React.createElement("path", { id: "Vector", d: "M32 45.3334C39.3638 45.3334 45.3333 39.3639 45.3333 32.0001C45.3333 24.6363 39.3638 18.6667 32 18.6667C24.6362 18.6667 18.6666 24.6363 18.6666 32.0001C18.6666 39.3639 24.6362 45.3334 32 45.3334Z", fill: "#9F47F5", stroke: "#9F47F5", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { id: "Vector_2", d: "M26.6666 32H37.3333", stroke: "white", strokeWidth: 3, strokeLinecap: "round", strokeLinejoin: "round" }))), /* @__PURE__ */ React.createElement("defs", null, /* @__PURE__ */ React.createElement("clipPath", { id: "clip0_2280_4218" }, /* @__PURE__ */ React.createElement("rect", { width: 64, height: 64, fill: "white" }))));
const SvgAlarmBreakdownRed = (props) => /* @__PURE__ */ React.createElement("svg", { width: 64, height: 64, viewBox: "0 0 64 64", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("g", { id: "ic_64/ic64_alarm_breakdown_red", clipPath: "url(#clip0_2280_4223)" }, /* @__PURE__ */ React.createElement("circle", { id: "Ellipse 1", cx: 32, cy: 32, r: 32, fill: "#FF4545", fillOpacity: 0.12 }), /* @__PURE__ */ React.createElement("g", { id: "fi:minus-circle" }, /* @__PURE__ */ React.createElement("path", { id: "Vector", d: "M32 45.3334C39.3638 45.3334 45.3334 39.3639 45.3334 32.0001C45.3334 24.6363 39.3638 18.6667 32 18.6667C24.6362 18.6667 18.6667 24.6363 18.6667 32.0001C18.6667 39.3639 24.6362 45.3334 32 45.3334Z", fill: "#FF4545", stroke: "#FF4545", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { id: "Vector_2", d: "M26.6667 32H37.3334", stroke: "white", strokeWidth: 3, strokeLinecap: "round", strokeLinejoin: "round" }))), /* @__PURE__ */ React.createElement("defs", null, /* @__PURE__ */ React.createElement("clipPath", { id: "clip0_2280_4223" }, /* @__PURE__ */ React.createElement("rect", { width: 64, height: 64, fill: "white" }))));
const SvgAlarmCritical = (props) => /* @__PURE__ */ React.createElement("svg", { width: 64, height: 64, viewBox: "0 0 64 64", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("g", { id: "ic_64/ic64_alarm_critical", clipPath: "url(#clip0_2280_4200)" }, /* @__PURE__ */ React.createElement("circle", { id: "Ellipse 1", cx: 32, cy: 32, r: 32, fill: "#FF4545", fillOpacity: 0.12 }), /* @__PURE__ */ React.createElement("g", { id: "fi:alert-triangle" }, /* @__PURE__ */ React.createElement("path", { id: "Vector", d: "M29.72 21.1467L18.4267 40C18.1939 40.4033 18.0707 40.8604 18.0693 41.3261C18.068 41.7917 18.1887 42.2495 18.4193 42.6541C18.6498 43.0586 18.9823 43.3957 19.3836 43.6318C19.7849 43.868 20.2411 43.9949 20.7067 44H43.2934C43.759 43.9949 44.2151 43.868 44.6164 43.6318C45.0177 43.3957 45.3502 43.0586 45.5808 42.6541C45.8114 42.2495 45.932 41.7917 45.9307 41.3261C45.9294 40.8604 45.8062 40.4033 45.5734 40L34.28 21.1467C34.0423 20.7548 33.7077 20.4309 33.3083 20.206C32.9089 19.9812 32.4583 19.863 32 19.863C31.5417 19.863 31.0911 19.9812 30.6918 20.206C30.2924 20.4309 29.9577 20.7548 29.72 21.1467Z", fill: "#FF4545", stroke: "#FF4545", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { id: "Vector_2", d: "M32 28V33.3333", stroke: "white", strokeWidth: 3, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { id: "Vector_3", d: "M32 38.6667H32.0133", stroke: "white", strokeWidth: 3, strokeLinecap: "round", strokeLinejoin: "round" }))), /* @__PURE__ */ React.createElement("defs", null, /* @__PURE__ */ React.createElement("clipPath", { id: "clip0_2280_4200" }, /* @__PURE__ */ React.createElement("rect", { width: 64, height: 64, fill: "white" }))));
const SvgAlarmFilter = (props) => /* @__PURE__ */ React.createElement("svg", { width: 64, height: 64, viewBox: "0 0 64 64", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("g", { id: "ic_64/ic64_alarm_filter" }, /* @__PURE__ */ React.createElement("circle", { id: "Ellipse 1", cx: 32, cy: 32, r: 32, fill: "#9F47F5", fillOpacity: 0.12 }), /* @__PURE__ */ React.createElement("g", { id: "Vector" }, /* @__PURE__ */ React.createElement("path", { d: "M21.8624 35.2299C20.3335 30.4496 22.4032 25.189 26.784 22.7211C28.3646 21.8306 30.1652 21.3598 31.9887 21.3598C33.8122 21.3598 35.6982 21.8521 37.3038 22.7662C36.985 22.8442 36.6958 23.0151 36.4684 23.2633C36.1651 23.5949 36.009 24.0247 36.0292 24.4727C36.0689 25.3747 36.8061 26.0809 37.7081 26.0809L41.6503 25.9087C42.0989 25.8892 42.5133 25.6955 42.8166 25.3646C43.12 25.033 43.276 24.6032 43.2559 24.1552L43.0857 20.2876C43.0473 19.4011 42.296 18.6794 41.4115 18.6794L41.3321 18.6814C40.8835 18.7009 40.4692 18.8946 40.1658 19.2255C39.8907 19.5262 39.7367 19.9076 39.7253 20.3111C37.4444 18.8139 34.7364 18 31.9813 18C29.5814 18 27.2138 18.6195 25.1333 19.7919C19.3696 23.0386 16.6462 29.9619 18.6587 36.255C18.8833 36.9545 19.5263 37.424 20.2602 37.424C20.4344 37.424 20.6066 37.3971 20.7727 37.344C21.6559 37.0615 22.1449 36.1138 21.8624 35.2299Z", fill: "#9F47F5" }), /* @__PURE__ */ React.createElement("path", { d: "M45.3612 27.743C45.1379 27.0428 44.4955 26.5726 43.7617 26.5726C43.5875 26.5726 43.4139 26.6002 43.2471 26.6533C42.8193 26.7899 42.4702 27.0851 42.2644 27.4847C42.0593 27.8835 42.0209 28.3389 42.1575 28.7674C43.6857 33.5477 41.616 38.8083 37.2352 41.2762C35.6559 42.166 33.8573 42.6362 32.0345 42.6362C30.1935 42.6362 28.3767 42.1573 26.786 41.2674C27.0611 41.1773 27.31 41.0165 27.5097 40.7952C27.8104 40.4616 27.9631 40.0305 27.9402 39.5825C27.8945 38.6879 27.1559 37.9877 26.2593 37.9877L26.1739 37.9897L22.307 38.1895C21.8583 38.213 21.4467 38.4094 21.146 38.7424C20.8447 39.076 20.692 39.5065 20.7155 39.9558L20.916 43.8214C20.9617 44.7153 21.6996 45.4162 22.5942 45.4162L22.6823 45.4141C23.1309 45.3906 23.5439 45.1942 23.8446 44.8606C24.1392 44.5344 24.2919 44.114 24.2757 43.6761C26.56 45.1814 29.272 46 32.0304 46C34.433 46 36.8034 45.3798 38.8865 44.2061C44.6502 40.9594 47.373 34.0347 45.3612 27.743Z", fill: "#9F47F5" }))));
const SvgAlarmMajor = (props) => /* @__PURE__ */ React.createElement("svg", { width: 64, height: 64, viewBox: "0 0 64 64", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("g", { id: "ic_64/ic64_alarm_major", clipPath: "url(#clip0_2280_4187)" }, /* @__PURE__ */ React.createElement("circle", { id: "Ellipse 1", cx: 32, cy: 32, r: 32, fill: "#FDB541", fillOpacity: 0.15 }), /* @__PURE__ */ React.createElement("g", { id: "fi:alert-circle" }, /* @__PURE__ */ React.createElement("path", { id: "Vector", d: "M32 45.3334C39.3638 45.3334 45.3334 39.3639 45.3334 32.0001C45.3334 24.6363 39.3638 18.6667 32 18.6667C24.6362 18.6667 18.6667 24.6363 18.6667 32.0001C18.6667 39.3639 24.6362 45.3334 32 45.3334Z", fill: "#FDB541", stroke: "#FDB541", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { id: "Vector_2", d: "M32 37.3333H32.0133", stroke: "white", strokeWidth: 3, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { id: "Vector_3", d: "M32 26.6667V32.0001", stroke: "white", strokeWidth: 3, strokeLinecap: "round", strokeLinejoin: "round" }))), /* @__PURE__ */ React.createElement("defs", null, /* @__PURE__ */ React.createElement("clipPath", { id: "clip0_2280_4187" }, /* @__PURE__ */ React.createElement("rect", { width: 64, height: 64, fill: "white" }))));
const SvgAlarmManage = (props) => /* @__PURE__ */ React.createElement("svg", { width: 64, height: 64, viewBox: "0 0 64 64", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("g", { id: "ic_64/ic64_alarm_manage", clipPath: "url(#clip0_2280_4179)" }, /* @__PURE__ */ React.createElement("circle", { id: "Ellipse 1", cx: 32, cy: 32, r: 32, fill: "#46CDD0", fillOpacity: 0.15 }), /* @__PURE__ */ React.createElement("g", { id: "fi:settings", clipPath: "url(#clip1_2280_4179)" }, /* @__PURE__ */ React.createElement("g", { id: "Subtract" }, /* @__PURE__ */ React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M41.7146 37.2807C41.6362 36.8482 41.6891 36.4021 41.8666 35.9999C42.0356 35.6056 42.3162 35.2692 42.674 35.0323C43.0317 34.7954 43.4509 34.6683 43.8799 34.6666H43.9999C44.7072 34.6666 45.3854 34.3856 45.8855 33.8855C46.3856 33.3854 46.6666 32.7072 46.6666 31.9999C46.6666 31.2927 46.3856 30.6144 45.8855 30.1143C45.3854 29.6142 44.7072 29.3333 43.9999 29.3333H43.7733C43.3442 29.3315 42.925 29.2044 42.5673 28.9675C42.2096 28.7306 41.9289 28.3943 41.7599 27.9999V27.8933C41.5824 27.4911 41.5295 27.045 41.6079 26.6125C41.6863 26.1799 41.8925 25.7808 42.1999 25.4666L42.2799 25.3866C42.5279 25.1389 42.7245 24.8448 42.8587 24.5211C42.9929 24.1974 43.062 23.8504 43.062 23.4999C43.062 23.1495 42.9929 22.8025 42.8587 22.4787C42.7245 22.155 42.5279 21.8609 42.2799 21.6133C42.0323 21.3653 41.7382 21.1686 41.4144 21.0344C41.0907 20.9002 40.7437 20.8312 40.3933 20.8312C40.0428 20.8312 39.6958 20.9002 39.3721 21.0344C39.0484 21.1686 38.7542 21.3653 38.5066 21.6133L38.4266 21.6933C38.1123 22.0006 37.7132 22.2068 37.2807 22.2853C36.8482 22.3637 36.4021 22.3107 35.9999 22.1333C35.6056 21.9642 35.2692 21.6836 35.0323 21.3259C34.7954 20.9682 34.6683 20.549 34.6666 20.1199V19.9999C34.6666 19.2927 34.3856 18.6144 33.8855 18.1143C33.3854 17.6142 32.7072 17.3333 31.9999 17.3333C31.2927 17.3333 30.6144 17.6142 30.1143 18.1143C29.6142 18.6144 29.3333 19.2927 29.3333 19.9999V20.2266C29.3315 20.6556 29.2044 21.0748 28.9675 21.4325C28.7306 21.7903 28.3943 22.0709 27.9999 22.2399H27.8933C27.4911 22.4174 27.045 22.4703 26.6125 22.3919C26.1799 22.3135 25.7808 22.1073 25.4666 21.7999L25.3866 21.7199C25.1389 21.472 24.8448 21.2753 24.5211 21.1411C24.1974 21.0069 23.8504 20.9378 23.4999 20.9378C23.1495 20.9378 22.8025 21.0069 22.4787 21.1411C22.155 21.2753 21.8609 21.472 21.6133 21.7199C21.3653 21.9676 21.1686 22.2617 21.0344 22.5854C20.9002 22.9091 20.8312 23.2561 20.8312 23.6066C20.8312 23.957 20.9002 24.304 21.0344 24.6278C21.1686 24.9515 21.3653 25.2456 21.6133 25.4933L21.6933 25.5733C22.0006 25.8875 22.2068 26.2866 22.2853 26.7191C22.3637 27.1517 22.3107 27.5978 22.1333 27.9999C21.9809 28.4142 21.7074 28.7731 21.3483 29.0299C20.9893 29.2867 20.5612 29.4296 20.1199 29.4399H19.9999C19.2927 29.4399 18.6144 29.7209 18.1143 30.221C17.6142 30.7211 17.3333 31.3993 17.3333 32.1066C17.3333 32.8138 17.6142 33.4921 18.1143 33.9922C18.6144 34.4923 19.2927 34.7733 19.9999 34.7733H20.2266C20.6556 34.775 21.0748 34.9021 21.4325 35.139C21.7903 35.3759 22.0709 35.7122 22.2399 36.1066C22.4174 36.5087 22.4703 36.9548 22.3919 37.3874C22.3135 37.8199 22.1073 38.219 21.7999 38.5333L21.7199 38.6133C21.472 38.8609 21.2753 39.155 21.1411 39.4787C21.0069 39.8025 20.9378 40.1495 20.9378 40.4999C20.9378 40.8504 21.0069 41.1974 21.1411 41.5211C21.2753 41.8448 21.472 42.1389 21.7199 42.3866C21.9676 42.6345 22.2617 42.8312 22.5854 42.9654C22.9091 43.0996 23.2561 43.1687 23.6066 43.1687C23.957 43.1687 24.304 43.0996 24.6278 42.9654C24.9515 42.8312 25.2456 42.6345 25.4933 42.3866L25.5733 42.3066C25.8875 41.9992 26.2866 41.793 26.7191 41.7146C27.1517 41.6362 27.5978 41.6891 27.9999 41.8666C28.4142 42.019 28.7731 42.2925 29.0299 42.6515C29.2867 43.0106 29.4296 43.4386 29.4399 43.8799V43.9999C29.4399 44.7072 29.7209 45.3854 30.221 45.8855C30.7211 46.3856 31.3993 46.6666 32.1066 46.6666C32.8138 46.6666 33.4921 46.3856 33.9922 45.8855C34.4923 45.3854 34.7733 44.7072 34.7733 43.9999V43.7733C34.775 43.3442 34.9021 42.925 35.139 42.5673C35.3759 42.2096 35.7122 41.9289 36.1066 41.7599C36.5087 41.5824 36.9548 41.5295 37.3874 41.6079C37.8199 41.6863 38.219 41.8925 38.5333 42.1999L38.6133 42.2799C38.8609 42.5279 39.155 42.7245 39.4787 42.8587C39.8025 42.9929 40.1495 43.062 40.4999 43.062C40.8504 43.062 41.1974 42.9929 41.5211 42.8587C41.8448 42.7245 42.1389 42.5279 42.3866 42.2799C42.6345 42.0323 42.8312 41.7382 42.9654 41.4144C43.0996 41.0907 43.1687 40.7437 43.1687 40.3933C43.1687 40.0428 43.0996 39.6958 42.9654 39.3721C42.8312 39.0484 42.6345 38.7542 42.3866 38.5066L42.3066 38.4266C41.9992 38.1123 41.793 37.7132 41.7146 37.2807ZM27 31.9999C27 29.2385 29.2386 26.9999 32 26.9999C34.7614 26.9999 37 29.2385 37 31.9999C37 34.7614 34.7614 36.9999 32 36.9999C29.2386 36.9999 27 34.7614 27 31.9999Z", fill: "#46CDD0" }), /* @__PURE__ */ React.createElement("path", { d: "M41.8666 35.9999L42.7815 36.4037L42.7857 36.3939L41.8666 35.9999ZM41.7146 37.2807L42.6985 37.1023L42.6985 37.1023L41.7146 37.2807ZM42.674 35.0323L43.2261 35.8661L43.2261 35.8661L42.674 35.0323ZM43.8799 34.6666V33.6666L43.8759 33.6666L43.8799 34.6666ZM45.8855 33.8855L45.1784 33.1784V33.1784L45.8855 33.8855ZM45.8855 30.1143L45.1784 30.8214L45.1784 30.8214L45.8855 30.1143ZM43.7733 29.3333L43.7693 30.3333H43.7733V29.3333ZM42.5673 28.9675L42.0152 29.8013V29.8013L42.5673 28.9675ZM41.7599 27.9999H40.7599C40.7599 28.1354 40.7874 28.2694 40.8408 28.3939L41.7599 27.9999ZM41.7599 27.8933H42.7599C42.7599 27.7542 42.7309 27.6167 42.6748 27.4895L41.7599 27.8933ZM41.6079 26.6125L42.5919 26.7909L42.5919 26.7909L41.6079 26.6125ZM42.1999 25.4666L41.4928 24.7594L41.4851 24.7673L42.1999 25.4666ZM42.2799 25.3866L41.5732 24.6791L41.5728 24.6795L42.2799 25.3866ZM42.8587 24.5211L43.7825 24.904L43.7825 24.904L42.8587 24.5211ZM42.8587 22.4787L43.7825 22.0958L43.7825 22.0958L42.8587 22.4787ZM42.2799 21.6133L41.5724 22.32L41.5732 22.3208L42.2799 21.6133ZM41.4144 21.0344L41.0315 21.9582L41.4144 21.0344ZM39.3721 21.0344L38.9891 20.1107L38.9891 20.1107L39.3721 21.0344ZM38.5066 21.6133L39.2137 22.3204L39.2141 22.32L38.5066 21.6133ZM38.4266 21.6933L39.1259 22.4082L39.1337 22.4004L38.4266 21.6933ZM37.2807 22.2853L37.4591 23.2692H37.4591L37.2807 22.2853ZM35.9999 22.1333L36.4037 21.2183L36.3939 21.2141L35.9999 22.1333ZM35.0323 21.3259L35.8661 20.7737L35.8661 20.7737L35.0323 21.3259ZM34.6666 20.1199H33.6666L33.6666 20.1239L34.6666 20.1199ZM30.1143 18.1143L30.8214 18.8214L30.8214 18.8214L30.1143 18.1143ZM29.3333 20.2266L30.3333 20.2306V20.2266H29.3333ZM28.9675 21.4325L28.1338 20.8804L28.1338 20.8804L28.9675 21.4325ZM27.9999 22.2399V23.2399C28.1354 23.2399 28.2694 23.2124 28.3939 23.1591L27.9999 22.2399ZM27.8933 22.2399V21.2399C27.7542 21.2399 27.6167 21.2689 27.4895 21.3251L27.8933 22.2399ZM26.6125 22.3919L26.4341 23.3759H26.4341L26.6125 22.3919ZM25.4666 21.7999L24.7594 22.5071L24.7673 22.5148L25.4666 21.7999ZM25.3866 21.7199L24.6791 22.4266L24.6795 22.427L25.3866 21.7199ZM24.5211 21.1411L24.1382 22.0649L24.1382 22.0649L24.5211 21.1411ZM22.4787 21.1411L22.8617 22.0649L22.4787 21.1411ZM21.6133 21.7199L22.32 22.4274L22.3208 22.4266L21.6133 21.7199ZM21.0344 22.5854L21.9582 22.9684L21.0344 22.5854ZM21.0344 24.6278L21.9582 24.2448L21.9582 24.2448L21.0344 24.6278ZM21.6133 25.4933L22.3204 24.7861L22.32 24.7858L21.6133 25.4933ZM21.6933 25.5733L22.4082 24.8739L22.4004 24.8661L21.6933 25.5733ZM22.2853 26.7191L23.2692 26.5407V26.5407L22.2853 26.7191ZM22.1333 27.9999L21.2184 27.5962C21.2099 27.6154 21.202 27.635 21.1947 27.6547L22.1333 27.9999ZM20.1199 29.4399V30.4399C20.1277 30.4399 20.1355 30.4398 20.1433 30.4396L20.1199 29.4399ZM18.1143 30.221L18.8214 30.9281L18.8214 30.9281L18.1143 30.221ZM20.2266 34.7733L20.2306 33.7733H20.2266V34.7733ZM21.4325 35.139L20.8804 35.9727L20.8804 35.9727L21.4325 35.139ZM22.2399 36.1066L21.3207 36.5005L21.3251 36.5104L22.2399 36.1066ZM22.3919 37.3874L23.3759 37.5658V37.5658L22.3919 37.3874ZM21.7999 38.5333L22.5071 39.2404L22.5148 39.2325L21.7999 38.5333ZM21.7199 38.6133L22.4266 39.3208L22.427 39.3204L21.7199 38.6133ZM21.1411 39.4787L20.2173 39.0958L20.2173 39.0958L21.1411 39.4787ZM21.1411 41.5211L22.0649 41.1382L21.1411 41.5211ZM21.7199 42.3866L22.4274 41.6799L22.4266 41.6791L21.7199 42.3866ZM22.5854 42.9654L22.2025 43.8892L22.2025 43.8892L22.5854 42.9654ZM24.6278 42.9654L25.0107 43.8892L25.0107 43.8892L24.6278 42.9654ZM25.4933 42.3866L24.7861 41.6795L24.7857 41.6799L25.4933 42.3866ZM25.5733 42.3066L24.8739 41.5917L24.8661 41.5995L25.5733 42.3066ZM26.7191 41.7146L26.8975 42.6985L26.8975 42.6985L26.7191 41.7146ZM27.9999 41.8666L27.5962 42.7814C27.6154 42.79 27.635 42.7978 27.6547 42.8051L27.9999 41.8666ZM29.0299 42.6515L29.8433 42.0698L29.8433 42.0698L29.0299 42.6515ZM29.4399 43.8799H30.4399C30.4399 43.8721 30.4398 43.8643 30.4396 43.8565L29.4399 43.8799ZM30.221 45.8855L30.9281 45.1784L30.9281 45.1784L30.221 45.8855ZM33.9922 45.8855L33.2851 45.1784H33.2851L33.9922 45.8855ZM34.7733 43.7733L33.7733 43.7693V43.7733H34.7733ZM35.139 42.5673L35.9727 43.1194L35.9727 43.1194L35.139 42.5673ZM36.1066 41.7599L36.5005 42.6791L36.5104 42.6748L36.1066 41.7599ZM37.3874 41.6079L37.209 42.5919L37.209 42.5919L37.3874 41.6079ZM38.5333 42.1999L39.2404 41.4928L39.2325 41.4851L38.5333 42.1999ZM38.6133 42.2799L39.3207 41.5732L39.3204 41.5728L38.6133 42.2799ZM39.4787 42.8587L39.0958 43.7825L39.0958 43.7825L39.4787 42.8587ZM41.5211 42.8587L41.904 43.7825L41.904 43.7825L41.5211 42.8587ZM42.3866 42.2799L41.6799 41.5724L41.6791 41.5732L42.3866 42.2799ZM42.9654 41.4144L43.8892 41.7974L43.8892 41.7974L42.9654 41.4144ZM42.9654 39.3721L43.8892 38.9891L43.8892 38.9891L42.9654 39.3721ZM42.3866 38.5066L41.6795 39.2137L41.6799 39.2141L42.3866 38.5066ZM42.3066 38.4266L41.5917 39.1259L41.5995 39.1337L42.3066 38.4266ZM40.9517 35.5962C40.6936 36.1811 40.6166 36.83 40.7306 37.4591L42.6985 37.1023C42.6558 36.8664 42.6846 36.623 42.7814 36.4037L40.9517 35.5962ZM42.1218 34.1986C41.6015 34.5432 41.1933 35.0324 40.9474 35.606L42.7857 36.3939C42.8779 36.1787 43.031 35.9953 43.2261 35.8661L42.1218 34.1986ZM43.8759 33.6666C43.2519 33.6691 42.6421 33.854 42.1218 34.1986L43.2261 35.8661C43.4212 35.7369 43.6499 35.6675 43.8839 35.6666L43.8759 33.6666ZM43.9999 33.6666H43.8799V35.6666H43.9999V33.6666ZM45.1784 33.1784C44.8659 33.491 44.4419 33.6666 43.9999 33.6666V35.6666C44.9724 35.6666 45.905 35.2803 46.5926 34.5926L45.1784 33.1784ZM45.6666 31.9999C45.6666 32.4419 45.491 32.8659 45.1784 33.1784L46.5926 34.5926C47.2803 33.905 47.6666 32.9724 47.6666 31.9999H45.6666ZM45.1784 30.8214C45.491 31.134 45.6666 31.5579 45.6666 31.9999H47.6666C47.6666 31.0275 47.2803 30.0948 46.5926 29.4072L45.1784 30.8214ZM43.9999 30.3333C44.4419 30.3333 44.8659 30.5088 45.1784 30.8214L46.5926 29.4072C45.905 28.7196 44.9724 28.3333 43.9999 28.3333V30.3333ZM43.7733 30.3333H43.9999V28.3333H43.7733V30.3333ZM42.0152 29.8013C42.5355 30.1458 43.1452 30.3308 43.7693 30.3332L43.7772 28.3333C43.5432 28.3323 43.3146 28.263 43.1194 28.1338L42.0152 29.8013ZM40.8408 28.3939C41.0866 28.9675 41.4948 29.4567 42.0152 29.8013L43.1194 28.1338C42.9243 28.0045 42.7712 27.8211 42.6791 27.606L40.8408 28.3939ZM40.7599 27.8933V27.9999H42.7599V27.8933H40.7599ZM40.624 26.4341C40.5099 27.0632 40.5869 27.7121 40.8451 28.297L42.6748 27.4895C42.578 27.2701 42.5491 27.0268 42.5919 26.7909L40.624 26.4341ZM41.4851 24.7673C41.038 25.2244 40.738 25.8049 40.624 26.4341L42.5919 26.7909C42.6346 26.555 42.7471 26.3373 42.9148 26.1658L41.4851 24.7673ZM41.5728 24.6795L41.4928 24.7595L42.907 26.1737L42.987 26.0937L41.5728 24.6795ZM41.935 24.1381C41.8511 24.3405 41.7282 24.5243 41.5732 24.6791L42.9866 26.0941C43.3275 25.7536 43.598 25.3492 43.7825 24.904L41.935 24.1381ZM42.062 23.4999C42.062 23.7189 42.0188 23.9358 41.935 24.1382L43.7825 24.904C43.967 24.4589 44.062 23.9818 44.062 23.4999H42.062ZM41.935 22.8617C42.0188 23.064 42.062 23.2809 42.062 23.4999H44.062C44.062 23.0181 43.967 22.5409 43.7825 22.0958L41.935 22.8617ZM41.5732 22.3208C41.7282 22.4755 41.8511 22.6594 41.935 22.8617L43.7825 22.0958C43.598 21.6507 43.3275 21.2463 42.9866 20.9058L41.5732 22.3208ZM41.0315 21.9582C41.2338 22.0421 41.4176 22.165 41.5724 22.32L42.9874 20.9065C42.6469 20.5656 42.2425 20.2952 41.7974 20.1107L41.0315 21.9582ZM40.3933 21.8312C40.6123 21.8312 40.8292 21.8743 41.0315 21.9582L41.7974 20.1107C41.3522 19.9261 40.8751 19.8312 40.3933 19.8312V21.8312ZM39.755 21.9582C39.9573 21.8743 40.1742 21.8312 40.3933 21.8312V19.8312C39.9114 19.8312 39.4343 19.9261 38.9891 20.1107L39.755 21.9582ZM39.2141 22.32C39.3689 22.165 39.5527 22.0421 39.755 21.9582L38.9891 20.1107C38.544 20.2952 38.1396 20.5656 37.7991 20.9065L39.2141 22.32ZM39.1337 22.4004L39.2137 22.3204L37.7995 20.9062L37.7195 20.9862L39.1337 22.4004ZM37.4591 23.2692C38.0882 23.1551 38.6688 22.8552 39.1259 22.4081L37.7273 20.9784C37.5559 21.1461 37.3382 21.2585 37.1023 21.3013L37.4591 23.2692ZM35.5962 23.0481C36.1811 23.3063 36.83 23.3833 37.4591 23.2692L37.1023 21.3013C36.8664 21.3441 36.623 21.3152 36.4037 21.2184L35.5962 23.0481ZM34.1986 21.878C34.5432 22.3983 35.0324 22.8065 35.606 23.0524L36.3939 21.2141C36.1787 21.1219 35.9953 20.9688 35.8661 20.7737L34.1986 21.878ZM33.6666 20.1239C33.6691 20.748 33.854 21.3577 34.1986 21.878L35.8661 20.7737C35.7369 20.5786 35.6675 20.35 35.6666 20.1159L33.6666 20.1239ZM33.6666 19.9999V20.1199H35.6666V19.9999H33.6666ZM33.1784 18.8214C33.491 19.134 33.6666 19.5579 33.6666 19.9999H35.6666C35.6666 19.0275 35.2803 18.0948 34.5926 17.4072L33.1784 18.8214ZM31.9999 18.3333C32.4419 18.3333 32.8659 18.5088 33.1784 18.8214L34.5926 17.4072C33.905 16.7196 32.9724 16.3333 31.9999 16.3333V18.3333ZM30.8214 18.8214C31.134 18.5088 31.5579 18.3333 31.9999 18.3333V16.3333C31.0275 16.3333 30.0948 16.7196 29.4072 17.4072L30.8214 18.8214ZM30.3333 19.9999C30.3333 19.5579 30.5088 19.134 30.8214 18.8214L29.4072 17.4072C28.7196 18.0948 28.3333 19.0275 28.3333 19.9999H30.3333ZM30.3333 20.2266V19.9999H28.3333V20.2266H30.3333ZM29.8013 21.9847C30.1458 21.4644 30.3308 20.8546 30.3332 20.2306L28.3333 20.2226C28.3323 20.4566 28.263 20.6853 28.1338 20.8804L29.8013 21.9847ZM28.3939 23.1591C28.9675 22.9132 29.4567 22.505 29.8013 21.9847L28.1338 20.8804C28.0045 21.0755 27.8211 21.2286 27.606 21.3208L28.3939 23.1591ZM27.8933 23.2399H27.9999V21.2399H27.8933V23.2399ZM26.4341 23.3759C27.0632 23.49 27.7121 23.4129 28.297 23.1548L27.4895 21.3251C27.2701 21.4219 27.0268 21.4507 26.7909 21.408L26.4341 23.3759ZM24.7673 22.5148C25.2244 22.9619 25.8049 23.2618 26.4341 23.3759L26.7909 21.408C26.555 21.3652 26.3373 21.2527 26.1658 21.0851L24.7673 22.5148ZM24.6795 22.427L24.7595 22.507L26.1737 21.0928L26.0937 21.0128L24.6795 22.427ZM24.1382 22.0649C24.3405 22.1487 24.5243 22.2717 24.6791 22.4266L26.0941 21.0132C25.7536 20.6723 25.3492 20.4018 24.904 20.2173L24.1382 22.0649ZM23.4999 21.9378C23.7189 21.9378 23.9358 21.981 24.1382 22.0649L24.904 20.2173C24.4589 20.0328 23.9818 19.9378 23.4999 19.9378V21.9378ZM22.8617 22.0649C23.064 21.981 23.2809 21.9378 23.4999 21.9378V19.9378C23.0181 19.9378 22.5409 20.0328 22.0958 20.2173L22.8617 22.0649ZM22.3208 22.4266C22.4755 22.2717 22.6594 22.1487 22.8617 22.0649L22.0958 20.2173C21.6507 20.4018 21.2463 20.6723 20.9058 21.0132L22.3208 22.4266ZM21.9582 22.9684C22.0421 22.766 22.165 22.5822 22.32 22.4274L20.9065 21.0124C20.5656 21.353 20.2952 21.7573 20.1107 22.2025L21.9582 22.9684ZM21.8312 23.6066C21.8312 23.3876 21.8743 23.1707 21.9582 22.9684L20.1107 22.2025C19.9261 22.6476 19.8312 23.1247 19.8312 23.6066H21.8312ZM21.9582 24.2448C21.8743 24.0425 21.8312 23.8256 21.8312 23.6066H19.8312C19.8312 24.0884 19.9261 24.5656 20.1107 25.0107L21.9582 24.2448ZM22.32 24.7858C22.165 24.631 22.0421 24.4471 21.9582 24.2448L20.1107 25.0107C20.2952 25.4558 20.5656 25.8602 20.9065 26.2008L22.32 24.7858ZM22.4004 24.8661L22.3204 24.7861L20.9061 26.2004L20.9861 26.2804L22.4004 24.8661ZM23.2692 26.5407C23.1551 25.9116 22.8552 25.3311 22.4081 24.874L20.9784 26.2725C21.1461 26.4439 21.2585 26.6616 21.3013 26.8975L23.2692 26.5407ZM23.0481 28.4037C23.3063 27.8187 23.3833 27.1699 23.2692 26.5407L21.3013 26.8975C21.3441 27.1335 21.3152 27.3768 21.2184 27.5962L23.0481 28.4037ZM21.9301 29.8433C22.4523 29.4698 22.8501 28.9477 23.0718 28.3451L21.1947 27.6547C21.1116 27.8807 20.9624 28.0765 20.7666 28.2166L21.9301 29.8433ZM20.1433 30.4396C20.7852 30.4246 21.4078 30.2168 21.9301 29.8433L20.7666 28.2166C20.5707 28.3566 20.3373 28.4346 20.0965 28.4402L20.1433 30.4396ZM19.9999 30.4399H20.1199V28.4399H19.9999V30.4399ZM18.8214 30.9281C19.134 30.6155 19.5579 30.4399 19.9999 30.4399V28.4399C19.0275 28.4399 18.0948 28.8262 17.4072 29.5139L18.8214 30.9281ZM18.3333 32.1066C18.3333 31.6646 18.5088 31.2406 18.8214 30.9281L17.4072 29.5139C16.7196 30.2015 16.3333 31.1341 16.3333 32.1066H18.3333ZM18.8214 33.2851C18.5088 32.9725 18.3333 32.5486 18.3333 32.1066H16.3333C16.3333 33.079 16.7196 34.0117 17.4072 34.6993L18.8214 33.2851ZM19.9999 33.7733C19.5579 33.7733 19.134 33.5977 18.8214 33.2851L17.4072 34.6993C18.0948 35.3869 19.0275 35.7733 19.9999 35.7733V33.7733ZM20.2266 33.7733H19.9999V35.7733H20.2266V33.7733ZM21.9847 34.3053C21.4644 33.9607 20.8546 33.7757 20.2306 33.7733L20.2226 35.7732C20.4566 35.7742 20.6853 35.8435 20.8804 35.9727L21.9847 34.3053ZM23.1591 35.7127C22.9132 35.139 22.505 34.6498 21.9847 34.3053L20.8804 35.9727C21.0755 36.102 21.2286 36.2854 21.3208 36.5005L23.1591 35.7127ZM23.3759 37.5658C23.49 36.9366 23.4129 36.2878 23.1548 35.7028L21.3251 36.5104C21.4219 36.7297 21.4507 36.973 21.408 37.209L23.3759 37.5658ZM22.5148 39.2325C22.9619 38.7754 23.2618 38.1949 23.3759 37.5658L21.408 37.209C21.3652 37.4449 21.2527 37.6626 21.0851 37.834L22.5148 39.2325ZM22.427 39.3204L22.507 39.2404L21.0928 37.8261L21.0128 37.9061L22.427 39.3204ZM22.0649 39.8617C22.1487 39.6594 22.2717 39.4755 22.4266 39.3208L21.0132 37.9058C20.6723 38.2463 20.4018 38.6507 20.2173 39.0958L22.0649 39.8617ZM21.9378 40.4999C21.9378 40.2809 21.981 40.064 22.0649 39.8617L20.2173 39.0958C20.0328 39.5409 19.9378 40.0181 19.9378 40.4999H21.9378ZM22.0649 41.1382C21.981 40.9358 21.9378 40.7189 21.9378 40.4999H19.9378C19.9378 40.9818 20.0328 41.4589 20.2173 41.904L22.0649 41.1382ZM22.4266 41.6791C22.2717 41.5243 22.1487 41.3405 22.0649 41.1382L20.2173 41.904C20.4018 42.3492 20.6723 42.7536 21.0132 43.0941L22.4266 41.6791ZM22.9684 42.0416C22.766 41.9578 22.5822 41.8348 22.4274 41.6799L21.0124 43.0933C21.353 43.4342 21.7573 43.7047 22.2025 43.8892L22.9684 42.0416ZM23.6066 42.1687C23.3876 42.1687 23.1707 42.1255 22.9683 42.0416L22.2025 43.8892C22.6476 44.0737 23.1247 44.1687 23.6066 44.1687V42.1687ZM24.2448 42.0416C24.0425 42.1255 23.8256 42.1687 23.6066 42.1687V44.1687C24.0884 44.1687 24.5656 44.0737 25.0107 43.8892L24.2448 42.0416ZM24.7857 41.6799C24.631 41.8348 24.4472 41.9578 24.2448 42.0416L25.0107 43.8892C25.4558 43.7047 25.8602 43.4342 26.2008 43.0933L24.7857 41.6799ZM24.8661 41.5995L24.7861 41.6795L26.2004 43.0937L26.2804 43.0137L24.8661 41.5995ZM26.5407 40.7306C25.9116 40.8447 25.3311 41.1446 24.874 41.5917L26.2725 43.0214C26.4439 42.8538 26.6616 42.7413 26.8975 42.6985L26.5407 40.7306ZM28.4037 40.9517C27.8187 40.6936 27.1699 40.6166 26.5407 40.7306L26.8975 42.6985C27.1335 42.6558 27.3768 42.6846 27.5962 42.7814L28.4037 40.9517ZM29.8433 42.0698C29.4698 41.5475 28.9477 41.1497 28.3451 40.928L27.6547 42.8051C27.8807 42.8882 28.0765 43.0374 28.2166 43.2333L29.8433 42.0698ZM30.4396 43.8565C30.4246 43.2146 30.2168 42.592 29.8433 42.0698L28.2166 43.2333C28.3566 43.4291 28.4346 43.6626 28.4402 43.9033L30.4396 43.8565ZM30.4399 43.9999V43.8799H28.4399V43.9999H30.4399ZM30.9281 45.1784C30.6155 44.8659 30.4399 44.4419 30.4399 43.9999H28.4399C28.4399 44.9724 28.8262 45.905 29.5139 46.5926L30.9281 45.1784ZM32.1066 45.6666C31.6646 45.6666 31.2406 45.491 30.9281 45.1784L29.5139 46.5926C30.2015 47.2803 31.1341 47.6666 32.1066 47.6666V45.6666ZM33.2851 45.1784C32.9725 45.491 32.5486 45.6666 32.1066 45.6666V47.6666C33.079 47.6666 34.0117 47.2803 34.6993 46.5926L33.2851 45.1784ZM33.7733 43.9999C33.7733 44.4419 33.5977 44.8659 33.2851 45.1784L34.6993 46.5926C35.3869 45.905 35.7733 44.9724 35.7733 43.9999H33.7733ZM33.7733 43.7733V43.9999H35.7733V43.7733H33.7733ZM34.3053 42.0151C33.9607 42.5355 33.7757 43.1452 33.7733 43.7693L35.7732 43.7772C35.7742 43.5432 35.8435 43.3146 35.9727 43.1194L34.3053 42.0151ZM35.7127 40.8408C35.139 41.0866 34.6498 41.4948 34.3053 42.0152L35.9727 43.1194C36.102 42.9243 36.2854 42.7712 36.5005 42.6791L35.7127 40.8408ZM37.5658 40.624C36.9367 40.5099 36.2878 40.5869 35.7028 40.8451L36.5104 42.6748C36.7297 42.578 36.973 42.5491 37.209 42.5919L37.5658 40.624ZM39.2325 41.4851C38.7754 41.038 38.1949 40.738 37.5658 40.624L37.209 42.5919C37.4449 42.6346 37.6626 42.7471 37.834 42.9148L39.2325 41.4851ZM39.3204 41.5728L39.2404 41.4928L37.8261 42.907L37.9061 42.987L39.3204 41.5728ZM39.8617 41.935C39.6594 41.8511 39.4755 41.7282 39.3207 41.5732L37.9058 42.9866C38.2463 43.3275 38.6507 43.598 39.0958 43.7825L39.8617 41.935ZM40.4999 42.062C40.2809 42.062 40.064 42.0188 39.8617 41.935L39.0958 43.7825C39.5409 43.967 40.0181 44.062 40.4999 44.062V42.062ZM41.1382 41.935C40.9358 42.0188 40.7189 42.062 40.4999 42.062V44.062C40.9818 44.062 41.4589 43.967 41.904 43.7825L41.1382 41.935ZM41.6791 41.5732C41.5243 41.7282 41.3405 41.8511 41.1382 41.935L41.904 43.7825C42.3492 43.598 42.7536 43.3275 43.0941 42.9866L41.6791 41.5732ZM42.0416 41.0315C41.9578 41.2338 41.8348 41.4176 41.6799 41.5724L43.0933 42.9874C43.4342 42.6469 43.7047 42.2425 43.8892 41.7974L42.0416 41.0315ZM42.1687 40.3933C42.1687 40.6123 42.1255 40.8292 42.0416 41.0315L43.8892 41.7974C44.0737 41.3522 44.1687 40.8751 44.1687 40.3933H42.1687ZM42.0416 39.755C42.1255 39.9573 42.1687 40.1742 42.1687 40.3933H44.1687C44.1687 39.9114 44.0737 39.4343 43.8892 38.9891L42.0416 39.755ZM41.6799 39.2141C41.8348 39.3689 41.9578 39.5527 42.0416 39.755L43.8892 38.9891C43.7047 38.544 43.4342 38.1396 43.0933 37.7991L41.6799 39.2141ZM41.5995 39.1337L41.6795 39.2137L43.0937 37.7995L43.0137 37.7195L41.5995 39.1337ZM40.7306 37.4591C40.8447 38.0882 41.1446 38.6688 41.5917 39.1259L43.0214 37.7273C42.8538 37.5559 42.7413 37.3382 42.6985 37.1023L40.7306 37.4591ZM32 25.9999C28.6863 25.9999 26 28.6862 26 31.9999H28C28 29.7908 29.7909 27.9999 32 27.9999V25.9999ZM38 31.9999C38 28.6862 35.3137 25.9999 32 25.9999V27.9999C34.2091 27.9999 36 29.7908 36 31.9999H38ZM32 37.9999C35.3137 37.9999 38 35.3136 38 31.9999H36C36 34.2091 34.2091 35.9999 32 35.9999V37.9999ZM26 31.9999C26 35.3136 28.6863 37.9999 32 37.9999V35.9999C29.7909 35.9999 28 34.2091 28 31.9999H26Z", fill: "#46CDD0" })))), /* @__PURE__ */ React.createElement("defs", null, /* @__PURE__ */ React.createElement("clipPath", { id: "clip0_2280_4179" }, /* @__PURE__ */ React.createElement("rect", { width: 64, height: 64, fill: "white" })), /* @__PURE__ */ React.createElement("clipPath", { id: "clip1_2280_4179" }, /* @__PURE__ */ React.createElement("rect", { width: 32, height: 32, fill: "white", transform: "translate(16 16)" }))));
const SvgAlarmMinor = (props) => /* @__PURE__ */ React.createElement("svg", { width: 64, height: 64, viewBox: "0 0 64 64", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("g", { id: "ic_64/ic64_alarm_minor", clipPath: "url(#clip0_2280_4206)" }, /* @__PURE__ */ React.createElement("circle", { id: "Ellipse 1", cx: 32, cy: 32, r: 32, fill: "#FCDB2C", fillOpacity: 0.15 }), /* @__PURE__ */ React.createElement("g", { id: "fi:alert-circle" }, /* @__PURE__ */ React.createElement("path", { id: "Vector", d: "M26.48 18.6667H37.52L45.3333 26.4801V37.5201L37.52 45.3334H26.48L18.6666 37.5201V26.4801L26.48 18.6667Z", fill: "#FCDB2C", stroke: "#FCDB2C", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { id: "Vector_2", d: "M32 37.3333H32.0133", stroke: "white", strokeWidth: 3, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { id: "Vector_3", d: "M32 26.6667V32.0001", stroke: "white", strokeWidth: 3, strokeLinecap: "round", strokeLinejoin: "round" }))), /* @__PURE__ */ React.createElement("defs", null, /* @__PURE__ */ React.createElement("clipPath", { id: "clip0_2280_4206" }, /* @__PURE__ */ React.createElement("rect", { width: 64, height: 64, fill: "white" }))));
const SvgAlarmSensor = (props) => /* @__PURE__ */ React.createElement("svg", { width: 64, height: 64, viewBox: "0 0 64 64", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("g", { id: "ic_64/ic64_alarm_sensor" }, /* @__PURE__ */ React.createElement("circle", { id: "Ellipse 1", cx: 32, cy: 32, r: 32, fill: "#61D866", fillOpacity: 0.15 }), /* @__PURE__ */ React.createElement("g", { id: "Group 427320436" }, /* @__PURE__ */ React.createElement("g", { id: "Layer_1", clipPath: "url(#clip0_2280_4228)" }, /* @__PURE__ */ React.createElement("path", { id: "Vector", fillRule: "evenodd", clipRule: "evenodd", d: "M43.3863 20.4754C42.8189 19.908 42.8189 18.9922 43.3863 18.4248C43.951 17.86 44.8694 17.86 45.4368 18.4248C49.1474 22.1353 51.0026 26.9965 51.0026 31.8603C51.0026 36.7241 49.1474 41.5853 45.4368 45.2958C44.8721 45.8606 43.9537 45.8606 43.3863 45.2958C42.8189 44.7284 42.8189 43.81 43.3863 43.2453C46.5294 40.1021 48.1023 35.9825 48.1023 31.8603C48.1023 27.7381 46.532 23.6185 43.3863 20.4754ZM20.6164 43.2453C21.1838 43.8127 21.1838 44.7284 20.6164 45.2958C20.049 45.8606 19.1332 45.8606 18.5658 45.2958C14.8553 41.5853 13 36.7241 13 31.8603C13 26.9965 14.8553 22.1353 18.5658 18.4248C19.1332 17.86 20.049 17.86 20.6164 18.4248C21.1838 18.9922 21.1838 19.908 20.6164 20.4754C17.4732 23.6185 15.9003 27.7407 15.9003 31.8603C15.9003 35.9799 17.4732 40.1021 20.6164 43.2453ZM39.2825 24.5765C38.7178 24.0091 38.7178 23.0933 39.2825 22.5259C39.8499 21.9585 40.7657 21.9585 41.3331 22.5259C43.9114 25.1043 45.1993 28.4823 45.1993 31.8603C45.1993 35.2383 43.9114 38.6163 41.3331 41.1947C40.7657 41.7621 39.8473 41.7621 39.2825 41.1947C38.7178 40.6273 38.7178 39.7115 39.2825 39.1441C41.2935 37.1332 42.299 34.4967 42.299 31.8603C42.299 29.2239 41.2935 26.5874 39.2825 24.5765ZM24.7175 39.1441C25.2822 39.7089 25.2822 40.6273 24.7175 41.1947C24.1501 41.7621 23.2343 41.7621 22.6669 41.1947C20.0885 38.6163 18.8007 35.2383 18.8007 31.8603C18.8007 28.4823 20.0885 25.1043 22.6669 22.5259C23.2343 21.9585 24.1501 21.9585 24.7175 22.5259C25.2822 23.0933 25.2822 24.0091 24.7175 24.5765C22.7065 26.5874 21.701 29.2239 21.701 31.8603C21.701 34.4967 22.7065 37.1332 24.7175 39.1441ZM35.1814 28.6776C34.6166 28.1102 34.6166 27.1918 35.1814 26.627C35.7488 26.0596 36.6646 26.0596 37.232 26.627C38.6782 28.0732 39.3986 29.9655 39.3986 31.8603C39.3986 33.7552 38.6755 35.6474 37.232 37.0936C36.6672 37.661 35.7488 37.661 35.1814 37.0936C34.6166 36.5262 34.6166 35.6104 35.1814 35.043C36.0602 34.1642 36.4983 33.0136 36.4983 31.8603C36.4983 30.707 36.0602 29.5564 35.1814 28.6776ZM28.8186 35.043C29.386 35.6104 29.386 36.5262 28.8186 37.0936C28.2538 37.661 27.3354 37.661 26.768 37.0936C25.3218 35.65 24.6014 33.7552 24.6014 31.8603C24.6014 29.9655 25.3245 28.0732 26.768 26.627C27.3354 26.0596 28.2512 26.0596 28.8186 26.627C29.386 27.1944 29.386 28.1102 28.8186 28.6776C27.9398 29.5564 27.5017 30.707 27.5017 31.8603C27.5017 33.0136 27.9398 34.1642 28.8186 35.043Z", fill: "#61D866" }), /* @__PURE__ */ React.createElement("path", { id: "Vector_2", fillRule: "evenodd", clipRule: "evenodd", d: "M32.0013 30.2136C32.9118 30.2136 33.6481 30.9526 33.6481 31.8604C33.6481 32.7682 32.9092 33.5072 32.0013 33.5072C31.0935 33.5072 30.3546 32.7682 30.3546 31.8604C30.3546 30.9526 31.0935 30.2136 32.0013 30.2136Z", fill: "#61D866" })))), /* @__PURE__ */ React.createElement("defs", null, /* @__PURE__ */ React.createElement("clipPath", { id: "clip0_2280_4228" }, /* @__PURE__ */ React.createElement("rect", { width: 38, height: 27.7208, fill: "white", transform: "translate(13 18)" }))));
const SvgAlarmWarning = (props) => /* @__PURE__ */ React.createElement("svg", { width: 64, height: 64, viewBox: "0 0 64 64", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("g", { id: "ic_64/ic64_alarm_warning", clipPath: "url(#clip0_2280_4193)" }, /* @__PURE__ */ React.createElement("circle", { id: "Ellipse 1", cx: 32, cy: 32, r: 32, fill: "#61D866", fillOpacity: 0.15 }), /* @__PURE__ */ React.createElement("g", { id: "fi:alert-circle" }, /* @__PURE__ */ React.createElement("path", { id: "Vector", d: "M41.3333 20H22.6667C21.1939 20 20 21.1939 20 22.6667V41.3333C20 42.8061 21.1939 44 22.6667 44H41.3333C42.8061 44 44 42.8061 44 41.3333V22.6667C44 21.1939 42.8061 20 41.3333 20Z", fill: "#61D866", stroke: "#61D866", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { id: "Vector_2", d: "M32 37.3333H32.0133", stroke: "white", strokeWidth: 3, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { id: "Vector_3", d: "M32 26.6667V32.0001", stroke: "white", strokeWidth: 3, strokeLinecap: "round", strokeLinejoin: "round" }))), /* @__PURE__ */ React.createElement("defs", null, /* @__PURE__ */ React.createElement("clipPath", { id: "clip0_2280_4193" }, /* @__PURE__ */ React.createElement("rect", { width: 64, height: 64, fill: "white" }))));
const SvgAppSwitch = (props) => /* @__PURE__ */ React.createElement("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("path", { d: "M7 21L3 17L7 13", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M17 17H3", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M17 3L21 7L17 11", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M7 7H21", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }));
const SvgArrowDown = (props) => /* @__PURE__ */ React.createElement("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("path", { d: "M6 9L12 15L18 9", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }));
const SvgArrowLeft = (props) => /* @__PURE__ */ React.createElement("svg", { width: 32, height: 32, viewBox: "0 0 32 32", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("path", { d: "M20 24L12 16L20 8", stroke: "currentColor", strokeWidth: 2.5, strokeLinecap: "round", strokeLinejoin: "round" }));
const SvgArrowRight = (props) => /* @__PURE__ */ React.createElement("svg", { width: 32, height: 32, viewBox: "0 0 32 32", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("path", { d: "M12 24L20 16L12 8", stroke: "currentColor", strokeWidth: 2.5, strokeLinecap: "round", strokeLinejoin: "round" }));
const SvgArrowUp = (props) => /* @__PURE__ */ React.createElement("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("path", { d: "M18 15L12 9L6 15", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }));
const SvgCheckbox = (props) => /* @__PURE__ */ React.createElement("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("path", { d: "M6 11L10 15L18 7", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }));
const SvgPopClose = (props) => /* @__PURE__ */ React.createElement("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("g", { id: "ic_24/ic24_pop_close" }, /* @__PURE__ */ React.createElement("path", { id: "Vector", d: "M19 5L5 19", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { id: "Vector_2", d: "M5 5L19 19", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" })));
const SvgComposition = (props) => /* @__PURE__ */ React.createElement("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("path", { d: "M5.84533 14.3723L2.60261 19.84C2.53575 19.9569 2.50038 20.0895 2.5 20.2245C2.49963 20.3596 2.53427 20.4923 2.60048 20.6097C2.66668 20.727 2.76215 20.8247 2.87738 20.8932C2.99261 20.9617 3.12359 20.9985 3.25728 21H9.74272C9.87641 20.9985 10.0074 20.9617 10.1226 20.8932C10.2378 20.8247 10.3333 20.727 10.3995 20.6097C10.4657 20.4923 10.5004 20.3596 10.5 20.2245C10.4996 20.0895 10.4642 19.9569 10.3974 19.84L7.15467 14.3723C7.08642 14.2586 6.99032 14.1647 6.87565 14.0995C6.76098 14.0343 6.6316 14 6.5 14C6.3684 14 6.23902 14.0343 6.12435 14.0995C6.00968 14.1647 5.91358 14.2586 5.84533 14.3723V14.3723Z", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M21 3H14V10H21V3Z", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M3 6.5C3 8.433 4.567 10 6.5 10C8.433 10 10 8.433 10 6.5C10 4.567 8.433 3 6.5 3C4.567 3 3 4.567 3 6.5Z", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M18.5 14.5L21.5 17.5L18.5 20.5", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M14 17.5H21", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }));
const SvgDashboard = (props) => /* @__PURE__ */ React.createElement("svg", { width: 20, height: 20, viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("path", { d: "M17.5 11.6667H11.6666V17.5H17.5V11.6667Z", stroke: "currentColor", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M8.33333 11.6667H2.5V17.5H8.33333V11.6667Z", stroke: "currentColor", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M17.5 2.5H11.6666V8.33333H17.5V2.5Z", stroke: "currentColor", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M8.33333 2.5H2.5V8.33333H8.33333V2.5Z", stroke: "currentColor", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" }));
const SvgDashboardPlus = (props) => /* @__PURE__ */ React.createElement("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("path", { d: "M10 14H3V21H10V14Z", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M21 3H14V10H21V3Z", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M10 3H3V10H10V3Z", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M17.5 14V21", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M14 17.5H21", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }));
const SvgData = (props) => /* @__PURE__ */ React.createElement("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("path", { d: "M21.21 15.89C20.5739 17.3945 19.5788 18.7202 18.3119 19.7513C17.045 20.7824 15.5448 21.4874 13.9425 21.8048C12.3401 22.1221 10.6845 22.0421 9.12018 21.5718C7.55591 21.1015 6.13066 20.2551 4.96906 19.1067C3.80745 17.9582 2.94485 16.5428 2.45667 14.984C1.96849 13.4251 1.8696 11.7705 2.16863 10.1646C2.46767 8.55878 3.15553 7.05063 4.17208 5.77203C5.18863 4.49343 6.50292 3.48332 8.00004 2.83", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M22 12C22 10.6868 21.7413 9.38642 21.2388 8.17317C20.7362 6.95991 19.9997 5.85752 19.0711 4.92893C18.1425 4.00035 17.0401 3.26375 15.8268 2.7612C14.6136 2.25866 13.3132 2 12 2V12H22Z", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }));
const SvgDataSearch = (props) => /* @__PURE__ */ React.createElement("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("path", { d: "M11 19C15.4183 19 19 15.4183 19 11C19 6.58172 15.4183 3 11 3C6.58172 3 3 6.58172 3 11C3 15.4183 6.58172 19 11 19Z", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M21 21L16.65 16.65", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M8 14V12", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M14 14V10", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M11 14V8", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }));
const SvgDefault = (props) => /* @__PURE__ */ React.createElement("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("rect", { width: 24, height: 24, fill: "#FF0000", fillOpacity: 0.1 }));
const SvgEdit = (props) => /* @__PURE__ */ React.createElement("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("path", { d: "M8 13.3333H14", stroke: "currentColor", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M11 2.33333C11.2652 2.06811 11.6249 1.91911 12 1.91911C12.1857 1.91911 12.3696 1.95569 12.5412 2.02676C12.7128 2.09783 12.8687 2.202 13 2.33333C13.1313 2.46465 13.2355 2.62055 13.3066 2.79213C13.3776 2.96371 13.4142 3.14761 13.4142 3.33333C13.4142 3.51904 13.3776 3.70294 13.3066 3.87452C13.2355 4.0461 13.1313 4.202 13 4.33333L4.66667 12.6667L2 13.3333L2.66667 10.6667L11 2.33333Z", stroke: "currentColor", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" }));
const SvgEmergency = (props) => /* @__PURE__ */ React.createElement("svg", { width: 20, height: 20, viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("path", { d: "M8.60883 3.29773L1.71805 15.0142C1.57598 15.2648 1.5008 15.5489 1.50001 15.8383C1.49921 16.1276 1.57282 16.4122 1.71351 16.6635C1.8542 16.9149 2.05707 17.1244 2.30194 17.2712C2.5468 17.4179 2.82513 17.4968 3.10922 17.5H16.8908C17.1749 17.4968 17.4532 17.4179 17.6981 17.2712C17.9429 17.1244 18.1458 16.9149 18.2865 16.6635C18.4272 16.4122 18.5008 16.1276 18.5 15.8383C18.4992 15.5489 18.424 15.2648 18.282 15.0142L11.3912 3.29773C11.2461 3.05421 11.0419 2.85287 10.7983 2.71314C10.5546 2.57341 10.2796 2.5 10 2.5C9.72035 2.5 9.44543 2.57341 9.20175 2.71314C8.95807 2.85287 8.75386 3.05421 8.60883 3.29773Z", fill: "#FF4545", stroke: "#FF4545", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M10 7.5V10.8333", stroke: "white", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M10 14.1667H10.0083", stroke: "white", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }));
const SvgEmergencyAlert = (props) => /* @__PURE__ */ React.createElement("svg", { width: 120, height: 120, viewBox: "0 0 120 120", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("g", { clipPath: "url(#clip0_2280_4243)" }, /* @__PURE__ */ React.createElement("circle", { opacity: 0.08, cx: 60, cy: 60, r: 60, fill: "#FF4545" }), /* @__PURE__ */ React.createElement("circle", { opacity: 0.2, cx: 60, cy: 60, r: 48, fill: "#FF4545" }), /* @__PURE__ */ React.createElement("circle", { opacity: 0.4, cx: 60, cy: 60, r: 40, fill: "#FF4545" }), /* @__PURE__ */ React.createElement("circle", { cx: 60, cy: 60, r: 36, fill: "#FF4545" }), /* @__PURE__ */ React.createElement("g", { filter: "url(#filter0_d_2280_4243)" }, /* @__PURE__ */ React.createElement("path", { d: "M56.58 40.7199L39.64 68.9999C39.2908 69.6048 39.106 70.2905 39.104 70.989C39.1021 71.6874 39.283 72.3742 39.6289 72.981C39.9748 73.5878 40.4735 74.0934 41.0755 74.4476C41.6774 74.8018 42.3616 74.9922 43.06 74.9999H76.94C77.6384 74.9922 78.3227 74.8018 78.9246 74.4476C79.5266 74.0934 80.0253 73.5878 80.3712 72.981C80.7171 72.3742 80.898 71.6874 80.8961 70.989C80.8941 70.2905 80.7093 69.6048 80.36 68.9999L63.42 40.7199C63.0635 40.1321 62.5615 39.6462 61.9624 39.3089C61.3634 38.9716 60.6875 38.7944 60 38.7944C59.3126 38.7944 58.6367 38.9716 58.0377 39.3089C57.4386 39.6462 56.9366 40.1321 56.58 40.7199Z", fill: "white", stroke: "white", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M60 51V59", stroke: "#FF4545", strokeWidth: 5, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M60 67H60.02", stroke: "#FF4545", strokeWidth: 5, strokeLinecap: "round", strokeLinejoin: "round" }))), /* @__PURE__ */ React.createElement("defs", null, /* @__PURE__ */ React.createElement("filter", { id: "filter0_d_2280_4243", x: 18.104, y: 17.7944, width: 83.7921, height: 78.2056, filterUnits: "userSpaceOnUse", colorInterpolationFilters: "sRGB" }, /* @__PURE__ */ React.createElement("feFlood", { floodOpacity: 0, result: "BackgroundImageFix" }), /* @__PURE__ */ React.createElement("feColorMatrix", { in: "SourceAlpha", type: "matrix", values: "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0", result: "hardAlpha" }), /* @__PURE__ */ React.createElement("feOffset", null), /* @__PURE__ */ React.createElement("feGaussianBlur", { stdDeviation: 10 }), /* @__PURE__ */ React.createElement("feComposite", { in2: "hardAlpha", operator: "out" }), /* @__PURE__ */ React.createElement("feColorMatrix", { type: "matrix", values: "0 0 0 0 0.827451 0 0 0 0 0.184314 0 0 0 0 0.184314 0 0 0 1 0" }), /* @__PURE__ */ React.createElement("feBlend", { mode: "multiply", in2: "BackgroundImageFix", result: "effect1_dropShadow_2280_4243" }), /* @__PURE__ */ React.createElement("feBlend", { mode: "normal", in: "SourceGraphic", in2: "effect1_dropShadow_2280_4243", result: "shape" })), /* @__PURE__ */ React.createElement("clipPath", { id: "clip0_2280_4243" }, /* @__PURE__ */ React.createElement("rect", { width: 120, height: 120, fill: "white" }))));
const SvgFolder = (props) => /* @__PURE__ */ React.createElement("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("path", { d: "M22 19C22 19.5304 21.7893 20.0391 21.4142 20.4142C21.0391 20.7893 20.5304 21 20 21H4C3.46957 21 2.96086 20.7893 2.58579 20.4142C2.21071 20.0391 2 19.5304 2 19V5C2 4.46957 2.21071 3.96086 2.58579 3.58579C2.96086 3.21071 3.46957 3 4 3H9L11 6H20C20.5304 6 21.0391 6.21071 21.4142 6.58579C21.7893 6.96086 22 7.46957 22 8V19Z", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }));
const SvgFilter = (props) => /* @__PURE__ */ React.createElement("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("path", { d: "M13.3333 14V10.6667", stroke: "currentColor", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M11.5 10.6667H15", stroke: "currentColor", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M2.66666 14V9.33333", stroke: "currentColor", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M1 9.33333H4.5", stroke: "currentColor", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M8 14V8", stroke: "currentColor", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M6.25 5.33333H9.75", stroke: "currentColor", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M13.3333 8V2", stroke: "currentColor", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M8 5.33333V2", stroke: "currentColor", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M2.66666 6.66667V2", stroke: "currentColor", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" }));
const SvgFullframe = (props) => /* @__PURE__ */ React.createElement("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("path", { d: "M5.33333 2H3.33333C2.97971 2 2.64057 2.14048 2.39052 2.39052C2.14048 2.64057 2 2.97971 2 3.33333V5.33333M14 5.33333V3.33333C14 2.97971 13.8595 2.64057 13.6095 2.39052C13.3594 2.14048 13.0203 2 12.6667 2H10.6667M10.6667 14H12.6667C13.0203 14 13.3594 13.8595 13.6095 13.6095C13.8595 13.3594 14 13.0203 14 12.6667V10.6667M2 10.6667V12.6667C2 13.0203 2.14048 13.3594 2.39052 13.6095C2.64057 13.8595 2.97971 14 3.33333 14H5.33333", stroke: "currentColor", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" }));
const SvgHome = (props) => /* @__PURE__ */ React.createElement("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("path", { d: "M3 9L12 2L21 9V20C21 20.5304 20.7893 21.0391 20.4142 21.4142C20.0391 21.7893 19.5304 22 19 22H5C4.46957 22 3.96086 21.7893 3.58579 21.4142C3.21071 21.0391 3 20.5304 3 20V9Z", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M9 22V14H15V22", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }));
const SvgLogo01 = (props) => /* @__PURE__ */ React.createElement("svg", { width: 346, height: 134, viewBox: "0 0 346 134", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("path", { d: "M102.71 112.59C87.75 112.59 78.52 109.13 78.52 94.6099V27.7699H95.9799V94.4999C95.9799 99.3399 100.59 100.49 105.33 100.61V112.6H102.71V112.59Z", fill: "currentColor" }), /* @__PURE__ */ React.createElement("path", { d: "M183.15 53.24H165.57V112.59H183.15V53.24Z", fill: "currentColor" }), /* @__PURE__ */ React.createElement("path", { d: "M211.34 53.24L223.44 100.95H223.69C227.68 85.28 231.8 68.91 235.66 53.24H252.62C247.38 71.45 242.02 89.43 236.78 107.64C235.91 110.29 234.41 112.6 231.04 112.6H215.83C212.59 112.6 211.22 111.33 210.22 107.99C205.23 90.36 199.37 70.88 194.38 53.25H211.34V53.24Z", fill: "currentColor" }), /* @__PURE__ */ React.createElement("path", { d: "M281.43 53.24H263.85V112.59H281.43V53.24Z", fill: "currentColor" }), /* @__PURE__ */ React.createElement("path", { d: "M324.48 12.38V33.55L307.35 39.97V19.12L324.48 12.38Z", fill: "#A3CDFF" }), /* @__PURE__ */ React.createElement("path", { d: "M300.19 9.22V27.78L283.3 19.71V1L300.19 9.22Z", fill: "#005ECD" }), /* @__PURE__ */ React.createElement("path", { d: "M135.76 96.4599V65.2299H153.09L155.59 53.2499H135.76V29.1599C131.02 30.3099 126.03 31.6999 121.42 32.8499C121.39 32.8499 121.37 32.8699 121.34 32.8799L118.18 33.6999V53.2599H107.83V65.2399H118.18V97.8599C118.18 108.23 122.3 112.61 133.64 112.61H154.22V100.63H140C138 100.63 135.76 100.28 135.76 96.4799V96.4599Z", fill: "currentColor" }), /* @__PURE__ */ React.createElement("path", { d: "M165.57 32.0099L182.16 27.7699V43.2099L165.57 47.4599V32.0099Z", fill: "currentColor" }), /* @__PURE__ */ React.createElement("path", { d: "M263.85 32.0099L280.43 27.7699V43.2099L263.85 47.4599V32.0099Z", fill: "#173061" }), /* @__PURE__ */ React.createElement("path", { d: "M344.41 90.24C344.41 87.24 343.41 82.98 336.93 81.25L319.26 76.71L316.73 76.06C316.69 76.05 316.65 76.03 316.61 76.02L313.86 75.31V65.23H341.79V53.25H307.3C301.28 53.25 296.4 58.06 296.4 64V74.22C296.4 80.56 299.14 83.56 303.63 84.82L323.72 90.05L326.95 90.88V100.61H297.52V112.59H334.02C339.75 112.59 344.4 108.01 344.4 102.35V98.45C344.4 98.28 344.42 98.11 344.42 97.95V90.23L344.41 90.24Z", fill: "currentColor" }), /* @__PURE__ */ React.createElement("path", { d: "M48.3399 90.5699C48.3399 95.0599 45.0999 97.8299 40.2299 97.8299H28.0099C23.0199 97.8299 19.6499 95.0599 19.6499 90.5699V27.7699H1.93994V95.6499C1.93994 102.22 13.5399 112.59 24.6399 112.59H43.3499C54.4499 112.59 66.0499 102.22 66.0499 95.6499V27.7699H48.3399V90.5699Z", fill: "currentColor" }));
const SvgLogo02 = (props) => /* @__PURE__ */ React.createElement("svg", { width: 480, height: 125, viewBox: "0 0 480 125", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("g", { clipPath: "url(#clip0_41_440)" }, /* @__PURE__ */ React.createElement("path", { d: "M237.71 111.59C222.75 111.59 213.52 108.13 213.52 93.6099V26.7699H230.98V93.4999C230.98 98.3399 235.59 99.4899 240.33 99.6099V111.6H237.71V111.59Z", fill: "currentColor" }), /* @__PURE__ */ React.createElement("path", { d: "M318.15 52.24H300.57V111.59H318.15V52.24Z", fill: "currentColor" }), /* @__PURE__ */ React.createElement("path", { d: "M346.34 52.24L358.44 99.95H358.69C362.68 84.28 366.8 67.91 370.66 52.24H387.62C382.38 70.45 377.02 88.43 371.78 106.64C370.91 109.29 369.41 111.6 366.04 111.6H350.83C347.59 111.6 346.22 110.33 345.22 106.99C340.23 89.36 334.37 69.88 329.38 52.25H346.34V52.24Z", fill: "currentColor" }), /* @__PURE__ */ React.createElement("path", { d: "M416.43 52.24H398.85V111.59H416.43V52.24Z", fill: "currentColor" }), /* @__PURE__ */ React.createElement("path", { d: "M459.48 11.38V32.55L442.35 38.97V18.12L459.48 11.38Z", fill: "#A3CDFF" }), /* @__PURE__ */ React.createElement("path", { d: "M435.19 8.22V26.78L418.3 18.71V0L435.19 8.22Z", fill: "#005ECD" }), /* @__PURE__ */ React.createElement("path", { d: "M270.76 95.4599V64.2299H288.09L290.59 52.2499H270.76V28.1599C266.02 29.3099 261.03 30.6999 256.42 31.8499C256.39 31.8499 256.37 31.8699 256.34 31.8799L253.18 32.6999V52.2599H242.83V64.2399H253.18V96.8599C253.18 107.23 257.3 111.61 268.64 111.61H289.22V99.6299H275C273 99.6299 270.76 99.2799 270.76 95.4799V95.4599Z", fill: "currentColor" }), /* @__PURE__ */ React.createElement("path", { d: "M300.57 31.0099L317.16 26.7699V42.2099L300.57 46.4599V31.0099Z", fill: "currentColor" }), /* @__PURE__ */ React.createElement("path", { d: "M398.85 31.0099L415.43 26.7699V42.2099L398.85 46.4599V31.0099Z", fill: "#173061" }), /* @__PURE__ */ React.createElement("path", { d: "M25.53 102.52V72.6699L51.41 87.4599L25.53 102.52Z", fill: "#004FAC" }), /* @__PURE__ */ React.createElement("path", { d: "M25.53 102.52L64.15 80.0499L102.47 102.52L64 124.99L25.53 102.52Z", fill: "#0075FF" }), /* @__PURE__ */ React.createElement("path", { d: "M38.78 20.49L64.57 35.52L38.76 50.44L38.78 20.49Z", fill: "#58A5FF" }), /* @__PURE__ */ React.createElement("path", { d: "M38.78 20.49L38.74 65.18L0.04 86.97L0 42.42L38.78 20.49Z", fill: "#A3CDFF" }), /* @__PURE__ */ React.createElement("path", { d: "M103.22 72.82L77.09 87.64V58.1L103.22 72.82Z", fill: "#134179" }), /* @__PURE__ */ React.createElement("path", { d: "M103.22 72.82L64.29 50.89L64.27 6.46997L103.12 28.27L103.22 72.82Z", fill: "#04266A" }), /* @__PURE__ */ React.createElement("path", { d: "M479.41 89.24C479.41 86.24 478.41 81.98 471.93 80.25L454.26 75.71L451.73 75.06C451.69 75.05 451.65 75.03 451.61 75.02L448.86 74.31V64.23H476.79V52.25H442.3C436.28 52.25 431.4 57.06 431.4 63V73.22C431.4 79.56 434.14 82.56 438.63 83.82L458.72 89.05L461.95 89.88V99.61H432.52V111.59H469.02C474.75 111.59 479.4 107.01 479.4 101.35V97.45C479.4 97.28 479.42 97.11 479.42 96.95V89.23L479.41 89.24Z", fill: "currentColor" }), /* @__PURE__ */ React.createElement("path", { d: "M183.34 89.5699C183.34 94.0599 180.1 96.8299 175.23 96.8299H163.01C158.02 96.8299 154.65 94.0599 154.65 89.5699V26.7699H136.94V94.6499C136.94 101.22 148.54 111.59 159.64 111.59H178.35C189.45 111.59 201.05 101.22 201.05 94.6499V26.7699H183.34V89.5699Z", fill: "currentColor" })), /* @__PURE__ */ React.createElement("defs", null, /* @__PURE__ */ React.createElement("clipPath", { id: "clip0_41_440" }, /* @__PURE__ */ React.createElement("rect", { width: 480, height: 125, fill: "white" }))));
const SvgMenuDrawer = (props) => /* @__PURE__ */ React.createElement("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("path", { d: "M4 18H20", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M4 12H20", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M4 6H20", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }));
const SvgMore = (props) => /* @__PURE__ */ React.createElement("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("path", { d: "M12.6667 8.66666C13.0349 8.66666 13.3333 8.36818 13.3333 7.99999C13.3333 7.63181 13.0349 7.33333 12.6667 7.33333C12.2985 7.33333 12 7.63181 12 7.99999C12 8.36818 12.2985 8.66666 12.6667 8.66666Z", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M8.00001 8.66666C8.3682 8.66666 8.66668 8.36818 8.66668 7.99999C8.66668 7.63181 8.3682 7.33333 8.00001 7.33333C7.63182 7.33333 7.33334 7.63181 7.33334 7.99999C7.33334 8.36818 7.63182 8.66666 8.00001 8.66666Z", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M3.33332 8.66666C3.70151 8.66666 3.99999 8.36818 3.99999 7.99999C3.99999 7.63181 3.70151 7.33333 3.33332 7.33333C2.96513 7.33333 2.66666 7.63181 2.66666 7.99999C2.66666 8.36818 2.96513 8.66666 3.33332 8.66666Z", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" }));
const SvgNavigation = (props) => /* @__PURE__ */ React.createElement("svg", { width: 20, height: 20, viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("path", { d: "M17.5 8.33333C17.5 14.1667 10 19.1667 10 19.1667C10 19.1667 2.5 14.1667 2.5 8.33333C2.5 6.3442 3.29018 4.43655 4.6967 3.03003C6.10322 1.6235 8.01088 0.833328 10 0.833328C11.9891 0.833328 13.8968 1.6235 15.3033 3.03003C16.7098 4.43655 17.5 6.3442 17.5 8.33333Z", stroke: "currentColor", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M10 10.8333C11.3807 10.8333 12.5 9.71404 12.5 8.33333C12.5 6.95262 11.3807 5.83333 10 5.83333C8.61929 5.83333 7.5 6.95262 7.5 8.33333C7.5 9.71404 8.61929 10.8333 10 10.8333Z", stroke: "currentColor", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" }));
const SvgProfile = (props) => /* @__PURE__ */ React.createElement("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("path", { d: "M20 21V19C20 17.9391 19.5786 16.9217 18.8284 16.1716C18.0783 15.4214 17.0609 15 16 15H8C6.93913 15 5.92172 15.4214 5.17157 16.1716C4.42143 16.9217 4 17.9391 4 19V21", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M12 11C14.2091 11 16 9.20914 16 7C16 4.79086 14.2091 3 12 3C9.79086 3 8 4.79086 8 7C8 9.20914 9.79086 11 12 11Z", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }));
const SvgReport = (props) => /* @__PURE__ */ React.createElement("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("path", { d: "M16 4H18C18.5304 4 19.0391 4.21071 19.4142 4.58579C19.7893 4.96086 20 5.46957 20 6V20C20 20.5304 19.7893 21.0391 19.4142 21.4142C19.0391 21.7893 18.5304 22 18 22H6C5.46957 22 4.96086 21.7893 4.58579 21.4142C4.21071 21.0391 4 20.5304 4 20V6C4 5.46957 4.21071 4.96086 4.58579 4.58579C4.96086 4.21071 5.46957 4 6 4H8", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M15 2H9C8.44772 2 8 2.44772 8 3V5C8 5.55228 8.44772 6 9 6H15C15.5523 6 16 5.55228 16 5V3C16 2.44772 15.5523 2 15 2Z", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }));
const SvgSearch = (props) => /* @__PURE__ */ React.createElement("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("path", { d: "M11 19C15.4183 19 19 15.4183 19 11C19 6.58172 15.4183 3 11 3C6.58172 3 3 6.58172 3 11C3 15.4183 6.58172 19 11 19Z", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M21 21L16.65 16.65", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }));
const SvgSetting = (props) => /* @__PURE__ */ React.createElement("svg", { width: 20, height: 20, viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("g", { clipPath: "url(#clip0_104_3226)" }, /* @__PURE__ */ React.createElement("path", { d: "M10 12.5C11.3807 12.5 12.5 11.3807 12.5 10C12.5 8.61929 11.3807 7.5 10 7.5C8.61929 7.5 7.5 8.61929 7.5 10C7.5 11.3807 8.61929 12.5 10 12.5Z", stroke: "currentColor", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M16.1667 12.5C16.0558 12.7513 16.0227 13.0302 16.0717 13.3005C16.1207 13.5708 16.2496 13.8203 16.4417 14.0167L16.4917 14.0667C16.6467 14.2214 16.7696 14.4053 16.8535 14.6076C16.9373 14.8099 16.9805 15.0268 16.9805 15.2458C16.9805 15.4649 16.9373 15.6817 16.8535 15.8841C16.7696 16.0864 16.6467 16.2702 16.4917 16.425C16.3369 16.58 16.1531 16.7029 15.9508 16.7868C15.7484 16.8706 15.5316 16.9138 15.3125 16.9138C15.0935 16.9138 14.8766 16.8706 14.6743 16.7868C14.472 16.7029 14.2882 16.58 14.1334 16.425L14.0834 16.375C13.887 16.1829 13.6375 16.054 13.3672 16.005C13.0969 15.956 12.8181 15.9891 12.5667 16.1C12.3202 16.2056 12.11 16.381 11.962 16.6046C11.8139 16.8282 11.7344 17.0902 11.7334 17.3583V17.5C11.7334 17.942 11.5578 18.3659 11.2452 18.6785C10.9327 18.9911 10.5087 19.1667 10.0667 19.1667C9.62468 19.1667 9.20076 18.9911 8.8882 18.6785C8.57563 18.3659 8.40004 17.942 8.40004 17.5V17.425C8.39359 17.1492 8.30431 16.8817 8.1438 16.6572C7.98329 16.4328 7.75899 16.2619 7.50004 16.1667C7.24869 16.0557 6.96988 16.0226 6.69955 16.0717C6.42922 16.1207 6.17977 16.2495 5.98337 16.4417L5.93337 16.4917C5.77858 16.6466 5.59477 16.7696 5.39244 16.8534C5.19011 16.9373 4.97323 16.9805 4.75421 16.9805C4.53518 16.9805 4.3183 16.9373 4.11597 16.8534C3.91364 16.7696 3.72983 16.6466 3.57504 16.4917C3.42008 16.3369 3.29715 16.1531 3.21327 15.9507C3.1294 15.7484 3.08623 15.5315 3.08623 15.3125C3.08623 15.0935 3.1294 14.8766 3.21327 14.6743C3.29715 14.4719 3.42008 14.2881 3.57504 14.1333L3.62504 14.0833C3.81715 13.8869 3.94603 13.6375 3.99504 13.3672C4.04406 13.0968 4.01097 12.818 3.90004 12.5667C3.7944 12.3202 3.619 12.11 3.39543 11.9619C3.17185 11.8139 2.90986 11.7344 2.64171 11.7333H2.50004C2.05801 11.7333 1.63409 11.5577 1.32153 11.2452C1.00897 10.9326 0.833374 10.5087 0.833374 10.0667C0.833374 9.62463 1.00897 9.20071 1.32153 8.88815C1.63409 8.57559 2.05801 8.39999 2.50004 8.39999H2.57504C2.85087 8.39354 3.11838 8.30426 3.34279 8.14375C3.5672 7.98325 3.73814 7.75894 3.83337 7.49999C3.9443 7.24865 3.97739 6.96983 3.92838 6.6995C3.87936 6.42917 3.75049 6.17973 3.55837 5.98333L3.50837 5.93333C3.35341 5.77854 3.23048 5.59473 3.14661 5.39239C3.06273 5.19006 3.01956 4.97319 3.01956 4.75416C3.01956 4.53514 3.06273 4.31826 3.14661 4.11593C3.23048 3.9136 3.35341 3.72978 3.50837 3.57499C3.66316 3.42003 3.84698 3.2971 4.04931 3.21323C4.25164 3.12935 4.46851 3.08618 4.68754 3.08618C4.90657 3.08618 5.12344 3.12935 5.32577 3.21323C5.5281 3.2971 5.71192 3.42003 5.86671 3.57499L5.91671 3.62499C6.11311 3.81711 6.36255 3.94598 6.63288 3.995C6.90321 4.04401 7.18203 4.01092 7.43337 3.89999H7.50004C7.74651 3.79436 7.95672 3.61896 8.10478 3.39538C8.25285 3.17181 8.3323 2.90982 8.33337 2.64166V2.49999C8.33337 2.05797 8.50897 1.63404 8.82153 1.32148C9.13409 1.00892 9.55801 0.833328 10 0.833328C10.4421 0.833328 10.866 1.00892 11.1786 1.32148C11.4911 1.63404 11.6667 2.05797 11.6667 2.49999V2.57499C11.6678 2.84315 11.7472 3.10514 11.8953 3.32872C12.0434 3.55229 12.2536 3.72769 12.5 3.83333C12.7514 3.94426 13.0302 3.97735 13.3005 3.92833C13.5709 3.87932 13.8203 3.75044 14.0167 3.55833L14.0667 3.50833C14.2215 3.35337 14.4053 3.23044 14.6076 3.14656C14.81 3.06269 15.0268 3.01952 15.2459 3.01952C15.4649 3.01952 15.6818 3.06269 15.8841 3.14656C16.0864 3.23044 16.2702 3.35337 16.425 3.50833C16.58 3.66312 16.7029 3.84693 16.7868 4.04926C16.8707 4.25159 16.9139 4.46847 16.9139 4.68749C16.9139 4.90652 16.8707 5.1234 16.7868 5.32573C16.7029 5.52806 16.58 5.71187 16.425 5.86666L16.375 5.91666C16.1829 6.11306 16.0541 6.36251 16.005 6.63284C15.956 6.90317 15.9891 7.18198 16.1 7.43333V7.49999C16.2057 7.74647 16.3811 7.95668 16.6047 8.10474C16.8282 8.2528 17.0902 8.33226 17.3584 8.33333H17.5C17.9421 8.33333 18.366 8.50892 18.6785 8.82148C18.9911 9.13404 19.1667 9.55797 19.1667 9.99999C19.1667 10.442 18.9911 10.8659 18.6785 11.1785C18.366 11.4911 17.9421 11.6667 17.5 11.6667H17.425C17.1569 11.6677 16.8949 11.7472 16.6713 11.8952C16.4477 12.0433 16.2723 12.2535 16.1667 12.5V12.5Z", stroke: "currentColor", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" })), /* @__PURE__ */ React.createElement("defs", null, /* @__PURE__ */ React.createElement("clipPath", { id: "clip0_104_3226" }, /* @__PURE__ */ React.createElement("rect", { width: 20, height: 20, fill: "white" }))));
const SvgTool = (props) => /* @__PURE__ */ React.createElement("svg", { width: 20, height: 20, viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("path", { d: "M12.25 5.25C12.0973 5.40578 12.0118 5.61521 12.0118 5.83334C12.0118 6.05146 12.0973 6.2609 12.25 6.41667L13.5833 7.75C13.7391 7.90269 13.9485 7.98822 14.1667 7.98822C14.3848 7.98822 14.5942 7.90269 14.75 7.75L17.8917 4.60834C18.3107 5.53433 18.4376 6.56603 18.2554 7.56596C18.0732 8.56588 17.5906 9.48654 16.8719 10.2052C16.1532 10.9239 15.2325 11.4065 14.2326 11.5887C13.2327 11.7709 12.201 11.644 11.275 11.225L5.51667 16.9833C5.18515 17.3149 4.73551 17.5011 4.26667 17.5011C3.79783 17.5011 3.34819 17.3149 3.01667 16.9833C2.68515 16.6518 2.4989 16.2022 2.4989 15.7333C2.4989 15.2645 2.68515 14.8149 3.01667 14.4833L8.775 8.725C8.35597 7.79901 8.2291 6.76731 8.41129 5.76738C8.59348 4.76746 9.07607 3.8468 9.79477 3.1281C10.5135 2.40941 11.4341 1.92681 12.434 1.74462C13.434 1.56243 14.4657 1.68931 15.3917 2.10834L12.2583 5.24167L12.25 5.25Z", stroke: "currentColor", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" }));
const SvgWidgetPlus = (props) => /* @__PURE__ */ React.createElement("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("path", { d: "M12.6667 2H3.33333C2.59695 2 2 2.59695 2 3.33333V12.6667C2 13.403 2.59695 14 3.33333 14H12.6667C13.403 14 14 13.403 14 12.6667V3.33333C14 2.59695 13.403 2 12.6667 2Z", stroke: "currentColor", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M8 5.33333V10.6667", stroke: "currentColor", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M5.33334 8H10.6667", stroke: "currentColor", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" }));
const SvgMapPin = (props) => /* @__PURE__ */ React.createElement("svg", { width: 20, height: 30, viewBox: "0 0 20 30", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("g", { clipPath: "url(#clip0_2280_4362)" }, /* @__PURE__ */ React.createElement("path", { d: "M9.99995 0.714355C4.87138 0.714355 0.714233 4.98578 0.714233 10.2501C0.714233 11.8358 1.09995 13.3358 1.76423 14.6501L9.33566 28.8144C9.33566 28.8144 9.36423 28.8715 9.37852 28.8929C9.49995 29.1215 9.72852 29.2786 9.99995 29.2786C10.2714 29.2786 10.4999 29.1215 10.6214 28.8929L10.6642 28.8144L18.2357 14.6501C18.9071 13.3358 19.2857 11.8358 19.2857 10.2501C19.2857 4.98578 15.1285 0.714355 9.99995 0.714355ZM9.99995 12.8572C8.42138 12.8572 7.14281 11.5786 7.14281 10.0001C7.14281 8.4215 8.42138 7.14293 9.99995 7.14293C11.5785 7.14293 12.8571 8.4215 12.8571 10.0001C12.8571 11.5786 11.5785 12.8572 9.99995 12.8572Z", fill: "#0075FF", stroke: "#0456B6", strokeMiterlimit: 10 })), /* @__PURE__ */ React.createElement("defs", null, /* @__PURE__ */ React.createElement("clipPath", { id: "clip0_2280_4362" }, /* @__PURE__ */ React.createElement("rect", { width: 20, height: 30, fill: "white" }))));
const SvgInputDelete = (props) => /* @__PURE__ */ React.createElement("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("circle", { cx: 12, cy: 12, r: 9, fill: "#CCCCCC" }), /* @__PURE__ */ React.createElement("path", { d: "M9 9L15 15", stroke: "white", strokeWidth: 1.5, strokeLinecap: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M15 9L9 15", stroke: "white", strokeWidth: 1.5, strokeLinecap: "round" }));
const SvgSuccess = (props) => /* @__PURE__ */ React.createElement("svg", { width: 20, height: 20, viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M19 10C19 14.9706 14.9706 19 10 19C5.02944 19 1 14.9706 1 10C1 5.02944 5.02944 1 10 1C14.9706 1 19 5.02944 19 10ZM14.7071 7.95711C15.0976 7.56658 15.0976 6.93342 14.7071 6.54289C14.3166 6.15237 13.6834 6.15237 13.2929 6.54289L8.5 11.3358L6.70711 9.54289C6.31658 9.15237 5.68342 9.15237 5.29289 9.54289C4.90237 9.93342 4.90237 10.5666 5.29289 10.9571L7.79289 13.4571C8.18342 13.8476 8.81658 13.8476 9.20711 13.4571L14.7071 7.95711Z", fill: "white" }));
const SvgMoreVertical = (props) => /* @__PURE__ */ React.createElement("svg", { width: 20, height: 20, viewBox: "0 0 20 20", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("path", { d: "M10 17.5C10.8284 17.5 11.5 16.8284 11.5 16C11.5 15.1716 10.8284 14.5 10 14.5C9.17157 14.5 8.5 15.1716 8.5 16C8.5 16.8284 9.17157 17.5 10 17.5Z" }), /* @__PURE__ */ React.createElement("path", { d: "M10 11.5C10.8284 11.5 11.5 10.8284 11.5 10C11.5 9.17157 10.8284 8.5 10 8.5C9.17157 8.5 8.5 9.17157 8.5 10C8.5 10.8284 9.17157 11.5 10 11.5Z" }), /* @__PURE__ */ React.createElement("path", { d: "M10 5.5C10.8284 5.5 11.5 4.82843 11.5 4C11.5 3.17157 10.8284 2.5 10 2.5C9.17157 2.5 8.5 3.17157 8.5 4C8.5 4.82843 9.17157 5.5 10 5.5Z" }));
const SvgMinus = (props) => /* @__PURE__ */ React.createElement("svg", { width: 20, height: 20, viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("path", { d: "M4 10H16", stroke: "#666666", strokeWidth: 1.5, strokeLinecap: "round" }));
const SvgPlus = (props) => /* @__PURE__ */ React.createElement("svg", { width: 20, height: 20, viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("path", { d: "M4 10H16", stroke: "currentColor", strokeWidth: 1.5, strokeLinecap: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M10 16L10 4", stroke: "currentColor", strokeWidth: 1.5, strokeLinecap: "round" }));
const SvgStyle = (props) => /* @__PURE__ */ React.createElement("svg", { width: 20, height: 20, viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("path", { d: "M15.8333 2.5H4.16667C3.24619 2.5 2.5 3.24619 2.5 4.16667V15.8333C2.5 16.7538 3.24619 17.5 4.16667 17.5H15.8333C16.7538 17.5 17.5 16.7538 17.5 15.8333V4.16667C17.5 3.24619 16.7538 2.5 15.8333 2.5Z", stroke: "currentColor", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M14.1667 5.83325H11.6667V9.99992H14.1667V5.83325Z", stroke: "currentColor", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M8.33331 5.83325H5.83331V13.3333H8.33331V5.83325Z", stroke: "currentColor", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" }));
const SvgFolderOpen = (props) => /* @__PURE__ */ React.createElement("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("path", { d: "M15 21H4C3.46957 21 2.96086 20.7893 2.58579 20.4142C2.21071 20.0391 2 19.5304 2 19V5C2 4.46957 2.21071 3.96086 2.58579 3.58579C2.96086 3.21071 3.46957 3 4 3H9L11 6H18C18.5304 6 19.0391 6.21071 19.4142 6.58579C19.7893 6.96086 20 7.46957 20 8V9.5", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M6 17.4737L7.79175 11.4314C8.04352 10.5824 8.82365 10 9.70923 10H20.6036C21.8514 10 22.7945 11.1301 22.5713 12.3578L21.2986 19.3578C21.1257 20.3087 20.2974 21 19.3308 21H15", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round" }));
const SvgDevice = (props) => /* @__PURE__ */ React.createElement("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("path", { d: "M4.66667 14.0003L2 11.3337L4.66667 8.66699", stroke: "currentColor", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M11.3333 11.333H2", stroke: "currentColor", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M11.3333 2L13.9999 4.66667L11.3333 7.33333", stroke: "currentColor", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M4.66663 4.66699H14", stroke: "currentColor", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" }));
const SvgFail = (props) => /* @__PURE__ */ React.createElement("svg", { width: 20, height: 20, viewBox: "0 0 20 20", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M10 19C14.9706 19 19 14.9706 19 10C19 5.02944 14.9706 1 10 1C5.02944 1 1 5.02944 1 10C1 14.9706 5.02944 19 10 19ZM13.7071 6.29289C14.0976 6.68342 14.0976 7.31658 13.7071 7.70711L11.4142 10L13.7071 12.2929C14.0976 12.6834 14.0976 13.3166 13.7071 13.7071C13.3166 14.0976 12.6834 14.0976 12.2929 13.7071L10 11.4142L7.70711 13.7071C7.31658 14.0976 6.68342 14.0976 6.29289 13.7071C5.90237 13.3166 5.90237 12.6834 6.29289 12.2929L8.58579 10L6.29289 7.70711C5.90237 7.31658 5.90237 6.68342 6.29289 6.29289C6.68342 5.90237 7.31658 5.90237 7.70711 6.29289L10 8.58579L12.2929 6.29289C12.6834 5.90237 13.3166 5.90237 13.7071 6.29289Z", fill: "white" }));
const SvgCalendar = (props) => /* @__PURE__ */ React.createElement("svg", { width: 20, height: 20, viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("path", { d: "M15.8333 3.33398H4.16667C3.24619 3.33398 2.5 4.08018 2.5 5.00065V16.6673C2.5 17.5878 3.24619 18.334 4.16667 18.334H15.8333C16.7538 18.334 17.5 17.5878 17.5 16.6673V5.00065C17.5 4.08018 16.7538 3.33398 15.8333 3.33398Z", stroke: "currentColor", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M2.5 8.33398H17.5", stroke: "currentColor", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M13.3335 1.66602V4.99935", stroke: "currentColor", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M6.6665 1.66602V4.99935", stroke: "currentColor", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" }));
const SvgEmptyList = (props) => /* @__PURE__ */ React.createElement("svg", { width: 65, height: 65, viewBox: "0 0 65 65", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("g", { style: {
  mixBlendMode: "luminosity"
}, clipPath: "url(#clip0_2709_10618)" }, /* @__PURE__ */ React.createElement("circle", { cx: 32.5, cy: 32.5, r: 32, fill: "currentColor", fillOpacity: 0.15 }), /* @__PURE__ */ React.createElement("path", { d: "M35.2499 18.5H24.25C23.5206 18.5 22.8212 18.795 22.3055 19.3201C21.7897 19.8452 21.5 20.5574 21.5 21.3V43.7C21.5 44.4426 21.7897 45.1548 22.3055 45.6799C22.8212 46.205 23.5206 46.5 24.25 46.5H40.7499C41.4792 46.5 42.1787 46.205 42.6944 45.6799C43.2101 45.1548 43.4998 44.4426 43.4998 43.7V26.9L35.2499 18.5Z", stroke: "currentColor", strokeWidth: 2.5, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M37.9999 38.5H27", stroke: "currentColor", strokeWidth: 2.5, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M37.9999 33.5H27", stroke: "currentColor", strokeWidth: 2.5, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M30 28.5H28.5H27", stroke: "currentColor", strokeWidth: 2.5, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M35.5 19.5V27.5H43.5", stroke: "currentColor", strokeWidth: 2.5, strokeLinecap: "round", strokeLinejoin: "round" })), /* @__PURE__ */ React.createElement("defs", null, /* @__PURE__ */ React.createElement("clipPath", { id: "clip0_2709_10618" }, /* @__PURE__ */ React.createElement("rect", { width: 64, height: 64, fill: "white", transform: "translate(0.5 0.5)" }))));
const SvgDangerZone = (props) => /* @__PURE__ */ React.createElement("svg", { width: 32, height: 32, viewBox: "0 0 32 32", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("g", { clipPath: "url(#clip0_2800_40467)" }, /* @__PURE__ */ React.createElement("circle", { cx: 16, cy: 16, r: 16, fill: "#444444", fillOpacity: 0.1 }), /* @__PURE__ */ React.createElement("path", { d: "M21.25 9.25H10.75C9.92157 9.25 9.25 9.92157 9.25 10.75V21.25C9.25 22.0784 9.92157 22.75 10.75 22.75H21.25C22.0784 22.75 22.75 22.0784 22.75 21.25V10.75C22.75 9.92157 22.0784 9.25 21.25 9.25Z", fill: "black", stroke: "black", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M13.75 13.75L18.25 18.25", stroke: "white", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M18.25 13.75L13.75 18.25", stroke: "white", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" })), /* @__PURE__ */ React.createElement("defs", null, /* @__PURE__ */ React.createElement("clipPath", { id: "clip0_2800_40467" }, /* @__PURE__ */ React.createElement("rect", { width: 32, height: 32, fill: "white" }))));
const SvgDetection = (props) => /* @__PURE__ */ React.createElement("svg", { width: 32, height: 32, viewBox: "0 0 32 32", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("g", { clipPath: "url(#clip0_2800_40458)" }, /* @__PURE__ */ React.createElement("circle", { cx: 16, cy: 16, r: 16, fill: "#FF4545", fillOpacity: 0.12 }), /* @__PURE__ */ React.createElement("g", { clipPath: "url(#clip1_2800_40458)" }, /* @__PURE__ */ React.createElement("path", { d: "M16.0001 24.3337C20.6025 24.3337 24.3334 20.6027 24.3334 16.0003C24.3334 11.398 20.6025 7.66699 16.0001 7.66699C11.3977 7.66699 7.66675 11.398 7.66675 16.0003C7.66675 20.6027 11.3977 24.3337 16.0001 24.3337Z", fill: "#FF4545", stroke: "#FF4545", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M16 17.25C16.6904 17.25 17.25 16.6904 17.25 16C17.25 15.3096 16.6904 14.75 16 14.75C15.3096 14.75 14.75 15.3096 14.75 16C14.75 16.6904 15.3096 17.25 16 17.25Z", stroke: "white", strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M18.6499 13.3498C18.9985 13.6981 19.2751 14.1117 19.4639 14.5669C19.6526 15.0221 19.7497 15.5101 19.7497 16.0029C19.7497 16.4957 19.6526 16.9837 19.4639 17.439C19.2751 17.8942 18.9985 18.3078 18.6499 18.6561M13.3499 18.6498C13.0012 18.3015 12.7246 17.8879 12.5359 17.4327C12.3472 16.9775 12.2501 16.4895 12.2501 15.9967C12.2501 15.5039 12.3472 15.0159 12.5359 14.5607C12.7246 14.1054 13.0012 13.6918 13.3499 13.3436M20.4186 11.5811C21.5903 12.7531 22.2486 14.3425 22.2486 15.9998C22.2486 17.6571 21.5903 19.2465 20.4186 20.4186M11.5811 20.4186C10.4094 19.2465 9.75122 17.6571 9.75122 15.9998C9.75122 14.3425 10.4094 12.7531 11.5811 11.5811", stroke: "white", strokeLinecap: "round", strokeLinejoin: "round" }))), /* @__PURE__ */ React.createElement("defs", null, /* @__PURE__ */ React.createElement("clipPath", { id: "clip0_2800_40458" }, /* @__PURE__ */ React.createElement("rect", { width: 32, height: 32, fill: "white" })), /* @__PURE__ */ React.createElement("clipPath", { id: "clip1_2800_40458" }, /* @__PURE__ */ React.createElement("rect", { width: 20, height: 20, fill: "white", transform: "translate(6 6)" }))));
const SvgSafetyGear = (props) => /* @__PURE__ */ React.createElement("svg", { width: 32, height: 32, viewBox: "0 0 32 32", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("g", { clipPath: "url(#clip0_2800_40461)" }, /* @__PURE__ */ React.createElement("circle", { cx: 16, cy: 16, r: 16, fill: "#FDB541", fillOpacity: 0.15 }), /* @__PURE__ */ React.createElement("path", { d: "M16.2083 23.9157C20.8107 23.9157 24.5417 20.1847 24.5417 15.5824C24.5417 10.98 20.8107 7.24902 16.2083 7.24902C11.606 7.24902 7.875 10.98 7.875 15.5824C7.875 20.1847 11.606 23.9157 16.2083 23.9157Z", fill: "#FDB541", stroke: "#FDB541", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M19.7499 14.283V14.2033C19.7527 13.4059 19.4997 12.6287 19.0281 11.9857C18.5564 11.3428 17.891 10.8681 17.1296 10.6314H17.1015C16.7082 10.5115 16.2984 10.4546 15.8874 10.4627C14.9086 10.5164 13.9871 10.9416 13.3111 11.6516C12.6352 12.3615 12.2556 13.3027 12.2499 14.283C11.9752 14.3796 11.7373 14.5591 11.569 14.7967C11.4007 15.0344 11.3103 15.3184 11.3103 15.6095C11.3103 15.9007 11.4007 16.1847 11.569 16.4223C11.7373 16.66 11.9752 16.8395 12.2499 16.9361C12.3464 17.8618 12.7838 18.7185 13.4768 19.3397C14.1699 19.9608 15.0692 20.3021 15.9999 20.297H16.1077C17.0077 20.2535 17.8631 19.8924 18.5222 19.278C19.1812 18.6636 19.6013 17.8355 19.7077 16.9408C19.9856 16.8496 20.2282 16.6741 20.4017 16.4386C20.5751 16.2031 20.6708 15.9194 20.6755 15.6269C20.6801 15.3345 20.5935 15.0478 20.4276 14.807C20.2617 14.5661 20.0248 14.3829 19.7499 14.283ZM16.0843 19.3595C15.4057 19.3792 14.7429 19.1527 14.2183 18.722C13.6936 18.2912 13.3424 17.6852 13.2296 17.0158H18.7468C18.6324 17.6495 18.3071 18.2259 17.8237 18.6514C17.3404 19.0769 16.7274 19.3264 16.0843 19.3595ZM19.2811 16.0783H12.7186C12.5943 16.0783 12.4751 16.0289 12.3872 15.941C12.2993 15.8531 12.2499 15.7339 12.2499 15.6095C12.2499 15.4852 12.2993 15.366 12.3872 15.2781C12.4751 15.1902 12.5943 15.1408 12.7186 15.1408H13.6561C13.7805 15.1408 13.8997 15.0914 13.9876 15.0035C14.0755 14.9156 14.1249 14.7964 14.1249 14.672C14.1249 14.5477 14.0755 14.4285 13.9876 14.3406C13.8997 14.2527 13.7805 14.2033 13.6561 14.2033H13.1874C13.2084 13.717 13.3474 13.2432 13.5924 12.8226C13.8374 12.402 14.181 12.0474 14.5936 11.7892V13.2658C14.5936 13.3901 14.643 13.5093 14.7309 13.5973C14.8188 13.6852 14.9381 13.7345 15.0624 13.7345C15.1867 13.7345 15.3059 13.6852 15.3939 13.5973C15.4818 13.5093 15.5311 13.3901 15.5311 13.2658V11.433C15.6584 11.4117 15.7867 11.3976 15.9155 11.3908H15.9999C16.157 11.393 16.3137 11.4071 16.4686 11.433V13.2658C16.4686 13.3901 16.518 13.5093 16.6059 13.5973C16.6938 13.6852 16.8131 13.7345 16.9374 13.7345C17.0617 13.7345 17.1809 13.6852 17.2689 13.5973C17.3568 13.5093 17.4061 13.3901 17.4061 13.2658V11.7752C17.605 11.8903 17.7905 12.0271 17.9593 12.183C18.2295 12.4454 18.4443 12.7595 18.5909 13.1066C18.7374 13.4536 18.8127 13.8266 18.8124 14.2033H18.3436C18.2193 14.2033 18.1001 14.2527 18.0122 14.3406C17.9243 14.4285 17.8749 14.5477 17.8749 14.672C17.8749 14.7964 17.9243 14.9156 18.0122 15.0035C18.1001 15.0914 18.2193 15.1408 18.3436 15.1408H19.2811C19.4055 15.1408 19.5247 15.1902 19.6126 15.2781C19.7005 15.366 19.7499 15.4852 19.7499 15.6095C19.7499 15.7339 19.7005 15.8531 19.6126 15.941C19.5247 16.0289 19.4055 16.0783 19.2811 16.0783Z", fill: "white" })), /* @__PURE__ */ React.createElement("defs", null, /* @__PURE__ */ React.createElement("clipPath", { id: "clip0_2800_40461" }, /* @__PURE__ */ React.createElement("rect", { width: 32, height: 32, fill: "white" }))));
const SvgShield = (props) => /* @__PURE__ */ React.createElement("svg", { width: 32, height: 32, viewBox: "0 0 32 32", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("g", { clipPath: "url(#clip0_2800_40464)" }, /* @__PURE__ */ React.createElement("circle", { cx: 16, cy: 16, r: 16, fill: "#46CDD0", fillOpacity: 0.15 }), /* @__PURE__ */ React.createElement("path", { d: "M15.9999 24.3337C15.9999 24.3337 22.6666 21.0003 22.6666 16.0003V10.167L15.9999 7.66699L9.33325 10.167V16.0003C9.33325 21.0003 15.9999 24.3337 15.9999 24.3337Z", fill: "#46CDD0" }), /* @__PURE__ */ React.createElement("path", { d: "M14 15.2857L16 17L18.8 14", stroke: "white", strokeWidth: 2, strokeLinecap: "round" })), /* @__PURE__ */ React.createElement("defs", null, /* @__PURE__ */ React.createElement("clipPath", { id: "clip0_2800_40464" }, /* @__PURE__ */ React.createElement("rect", { width: 32, height: 32, fill: "white" }))));
const SvgFilter2 = (props) => /* @__PURE__ */ React.createElement("svg", { width: 32, height: 32, viewBox: "0 0 32 32", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("path", { d: "M27.49 2H5.49001C5.09203 2.01292 4.71453 2.17949 4.43672 2.46476C4.15891 2.75003 4.00239 3.13182 4.00001 3.53V5.53C3.99855 5.86561 4.10748 6.19239 4.31001 6.46L12.14 16.82C12.699 17.5677 13.0007 18.4764 13 19.41V24.33C13.0006 24.8691 13.1232 25.4011 13.3588 25.886C13.5943 26.371 13.9366 26.7963 14.36 27.13L17.58 29.63C17.846 29.8368 18.1731 29.9493 18.51 29.95C18.743 29.9517 18.9729 29.8968 19.18 29.79C19.4318 29.662 19.6424 29.4655 19.7874 29.2232C19.9325 28.9808 20.0062 28.7024 20 28.42V19.42C19.9971 18.483 20.299 17.5705 20.86 16.82L28.69 6.47C28.8926 6.20239 29.0015 5.87561 29 5.54V3.54C29.0027 3.33955 28.9656 3.14056 28.891 2.95449C28.8165 2.76841 28.7058 2.59893 28.5655 2.45579C28.4251 2.31265 28.2578 2.19869 28.0733 2.12047C27.8887 2.04224 27.6905 2.0013 27.49 2ZM27 5.39L19.27 15.61C18.4449 16.7126 17.9993 18.0529 18 19.43V27.43L15.55 25.54C15.3754 25.3908 15.2357 25.2051 15.1407 24.9961C15.0456 24.787 14.9976 24.5596 15 24.33V19.41C15 18.0422 14.5542 16.7116 13.73 15.62L6.00001 5.39V4H27V5.39Z", fill: "currentColor" }));
const SvgRefresh = (props) => /* @__PURE__ */ React.createElement("svg", { width: 20, height: 20, viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("path", { d: "M0.833252 16.668V11.668H5.83325", stroke: "currentColor", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M19.1667 3.33203V8.33203H14.1667", stroke: "currentColor", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M2.92492 7.50193C3.34756 6.30759 4.06586 5.23977 5.01281 4.39812C5.95975 3.55646 7.10447 2.96841 8.34016 2.68882C9.57584 2.40923 10.8622 2.44722 12.0792 2.79925C13.2963 3.15127 14.4043 3.80586 15.2999 4.70193L19.1666 8.33527M0.833252 11.6686L4.69992 15.3019C5.59554 16.198 6.70356 16.8526 7.92059 17.2046C9.13762 17.5567 10.424 17.5946 11.6597 17.3151C12.8954 17.0355 14.0401 16.4474 14.987 15.6058C15.934 14.7641 16.6523 13.6963 17.0749 12.5019", stroke: "#666666", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" }));
const SvgCritical = (props) => /* @__PURE__ */ React.createElement("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("path", { d: "M10.3633 3.95728L2.25653 18.017C2.08938 18.3177 2.00094 18.6587 2.00001 19.0059C1.99907 19.3531 2.08567 19.6946 2.25119 19.9963C2.41671 20.2979 2.65538 20.5493 2.94346 20.7254C3.23153 20.9015 3.55897 20.9962 3.8932 21H20.1068C20.441 20.9962 20.7685 20.9015 21.0565 20.7254C21.3446 20.5493 21.5833 20.2979 21.7488 19.9963C21.9143 19.6946 22.0009 19.3531 22 19.0059C21.9991 18.6587 21.9106 18.3177 21.7435 18.017L13.6367 3.95728C13.466 3.66505 13.2258 3.42345 12.9391 3.25577C12.6524 3.08809 12.329 3 12 3C11.671 3 11.3476 3.08809 11.0609 3.25577C10.7742 3.42345 10.534 3.66505 10.3633 3.95728Z", fill: "#FF4545", stroke: "#FF4545", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M12 9V13", stroke: "white", strokeWidth: 2.5, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M12 17H12.01", stroke: "white", strokeWidth: 2.5, strokeLinecap: "round", strokeLinejoin: "round" }));
const SvgMajor = (props) => /* @__PURE__ */ React.createElement("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("path", { d: "M12 21.5C17.2467 21.5 21.5 17.2467 21.5 12C21.5 6.75329 17.2467 2.5 12 2.5C6.75329 2.5 2.5 6.75329 2.5 12C2.5 17.2467 6.75329 21.5 12 21.5Z", fill: "#FDB541", stroke: "#FDB541", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M12 8V12", stroke: "white", strokeWidth: 2.5, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M12 16H12.01", stroke: "white", strokeWidth: 2.5, strokeLinecap: "round", strokeLinejoin: "round" }));
const SvgMinor = (props) => /* @__PURE__ */ React.createElement("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("path", { d: "M8.067 2.5H15.933L21.5 8.067V15.933L15.933 21.5H8.067L2.5 15.933V8.067L8.067 2.5Z", fill: "#FCDB2C", stroke: "#FCDB2C", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M12 8V12", stroke: "white", strokeWidth: 2.5, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M12 16H12.01", stroke: "white", strokeWidth: 2.5, strokeLinecap: "round", strokeLinejoin: "round" }));
const SvgWarning = (props) => /* @__PURE__ */ React.createElement("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("path", { d: "M19 3H5C3.89543 3 3 3.89543 3 5V19C3 20.1046 3.89543 21 5 21H19C20.1046 21 21 20.1046 21 19V5C21 3.89543 20.1046 3 19 3Z", fill: "#61D866", stroke: "#61D866", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M12 8V12", stroke: "white", strokeWidth: 2.5, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M12 16H12.01", stroke: "white", strokeWidth: 2.5, strokeLinecap: "round", strokeLinejoin: "round" }));
const SvgAlarmOn = (props) => /* @__PURE__ */ React.createElement("svg", { width: 40, height: 40, viewBox: "0 0 40 40", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("g", { clipPath: "url(#clip0_2800_40247)" }, /* @__PURE__ */ React.createElement("circle", { cx: 20, cy: 20, r: 20, fill: "#0075FF", fillOpacity: 0.1 }), /* @__PURE__ */ React.createElement("path", { d: "M26 16C26 14.4087 25.3679 12.8826 24.2426 11.7574C23.1174 10.6321 21.5913 10 20 10C18.4087 10 16.8826 10.6321 15.7574 11.7574C14.6321 12.8826 14 14.4087 14 16C14 23 11 25 11 25H29C29 25 26 23 26 16Z", stroke: "#0075FF", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M23 28C22.6951 28.6083 22.2575 29.1132 21.731 29.4642C21.2045 29.8153 20.6076 30 20 30C19.3924 30 18.7955 29.8153 18.269 29.4642C17.7425 29.1132 17.3049 28.6083 17 28", stroke: "#0075FF", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("circle", { cx: 26, cy: 14, r: 3, fill: "#0075FF" })), /* @__PURE__ */ React.createElement("defs", null, /* @__PURE__ */ React.createElement("clipPath", { id: "clip0_2800_40247" }, /* @__PURE__ */ React.createElement("rect", { width: 40, height: 40, fill: "white" }))));
const SvgAlarmOff = (props) => /* @__PURE__ */ React.createElement("svg", { width: 40, height: 40, viewBox: "0 0 40 40", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("g", { clipPath: "url(#clip0_2800_40252)" }, /* @__PURE__ */ React.createElement("circle", { cx: 20, cy: 20, r: 20, fill: "currentColor", fillOpacity: 0.1 }), /* @__PURE__ */ React.createElement("path", { d: "M26 16C26 14.4087 25.3679 12.8826 24.2426 11.7574C23.1174 10.6321 21.5913 10 20 10C18.4087 10 16.8826 10.6321 15.7574 11.7574C14.6321 12.8826 14 14.4087 14 16C14 23 11 25 11 25H29C29 25 26 23 26 16Z", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round", fillOpacity: 0.1 }), /* @__PURE__ */ React.createElement("path", { d: "M23 28C22.6951 28.6083 22.2575 29.1132 21.731 29.4642C21.2045 29.8153 20.6076 30 20 30C19.3924 30 18.7955 29.8153 18.269 29.4642C17.7425 29.1132 17.3049 28.6083 17 28", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" })), /* @__PURE__ */ React.createElement("defs", null, /* @__PURE__ */ React.createElement("clipPath", { id: "clip0_2800_40252" }, /* @__PURE__ */ React.createElement("rect", { width: 40, height: 40, fill: "white" }))));
const SvgAlarmClear = (props) => /* @__PURE__ */ React.createElement("svg", { width: 40, height: 40, viewBox: "0 0 40 40", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("g", { clipPath: "url(#clip0_2800_40252)" }, /* @__PURE__ */ React.createElement("circle", { cx: 20, cy: 20, r: 20, fill: "currentColor", opacity: 0.1 }), /* @__PURE__ */ React.createElement("path", { d: "M26 16C26 14.4087 25.3679 12.8826 24.2426 11.7574C23.1174 10.6321 21.5913 10 20 10C18.4087 10 16.8826 10.6321 15.7574 11.7574C14.6321 12.8826 14 14.4087 14 16C14 23 11 25 11 25H29C29 25 26 23 26 16Z", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M23 28C22.6951 28.6083 22.2575 29.1132 21.731 29.4642C21.2045 29.8153 20.6076 30 20 30C19.3924 30 18.7955 29.8153 18.269 29.4642C17.7425 29.1132 17.3049 28.6083 17 28", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M10 10 L30 30", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round" })), /* @__PURE__ */ React.createElement("defs", null, /* @__PURE__ */ React.createElement("clipPath", { id: "clip0_2800_40252" }, /* @__PURE__ */ React.createElement("rect", { width: 40, height: 40, fill: "white" }))));
const SvgCheckOff = (props) => /* @__PURE__ */ React.createElement("svg", { width: 40, height: 40, viewBox: "0 0 40 40", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("g", { clipPath: "url(#clip0_2800_40247)" }, /* @__PURE__ */ React.createElement("circle", { cx: 20, cy: 20, r: 20, fill: "#EEEEEE" }), /* @__PURE__ */ React.createElement("path", { d: "M12 20L18 26L28 14", stroke: "currentColor", strokeWidth: 2.5, strokeLinecap: "round", strokeLinejoin: "round" })), /* @__PURE__ */ React.createElement("defs", null, /* @__PURE__ */ React.createElement("clipPath", { id: "clip0_2800_40247" }, /* @__PURE__ */ React.createElement("rect", { width: 40, height: 40, fill: "white" }))));
const SvgTrash = (props) => /* @__PURE__ */ React.createElement("svg", { width: 48, height: 48, viewBox: "0 0 48 48", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("path", { d: "M6 12H10M10 12H42M10 12V40C10 41.0609 10.4214 42.0783 11.1716 42.8284C11.9217 43.5786 12.9391 44 14 44H34C35.0609 44 36.0783 43.5786 36.8284 42.8284C37.5786 42.0783 38 41.0609 38 40V12M16 12V8C16 6.93913 16.4214 5.92172 17.1716 5.17157C17.9217 4.42143 18.9391 4 20 4H28C29.0609 4 30.0783 4.42143 30.8284 5.17157C31.5786 5.92172 32 6.93913 32 8V12M20 22V34M28 22V34", stroke: "currentColor", strokeWidth: 4, strokeLinecap: "round", strokeLinejoin: "round" }));
const SvgMoonNight = (props) => /* @__PURE__ */ React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", ...props }, /* @__PURE__ */ React.createElement("path", { fill: "currentColor", d: "M12,2A10,10,0,1,0,22,12,10,10,0,0,0,12,2Zm0,18A8,8,0,0,1,12,4c.16,0,.316.015.473.024a9.908,9.908,0,0,0,6.194,12.388A8,8,0,0,1,12,20Z" }));
const SvgTranslate = (props) => /* @__PURE__ */ React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", xmlnsXlink: "http://www.w3.org/1999/xlink", x: "0px", y: "0px", viewBox: "0 0 128 128", style: {
  enableBackground: "new 0 0 128 128"
}, xmlSpace: "preserve", ...props }, /* @__PURE__ */ React.createElement("g", { id: "_x31_1" }, /* @__PURE__ */ React.createElement("path", { id: "icon_1_", style: {
  fill: "currentColor"
}, d: "M68.918,109.572L55.77,96.045v5.635H23.099l16.014,15.8H55.77v5.618L68.918,109.572z  M30.019,72.946L16.492,86.094h5.618v14.383h15.817V86.094h5.602L30.019,72.946z M93.154,75.5l-4.712,14.252h9.276L93.154,75.5z  M93.154,75.5l-4.712,14.252h9.276L93.154,75.5z M93.154,75.5l-4.712,14.252h9.276L93.154,75.5z M121.426,50.078H83.17V10.685 c0-5.421-4.432-9.853-9.869-9.853H9.869C4.432,0.832,0,5.264,0,10.685v63.992c0,5.437,4.432,9.852,9.869,9.852h4.547v-6.59H9.869 c-1.812,0-3.279-1.466-3.279-3.262V10.685c0-1.796,1.466-3.262,3.279-3.262h63.432c1.812,0,3.279,1.466,3.279,3.262v39.393H57.995 c-2.751,0-5.091,1.664-6.08,4.053c-2.191-1.746-4.152-3.493-5.931-5.19C56.858,37.21,58.687,26.238,58.802,25.562l0.071-0.362 h8.694v-4.943H45.292v-7.381h-4.943v7.381H18.074V25.2h35.752c-0.395,1.911-2.636,10.693-11.352,20.166 c-6.426-6.953-9.309-12.456-9.358-12.555l-2.191,1.12l-2.208,1.12c0.214,0.412,3.312,6.393,10.248,13.84 c-4.564,4.218-10.479,8.403-18.14,12.077l2.142,4.448c8.221-3.921,14.581-8.436,19.491-12.966c2.57,2.471,5.552,5.025,8.963,7.529 v17.958h-5.602v6.59h5.602v9.193h4.992v-0.28l16.014,16.459l-16.014,16.459c0,0-2.059,0.807,1.582,0.807h63.432 c3.641,0,6.574-2.933,6.574-6.557V56.635C128,53.011,125.067,50.078,121.426,50.078z M102.117,103.443l-2.389-7.447H86.382 l-2.455,7.447h-7.908l12.934-36.214h8.551l12.818,36.214H102.117z" })), /* @__PURE__ */ React.createElement("g", { id: "Layer_1" }));
const SvgLogOut = (props) => /* @__PURE__ */ React.createElement("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("path", { d: "M16 17L21 12L16 7", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M21 12H9", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M9 21H5C4.46957 21 3.96086 20.7893 3.58579 20.4142C3.21071 20.0391 3 19.5304 3 19V5C3 4.46957 3.21071 3.96086 3.58579 3.58579C3.96086 3.21071 4.46957 3 5 3H9", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }));
const SvgBookmark = (props) => /* @__PURE__ */ React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", xmlSpace: "preserve", width: "6.82666in", height: "6.82666in", style: {
  shapeRendering: "geometricPrecision",
  textRendering: "geometricPrecision",
  imageRendering: "optimizeQuality",
  fillRule: "evenodd",
  clipRule: "evenodd"
}, viewBox: "0 0 6.82666 6.82666", xmlnsXlink: "http://www.w3.org/1999/xlink", ...props }, /* @__PURE__ */ React.createElement("defs", null, /* @__PURE__ */ React.createElement("style", { type: "text/css" })), /* @__PURE__ */ React.createElement("g", { id: "Layer_x0020_1" }, /* @__PURE__ */ React.createElement("metadata", { id: "CorelCorpID_0Corel-Layer" }), /* @__PURE__ */ React.createElement("g", { id: "_558160760" }, /* @__PURE__ */ React.createElement("path", { id: "_558162008", className: "fil0", d: "M1.33333 0.853331l3.09333 0c0.0589094,0 0.106669,0.0477598 0.106669,0.106669l0 0.881591c0,0.0589094 -0.0477598,0.106669 -0.106669,0.106669 -0.00463386,0 -0.00920079,-0.000295276 -0.0136811,-0.000870079 -0.0126693,-0.000850394 -0.0229134,-0.00142913 -0.0305433,-0.00170079 -0.00598819,-0.000216535 -0.018185,-0.000330709 -0.0370827,-0.000330709 -0.287559,0 -0.54789,0.116551 -0.736323,0.30498 -0.188429,0.188433 -0.30498,0.448764 -0.30498,0.736323 0,0.287559 0.116551,0.54789 0.30498,0.736323 0.188433,0.188429 0.448764,0.30498 0.736323,0.30498 0.0188976,0 0.0310945,-0.000114173 0.0370827,-0.000330709 0.00884646,-0.000314961 0.0212047,-0.00103937 0.0367795,-0.00212992l-1.1811e-005 -0.000177165c0.0587638,-0.00411811 0.109744,0.040185 0.113862,0.0989488 0.000173228,0.00250394 0.000259843,0.00498819 0.000259843,0.00745669l3.93701e-006 0 0 0.000751969 0 1.73418c0,0.0589094 -0.0477598,0.106669 -0.106669,0.106669 -0.0349843,0 -0.0660315,-0.0168425 -0.0854843,-0.0428583l-1.46119 -1.76349 -1.46458 1.76759 -0.0820827 -0.0679173 0.0821378 0.0680551c-0.0375827,0.0453622 -0.104831,0.0516654 -0.150193,0.0140827 -0.0254409,-0.0210787 -0.0385945,-0.0514882 -0.0386102,-0.0821378l-3.93701e-006 0 0 -0.000267717 0 -4.90639c0,-0.0589094 0.0477598,-0.106669 0.106669,-0.106669zm2.98667 0.213339l-2.88 0 0 4.50427 1.35439 -1.6346c0.00498819,-0.00669685 0.0108386,-0.0129134 0.0175551,-0.0184764 0.0453622,-0.0375827 0.11261,-0.0312795 0.150193,0.0140827l-0.0821378 0.0680551 0.0820827 -0.0679173 1.35792 1.63885 0 -1.32991c-0.336374,-0.00667323 -0.640299,-0.145717 -0.861795,-0.367209 -0.227047,-0.227051 -0.367484,-0.540713 -0.367484,-0.887157 0,-0.346445 0.140437,-0.660106 0.367484,-0.887157 0.221496,-0.221492 0.525421,-0.360535 0.861795,-0.367209l0 -0.665626z" }), /* @__PURE__ */ React.createElement("path", { id: "_558161792", className: "fil0", d: "M4.34536 1.73202c0.346445,0 0.660106,0.140437 0.887157,0.367484 0.227047,0.227051 0.367484,0.540713 0.367484,0.887157 0,0.346445 -0.140437,0.660106 -0.367484,0.887157 -0.227051,0.227047 -0.540713,0.367484 -0.887157,0.367484 -0.346445,0 -0.660106,-0.140437 -0.887157,-0.367484 -0.227047,-0.227051 -0.367484,-0.540713 -0.367484,-0.887157 0,-0.346445 0.140437,-0.660106 0.367484,-0.887157 0.227051,-0.227047 0.540713,-0.367484 0.887157,-0.367484zm0.736323 0.518319c-0.188433,-0.188429 -0.448764,-0.30498 -0.736323,-0.30498 -0.287559,0 -0.54789,0.116551 -0.736323,0.30498 -0.188429,0.188433 -0.30498,0.448764 -0.30498,0.736323 0,0.287559 0.116551,0.54789 0.30498,0.736323 0.188433,0.188429 0.448764,0.30498 0.736323,0.30498 0.287559,0 0.54789,-0.116551 0.736323,-0.30498 0.188429,-0.188433 0.30498,-0.448764 0.30498,-0.736323 0,-0.287559 -0.116551,-0.54789 -0.30498,-0.736323z" }), /* @__PURE__ */ React.createElement("polygon", { id: "_558161024", className: "fil0", points: "4.48,2.24 4.48,3.73333 4.26667,3.73333 4.26667,2.24 " }), /* @__PURE__ */ React.createElement("polygon", { id: "_558160880", className: "fil0", points: "3.62667,2.87999 5.12,2.87999 5.12,3.09333 3.62667,3.09333 " }))));
const SvgImage = (props) => /* @__PURE__ */ React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", xmlSpace: "preserve", width: "6.82666in", height: "6.82666in", style: {
  shapeRendering: "geometricPrecision",
  textRendering: "geometricPrecision",
  imageRendering: "optimizeQuality",
  fillRule: "evenodd",
  clipRule: "evenodd"
}, viewBox: "0 0 6.82666 6.82666", xmlnsXlink: "http://www.w3.org/1999/xlink", ...props }, /* @__PURE__ */ React.createElement("defs", null, /* @__PURE__ */ React.createElement("style", { type: "text/css" })), /* @__PURE__ */ React.createElement("g", { id: "Layer_x0020_1" }, /* @__PURE__ */ React.createElement("metadata", { id: "CorelCorpID_0Corel-Layer" }), /* @__PURE__ */ React.createElement("g", { id: "_554253040" }, /* @__PURE__ */ React.createElement("path", { id: "_554253832", className: "fil0", d: "M1.02667 1.39999l4.77333 0c0.0477756,0 0.0911378,0.0194803 0.122496,0.0508386l-0.000208661 0.000208661c0.0315039,0.0315945 0.0510472,0.0749016 0.0510472,0.122287l0 3.68002c0,0.0473819 -0.0195551,0.0906929 -0.0510512,0.122283l0.000208661 0.000208661c-0.0313622,0.0313622 -0.0747283,0.0508425 -0.122492,0.0508425l-4.77333 0c-0.0477638,0 -0.0911299,-0.0194685 -0.1225,-0.0508386 -0.0313622,-0.0313622 -0.0508346,-0.0747244 -0.0508346,-0.122496l0 -3.68002c0,-0.0477795 0.0194724,-0.0911378 0.0508346,-0.1225l0.000208661 0.000208661c0.0315906,-0.0314961 0.0748937,-0.0510433 0.122291,-0.0510433zm4.73333 0.213339l-4.69333 0 0 3.60001 4.69333 0 0 -3.60001z" }), /* @__PURE__ */ React.createElement("path", { id: "_554253304", className: "fil0", d: "M1.32618 4.61791c-0.0416496,0.0416496 -0.0416496,0.109185 0,0.150835 0.0416496,0.0416496 0.109185,0.0416496 0.150835,0l1.31125 -1.31125 0.991248 0.991248c0.0416496,0.0416496 0.109185,0.0416496 0.150835,0 0.0416496,-0.0416496 0.0416496,-0.109185 0,-0.150835l-1.06607 -1.06607 -0.000590551 -0.000606299c-0.0416535,-0.0416535 -0.109197,-0.0416535 -0.15085,0l7.87402e-006 7.87402e-006 -1.38667 1.38667z" }), /* @__PURE__ */ React.createElement("path", { id: "_554253592", className: "fil0", d: "M3.29951 3.81792c-0.0416496,0.0416496 -0.0416496,0.109185 0,0.150835 0.0416496,0.0416496 0.109185,0.0416496 0.150835,0l0.908051 -0.908051 0.991248 0.991248c0.0416496,0.0416496 0.109185,0.0416496 0.150835,0 0.0416496,-0.0416496 0.0416496,-0.109185 0,-0.150835l-1.06607 -1.06607 -0.000590551 -0.000606299c-0.0416535,-0.0416535 -0.109197,-0.0416535 -0.15085,0l7.87402e-006 7.87402e-006 -0.983469 0.983469z" }), /* @__PURE__ */ React.createElement("path", { id: "_554253280", className: "fil0", d: "M2.14826 2.02666c0.147264,0 0.280602,0.0597008 0.377114,0.15622 0.0965197,0.0965118 0.15622,0.229846 0.15622,0.377114 0,0.147264 -0.0597008,0.280602 -0.15622,0.377114 -0.0965118,0.0965197 -0.22985,0.15622 -0.377114,0.15622 -0.147268,0 -0.280602,-0.0597008 -0.377114,-0.15622 -0.0965197,-0.0965118 -0.15622,-0.22985 -0.15622,-0.377114 0,-0.147268 0.0597008,-0.280602 0.15622,-0.377114 0.0965118,-0.0965197 0.229846,-0.15622 0.377114,-0.15622zm0.22628 0.307055c-0.0578976,-0.0578976 -0.137906,-0.0937165 -0.22628,-0.0937165 -0.088378,0 -0.168382,0.0358189 -0.22628,0.0937165 -0.0578976,0.0578976 -0.0937165,0.137902 -0.0937165,0.22628 0,0.088374 0.0358189,0.168382 0.0937165,0.22628 0.0578976,0.0578976 0.137902,0.0937165 0.22628,0.0937165 0.088374,0 0.168382,-0.0358189 0.22628,-0.0937165 0.0578976,-0.0578976 0.0937165,-0.137906 0.0937165,-0.22628 0,-0.088378 -0.0358189,-0.168382 -0.0937165,-0.22628z" }))));
const SvgResetfilter = (props) => /* @__PURE__ */ React.createElement("svg", { width: 32, height: 32, viewBox: "0 0 32 32", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("path", { d: "M27.49 2H5.49001C5.09203 2.01292 4.71453 2.17949 4.43672 2.46476C4.15891 2.75003 4.00239 3.13182 4.00001 3.53V5.53C3.99855 5.86561 4.10748 6.19239 4.31001 6.46L12.14 16.82C12.699 17.5677 13.0007 18.4764 13 19.41V24.33C13.0006 24.8691 13.1232 25.4011 13.3588 25.886C13.5943 26.371 13.9366 26.7963 14.36 27.13L17.58 29.63C17.846 29.8368 18.1731 29.9493 18.51 29.95C18.743 29.9517 18.9729 29.8968 19.18 29.79C19.4318 29.662 19.6424 29.4655 19.7874 29.2232C19.9325 28.9808 20.0062 28.7024 20 28.42V19.42C19.9971 18.483 20.299 17.5705 20.86 16.82L28.69 6.47C28.8926 6.20239 29.0015 5.87561 29 5.54V3.54C29.0027 3.33955 28.9656 3.14056 28.891 2.95449C28.8165 2.76841 28.7058 2.59893 28.5655 2.45579C28.4251 2.31265 28.2578 2.19869 28.0733 2.12047C27.8887 2.04224 27.6905 2.0013 27.49 2ZM27 5.39L19.27 15.61C18.4449 16.7126 17.9993 18.0529 18 19.43V27.43L15.55 25.54C15.3754 25.3908 15.2357 25.2051 15.1407 24.9961C15.0456 24.787 14.9976 24.5596 15 24.33V19.41C15 18.0422 14.5542 16.7116 13.73 15.62L6.00001 5.39V4H27V5.39Z", fill: "currentColor" }), /* @__PURE__ */ React.createElement("g", { clipPath: "url(#clip0_4_10)" }, /* @__PURE__ */ React.createElement("path", { d: "M23.5863 28L27 24.5863L30.4137 28L32 26.4137L28.5863 23L32 19.5863L30.4137 18L27 21.4137L23.5863 18L22 19.5863L25.4132 23L22 26.4137L23.5863 28Z", fill: "#D32F2F" })), /* @__PURE__ */ React.createElement("defs", null, /* @__PURE__ */ React.createElement("clipPath", { id: "clip0_4_10" }, /* @__PURE__ */ React.createElement("rect", { width: 10, height: 10, fill: "currentColor", transform: "translate(22 18)" }))));
const SvgVideo = (props) => /* @__PURE__ */ React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 64 64", ...props }, /* @__PURE__ */ React.createElement("defs", null, /* @__PURE__ */ React.createElement("style", null, ".cls-1{fill:currentColor;}")), /* @__PURE__ */ React.createElement("title", null, "Time Video Camera"), /* @__PURE__ */ React.createElement("g", { id: "Layer_2", "data-name": "Layer 2" }, /* @__PURE__ */ React.createElement("path", { className: "cls-1", d: "M11.92,52H36.23a7.86,7.86,0,0,0,7.86-7.86V19.89A7.86,7.86,0,0,0,36.23,12H11.92A7.92,7.92,0,0,0,4,19.95V44.05A7.92,7.92,0,0,0,11.92,52ZM24,19.94A12,12,0,1,1,12,32,12,12,0,0,1,24,19.94Z" }), /* @__PURE__ */ React.createElement("path", { className: "cls-1", d: "M56.15,17.89l-6.32,3.24A3.27,3.27,0,0,0,48.06,24V40a3.27,3.27,0,0,0,1.77,2.9l6.32,3.25A2.64,2.64,0,0,0,60,43.76V20.24A2.64,2.64,0,0,0,56.15,17.89Z" }), /* @__PURE__ */ React.createElement("path", { className: "cls-1", d: "M20,37h3.37A2.63,2.63,0,0,0,26,34.37V29a2,2,0,0,0-2.34-2A2.07,2.07,0,0,0,22,29.11v3.15a.74.74,0,0,1-.74.74H20.11A2.07,2.07,0,0,0,18,34.66,2,2,0,0,0,20,37Z" })));
const SvgDeviceManagement = (props) => /* @__PURE__ */ React.createElement("svg", { width: 40, height: 40, viewBox: "0 0 40 40", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("path", { d: "M6.5 9.5H33.5V21C33.5 22.3807 32.3807 23.5 31 23.5H9C7.61929 23.5 6.5 22.3807 6.5 21V9.5Z", stroke: "currentColor", strokeWidth: 3 }), /* @__PURE__ */ React.createElement("rect", { x: 9.5, y: 3.5, width: 21, height: 6, stroke: "currentColor", strokeWidth: 3 }), /* @__PURE__ */ React.createElement("rect", { x: 16.5, y: 23.5, width: 7, height: 13, stroke: "currentColor", strokeWidth: 3 }));
const SvgMachineLearningWorkbench = (props) => /* @__PURE__ */ React.createElement("svg", { width: 40, height: 40, viewBox: "0 0 40 40", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("g", { clipPath: "url(#clip0_2800_40328)" }, /* @__PURE__ */ React.createElement("path", { d: "M29.9998 6.66699H9.99984C8.15889 6.66699 6.6665 8.15938 6.6665 10.0003V30.0003C6.6665 31.8413 8.15889 33.3337 9.99984 33.3337H29.9998C31.8408 33.3337 33.3332 31.8413 33.3332 30.0003V10.0003C33.3332 8.15938 31.8408 6.66699 29.9998 6.66699Z", stroke: "currentColor", strokeWidth: 3, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M25 15H15V25H25V15Z", stroke: "currentColor", strokeWidth: 3, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M15 1.66699V6.66699", stroke: "currentColor", strokeWidth: 3, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M25 1.66699V6.66699", stroke: "currentColor", strokeWidth: 3, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M15 33.333V38.333", stroke: "currentColor", strokeWidth: 3, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M25 33.333V38.333", stroke: "currentColor", strokeWidth: 3, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M33.3335 15H38.3335", stroke: "currentColor", strokeWidth: 3, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M33.3335 23.333H38.3335", stroke: "currentColor", strokeWidth: 3, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M1.6665 15H6.6665", stroke: "currentColor", strokeWidth: 3, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M1.6665 23.333H6.6665", stroke: "currentColor", strokeWidth: 3, strokeLinecap: "round", strokeLinejoin: "round" })), /* @__PURE__ */ React.createElement("defs", null, /* @__PURE__ */ React.createElement("clipPath", { id: "clip0_2800_40328" }, /* @__PURE__ */ React.createElement("rect", { width: 40, height: 40, fill: "white" }))));
const SvgMigrationTool = (props) => /* @__PURE__ */ React.createElement("svg", { width: 40, height: 40, viewBox: "0 0 40 40", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("path", { d: "M26.6668 26.6667L20.0002 20L13.3335 26.6667", stroke: "currentColor", strokeWidth: 3, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M20 20V35", stroke: "currentColor", strokeWidth: 3, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M33.9833 30.6498C35.6088 29.7636 36.893 28.3613 37.6331 26.6642C38.3731 24.9671 38.527 23.0719 38.0703 21.2776C37.6136 19.4834 36.5724 17.8923 35.1111 16.7556C33.6497 15.6188 31.8514 15.001 29.9999 14.9998H27.8999C27.3955 13.0485 26.4552 11.237 25.1498 9.70147C23.8445 8.1659 22.208 6.94623 20.3634 6.13416C18.5189 5.32208 16.5142 4.93874 14.5001 5.01295C12.4861 5.08715 10.515 5.61698 8.73523 6.56259C6.95541 7.5082 5.41312 8.84498 4.2243 10.4724C3.03549 12.0999 2.23108 13.9757 1.87157 15.9588C1.51205 17.9419 1.60678 19.9807 2.14862 21.9219C2.69047 23.8631 3.66534 25.6563 4.99993 27.1665", stroke: "currentColor", strokeWidth: 3, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M26.6668 26.6667L20.0002 20L13.3335 26.6667", stroke: "currentColor", strokeWidth: 3, strokeLinecap: "round", strokeLinejoin: "round" }));
const SvgAdministration = (props) => /* @__PURE__ */ React.createElement("svg", { width: 40, height: 40, viewBox: "0 0 40 40", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("g", { clipPath: "url(#clip0_2800_40352)" }, /* @__PURE__ */ React.createElement("path", { d: "M20 25C22.7614 25 25 22.7614 25 20C25 17.2386 22.7614 15 20 15C17.2386 15 15 17.2386 15 20C15 22.7614 17.2386 25 20 25Z", stroke: "currentColor", strokeWidth: 3, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M32.3332 25.0003C32.1113 25.503 32.0451 26.0606 32.1432 26.6013C32.2412 27.142 32.4989 27.6409 32.8832 28.0337L32.9832 28.1337C33.2931 28.4432 33.539 28.8109 33.7067 29.2155C33.8744 29.6202 33.9608 30.0539 33.9608 30.492C33.9608 30.93 33.8744 31.3638 33.7067 31.7685C33.539 32.1731 33.2931 32.5407 32.9832 32.8503C32.6736 33.1602 32.306 33.4061 31.9013 33.5739C31.4966 33.7416 31.0629 33.8279 30.6248 33.8279C30.1868 33.8279 29.753 33.7416 29.3484 33.5739C28.9437 33.4061 28.5761 33.1602 28.2665 32.8503L28.1665 32.7503C27.7737 32.3661 27.2748 32.1083 26.7341 32.0103C26.1935 31.9123 25.6359 31.9785 25.1332 32.2003C24.6402 32.4116 24.2198 32.7624 23.9237 33.2095C23.6276 33.6567 23.4686 34.1807 23.4665 34.717V35.0003C23.4665 35.8844 23.1153 36.7322 22.4902 37.3573C21.8651 37.9825 21.0172 38.3337 20.1332 38.3337C19.2491 38.3337 18.4013 37.9825 17.7761 37.3573C17.151 36.7322 16.7998 35.8844 16.7998 35.0003V34.8503C16.7869 34.2987 16.6084 33.7636 16.2874 33.3148C15.9663 32.866 15.5177 32.5241 14.9998 32.3337C14.4971 32.1118 13.9395 32.0456 13.3989 32.1436C12.8582 32.2417 12.3593 32.4994 11.9665 32.8837L11.8665 32.9837C11.5569 33.2936 11.1893 33.5394 10.7846 33.7072C10.38 33.8749 9.94622 33.9613 9.50817 33.9613C9.07012 33.9613 8.63636 33.8749 8.2317 33.7072C7.82704 33.5394 7.45941 33.2936 7.14984 32.9837C6.83992 32.6741 6.59405 32.3065 6.4263 31.9018C6.25856 31.4971 6.17221 31.0634 6.17221 30.6253C6.17221 30.1873 6.25856 29.7535 6.4263 29.3489C6.59405 28.9442 6.83992 28.5766 7.14984 28.267L7.24984 28.167C7.63406 27.7742 7.89181 27.2753 7.98984 26.7346C8.08788 26.194 8.02169 25.6363 7.79984 25.1337C7.58856 24.6407 7.23776 24.2203 6.79061 23.9242C6.34346 23.628 5.81948 23.4691 5.28317 23.467H4.99984C4.11578 23.467 3.26794 23.1158 2.64281 22.4907C2.01769 21.8656 1.6665 21.0177 1.6665 20.1337C1.6665 19.2496 2.01769 18.4018 2.64281 17.7766C3.26794 17.1515 4.11578 16.8003 4.99984 16.8003H5.14984C5.70149 16.7874 6.23651 16.6089 6.68534 16.2878C7.13416 15.9668 7.47603 15.5182 7.6665 15.0003C7.88836 14.4976 7.95454 13.94 7.85651 13.3993C7.75848 12.8587 7.50073 12.3598 7.1165 11.967L7.0165 11.867C6.70658 11.5574 6.46072 11.1898 6.29297 10.7851C6.12522 10.3805 6.03888 9.94671 6.03888 9.50866C6.03888 9.07061 6.12522 8.63685 6.29297 8.23219C6.46072 7.82753 6.70658 7.4599 7.0165 7.15032C7.32608 6.8404 7.69371 6.59454 8.09837 6.42679C8.50303 6.25904 8.93678 6.1727 9.37484 6.1727C9.81289 6.1727 10.2466 6.25904 10.6513 6.42679C11.056 6.59454 11.4236 6.8404 11.7332 7.15032L11.8332 7.25032C12.226 7.63455 12.7249 7.8923 13.2655 7.99033C13.8062 8.08836 14.3638 8.02218 14.8665 7.80032H14.9998C15.4928 7.58905 15.9132 7.23825 16.2093 6.7911C16.5054 6.34395 16.6644 5.81997 16.6665 5.28366V5.00033C16.6665 4.11627 17.0177 3.26842 17.6428 2.6433C18.2679 2.01818 19.1158 1.66699 19.9998 1.66699C20.8839 1.66699 21.7317 2.01818 22.3569 2.6433C22.982 3.26842 23.3332 4.11627 23.3332 5.00033V5.15033C23.3353 5.68664 23.4942 6.21062 23.7903 6.65777C24.0865 7.10492 24.5069 7.45572 24.9998 7.66699C25.5025 7.88885 26.0602 7.95503 26.6008 7.857C27.1415 7.75897 27.6404 7.50122 28.0332 7.11699L28.1332 7.01699C28.4427 6.70707 28.8104 6.46121 29.215 6.29346C29.6197 6.12571 30.0534 6.03937 30.4915 6.03937C30.9296 6.03937 31.3633 6.12571 31.768 6.29346C32.1726 6.46121 32.5403 6.70707 32.8498 7.01699C33.1598 7.32657 33.4056 7.6942 33.5734 8.09886C33.7411 8.50352 33.8275 8.93727 33.8275 9.37532C33.8275 9.81338 33.7411 10.2471 33.5734 10.6518C33.4056 11.0565 33.1598 11.4241 32.8498 11.7337L32.7498 11.8337C32.3656 12.2265 32.1079 12.7254 32.0098 13.266C31.9118 13.8067 31.978 14.3643 32.1998 14.867V15.0003C32.4111 15.4933 32.7619 15.9137 33.2091 16.2098C33.6562 16.5059 34.1802 16.6649 34.7165 16.667H34.9998C35.8839 16.667 36.7317 17.0182 37.3569 17.6433C37.982 18.2684 38.3332 19.1163 38.3332 20.0003C38.3332 20.8844 37.982 21.7322 37.3569 22.3573C36.7317 22.9825 35.8839 23.3337 34.9998 23.3337H34.8498C34.3135 23.3358 33.7895 23.4947 33.3424 23.7908C32.8952 24.087 32.5444 24.5074 32.3332 25.0003V25.0003Z", stroke: "currentColor", strokeWidth: 3, strokeLinecap: "round", strokeLinejoin: "round" })), /* @__PURE__ */ React.createElement("defs", null, /* @__PURE__ */ React.createElement("clipPath", { id: "clip0_2800_40352" }, /* @__PURE__ */ React.createElement("rect", { width: 40, height: 40, fill: "white" }))));
const SvgAdvancedSimulators = (props) => /* @__PURE__ */ React.createElement("svg", { width: 40, height: 40, viewBox: "0 0 40 40", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("path", { d: "M33.1835 25.8497H25.6335C25.1915 25.8497 24.7675 26.0253 24.455 26.3378C24.1424 26.6504 23.9668 27.0743 23.9668 27.5163C23.9668 27.9584 24.1424 28.3823 24.455 28.6949C24.7675 29.0074 25.1915 29.183 25.6335 29.183H29.6335C27.7951 31.1042 25.4242 32.4319 22.8254 32.9953C20.2267 33.5588 17.5188 33.3323 15.0498 32.3451C12.5807 31.3578 10.4633 29.6548 8.96948 27.455C7.47568 25.2551 6.67379 22.6588 6.66683 19.9997C6.66683 19.5576 6.49124 19.1337 6.17867 18.8212C5.86611 18.5086 5.44219 18.333 5.00016 18.333C4.55814 18.333 4.13421 18.5086 3.82165 18.8212C3.50909 19.1337 3.3335 19.5576 3.3335 19.9997C3.34231 23.2543 4.30386 26.4352 6.0995 29.1497C7.89514 31.8642 10.4463 33.9936 13.4381 35.275C16.4299 36.5565 19.7314 36.9339 22.9352 36.3607C26.139 35.7876 29.1049 34.2889 31.4668 32.0497V34.9997C31.4668 35.4417 31.6424 35.8656 31.955 36.1782C32.2675 36.4907 32.6915 36.6663 33.1335 36.6663C33.5755 36.6663 33.9994 36.4907 34.312 36.1782C34.6246 35.8656 34.8002 35.4417 34.8002 34.9997V27.4997C34.796 27.0691 34.6254 26.6568 34.324 26.3492C34.0227 26.0416 33.6139 25.8626 33.1835 25.8497ZM25.0002 19.9997C25.0002 19.0108 24.7069 18.0441 24.1575 17.2218C23.6081 16.3996 22.8272 15.7587 21.9136 15.3803C21 15.0018 19.9946 14.9028 19.0247 15.0957C18.0548 15.2887 17.1639 15.7649 16.4646 16.4641C15.7654 17.1634 15.2892 18.0543 15.0962 19.0242C14.9033 19.9941 15.0023 20.9995 15.3808 21.9131C15.7592 22.8267 16.4001 23.6076 17.2223 24.157C18.0446 24.7064 19.0113 24.9997 20.0002 24.9997C21.3262 24.9997 22.598 24.4729 23.5357 23.5352C24.4734 22.5975 25.0002 21.3258 25.0002 19.9997ZM18.3335 19.9997C18.3335 19.67 18.4312 19.3478 18.6144 19.0737C18.7975 18.7996 19.0578 18.586 19.3624 18.4599C19.6669 18.3337 20.002 18.3007 20.3253 18.365C20.6486 18.4293 20.9456 18.5881 21.1787 18.8212C21.4118 19.0543 21.5705 19.3512 21.6348 19.6745C21.6991 19.9978 21.6661 20.3329 21.54 20.6375C21.4138 20.942 21.2002 21.2023 20.9261 21.3855C20.652 21.5686 20.3298 21.6663 20.0002 21.6663C19.5581 21.6663 19.1342 21.4907 18.8217 21.1782C18.5091 20.8656 18.3335 20.4417 18.3335 19.9997ZM20.0002 3.33301C15.7275 3.34519 11.6226 4.99786 8.5335 7.94967V4.99967C8.5335 4.55765 8.3579 4.13372 8.04534 3.82116C7.73278 3.5086 7.30886 3.33301 6.86683 3.33301C6.4248 3.33301 6.00088 3.5086 5.68832 3.82116C5.37576 4.13372 5.20016 4.55765 5.20016 4.99967V12.4997C5.20016 12.9417 5.37576 13.3656 5.68832 13.6782C6.00088 13.9907 6.4248 14.1663 6.86683 14.1663H14.3668C14.8089 14.1663 15.2328 13.9907 15.5453 13.6782C15.8579 13.3656 16.0335 12.9417 16.0335 12.4997C16.0335 12.0576 15.8579 11.6337 15.5453 11.3212C15.2328 11.0086 14.8089 10.833 14.3668 10.833H10.3668C12.2043 8.91279 14.5736 7.58551 17.1708 7.02152C19.768 6.45754 22.4745 6.68258 24.9428 7.66778C27.4112 8.65297 29.5288 10.3534 31.0239 12.5507C32.5189 14.748 33.3232 17.342 33.3335 19.9997C33.3335 20.4417 33.5091 20.8656 33.8217 21.1782C34.1342 21.4907 34.5581 21.6663 35.0002 21.6663C35.4422 21.6663 35.8661 21.4907 36.1787 21.1782C36.4912 20.8656 36.6668 20.4417 36.6668 19.9997C36.6668 17.811 36.2357 15.6437 35.3982 13.6216C34.5606 11.5995 33.3329 9.7622 31.7853 8.21456C30.2376 6.66692 28.4003 5.43926 26.3782 4.60168C24.3561 3.7641 22.1889 3.33301 20.0002 3.33301Z", fill: "currentColor" }));
const SvgCockpit = (props) => /* @__PURE__ */ React.createElement("svg", { width: 40, height: 40, viewBox: "0 0 40 40", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("circle", { cx: 20, cy: 20, r: 16.5, stroke: "currentColor", strokeWidth: 3 }), /* @__PURE__ */ React.createElement("circle", { cx: 20.0004, cy: 25.4008, r: 2.1, stroke: "currentColor", strokeWidth: 3 }), /* @__PURE__ */ React.createElement("path", { d: "M20 22.7008V10.5508", stroke: "currentColor", strokeWidth: 3, strokeLinecap: "round" }));
const SvgInfo = (props) => /* @__PURE__ */ React.createElement("svg", { width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("g", { clipPath: "url(#clip0_2800_39597)" }, /* @__PURE__ */ React.createElement("path", { d: "M8.00004 14.6663C11.6819 14.6663 14.6667 11.6816 14.6667 7.99967C14.6667 4.31778 11.6819 1.33301 8.00004 1.33301C4.31814 1.33301 1.33337 4.31778 1.33337 7.99967C1.33337 11.6816 4.31814 14.6663 8.00004 14.6663Z", stroke: "#999999", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M8 10.6667V8", stroke: "#999999", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ React.createElement("path", { d: "M8 5.33301H8.00667", stroke: "#999999", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" })), /* @__PURE__ */ React.createElement("defs", null, /* @__PURE__ */ React.createElement("clipPath", { id: "clip0_2800_39597" }, /* @__PURE__ */ React.createElement("rect", { width: 16, height: 16, fill: "white" }))));
const SvgCircle = (props) => /* @__PURE__ */ React.createElement("svg", { width: 16, height: 16, viewBox: "0 0 16 16", stroke: "inherit", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ React.createElement("g", null, /* @__PURE__ */ React.createElement("path", { d: "M8.00004 14.6663C11.6819 14.6663 14.6667 11.6816 14.6667 7.99967C14.6667 4.31778 11.6819 1.33301 8.00004 1.33301C4.31814 1.33301 1.33337 4.31778 1.33337 7.99967C1.33337 11.6816 4.31814 14.6663 8.00004 14.6663Z", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" })));
const DataMenu = ({
  dataType,
  onDelete,
  currentData,
  index: index2,
  datapointLibraries,
  saveDatapointLibrary,
  loadDatapointLibrary,
  loadedDatapoint,
  updateDatapointLibrary
}) => {
  const { t: t2 } = useTranslation();
  const matchedDatapointLibraries = useMemo(
    () => datapointLibraries == null ? void 0 : datapointLibraries.filter(
      ({ c8y_Kpi, source: source2 }) => {
        var _a;
        return c8y_Kpi.fragment === ((_a = currentData.__original) == null ? void 0 : _a.fragment) && c8y_Kpi.series === currentData.series && source2 === currentData.__target.id;
      }
    ),
    [datapointLibraries, currentData]
  );
  const saveOrUpdate = () => {
    if (loadedDatapoint) {
      updateDatapointLibrary({
        loadedDatapoint,
        currentData
      });
    } else {
      saveDatapointLibrary({ currentData });
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(DropdownMenu, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      DropdownMenuTrigger,
      {
        asChild: true,
        className: "flex h-9 items-center justify-center",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button$1,
          {
            title: t2("expand"),
            size: "icon",
            type: "button",
            variant: "ghost",
            className: "mx-1 w-12 gap-x-0 fill-grayscale-300 dark:fill-grayscale-600",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(SvgMoreVertical, { className: "text-grayscale-300 dark:text-dark-grayscale-200" })
          }
        )
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(DropdownMenuContent, { className: "absolute right-0 min-w-max dark:border-dark-grayscale-500 dark:bg-dark-bg-333", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        DropdownMenuItem,
        {
          className: "dlt-c8y-icon-minus-circle hover:bg-grayscale-500/80",
          onSelect: () => onDelete(currentData.series, index2),
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "ml-2", children: t2("remove from list") })
        }
      ),
      dataType === "datapoints" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        matchedDatapointLibraries == null ? void 0 : matchedDatapointLibraries.map((datapointLibrary) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          DropdownMenuItem,
          {
            className: "dlt-c8y-icon-floppy-o hover:bg-grayscale-500/80",
            onSelect: () => loadDatapointLibrary(datapointLibrary),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "ml-2", children: t2("load from library", {
              label: datapointLibrary.c8y_Kpi.label
            }) })
          },
          datapointLibrary.id
        )),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          DropdownMenuItem,
          {
            className: "dlt-c8y-icon-floppy-o hover:bg-grayscale-500/80",
            onSelect: saveOrUpdate,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "ml-2", children: loadedDatapoint ? t2("update in library", {
              label: loadedDatapoint.c8y_Kpi.label
            }) : t2("save to library") })
          }
        )
      ] })
    ] })
  ] });
};
const alarmSchema = {
  id: "c8ySchema",
  title: "Alarms",
  type: "object",
  printFormat: "hidden",
  properties: {
    id: {
      title: "ID",
      type: "string",
      readonly: true
    },
    creationTime: {
      title: "Creation time",
      type: "string",
      format: "datetime"
    },
    type: {
      title: "Type",
      type: "string"
    },
    time: {
      title: "Time",
      type: "string",
      format: "datetime"
    },
    text: {
      title: "Text",
      type: "string"
    },
    status: {
      title: "Status",
      type: "string",
      enum: ["ACTIVE", "ACKNOWLEDGED", "CLEARED"]
    },
    severity: {
      title: "Severity",
      type: "string",
      enum: ["CRITICAL", "MAJOR", "MINOR", "WARNING"]
    },
    source: {
      title: "Source",
      type: "integer"
    },
    count: {
      title: "Reoccurrence count",
      type: "number"
    },
    DEVICE_NAME: {
      title: "Device name",
      type: "String"
    }
  }
};
const alarmStatusIcon = {
  ACTIVE: "dlt-c8y-icon-bell",
  ACKNOWLEDGED: "dlt-c8y-icon-bell-slash",
  DEFAULT: "c8y-icon c8y-icon-alert-idle"
};
const alarmSeverityIcon = {
  CRITICAL: "status stroked-icon dlt-c8y-icon-exclamation-circle critical text-red-500",
  MAJOR: "status stroked-icon dlt-c8y-icon-warning major text-orange-500",
  MINOR: "status stroked-icon dlt-c8y-icon-high-priority minor text-yellow-500",
  DEFAULT: "status stroked-icon dlt-c8y-icon-circle warning text-blue-500"
};
const chartDisplayOptions = [
  { name: "min", value: "min" },
  { name: "max", value: "max" }
];
const chartTypeOptions = {
  Line: "line",
  // Points: 'point',
  Bars: "bar"
  // 'Step before': 'step before',
  // 'Step after': 'step after',
};
const yAxisPositionOptions = [
  { name: "auto", value: "auto" },
  { name: "left", value: "left" },
  { name: "right", value: "right" }
];
const eventSchema = {
  id: "c8ySchema",
  title: "Events",
  type: "object",
  printFormat: "hidden",
  properties: {
    id: {
      title: "ID",
      type: "string",
      readonly: true
    },
    creationTime: {
      title: "Creation time",
      type: "string",
      format: "datetime"
    },
    type: {
      title: "Type",
      type: "string"
    },
    time: {
      title: "Time",
      type: "string",
      format: "datetime"
    },
    text: {
      title: "Text",
      type: "string"
    },
    source: {
      title: "Source",
      type: "integer"
    },
    DEVICE_NAME: {
      title: "Device name",
      type: "String"
    }
  }
};
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys2 = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys2.push(key);
      }
    }
    return keys2;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value2) => {
    if (typeof value2 === "bigint") {
      return value2.toString();
    }
    return value2;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second2) => {
    return {
      ...first,
      ...second2
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
const ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
const getParsedType = (data) => {
  const t2 = typeof data;
  switch (t2) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
const ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
const quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
class ZodError extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error2) => {
      for (const issue of error2.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i2 = 0;
          while (i2 < issue.path.length) {
            const el = issue.path[i2];
            const terminal = i2 === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i2++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value2) {
    if (!(value2 instanceof ZodError)) {
      throw new Error(`Not a ZodError: ${value2}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (issues) => {
  const error2 = new ZodError(issues);
  return error2;
};
const errorMap = (issue, _ctx) => {
  let message2;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message2 = "Required";
      } else {
        message2 = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message2 = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message2 = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message2 = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message2 = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message2 = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message2 = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message2 = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message2 = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message2 = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message2 = `${message2} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message2 = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message2 = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message2 = `Invalid ${issue.validation}`;
      } else {
        message2 = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message2 = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message2 = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message2 = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message2 = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message2 = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message2 = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message2 = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message2 = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message2 = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message2 = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message2 = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message2 = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message2 = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message2 = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message2 = "Number must be finite";
      break;
    default:
      message2 = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message: message2 };
};
let overrideErrorMap = errorMap;
function setErrorMap(map2) {
  overrideErrorMap = map2;
}
function getErrorMap() {
  return overrideErrorMap;
}
const makeIssue = (params) => {
  const { data, path: path2, errorMaps, issueData } = params;
  const fullPath = [...path2, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map2 of maps) {
    errorMessage = map2(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
const EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === errorMap ? void 0 : errorMap
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status2, results) {
    const arrayValue = [];
    for (const s2 of results) {
      if (s2.status === "aborted")
        return INVALID;
      if (s2.status === "dirty")
        status2.dirty();
      arrayValue.push(s2.value);
    }
    return { status: status2.value, value: arrayValue };
  }
  static async mergeObjectAsync(status2, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value2 = await pair.value;
      syncPairs.push({
        key,
        value: value2
      });
    }
    return ParseStatus.mergeObjectSync(status2, syncPairs);
  }
  static mergeObjectSync(status2, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value: value2 } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value2.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status2.dirty();
      if (value2.status === "dirty")
        status2.dirty();
      if (key.value !== "__proto__" && (typeof value2.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value2.value;
      }
    }
    return { status: status2.value, value: finalObject };
  }
}
const INVALID = Object.freeze({
  status: "aborted"
});
const DIRTY = (value2) => ({ status: "dirty", value: value2 });
const OK = (value2) => ({ status: "valid", value: value2 });
const isAborted = (x) => x.status === "aborted";
const isDirty = (x) => x.status === "dirty";
const isValid = (x) => x.status === "valid";
const isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value2, kind, f) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return state.set(receiver, value2), value2;
}
typeof SuppressedError === "function" ? SuppressedError : function(error2, suppressed, message2) {
  var e = new Error(message2);
  return e.name = "SuppressedError", e.error = error2, e.suppressed = suppressed, e;
};
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message2) => typeof message2 === "string" ? { message: message2 } : message2 || {};
  errorUtil2.toString = (message2) => typeof message2 === "string" ? message2 : message2 === null || message2 === void 0 ? void 0 : message2.message;
})(errorUtil || (errorUtil = {}));
var _ZodEnum_cache, _ZodNativeEnum_cache;
class ParseInputLazyPath {
  constructor(parent, value2, path2, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value2;
    this._path = path2;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
const handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error2 = new ZodError(ctx.common.issues);
        this._error = error2;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description: description2 } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description: description2 };
  const customMap = (iss, ctx) => {
    var _a, _b;
    const { message: message2 } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message2 !== null && message2 !== void 0 ? message2 : ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: (_a = message2 !== null && message2 !== void 0 ? message2 : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: (_b = message2 !== null && message2 !== void 0 ? message2 : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };
  };
  return { errorMap: customMap, description: description2 };
}
class ZodType {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    var _a, _b;
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if ((_b = (_a = err === null || err === void 0 ? void 0 : err.message) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message2) {
    const getIssueProperties = (val) => {
      if (typeof message2 === "string" || typeof message2 === "undefined") {
        return { message: message2 };
      } else if (typeof message2 === "function") {
        return message2(val);
      } else {
        return message2;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description2) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description: description2
    });
  }
  pipe(target2) {
    return ZodPipeline.create(this, target2);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[0-9a-z]+$/;
const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex = /^[a-z0-9_-]{21}$/i;
const jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
const durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex;
const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
const ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
const ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
const base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
const dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
  if (args.precision) {
    regex = `${regex}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    regex = `${regex}(\\.\\d+)?`;
  }
  return regex;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip2, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex.test(ip2)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex.test(ip2)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if (!decoded.typ || !decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch (_a) {
    return false;
  }
}
function isValidCidr(ip2, version2) {
  if ((version2 === "v4" || !version2) && ipv4CidrRegex.test(ip2)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6CidrRegex.test(ip2)) {
    return true;
  }
  return false;
}
class ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status2 = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status2.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status2.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status2.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status2.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status2.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status2.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status2.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status2.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status2.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status2.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status2.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status2.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status2.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status2.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status2.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status2.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status2.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status2.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status2.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status2.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "jwt",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status2.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cidr",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status2.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status2.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status2.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status2.value, value: input.data };
  }
  _regex(regex, validation, message2) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message2)
    });
  }
  _addCheck(check) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message2) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message2) });
  }
  url(message2) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message2) });
  }
  emoji(message2) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message2) });
  }
  uuid(message2) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message2) });
  }
  nanoid(message2) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message2) });
  }
  cuid(message2) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message2) });
  }
  cuid2(message2) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message2) });
  }
  ulid(message2) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message2) });
  }
  base64(message2) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message2) });
  }
  base64url(message2) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message2)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a, _b;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
      local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  date(message2) {
    return this._addCheck({ kind: "date", message: message2 });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  duration(message2) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message2) });
  }
  regex(regex, message2) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message2)
    });
  }
  includes(value2, options) {
    return this._addCheck({
      kind: "includes",
      value: value2,
      position: options === null || options === void 0 ? void 0 : options.position,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  startsWith(value2, message2) {
    return this._addCheck({
      kind: "startsWith",
      value: value2,
      ...errorUtil.errToObj(message2)
    });
  }
  endsWith(value2, message2) {
    return this._addCheck({
      kind: "endsWith",
      value: value2,
      ...errorUtil.errToObj(message2)
    });
  }
  min(minLength, message2) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message2)
    });
  }
  max(maxLength, message2) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message2)
    });
  }
  length(len, message2) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message2)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message2) {
    return this.min(1, errorUtil.errToObj(message2));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2;
  }
  get maxLength() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2;
  }
}
ZodString.create = (params) => {
  var _a;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
class ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status2 = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status2.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status2.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status2.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status2.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status2.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status2.value, value: input.data };
  }
  gte(value2, message2) {
    return this.setLimit("min", value2, true, errorUtil.toString(message2));
  }
  gt(value2, message2) {
    return this.setLimit("min", value2, false, errorUtil.toString(message2));
  }
  lte(value2, message2) {
    return this.setLimit("max", value2, true, errorUtil.toString(message2));
  }
  lt(value2, message2) {
    return this.setLimit("max", value2, false, errorUtil.toString(message2));
  }
  setLimit(kind, value2, inclusive, message2) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value: value2,
          inclusive,
          message: errorUtil.toString(message2)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message2) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message2)
    });
  }
  positive(message2) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message2)
    });
  }
  negative(message2) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message2)
    });
  }
  nonpositive(message2) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message2)
    });
  }
  nonnegative(message2) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message2)
    });
  }
  multipleOf(value2, message2) {
    return this._addCheck({
      kind: "multipleOf",
      value: value2,
      message: errorUtil.toString(message2)
    });
  }
  finite(message2) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message2)
    });
  }
  safe(message2) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message2)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message2)
    });
  }
  get minValue() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2;
  }
  get maxValue() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max2 = null, min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      } else if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return Number.isFinite(min2) && Number.isFinite(max2);
  }
}
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch (_a) {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status2 = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status2.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status2.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status2.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status2.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    });
    return INVALID;
  }
  gte(value2, message2) {
    return this.setLimit("min", value2, true, errorUtil.toString(message2));
  }
  gt(value2, message2) {
    return this.setLimit("min", value2, false, errorUtil.toString(message2));
  }
  lte(value2, message2) {
    return this.setLimit("max", value2, true, errorUtil.toString(message2));
  }
  lt(value2, message2) {
    return this.setLimit("max", value2, false, errorUtil.toString(message2));
  }
  setLimit(kind, value2, inclusive, message2) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value: value2,
          inclusive,
          message: errorUtil.toString(message2)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message2) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message2)
    });
  }
  negative(message2) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message2)
    });
  }
  nonpositive(message2) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message2)
    });
  }
  nonnegative(message2) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message2)
    });
  }
  multipleOf(value2, message2) {
    return this._addCheck({
      kind: "multipleOf",
      value: value2,
      message: errorUtil.toString(message2)
    });
  }
  get minValue() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2;
  }
  get maxValue() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2;
  }
}
ZodBigInt.create = (params) => {
  var _a;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
class ZodBoolean extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
class ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status2 = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status2.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status2.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status2.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message2) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message2)
    });
  }
  max(maxDate, message2) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message2)
    });
  }
  get minDate() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2 != null ? new Date(min2) : null;
  }
  get maxDate() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2 != null ? new Date(max2) : null;
  }
}
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
class ZodSymbol extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
class ZodUndefined extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
class ZodNull extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
class ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
class ZodNever extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
}
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
class ZodVoid extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
class ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status: status2 } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status2.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status2.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status2.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i2) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
      })).then((result2) => {
        return ParseStatus.mergeArray(status2, result2);
      });
    }
    const result = [...ctx.data].map((item, i2) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
    });
    return ParseStatus.mergeArray(status2, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message2) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message2) }
    });
  }
  max(maxLength, message2) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message2) }
    });
  }
  length(len, message2) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message2) }
    });
  }
  nonempty(message2) {
    return this.min(1, message2);
  }
}
ZodArray.create = (schema2, params) => {
  return new ZodArray({
    type: schema2,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema2) {
  if (schema2 instanceof ZodObject) {
    const newShape = {};
    for (const key in schema2.shape) {
      const fieldSchema = schema2.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema2._def,
      shape: () => newShape
    });
  } else if (schema2 instanceof ZodArray) {
    return new ZodArray({
      ...schema2._def,
      type: deepPartialify(schema2.element)
    });
  } else if (schema2 instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema2.unwrap()));
  } else if (schema2 instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema2.unwrap()));
  } else if (schema2 instanceof ZodTuple) {
    return ZodTuple.create(schema2.items.map((item) => deepPartialify(item)));
  } else {
    return schema2;
  }
}
class ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys2 = util.objectKeys(shape);
    return this._cached = { shape, keys: keys2 };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status: status2, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value2 = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value2, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status2.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value2 = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value2, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value2 = await pair.value;
          syncPairs.push({
            key,
            value: value2,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status2, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status2, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message2) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message2 !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message2).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema2) {
    return this.augment({ [key]: schema2 });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index2) {
    return new ZodObject({
      ...this._def,
      catchall: index2
    });
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
}
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
class ZodUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
const getDiscriminator = (type2) => {
  if (type2 instanceof ZodLazy) {
    return getDiscriminator(type2.schema);
  } else if (type2 instanceof ZodEffects) {
    return getDiscriminator(type2.innerType());
  } else if (type2 instanceof ZodLiteral) {
    return [type2.value];
  } else if (type2 instanceof ZodEnum) {
    return type2.options;
  } else if (type2 instanceof ZodNativeEnum) {
    return util.objectValues(type2.enum);
  } else if (type2 instanceof ZodDefault) {
    return getDiscriminator(type2._def.innerType);
  } else if (type2 instanceof ZodUndefined) {
    return [void 0];
  } else if (type2 instanceof ZodNull) {
    return [null];
  } else if (type2 instanceof ZodOptional) {
    return [void 0, ...getDiscriminator(type2.unwrap())];
  } else if (type2 instanceof ZodNullable) {
    return [null, ...getDiscriminator(type2.unwrap())];
  } else if (type2 instanceof ZodBranded) {
    return getDiscriminator(type2.unwrap());
  } else if (type2 instanceof ZodReadonly) {
    return getDiscriminator(type2.unwrap());
  } else if (type2 instanceof ZodCatch) {
    return getDiscriminator(type2._def.innerType);
  } else {
    return [];
  }
};
class ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type2 of options) {
      const discriminatorValues = getDiscriminator(type2.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value2 of discriminatorValues) {
        if (optionsMap.has(value2)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value2)}`);
        }
        optionsMap.set(value2, type2);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
}
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index2 = 0; index2 < a.length; index2++) {
      const itemA = a[index2];
      const itemB = b[index2];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
class ZodIntersection extends ZodType {
  _parse(input) {
    const { status: status2, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status2.dirty();
      }
      return { status: status2.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left2, right2]) => handleParsed(left2, right2));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
}
ZodIntersection.create = (left2, right2, params) => {
  return new ZodIntersection({
    left: left2,
    right: right2,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
class ZodTuple extends ZodType {
  _parse(input) {
    const { status: status2, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status2.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema2 = this._def.items[itemIndex] || this._def.rest;
      if (!schema2)
        return null;
      return schema2._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status2, results);
      });
    } else {
      return ParseStatus.mergeArray(status2, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
}
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
class ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status: status2, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status2, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status2, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second2, third) {
    if (second2 instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second2,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second2)
    });
  }
}
class ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status: status2, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value2], index2) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index2, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value2, ctx.path, [index2, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value2 = await pair.value;
          if (key.status === "aborted" || value2.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value2.status === "dirty") {
            status2.dirty();
          }
          finalMap.set(key.value, value2.value);
        }
        return { status: status2.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value2 = pair.value;
        if (key.status === "aborted" || value2.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value2.status === "dirty") {
          status2.dirty();
        }
        finalMap.set(key.value, value2.value);
      }
      return { status: status2.value, value: finalMap };
    }
  }
}
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
class ZodSet extends ZodType {
  _parse(input) {
    const { status: status2, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status2.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status2.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status2.dirty();
        parsedSet.add(element.value);
      }
      return { status: status2.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i2) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i2)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message2) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message2) }
    });
  }
  max(maxSize, message2) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message2) }
    });
  }
  size(size2, message2) {
    return this.min(size2, message2).max(size2, message2);
  }
  nonempty(message2) {
    return this.min(1, message2);
  }
}
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
class ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error2) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error2
        }
      });
    }
    function makeReturnsIssue(returns, error2) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error2
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error2 = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error2.addIssue(makeArgsIssue(args, e));
          throw error2;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error2.addIssue(makeReturnsIssue(result, e));
          throw error2;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
}
class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
class ZodLiteral extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (value2, params) => {
  return new ZodLiteral({
    value: value2,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
class ZodEnum extends ZodType {
  constructor() {
    super(...arguments);
    _ZodEnum_cache.set(this, void 0);
  }
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache)) {
      __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values));
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache).has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
}
_ZodEnum_cache = /* @__PURE__ */ new WeakMap();
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
  constructor() {
    super(...arguments);
    _ZodNativeEnum_cache.set(this, void 0);
  }
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache)) {
      __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)));
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache).has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
_ZodNativeEnum_cache = /* @__PURE__ */ new WeakMap();
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise.create = (schema2, params) => {
  return new ZodPromise({
    type: schema2,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status: status2, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status2.abort();
        } else {
          status2.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status2.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status2.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status2.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status2.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status2.dirty();
        executeRefinement(inner.value);
        return { status: status2.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status2.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status2.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status2.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status2.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
}
ZodEffects.create = (schema2, effect, params) => {
  return new ZodEffects({
    schema: schema2,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema2, params) => {
  return new ZodEffects({
    schema: schema2,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
class ZodOptional extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (type2, params) => {
  return new ZodOptional({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
class ZodNullable extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (type2, params) => {
  return new ZodNullable({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
class ZodDefault extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (type2, params) => {
  return new ZodDefault({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
class ZodCatch extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (type2, params) => {
  return new ZodCatch({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
class ZodNaN extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
const BRAND = Symbol("zod_brand");
class ZodBranded extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class ZodPipeline extends ZodType {
  _parse(input) {
    const { status: status2, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status2.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status2.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}
class ZodReadonly extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodReadonly.create = (type2, params) => {
  return new ZodReadonly({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
function custom$2(check, params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a, _b;
      if (!check(data)) {
        const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
        const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
        const p2 = typeof p === "string" ? { message: p } : p;
        ctx.addIssue({ code: "custom", ...p2, fatal: _fatal });
      }
    });
  return ZodAny.create();
}
const late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
const instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom$2((data) => data instanceof cls, params);
const stringType = ZodString.create;
const numberType = ZodNumber.create;
const nanType = ZodNaN.create;
const bigIntType = ZodBigInt.create;
const booleanType = ZodBoolean.create;
const dateType = ZodDate.create;
const symbolType = ZodSymbol.create;
const undefinedType = ZodUndefined.create;
const nullType = ZodNull.create;
const anyType = ZodAny.create;
const unknownType = ZodUnknown.create;
const neverType = ZodNever.create;
const voidType = ZodVoid.create;
const arrayType = ZodArray.create;
const objectType = ZodObject.create;
const strictObjectType = ZodObject.strictCreate;
const unionType = ZodUnion.create;
const discriminatedUnionType = ZodDiscriminatedUnion.create;
const intersectionType = ZodIntersection.create;
const tupleType = ZodTuple.create;
const recordType = ZodRecord.create;
const mapType = ZodMap.create;
const setType = ZodSet.create;
const functionType = ZodFunction.create;
const lazyType = ZodLazy.create;
const literalType = ZodLiteral.create;
const enumType = ZodEnum.create;
const nativeEnumType = ZodNativeEnum.create;
const promiseType = ZodPromise.create;
const effectsType = ZodEffects.create;
const optionalType = ZodOptional.create;
const nullableType = ZodNullable.create;
const preprocessType = ZodEffects.createWithPreprocess;
const pipelineType = ZodPipeline.create;
const ostring = () => stringType().optional();
const onumber = () => numberType().optional();
const oboolean = () => booleanType().optional();
const coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
const NEVER = INVALID;
var z = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  datetimeRegex,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom: custom$2,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});
const fonts = [
  "SUIT-regular",
  "auto",
  "BlackHanSans",
  "cursive",
  "fantasy",
  "monospace",
  "NanumGothic",
  "NotoSans",
  "Roboto",
  "serif",
  "SongMyung"
];
const fontWeights = {
  light: "100",
  normal: "400",
  bold: "700"
};
const fontSchema = z.enum([
  "SUIT-regular",
  "auto",
  "BlackHanSans",
  "cursive",
  "fantasy",
  "monospace",
  "NanumGothic",
  "NotoSans",
  "Roboto",
  "serif",
  "SongMyung"
]);
const fontWeightSchema = z.enum(["100", "400", "700"]);
const textSchema = z.object({
  text: z.string(),
  font: fontSchema,
  fontSize: z.coerce.number().min(10).max(32),
  fontWeight: fontWeightSchema
});
const managedObjectSchema = {
  id: "c8ySchema",
  title: "Managed object",
  type: "object",
  printFormat: "hidden",
  properties: {
    id: {
      title: "ID",
      type: "string",
      readonly: true
    },
    name: {
      title: "Name",
      type: "string"
    },
    type: {
      title: "Type",
      type: "string"
    },
    owner: {
      title: "Owner",
      type: "string"
    },
    lastUpdated: {
      title: "Last updated",
      type: "string",
      printFormat: "datetime",
      readonly: true
    },
    creationTime: {
      title: "Creation time",
      type: "string",
      printFormat: "datetime",
      readonly: true
    },
    c8y_ActiveAlarmsStatus: {
      title: "Active alarms status",
      type: "object",
      printFormat: "hidden",
      properties: {
        critical: {
          title: "Critical",
          type: "number",
          readonly: true
        },
        major: {
          title: "Major",
          type: "number",
          readonly: true
        },
        minor: {
          title: "Minor",
          type: "number",
          readonly: true
        },
        warning: {
          title: "Warning",
          type: "number",
          readonly: true
        }
      }
    },
    c8y_Address: {
      title: "Address",
      type: "object",
      printFormat: "hidden",
      properties: {
        street: {
          title: "Street",
          type: "string"
        },
        city: {
          title: "City",
          type: "string"
        },
        cityCode: {
          title: "City code",
          type: "string"
        },
        territory: {
          title: "Territory",
          type: "string"
        },
        region: {
          title: "Region",
          type: "string"
        },
        country: {
          title: "Country",
          type: "string"
        }
      }
    },
    c8y_Availability: {
      title: "Availability",
      type: "object",
      printFormat: "hidden",
      properties: {
        status: {
          title: "Status",
          type: "string",
          readonly: true
        },
        lastMessage: {
          title: "Last message",
          type: "string",
          printFormat: "datetime",
          readonly: true
        }
      }
    },
    c8y_Connection: {
      title: "Connection",
      type: "object",
      printFormat: "hidden",
      properties: {
        status: {
          title: "Status",
          type: "string",
          readonly: true
        }
      }
    },
    c8y_CommunicationMode: {
      title: "Communication mode",
      type: "object",
      printFormat: "hidden",
      properties: {
        mode: {
          title: "Mode",
          type: "string"
        }
      }
    },
    c8y_Firmware: {
      title: "Firmware",
      type: "object",
      printFormat: "hidden",
      readonly: true,
      properties: {
        moduleVersion: {
          title: "Module version",
          type: "string"
        },
        name: {
          title: "Name",
          type: "string"
        },
        version: {
          title: "Version",
          type: "string"
        },
        url: {
          title: "URL",
          type: "string"
        }
      }
    },
    c8y_Hardware: {
      title: "Hardware",
      type: "object",
      printFormat: "hidden",
      properties: {
        model: {
          title: "Model",
          type: "string"
        },
        serialNumber: {
          title: "Serial number",
          type: "string"
        },
        revision: {
          title: "Revision",
          type: "string"
        }
      }
    },
    c8y_LpwanDevice: {
      title: "LPWAN device",
      type: "object",
      properties: {
        provisioned: {
          title: "Provisioned",
          type: "string",
          readonly: true
        }
      }
    },
    c8y_Mobile: {
      title: "Mobile",
      type: "object",
      printFormat: "hidden",
      properties: {
        cellId: {
          title: "Cell ID",
          type: "string"
        },
        connType: {
          title: "Connection type",
          type: "string",
          readonly: true
        },
        currentOperator: {
          title: "Current operator",
          type: "string",
          readonly: true
        },
        currentBand: {
          title: "Current band",
          type: "string",
          readonly: true
        },
        ecn0: {
          title: "ECN0",
          type: "string",
          readonly: true
        },
        iccid: {
          title: "ICCID",
          type: "string"
        },
        imei: {
          title: "IMEI",
          type: "string"
        },
        imsi: {
          title: "IMSI",
          type: "string"
        },
        lac: {
          title: "LAC",
          type: "string"
        },
        mcc: {
          title: "MCC",
          type: "string"
        },
        mnc: {
          title: "MNC",
          type: "string"
        },
        msisdn: {
          title: "MSISDN",
          type: "string"
        },
        rcsp: {
          title: "RCSP",
          type: "string",
          readonly: true
        },
        rscp: {
          title: "RSCP",
          type: "string",
          readonly: true
        },
        rsrp: {
          title: "RSRP",
          type: "string",
          readonly: true
        },
        rsrq: {
          title: "RSRQ",
          type: "string",
          readonly: true
        },
        rssi: {
          title: "RSSI",
          type: "string",
          readonly: true
        }
      }
    },
    c8y_Network: {
      title: "Network",
      type: "object",
      printFormat: "hidden",
      properties: {
        c8y_DHCP: {
          title: "DHCP",
          type: "object",
          printFormat: "hidden",
          properties: {
            addressRange: {
              title: "Address range",
              type: "object",
              printFormat: "hidden",
              properties: {
                start: {
                  title: "Start",
                  type: "string"
                },
                end: {
                  title: "End",
                  type: "string"
                }
              }
            },
            dns1: {
              title: "DNS 1",
              type: "string"
            },
            dns2: {
              title: "DNS 2",
              type: "string"
            },
            enabled: {
              title: "Enabled",
              type: "integer"
            }
          }
        },
        c8y_LAN: {
          title: "LAN",
          type: "object",
          printFormat: "hidden",
          properties: {
            enabled: {
              title: "Enabled",
              type: "integer"
            },
            ip: {
              title: "IP",
              type: "string"
            },
            mac: {
              title: "MAC",
              type: "string"
            },
            name: {
              title: "Name",
              type: "string"
            },
            netmask: {
              title: "Netmask",
              type: "string"
            }
          }
        },
        c8y_WAN: {
          title: "WAN",
          type: "object",
          printFormat: "hidden",
          properties: {
            apn: {
              title: "APN",
              type: "string"
            },
            authType: {
              title: "Auth type",
              type: "string"
            },
            ip: {
              title: "IP",
              type: "string"
            },
            password: {
              title: "Password",
              type: "string"
            },
            simStatus: {
              title: "SIM status",
              type: "string"
            },
            username: {
              title: "Username",
              type: "string"
            }
          }
        }
      }
    },
    c8y_Notes: {
      title: "Notes",
      type: "string",
      "x-schema-form": {
        type: "textarea"
      }
    },
    c8y_Position: {
      title: "Position",
      type: "object",
      printFormat: "hidden",
      properties: {
        lng: {
          title: "Longitude",
          type: "number"
        },
        lat: {
          title: "Latitude",
          type: "number"
        },
        alt: {
          title: "Altitude",
          type: "number"
        }
      }
    },
    c8y_RequiredAvailability: {
      title: "Required availability",
      type: "object",
      printFormat: "hidden",
      properties: {
        responseInterval: {
          title: "Response interval",
          description: "Takes a value between -32768 and 32767 minutes (a negative value indicates that the device is under maintenance).",
          type: "integer",
          minimum: -32768,
          maximum: 32767
        }
      }
    },
    c8y_Software: {
      title: "Software",
      type: "object",
      printFormat: "hidden",
      readonly: true,
      properties: {
        name: {
          title: "Name",
          type: "string"
        },
        version: {
          title: "Version",
          type: "string"
        },
        url: {
          title: "URL",
          type: "string"
        }
      }
    },
    alarmCountToday: {
      title: "Alarm count today",
      type: "number",
      readonly: true,
      computed: true,
      config: {
        type: "object",
        properties: {
          type: {
            title: "Alarm type",
            type: "string"
          }
        }
      }
    },
    alarmCount3Months: {
      title: "Alarm count 3 months",
      type: "number",
      readonly: true,
      computed: true,
      config: {
        type: "object",
        properties: {
          type: {
            title: "Alarm type",
            type: "string"
          }
        }
      }
    },
    eventCountToday: {
      title: "Event count today",
      type: "number",
      readonly: true,
      computed: true,
      config: {
        type: "object",
        properties: {
          type: {
            title: "Event type",
            type: "string"
          }
        }
      }
    },
    eventCount3Months: {
      title: "Event count 3 months",
      type: "number",
      readonly: true,
      computed: true,
      config: {
        type: "object",
        properties: {
          type: {
            title: "Event type",
            type: "string"
          }
        }
      }
    },
    lastDeviceMessage: {
      title: "Last device message",
      type: "string",
      printFormat: "datetime",
      readonly: true,
      computed: true
    },
    lastMeasurement: {
      title: "Last measurement",
      type: "string",
      readonly: true,
      computed: true,
      config: true
    },
    activeAlarmMessage: {
      title: "Active alarm message",
      type: "string",
      readonly: true,
      computed: true,
      config: {
        type: "object",
        properties: {
          type: {
            title: "Alarm type",
            type: "string"
          }
        }
      }
    },
    activeAlarmSeverity: {
      title: "Active alarm severity",
      type: "string",
      readonly: true,
      computed: true,
      config: {
        type: "object",
        properties: {
          type: {
            title: "Alarm type",
            type: "string"
          }
        }
      }
    },
    alarmsStatusCheck: {
      title: "Active alarms check",
      type: "string",
      readonly: true,
      computed: true
    },
    childDevicesCount: {
      title: "Number of child devices",
      type: "number",
      readonly: true,
      computed: true
    },
    childAssetsCount: {
      title: "Number of child assets",
      type: "number",
      readonly: true,
      computed: true
    },
    configurationSnapshot: {
      title: "Configuration snapshot",
      type: "string",
      readonly: true,
      computed: true
    }
  }
};
const measurementSchema = {
  id: "c8ySchema",
  title: "Measurements",
  type: "object",
  printFormat: "hidden",
  properties: {
    id: {
      title: "ID",
      type: "string",
      readonly: true
    },
    source: {
      title: "Source",
      type: "integer"
    },
    type: {
      title: "Type",
      type: "string"
    },
    time: {
      title: "Time",
      type: "string",
      format: "datetime"
    },
    DEVICE_NAME: {
      title: "Device name",
      type: "String"
    }
  }
};
const intervals = {
  hourly: "Hourly",
  daily: "Daily",
  weekly: "Weekly",
  monthly: "Monthly",
  last: "last"
};
const alarmPeriod = {
  "last week": "weeks",
  "last month": "months",
  "last year": "years",
  custom: "custom"
};
const periodSchema = z.enum([
  "minutes",
  "hours",
  "days",
  "weeks",
  "months",
  "years"
]);
const intervalSchema = z.enum([
  "Hourly",
  "Daily",
  "Weekly",
  "Monthly",
  "last"
]);
const period = {
  "last minute": "minutes",
  "last hour": "hours",
  "last day": "days",
  "last week": "weeks",
  "last month": "months",
  "last year": "years"
};
const customPeriod = {
  custom: "custom"
};
const tenantSchema = {
  id: "c8ySchema",
  title: "Tenants",
  type: "object",
  printFormat: "hidden",
  properties: {
    customProperties: {
      title: "Custom properties",
      type: "object",
      printFormat: "hidden",
      properties: {
        externalReference: {
          title: "External reference",
          type: "string"
        },
        "limit.devices.number": {
          title: "Limit number of devices",
          type: "integer",
          minimum: 0
        },
        "limit.http.requests": {
          title: "Limit HTTP requests",
          type: "integer",
          minimum: -1
        },
        "limit.http.queue": {
          title: "Limit HTTP queue",
          type: "integer",
          minimum: -1
        },
        "limit.stream.requests": {
          title: "Limit stream requests",
          type: "integer",
          minimum: -1
        },
        "limit.stream.queue": {
          title: "Limit stream queue",
          type: "integer",
          minimum: -1
        },
        "cepServer.queue.limit": {
          title: "Limit CEP server queue",
          type: "integer",
          minimum: 0,
          "x-show-if-any-available": [{ contextPath: "cep" }]
        },
        "data-broker.queue.limit": {
          title: "Limit data broker queue",
          type: "integer",
          minimum: 0,
          "x-show-if-any-available": [{ contextPath: "feature-broker" }]
        },
        gainsightEnabled: {
          type: "boolean",
          title: "Enable Gainsight product experience tracking",
          default: true
        }
      }
    }
  }
};
const DataDetail = ({
  dataType,
  data,
  isChart,
  onChangeField,
  onSaveDefault
}) => {
  const { t: t2 } = useTranslation();
  const getNameByValue = (options, value2) => {
    const option = options.find((option2) => option2.value === value2);
    return (option == null ? void 0 : option.name) ?? options[0].name;
  };
  if (dataType !== "datapoints") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mx-2 mt-[5px] bg-[#fbfbfc] text-xs dark:bg-dark-bg-333", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "data-point-details plt", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: "mb-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: "mx-2 flex items-center justify-between", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { className: "text-gray-500 font-semibold", children: t2("source") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: data.__original.name })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: "mx-2 flex items-center justify-between pb-1 pt-1", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { className: "text-gray-500 font-semibold", children: t2("type") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: data.__original.type })
      ] })
    ] }) }) }) });
  } else {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: `mt-[5px] rounded-lg bg-[#fbfbfc] px-2 py-2 text-xs dark:bg-dark-bg-333`,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "data-point-details plt", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: "mb-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: "mx-2 flex items-center justify-between", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { className: "text-gray-500 font-semibold", children: t2("source") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: data.__original.name })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: "mx-2 flex items-center justify-between pb-1 pt-1", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Label$1, { className: "text-gray-500 font-semibold", children: [
                t2("fragment"),
                " > ",
                t2("series")
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                data.__original.fragment,
                " > ",
                data.series
              ] })
            ] })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("fieldset", { className: "mb-4 border p-4 text-sm dark:border-dark-grayscale-500", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("legend", { className: "text-gray-500 ", children: t2("data point") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { className: "mb-2 flex max-w-fit items-center font-semibold leading-5", children: t2("label") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Input,
                {
                  className: "w-full p-2",
                  type: "text",
                  value: data.label ?? "",
                  onChange: (e) => onChangeField("label", e.target.value)
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between gap-x-4", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-1 flex-col justify-between", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { className: "mb-2 flex max-w-fit items-center font-semibold leading-5", children: t2("default unit") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Input,
                  {
                    type: "text",
                    value: data.unit ?? "",
                    onChange: (e) => onChangeField("unit", e.target.value)
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-1 flex-col justify-between", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Label$1, { className: "mb-2 flex max-w-fit items-center font-semibold leading-5", children: [
                  t2("target value"),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    QuestionTooltip,
                    {
                      className: "text-blue-500",
                      description: t2("expected target value for data point")
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Input,
                  {
                    type: "number",
                    value: data.target ?? "",
                    placeholder: t2("e.g. 50"),
                    onChange: (e) => onChangeField("target", e.target.value)
                  }
                )
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("fieldset", { className: "mb-4 border p-4 text-sm dark:border-dark-grayscale-500", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("legend", { className: "text-gray-500 ", children: t2("range") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-2 gap-4", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { className: "mb-2 flex max-w-fit items-center font-semibold leading-5", children: t2("min") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Input,
                  {
                    className: "max-w-[100%] ",
                    type: "number",
                    value: data.min ?? "",
                    placeholder: t2("e.g. 0"),
                    onChange: (e) => onChangeField("min", e.target.value)
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { className: "mb-2 flex max-w-fit items-center font-semibold leading-5", children: t2("max") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Input,
                  {
                    className: "max-w-[100%]",
                    type: "number",
                    value: data.max ?? "",
                    placeholder: t2("e.g. 100"),
                    onChange: (e) => onChangeField("max", e.target.value)
                  }
                )
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("fieldset", { className: "mb-4 border p-4 text-sm dark:border-dark-grayscale-500", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("legend", { className: "text-gray-500 ", children: t2("yellow range") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-2 gap-4", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { className: "mb-2 flex max-w-fit items-center font-semibold leading-5", children: t2("min") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Input,
                  {
                    className: "max-w-[100%]",
                    type: "number",
                    value: data.yellowRangeMin ?? "",
                    placeholder: t2("e.g. 25"),
                    onChange: (e) => onChangeField("yellowRangeMin", e.target.value)
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { className: "mb-2 flex max-w-fit items-center font-semibold leading-5", children: t2("max") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Input,
                  {
                    className: "max-w-[100%]",
                    type: "number",
                    value: data.yellowRangeMax ?? "",
                    placeholder: t2("e.g. 50"),
                    onChange: (e) => onChangeField("yellowRangeMax", e.target.value)
                  }
                )
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("fieldset", { className: "mb-4 border p-4 text-sm dark:border-dark-grayscale-500", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("legend", { className: "text-gray-500 ", children: t2("red range") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-2 gap-4", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { className: "mb-2 flex max-w-fit items-center font-semibold leading-5", children: t2("min") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Input,
                  {
                    className: "max-w-[100%]",
                    type: "number",
                    value: data.redRangeMin ?? "",
                    placeholder: t2("e.g. 50"),
                    onChange: (e) => onChangeField("redRangeMin", e.target.value)
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { className: "mb-2 flex max-w-fit items-center font-semibold leading-5", children: t2("max") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Input,
                  {
                    className: "max-w-[100%]",
                    type: "number",
                    value: data.redRangeMax ?? "",
                    placeholder: t2("e.g. 75"),
                    onChange: (e) => onChangeField("redRangeMax", e.target.value)
                  }
                )
              ] })
            ] })
          ] }),
          isChart && /* @__PURE__ */ jsxRuntimeExports.jsxs("fieldset", { className: "mb-4 border p-4 text-sm dark:border-dark-grayscale-500", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("legend", { className: "text-gray-500 ", children: t2("range") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `grid grid-cols-2 gap-4`, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Label$1, { className: "mb-2 flex max-w-fit items-center font-semibold leading-5", children: [
                  t2("display"),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    QuestionTooltip,
                    {
                      className: "text-blue-500",
                      description: t2("value displayed when data is aggregated")
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  Select,
                  {
                    onValueChange: (value2) => onChangeField("renderType", value2),
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(SelectTrigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                        SelectValue,
                        {
                          placeholder: t2(
                            getNameByValue(chartDisplayOptions, data.renderType)
                          )
                        }
                      ) }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectGroup, { children: chartDisplayOptions.map(({ name: name2, value: value2 }) => /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: value2, children: t2(name2) }, value2)) }) })
                    ]
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { className: "mb-2 flex max-w-fit items-center font-semibold leading-5", children: t2("chart type") }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  Select,
                  {
                    value: data.lineType ?? "line",
                    onValueChange: (value2) => onChangeField("lineType", value2),
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(SelectTrigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectValue, {}) }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectGroup, { children: Object.keys(chartTypeOptions).map((option) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                        SelectItem,
                        {
                          value: chartTypeOptions[option],
                          children: t2(chartTypeOptions[option])
                        },
                        chartTypeOptions[option]
                      )) }) })
                    ]
                  }
                )
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "my-4 pt-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button$1,
              {
                title: t2("use settings as default"),
                className: "dlt-c8y-icon-save h-5 rounded-full",
                variant: "outline",
                type: "button",
                onClick: onSaveDefault,
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "ml-1 text-xs", children: t2("save as default") })
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              QuestionTooltip,
              {
                className: "text-blue-500",
                description: t2(
                  "if you select the current settings as default, these values will be used whenever this data point is added to a data explorer or in existing threshold smart rules which refer to this data point"
                )
              }
            )
          ] })
        ]
      }
    ) });
  }
};
const useDatapointActions = (sourceId, actionType) => {
  const { postInventory, putDataPoints, putInventory } = useApi();
  const { toast } = useToast();
  const queryClient = useQueryClient();
  let mutationFn;
  let successMessage;
  let errorMessage;
  let queryKey;
  switch (actionType) {
    case "updateDefault":
      mutationFn = ({ deviceId, c8y_DataPoint }) => putDataPoints(deviceId, c8y_DataPoint);
      successMessage = "   .";
      errorMessage = "   .";
      queryKey = "device";
      break;
    case "updateLibrary":
      mutationFn = ({ loadedDatapoint, currentData }) => {
        const {
          __collapse,
          __target,
          __active,
          __selected,
          $$hashKey,
          yAxisType,
          lineType,
          lineWidth,
          background: background2,
          renderType,
          __original,
          ...dp
        } = currentData;
        putInventory(loadedDatapoint.id, {
          ...loadedDatapoint,
          c8y_Kpi: { ...dp, fragment: __original.fragment }
        });
      };
      successMessage = "  .";
      errorMessage = "  .";
      queryKey = "datapointLibrary";
      break;
    case "saveLibrary":
      mutationFn = ({ currentData }) => {
        const {
          __collapse,
          __target,
          __active,
          __selected,
          $$hashKey,
          yAxisType,
          lineType,
          lineWidth,
          background: background2,
          renderType,
          __original,
          ...dp
        } = currentData;
        const body = {
          c8y_Global: {},
          c8y_Kpi: { ...dp, fragment: __original.fragment },
          source: __target.id
        };
        postInventory(body);
      };
      successMessage = "  .";
      errorMessage = "  .";
      queryKey = "datapointLibrary";
      break;
  }
  const { mutate } = useMutation({
    mutationFn,
    onSuccess: () => {
      toast({
        title: successMessage,
        duration: 3e3,
        variant: "success"
      });
    },
    onError: () => {
      toast({
        title: errorMessage,
        duration: 3e3,
        variant: "error"
      });
    },
    onSettled: () => {
      queryClient.invalidateQueries([queryKey, sourceId]);
    }
  });
  return mutate;
};
const DataItem = ({
  dataType,
  data,
  device: device2,
  onDelete,
  onUpdate,
  index: index2,
  isChart,
  sourceId,
  datapointLibraries,
  activeDataLength,
  multiSelect
}) => {
  const { t: t2 } = useTranslation();
  const [currentData, setCurrentData] = useState(data);
  const [loadedDatapoint, setLoadedDatapoint] = useState(null);
  const [isCollapse, setIsCollapse] = useState(false);
  const changeField = (key, value2) => {
    setCurrentData((pre) => {
      const updatedData = { ...pre, [key]: value2 };
      onUpdate(updatedData, index2);
      return updatedData;
    });
  };
  const toggleCollapse = () => {
    setIsCollapse((pre) => !pre);
  };
  const saveDefault = () => {
    const deviceId = currentData.__target.id;
    let _id = String(Math.random()).substring(2);
    const { c8y_DataPoint } = device2;
    const { __target, __active, __selected, $$hashKey, id: id2, ...dp } = currentData;
    if (c8y_DataPoint) {
      const matchedId = Object.keys(c8y_DataPoint).find((key) => {
        const { fragment: fragment2, series: series2 } = c8y_DataPoint[key];
        return fragment2 === currentData.fragment && series2 === currentData.series;
      });
      if (matchedId) {
        _id = matchedId;
      }
      c8y_DataPoint[_id] = dp;
      updateDefaultDatapoint({ deviceId, c8y_DataPoint });
    } else {
      const c8y_DataPoint2 = { [_id]: dp };
      updateDefaultDatapoint({ deviceId, c8y_DataPoint: c8y_DataPoint2 });
    }
    changeField("_id", _id);
  };
  const loadDatapointLibrary = (datapointLibrary) => {
    setCurrentData((pre) => {
      const updatedDp = { ...pre, ...datapointLibrary.c8y_Kpi };
      onUpdate(updatedDp, index2);
      return updatedDp;
    });
    setLoadedDatapoint(datapointLibrary);
  };
  const updateDefaultDatapoint = useDatapointActions(sourceId, "updateDefault");
  const updateDatapointLibrary = useDatapointActions(sourceId, "updateLibrary");
  const saveDatapointLibrary = useDatapointActions(sourceId, "saveLibrary");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-2 box-border flex items-center justify-between rounded-lg border border-grayscale-600 px-4 py-2.5 dark:border-dark-grayscale-400", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex h-9 w-full items-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Switch,
        {
          checked: currentData.__active === true,
          onCheckedChange: (checked) => changeField("__active", checked),
          disabled: currentData.__active !== true && !multiSelect && activeDataLength >= 1
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mx-2 h-5 w-5", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          type: "color",
          className: "input-color",
          value: currentData.color,
          onChange: (e) => changeField("color", e.target.value)
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "w-full overflow-hidden text-ellipsis whitespace-nowrap text-base font-bold text-grayscale-100 dark:text-dark-grayscale-100", children: currentData.label }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button$1,
        {
          title: t2("expand"),
          size: "icon",
          type: "button",
          variant: "ghost",
          className: `mx-1 h-9 text-grayscale-300 transition duration-300 ease-in-out ${isCollapse ? "rotate-180" : "rotate-0"}`,
          onClick: toggleCollapse,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(SvgArrowDown, { className: "dark:text-dark-grayscale-200" })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        DataMenu,
        {
          index: index2,
          dataType,
          currentData,
          onDelete,
          datapointLibraries,
          saveDatapointLibrary,
          updateDatapointLibrary,
          loadDatapointLibrary,
          loadedDatapoint
        }
      )
    ] }) }),
    isCollapse && /* @__PURE__ */ jsxRuntimeExports.jsx(
      DataDetail,
      {
        dataType,
        data,
        onChangeField: changeField,
        onSaveDefault: saveDefault,
        isChart
      }
    )
  ] });
};
const DataList = ({ data, ...props }) => {
  const { t: t2 } = useTranslation();
  const renderContent = data.length ? data.map((item, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    DataItem,
    {
      data: item,
      index: index2,
      ...props
    },
    `${item.__target.id}${item.id ?? item.type ?? item.fragment + item.series}`
  )) : props.dataType !== "link" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center justify-center space-x-[15px] rounded-lg bg-grayscale-800 py-5 text-center text-grayscale-300 dark:bg-dark-bg-333 dark:text-grayscale-500", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm font-bold", children: t2(`No ${props.dataType} found.`) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "mb-3 mt-1 text-xs ", children: t2(`You must add at least one ${props.dataType}.`) })
  ] });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: renderContent });
};
const useDataManager = () => {
  const { measurementLogic, eventAlarmLogic } = useUltivisLogic();
  const getRandomColor = () => {
    return `#${Math.random().toString(16).slice(2, 8)}`;
  };
  const createDataMethods = {
    generateDataMap: (supportedMeasurementsAndSeries, u5sOrigin, origin2, target2) => {
      return measurementLogic(supportedMeasurementsAndSeries, u5sOrigin).reduce(
        (acc, { fragment: fragment2, series: series2, original }) => {
          const label2 = `${original}=>${series2}`;
          acc[label2] = {
            label: label2,
            fragment: fragment2,
            series: series2,
            color: getRandomColor(),
            __original: { ...origin2, fragment: original },
            __target: target2,
            __active: false
          };
          return acc;
        },
        {}
      );
    },
    /**
     * Removes selected data points from the data map.
     *
     * @param {Object} dataMap - The current data map.
     * @param {Array} data - The active data to compare.
     * @param {Array} checkedDataList - The list of checked data points to remove.
     */
    removeSelectedData: (dataMap, data, checkedDataList) => {
      [...data, ...checkedDataList].forEach((datapoint) => {
        const key = `${datapoint.__original.fragment}=>${datapoint.series}`;
        if (dataMap[key] && isSameDatapoint(datapoint, dataMap[key])) {
          delete dataMap[key];
        }
      });
    },
    /**
     * Overwrites the data map with KPI (Key Performance Indicator) data.
     *
     * @param {Object} dataMap - The current data map.
     * @param {Array} kpiData - The KPI data to overwrite.
     */
    overwriteWithKpiData: (dataMap, kpiData) => {
      kpiData.forEach(({ c8y_Kpi }) => {
        const { fragment: fragment2, series: series2 } = c8y_Kpi;
        const key = `${fragment2}=>${series2}`;
        if (dataMap[key]) {
          dataMap[key] = { ...dataMap[key], ...c8y_Kpi };
        }
      });
    },
    /**
     * Overwrites the data map with preset data.
     *
     * @param {Object} dataMap - The current data map.
     * @param {Object} presets - Preset data to overwrite the data map.
     * @param {string} u5sOrigin - The unique identifier for the origin.
     */
    overwriteWithPresetData: (dataMap, presets, u5sOrigin) => {
      Object.values(presets).forEach((preset) => {
        let { fragment: fragment2, series: series2 } = preset;
        let source2;
        if (fragment2.includes("|")) {
          [source2, fragment2] = fragment2.split("|");
        }
        const key = `${fragment2}=>${series2}`;
        if (u5sOrigin === source2 && dataMap[key]) {
          dataMap[key] = { ...dataMap[key], ...preset };
        }
      });
    },
    /**
     * Generates a data map for dashboards.
     *
     * @param {Array} dashboards - The list of dashboards.
     * @param {Object} origin - The source data.
     * @param {Object} target - The target data.
     * @param {boolean} isGroup - Whether the dashboard is a group.
     * @returns {Object} - A map of generated dashboard data points.
     */
    generateDashboardDataMap: (dashboards, origin2, target2, isGroup) => {
      return dashboards.reduce((acc, { id: id2, type: type2, name: name2, original }) => {
        acc[id2] = {
          label: name2,
          type: type2,
          color: getRandomColor(),
          isGroup,
          id: id2,
          __original: { ...origin2, type: original },
          __target: target2,
          __active: false
        };
        return acc;
      }, {});
    },
    /**
     * Generates a data map for events and alarms.
     *
     * @param {Array} recentTypeList - The recent types of events or alarms.
     * @param {string} u5sOrigin - The unique identifier for the origin.
     * @param {Object} origin - The source data.
     * @param {Object} target - The target data.
     * @returns {Object} - A map of generated event data points.
     */
    generateEventDataMap: (recentTypeList, u5sOrigin, origin2, target2) => {
      return eventAlarmLogic(recentTypeList, u5sOrigin).reduce(
        (acc, { type: type2, original }) => {
          acc[type2] = {
            label: original,
            type: type2,
            color: getRandomColor(),
            __original: { ...origin2, type: original },
            __target: target2,
            __active: false
          };
          return acc;
        },
        {}
      );
    }
  };
  return { getRandomColor, ...createDataMethods };
};
const AddData = ({
  dataType,
  data,
  info,
  onAppendData,
  category,
  modalIsOpen,
  onCloseModal
}) => {
  const { getInventory, getAlarms, getEvents, getDataPoints, getDashboards } = useApi();
  const { customFragmentLogic, u5sOriginLogic } = useUltivisLogic();
  const {
    getRandomColor,
    generateDataMap,
    removeSelectedData,
    overwriteWithKpiData,
    overwriteWithPresetData,
    generateDashboardDataMap,
    generateEventDataMap
  } = useDataManager();
  const { t: t2 } = useTranslation();
  const [dataList, setDataList] = useState([]);
  const [checkedDataList, setCheckedDataList] = useState([]);
  const [device2, setDevice] = useState({});
  const [customData, setCustomData] = useState({
    label: "",
    __selected: false,
    color: void 0
  });
  const dateTo = formatISO(/* @__PURE__ */ new Date());
  const pageSize = 2e3;
  const sameFunction = dataType === "datapoints" ? isSameDatapoint : dataType === "link" ? isSameId : isSameType;
  const createData = async ({
    target: target2,
    u5sOrigin = null,
    origin: origin2,
    presets = {},
    type: type2,
    isGroup
  }) => {
    const source2 = target2 == null ? void 0 : target2.id;
    let dataMap;
    if (dataType === "datapoints") {
      const [supportedMeasurementsAndSeries, kpis] = await getDataPoints(source2);
      if (u5sOrigin && u5sOrigin !== "parent") {
        presets = await getInventory(source2).then(
          (res) => res.data.c8y_DataPoint ?? {}
        );
      }
      dataMap = generateDataMap(
        supportedMeasurementsAndSeries,
        u5sOrigin,
        origin2,
        target2
      );
      removeSelectedData(dataMap, data, checkedDataList);
      overwriteWithKpiData(dataMap, kpis.data);
      overwriteWithPresetData(dataMap, presets, u5sOrigin);
    } else {
      if (dataType === "link") {
        const dashboards = await getDashboards(
          origin2 == null ? void 0 : origin2.id,
          isGroup ? "group" : "device",
          type2
        );
        dataMap = generateDashboardDataMap(dashboards, origin2, target2, isGroup);
      } else {
        let recentData;
        if (dataType === "alarms") {
          recentData = await getAlarms({
            dateTo,
            source: source2,
            pageSize,
            withSourceAssets: source2 ? true : false,
            withSourceDevices: source2 ? true : false
          });
        } else if (dataType === "events") {
          recentData = await getEvents({
            dateTo,
            source: source2,
            pageSize,
            withSourceAssets: source2 ? true : false,
            withSourceDevices: source2 ? true : false
          });
        }
        const recentTypeList = uniqWith(recentData.data, isSameType).map(
          (data2) => ({
            type: data2.type
          })
        );
        dataMap = generateEventDataMap(
          recentTypeList,
          u5sOrigin,
          origin2,
          target2
        );
        removeSelectedData(dataMap, data, checkedDataList);
      }
    }
    if (dataMap) {
      const dataList2 = sortBy(Object.values(dataMap), "label");
      setDataList(dataList2);
    }
  };
  const selectDevice = (selectedDevice) => {
    if (!selectedDevice) return;
    const deviceInfo = u5sOriginLogic(selectedDevice);
    if (dataType === "datapoints") {
      deviceInfo["presets"] = selectedDevice["c8y_Datapoint"];
    }
    if (dataType === "link") {
      const isGroup = Object.hasOwn(selectedDevice, "c8y_IsDeviceGroup");
      deviceInfo["isGroup"] = isGroup;
      deviceInfo["type"] = selectedDevice["type"];
    }
    setDevice(deviceInfo);
    createData(deviceInfo);
  };
  const addData = () => {
    let appendData = [...checkedDataList];
    if (dataType !== "datapoints") {
      if (customData.__selected) {
        const { type: type2, original } = customFragmentLogic(
          "type",
          customData.label,
          device2.u5sOrigin
        );
        let processedCustomData = {
          ...customData,
          type: type2,
          __target: { ...device2.target },
          __original: { ...device2.origin, type: original }
        };
        appendData.push(processedCustomData);
      }
    }
    onAppendData(appendData);
    onCloseModal();
  };
  const onCheckChange = (checked, data2) => {
    const selectData = { ...data2 };
    selectData.__selected = checked;
    setDataList(
      (prev) => prev.map((dp) => sameFunction(dp, selectData) ? selectData : dp)
    );
    setCheckedDataList(
      (prev) => checked ? [...prev, selectData] : prev.filter((dp) => !sameFunction(dp, selectData))
    );
  };
  const onChangeForCustom = (property2, value2) => setCustomData((prev) => ({ ...prev, [property2]: value2 }));
  useEffect(() => {
    if (dataType === "alarms" || dataType === "events")
      setCustomData((prev) => ({ ...prev, color: getRandomColor() }));
  }, []);
  useEffect(() => {
    if (info && category !== "group" && category !== "") selectDevice(info);
  }, [info, data]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog, { open: modalIsOpen, onOpenChange: onCloseModal, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogContent, { className: "max-h-[80vh] overflow-y-auto sm:max-w-[750px]  md:w-[450px]", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(DialogHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, { className: "pt-6 text-xl font-extrabold tracking-tight", children: t2(`add ${dataType}`) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(ScrollArea, { className: "flex h-[50vh] items-center justify-center pr-3", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center space-x-2", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full flex-1 gap-2 px-1", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "my-4 flex items-center gap-x-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex h-[30px] w-[30px] items-center justify-center rounded-full bg-primary text-grayscale-1000", children: "1" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Label$1,
            {
              htmlFor: "device-search",
              className: "text-xs text-grayscale-100 dark:text-dark-grayscale-100",
              children: t2("SELECT DEVICE")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-grow border-t-[1px] border-solid border-grayscale-600 opacity-50 dark:text-dark-grayscale-100" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(FallbackUi, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(LazyLoader, { children: category === "device" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          DeviceTree,
          {
            managedObject: info,
            context: info,
            selected: selectDevice
          }
        ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
          SearchDeviceTree,
          {
            context: info,
            selected: selectDevice,
            groupSelectable: dataType !== "datapoints"
          }
        ) }) })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center space-x-2", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1 gap-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "my-4 flex items-center gap-x-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex h-[30px] w-[30px] items-center justify-center rounded-full bg-primary text-grayscale-1000", children: "2" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Label$1,
            {
              htmlFor: "device-search",
              className: "text-xs text-grayscale-100 dark:text-dark-grayscale-100",
              children: t2(`SELECT ${dataType.toUpperCase()}`)
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-grow border-t-[1px] border-solid border-grayscale-600 opacity-50 dark:text-dark-grayscale-100" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4", children: [
          checkedDataList.length > 0 && checkedDataList.sort((a, b) => a.label.localeCompare(b.label)).map((data2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: "my-1 flex items-center gap-2",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Checkbox,
                  {
                    checked: data2.__selected,
                    onCheckedChange: (checked) => onCheckChange(checked, data2)
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    className: "h-4 w-4 rounded-full",
                    style: {
                      backgroundColor: data2.color
                    }
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: data2.label })
              ]
            },
            `${data2.__target.id}_${data2.__original.id}_${data2.label}`
          )),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "dark:text-dark-grayscale2000 opacity100 my-3 flex-grow border-t-[1px] border-solid border-grayscale-600" }),
          dataList.length > 0 ? dataList.sort((a, b) => a.label.localeCompare(b.label)).map((data2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: cn(
                "my-1 flex items-center gap-2",
                `${data2.__selected ? "hidden" : ""}`
              ),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Checkbox,
                  {
                    checked: data2.__selected,
                    onCheckedChange: (checked) => onCheckChange(checked, data2)
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    className: "h-4 w-4 rounded-full",
                    style: {
                      backgroundColor: data2.color
                    }
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: data2.label })
              ]
            },
            `${data2.__target.id}_${data2.__original.id}_${data2.label}_${data2.id}`
          )) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-x-2 rounded-lg px-1 py-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "icon-lg dlt-c8y-icon-exclamation-circle text-yellow-500" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: t2("No data found.") })
          ] }),
          (dataType !== "datapoints" && dataType !== "link" && (device2 == null ? void 0 : device2.id)) ?? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "my-1 flex items-center gap-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Checkbox,
              {
                checked: customData.__selected,
                onCheckedChange: (checked) => onChangeForCustom("__selected", checked)
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: "h-4 w-[1.2rem] rounded-full",
                style: { backgroundColor: customData.color }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input,
              {
                value: customData.label,
                onChange: (e) => onChangeForCustom("label", e.target.value)
              }
            )
          ] })
        ] })
      ] }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DialogFooter, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button$1,
        {
          variant: "destructive",
          onClick: onCloseModal,
          type: "button",
          children: t2("Cancel")
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button$1,
        {
          variant: "secondary",
          onClick: addData,
          type: "button",
          disabled: checkedDataList.length === 0 && !customData.__selected,
          children: t2("Add")
        }
      )
    ] }) })
  ] }) }) });
};
const DataManager = ({
  dataType,
  data = [],
  name: name2 = `config.${dataType}`,
  multiSelect = false,
  isChart = false,
  context = null,
  // sourceId
  showDivider = true,
  reset = false,
  getAllData = () => {
  }
}) => {
  const { getInventoryByFragmentType } = useApi();
  const { t: t2 } = useTranslation();
  const { control } = useFormContext();
  const { pathname } = useLocation();
  const { replace } = useFieldArray({
    control,
    name: name2
  });
  const [dataList, setDataList] = useState([]);
  const [modalIsOpen, setModalIsOpen] = useState(false);
  const { category: routeCategory, sourceId: routeSource } = useRoutingContext();
  const sourceId = context ?? routeSource;
  const selectedDevice = useWatch({ name: "config.device" });
  const { data: device2 } = useDeviceInventory(
    selectedDevice ? selectedDevice.id : sourceId,
    {
      select: (data2) => data2.data,
      enabled: !!sourceId || pathname === "/" || !!selectedDevice
    }
  );
  const { data: datapointLibraries } = useQuery({
    queryKey: ["datapointLibrary", sourceId],
    queryFn: () => getInventoryByFragmentType("c8y_Kpi").then((res) => res.data),
    enabled: !!sourceId && dataType === "datapoints"
  });
  const category = context ? (device2 == null ? void 0 : device2.c8y_IsDeviceGroup) ? "group" : "device" : routeCategory;
  const watchData = useWatch({ name: name2 });
  const setDataListLogic = (newDataList) => {
    setDataList(newDataList);
    if (dataType === "datapoints") {
      setDatapointsToLocal(sourceId, category, newDataList);
    }
    if (dataType === "alarms" || dataType === "events") {
      setTypesToLocal(sourceId, category, dataType, newDataList);
    }
  };
  const appendData = (appendedDataList) => {
    const updatedDataList = [...dataList, ...appendedDataList];
    setDataListLogic(updatedDataList);
  };
  const removeData = (index2) => {
    const updatedDataList = dataList.filter((_, i2) => i2 !== index2);
    setDataListLogic(updatedDataList);
    getAllData(updatedDataList);
    replace(getActiveData(updatedDataList));
  };
  const updateData = (updatedData, index2) => {
    const updatedDataList = [...dataList];
    updatedDataList[index2] = { ...updatedData };
    setDataList(updatedDataList);
    getAllData(updatedDataList);
    replace(getActiveData(updatedDataList));
  };
  const isMounted = useRef(false);
  useEffect(() => {
    if (!isMounted.current && reset) {
      setDataList([]);
      isMounted.current = true;
      return;
    }
    const cachedMap = {
      datapoints: () => getDatapointsFromLocal(sourceId, category),
      default: () => getTypesFromLocal(sourceId, category, dataType)
    };
    const comparatorMap = {
      link: isSameId,
      datapoints: isSameDatapoint,
      default: isSameType
    };
    const cached = (cachedMap[dataType] || cachedMap.default)();
    const comparator = comparatorMap[dataType] || comparatorMap.default;
    setDataList((prev) => {
      const combinedData = reset ? [...data, ...prev] : [...data, ...prev, ...cached];
      const uniqueData = uniqWith(combinedData, comparator);
      if (!isEqual(prev, uniqueData)) {
        return uniqueData;
      }
      return prev;
    });
  }, [data]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm font-medium", children: t2(capitalize$1(dataType)) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button$1,
        {
          variant: "secondary",
          type: "button",
          className: "flex h-8 items-center gap-x-1",
          onClick: () => setModalIsOpen(true),
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm font-bold", children: t2(`Add ${dataType}`) })
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-3", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        FormField,
        {
          name: name2,
          control,
          render: () => /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              DataList,
              {
                data: dataList,
                dataType,
                onDelete: (_, index2) => removeData(index2),
                onUpdate: (updatedDp, index2) => updateData(updatedDp, index2),
                activeDataLength: watchData == null ? void 0 : watchData.length,
                datapointLibraries,
                sourceId,
                category,
                multiSelect,
                isChart
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, { className: "text-sm" })
          ] })
        }
      ),
      showDivider && /* @__PURE__ */ jsxRuntimeExports.jsx(Separator, { className: "my-6" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      FormField,
      {
        name: name2,
        control,
        render: () => modalIsOpen && /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            AddData,
            {
              dataType,
              info: device2,
              data: dataList,
              onAppendData: (data2) => appendData(data2),
              modalIsOpen,
              onCloseModal: () => setModalIsOpen(false)
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, {})
        ] })
      }
    )
  ] });
};
const DatePicker = ({ dateRange, onDateRange, onApplyFilter, className }) => {
  const [startDateIsOpen, setStartDateIsOpen] = useState(false);
  const [endDateIsOpen, setEndDateIsOpen] = useState(false);
  const [lastDateRange, setLastDateRange] = useState(dateRange);
  const debounceTimeout = useRef(null);
  const textClass = "text-sm font-bold text-grayscale-400";
  const startDate = format(new Date(dateRange.startDate), "yyyy.MM.dd");
  const endDate = format(new Date(dateRange.endDate), "yyyy.MM.dd");
  useEffect(() => {
    if (!startDateIsOpen && !endDateIsOpen) {
      if (debounceTimeout.current) clearTimeout(debounceTimeout.current);
      debounceTimeout.current = setTimeout(() => {
        if (JSON.stringify(lastDateRange) !== JSON.stringify(dateRange)) {
          onDateRange(dateRange);
          setLastDateRange(dateRange);
          onApplyFilter && onApplyFilter();
        }
      }, 1e3);
    }
    return () => {
      if (debounceTimeout.current) clearTimeout(debounceTimeout.current);
    };
  }, [startDateIsOpen, endDateIsOpen]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: cn("flex items-center gap-x-2", className), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Popover,
      {
        open: startDateIsOpen,
        onOpenChange: (open) => setStartDateIsOpen(open),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(PopoverTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Button$1,
            {
              variant: "ghost",
              className: "flex w-full min-w-fit max-w-[230px] items-center justify-start gap-x-3 rounded-lg border border-grayscale-600 px-2 py-2 dark:border-dark-grayscale-600",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(SvgCalendar, { className: "h-5 w-5 text-grayscale-400" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: textClass, children: startDate })
              ]
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(PopoverContent, { className: "w-auto p-0", align: "start", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Calendar,
            {
              mode: "single",
              selected: new Date(dateRange.startDate),
              onSelect: (date) => {
                if (date) {
                  onDateRange({
                    ...dateRange,
                    startDate: formatISO(date)
                  });
                }
                setStartDateIsOpen(false);
                setEndDateIsOpen(true);
              },
              initialFocus: true,
              toDate: dateRange.endDate || /* @__PURE__ */ new Date()
            }
          ) })
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Popover,
      {
        open: endDateIsOpen,
        onOpenChange: (open) => setEndDateIsOpen(open),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(PopoverTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Button$1,
            {
              variant: "ghost",
              className: "flex w-full min-w-fit  max-w-[230px] items-center justify-start gap-x-3 rounded-lg border-[1px] border-grayscale-600 px-2 py-2 dark:border-dark-grayscale-600",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(SvgCalendar, { className: "h-5 w-5 text-grayscale-400" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: textClass, children: endDate })
              ]
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(PopoverContent, { className: "w-auto p-0", align: "start", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Calendar,
            {
              mode: "single",
              selected: new Date(dateRange.endDate),
              onSelect: (date) => {
                if (date) {
                  onDateRange({
                    ...dateRange,
                    endDate: formatISO(endOfDay(date))
                  });
                }
                setEndDateIsOpen(false);
              },
              initialFocus: true,
              toDate: /* @__PURE__ */ new Date(),
              fromDate: dateRange.startDate || /* @__PURE__ */ new Date(0)
            }
          ) })
        ]
      }
    )
  ] });
};
function createJSONStorage(getStorage, options) {
  let storage;
  try {
    storage = getStorage();
  } catch (_e) {
    return;
  }
  const persistStorage = {
    getItem: (name2) => {
      var _a;
      const parse2 = (str2) => {
        if (str2 === null) {
          return null;
        }
        return JSON.parse(str2, void 0);
      };
      const str = (_a = storage.getItem(name2)) != null ? _a : null;
      if (str instanceof Promise) {
        return str.then(parse2);
      }
      return parse2(str);
    },
    setItem: (name2, newValue) => storage.setItem(
      name2,
      JSON.stringify(newValue, void 0)
    ),
    removeItem: (name2) => storage.removeItem(name2)
  };
  return persistStorage;
}
const toThenable = (fn) => (input) => {
  try {
    const result = fn(input);
    if (result instanceof Promise) {
      return result;
    }
    return {
      then(onFulfilled) {
        return toThenable(onFulfilled)(result);
      },
      catch(_onRejected) {
        return this;
      }
    };
  } catch (e) {
    return {
      then(_onFulfilled) {
        return this;
      },
      catch(onRejected) {
        return toThenable(onRejected)(e);
      }
    };
  }
};
const oldImpl = (config, baseOptions) => (set2, get2, api) => {
  let options = {
    getStorage: () => localStorage,
    serialize: JSON.stringify,
    deserialize: JSON.parse,
    partialize: (state) => state,
    version: 0,
    merge: (persistedState, currentState) => ({
      ...currentState,
      ...persistedState
    }),
    ...baseOptions
  };
  let hasHydrated = false;
  const hydrationListeners = /* @__PURE__ */ new Set();
  const finishHydrationListeners = /* @__PURE__ */ new Set();
  let storage;
  try {
    storage = options.getStorage();
  } catch (_e) {
  }
  if (!storage) {
    return config(
      (...args) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`
        );
        set2(...args);
      },
      get2,
      api
    );
  }
  const thenableSerialize = toThenable(options.serialize);
  const setItem = () => {
    const state = options.partialize({ ...get2() });
    let errorInSync;
    const thenable = thenableSerialize({ state, version: options.version }).then(
      (serializedValue) => storage.setItem(options.name, serializedValue)
    ).catch((e) => {
      errorInSync = e;
    });
    if (errorInSync) {
      throw errorInSync;
    }
    return thenable;
  };
  const savedSetState = api.setState;
  api.setState = (state, replace) => {
    savedSetState(state, replace);
    void setItem();
  };
  const configResult = config(
    (...args) => {
      set2(...args);
      void setItem();
    },
    get2,
    api
  );
  let stateFromStorage;
  const hydrate = () => {
    var _a;
    if (!storage) return;
    hasHydrated = false;
    hydrationListeners.forEach((cb) => cb(get2()));
    const postRehydrationCallback = ((_a = options.onRehydrateStorage) == null ? void 0 : _a.call(options, get2())) || void 0;
    return toThenable(storage.getItem.bind(storage))(options.name).then((storageValue) => {
      if (storageValue) {
        return options.deserialize(storageValue);
      }
    }).then((deserializedStorageValue) => {
      if (deserializedStorageValue) {
        if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options.version) {
          if (options.migrate) {
            return options.migrate(
              deserializedStorageValue.state,
              deserializedStorageValue.version
            );
          }
          console.error(
            `State loaded from storage couldn't be migrated since no migrate function was provided`
          );
        } else {
          return deserializedStorageValue.state;
        }
      }
    }).then((migratedState) => {
      var _a2;
      stateFromStorage = options.merge(
        migratedState,
        (_a2 = get2()) != null ? _a2 : configResult
      );
      set2(stateFromStorage, true);
      return setItem();
    }).then(() => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);
      hasHydrated = true;
      finishHydrationListeners.forEach((cb) => cb(stateFromStorage));
    }).catch((e) => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);
    });
  };
  api.persist = {
    setOptions: (newOptions) => {
      options = {
        ...options,
        ...newOptions
      };
      if (newOptions.getStorage) {
        storage = newOptions.getStorage();
      }
    },
    clearStorage: () => {
      storage == null ? void 0 : storage.removeItem(options.name);
    },
    getOptions: () => options,
    rehydrate: () => hydrate(),
    hasHydrated: () => hasHydrated,
    onHydrate: (cb) => {
      hydrationListeners.add(cb);
      return () => {
        hydrationListeners.delete(cb);
      };
    },
    onFinishHydration: (cb) => {
      finishHydrationListeners.add(cb);
      return () => {
        finishHydrationListeners.delete(cb);
      };
    }
  };
  hydrate();
  return stateFromStorage || configResult;
};
const newImpl = (config, baseOptions) => (set2, get2, api) => {
  let options = {
    storage: createJSONStorage(() => localStorage),
    partialize: (state) => state,
    version: 0,
    merge: (persistedState, currentState) => ({
      ...currentState,
      ...persistedState
    }),
    ...baseOptions
  };
  let hasHydrated = false;
  const hydrationListeners = /* @__PURE__ */ new Set();
  const finishHydrationListeners = /* @__PURE__ */ new Set();
  let storage = options.storage;
  if (!storage) {
    return config(
      (...args) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`
        );
        set2(...args);
      },
      get2,
      api
    );
  }
  const setItem = () => {
    const state = options.partialize({ ...get2() });
    return storage.setItem(options.name, {
      state,
      version: options.version
    });
  };
  const savedSetState = api.setState;
  api.setState = (state, replace) => {
    savedSetState(state, replace);
    void setItem();
  };
  const configResult = config(
    (...args) => {
      set2(...args);
      void setItem();
    },
    get2,
    api
  );
  api.getInitialState = () => configResult;
  let stateFromStorage;
  const hydrate = () => {
    var _a, _b;
    if (!storage) return;
    hasHydrated = false;
    hydrationListeners.forEach((cb) => {
      var _a2;
      return cb((_a2 = get2()) != null ? _a2 : configResult);
    });
    const postRehydrationCallback = ((_b = options.onRehydrateStorage) == null ? void 0 : _b.call(options, (_a = get2()) != null ? _a : configResult)) || void 0;
    return toThenable(storage.getItem.bind(storage))(options.name).then((deserializedStorageValue) => {
      if (deserializedStorageValue) {
        if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options.version) {
          if (options.migrate) {
            return [
              true,
              options.migrate(
                deserializedStorageValue.state,
                deserializedStorageValue.version
              )
            ];
          }
          console.error(
            `State loaded from storage couldn't be migrated since no migrate function was provided`
          );
        } else {
          return [false, deserializedStorageValue.state];
        }
      }
      return [false, void 0];
    }).then((migrationResult) => {
      var _a2;
      const [migrated, migratedState] = migrationResult;
      stateFromStorage = options.merge(
        migratedState,
        (_a2 = get2()) != null ? _a2 : configResult
      );
      set2(stateFromStorage, true);
      if (migrated) {
        return setItem();
      }
    }).then(() => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);
      stateFromStorage = get2();
      hasHydrated = true;
      finishHydrationListeners.forEach((cb) => cb(stateFromStorage));
    }).catch((e) => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);
    });
  };
  api.persist = {
    setOptions: (newOptions) => {
      options = {
        ...options,
        ...newOptions
      };
      if (newOptions.storage) {
        storage = newOptions.storage;
      }
    },
    clearStorage: () => {
      storage == null ? void 0 : storage.removeItem(options.name);
    },
    getOptions: () => options,
    rehydrate: () => hydrate(),
    hasHydrated: () => hasHydrated,
    onHydrate: (cb) => {
      hydrationListeners.add(cb);
      return () => {
        hydrationListeners.delete(cb);
      };
    },
    onFinishHydration: (cb) => {
      finishHydrationListeners.add(cb);
      return () => {
        finishHydrationListeners.delete(cb);
      };
    }
  };
  if (!options.skipHydration) {
    hydrate();
  }
  return stateFromStorage || configResult;
};
const persistImpl = (config, baseOptions) => {
  if ("getStorage" in baseOptions || "serialize" in baseOptions || "deserialize" in baseOptions) {
    return oldImpl(config, baseOptions);
  }
  return newImpl(config, baseOptions);
};
const persist = persistImpl;
const storeCache = /* @__PURE__ */ new Map();
const useDatePickerStore = (key, useCache) => {
  if (!storeCache.has(key)) {
    const baseConfig = (set2) => ({
      aggregationType: "none",
      isRealtime: true,
      dateRange: {},
      updateAggrType: (newAggregationType) => set2({ aggregationType: newAggregationType }),
      updateIsRealtime: (newIsRealtime) => set2({ isRealtime: newIsRealtime }),
      updateDateRange: (newDateRange) => set2({ dateRange: newDateRange })
    });
    const store = create(
      useCache ? persist(baseConfig, {
        name: key,
        storage: createJSONStorage(() => localStorage)
      }) : baseConfig
    );
    storeCache.set(key, store);
  }
  return storeCache.get(key)();
};
function createContext2(rootComponentName, defaultContext) {
  const Context = React.createContext(defaultContext);
  const Provider2 = (props) => {
    const { children, ...context } = props;
    const value2 = React.useMemo(() => context, Object.values(context));
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Context.Provider, { value: value2, children });
  };
  Provider2.displayName = rootComponentName + "Provider";
  function useContext2(consumerName) {
    const context = React.useContext(Context);
    if (context) return context;
    if (defaultContext !== void 0) return defaultContext;
    throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
  }
  return [Provider2, useContext2];
}
function createContextScope(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function createContext3(rootComponentName, defaultContext) {
    const BaseContext = React.createContext(defaultContext);
    const index2 = defaultContexts.length;
    defaultContexts = [...defaultContexts, defaultContext];
    const Provider2 = (props) => {
      var _a;
      const { scope, children, ...context } = props;
      const Context = ((_a = scope == null ? void 0 : scope[scopeName]) == null ? void 0 : _a[index2]) || BaseContext;
      const value2 = React.useMemo(() => context, Object.values(context));
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Context.Provider, { value: value2, children });
    };
    Provider2.displayName = rootComponentName + "Provider";
    function useContext2(consumerName, scope) {
      var _a;
      const Context = ((_a = scope == null ? void 0 : scope[scopeName]) == null ? void 0 : _a[index2]) || BaseContext;
      const context = React.useContext(Context);
      if (context) return context;
      if (defaultContext !== void 0) return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    return [Provider2, useContext2];
  }
  const createScope = () => {
    const scopeContexts = defaultContexts.map((defaultContext) => {
      return React.createContext(defaultContext);
    });
    return function useScope(scope) {
      const contexts = (scope == null ? void 0 : scope[scopeName]) || scopeContexts;
      return React.useMemo(
        () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),
        [scope, contexts]
      );
    };
  };
  createScope.scopeName = scopeName;
  return [createContext3, composeContextScopes(createScope, ...createContextScopeDeps)];
}
function composeContextScopes(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1) return baseScope;
  const createScope = () => {
    const scopeHooks = scopes.map((createScope2) => ({
      useScope: createScope2(),
      scopeName: createScope2.scopeName
    }));
    return function useComposedScopes(overrideScopes) {
      const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return { ...nextScopes2, ...currentScope };
      }, {});
      return React.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
    };
  };
  createScope.scopeName = baseScope.scopeName;
  return createScope;
}
function setRef(ref, value2) {
  if (typeof ref === "function") {
    return ref(value2);
  } else if (ref !== null && ref !== void 0) {
    ref.current = value2;
  }
}
function composeRefs(...refs) {
  return (node) => {
    let hasCleanup = false;
    const cleanups = refs.map((ref) => {
      const cleanup = setRef(ref, node);
      if (!hasCleanup && typeof cleanup == "function") {
        hasCleanup = true;
      }
      return cleanup;
    });
    if (hasCleanup) {
      return () => {
        for (let i2 = 0; i2 < cleanups.length; i2++) {
          const cleanup = cleanups[i2];
          if (typeof cleanup == "function") {
            cleanup();
          } else {
            setRef(refs[i2], null);
          }
        }
      };
    }
  };
}
function useComposedRefs(...refs) {
  return React.useCallback(composeRefs(...refs), refs);
}
var Slot = React.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  const childrenArray = React.Children.toArray(children);
  const slottable = childrenArray.find(isSlottable);
  if (slottable) {
    const newElement = slottable.props.children;
    const newChildren = childrenArray.map((child) => {
      if (child === slottable) {
        if (React.Children.count(newElement) > 1) return React.Children.only(null);
        return React.isValidElement(newElement) ? newElement.props.children : null;
      } else {
        return child;
      }
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SlotClone, { ...slotProps, ref: forwardedRef, children: React.isValidElement(newElement) ? React.cloneElement(newElement, void 0, newChildren) : null });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SlotClone, { ...slotProps, ref: forwardedRef, children });
});
Slot.displayName = "Slot";
var SlotClone = React.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  if (React.isValidElement(children)) {
    const childrenRef = getElementRef$1(children);
    return React.cloneElement(children, {
      ...mergeProps(slotProps, children.props),
      // @ts-ignore
      ref: forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef
    });
  }
  return React.Children.count(children) > 1 ? React.Children.only(null) : null;
});
SlotClone.displayName = "SlotClone";
var Slottable = ({ children }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children });
};
function isSlottable(child) {
  return React.isValidElement(child) && child.type === Slottable;
}
function mergeProps(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          childPropValue(...args);
          slotPropValue(...args);
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef$1(element) {
  var _a, _b;
  let getter = (_a = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = (_b = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
function createCollection(name2) {
  const PROVIDER_NAME2 = name2 + "CollectionProvider";
  const [createCollectionContext, createCollectionScope2] = createContextScope(PROVIDER_NAME2);
  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext(
    PROVIDER_NAME2,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  );
  const CollectionProvider = (props) => {
    const { scope, children } = props;
    const ref = React__default.useRef(null);
    const itemMap = React__default.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(CollectionProviderImpl, { scope, itemMap, collectionRef: ref, children });
  };
  CollectionProvider.displayName = PROVIDER_NAME2;
  const COLLECTION_SLOT_NAME = name2 + "CollectionSlot";
  const CollectionSlot = React__default.forwardRef(
    (props, forwardedRef) => {
      const { scope, children } = props;
      const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);
      const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Slot, { ref: composedRefs, children });
    }
  );
  CollectionSlot.displayName = COLLECTION_SLOT_NAME;
  const ITEM_SLOT_NAME = name2 + "CollectionItemSlot";
  const ITEM_DATA_ATTR = "data-radix-collection-item";
  const CollectionItemSlot = React__default.forwardRef(
    (props, forwardedRef) => {
      const { scope, children, ...itemData } = props;
      const ref = React__default.useRef(null);
      const composedRefs = useComposedRefs(forwardedRef, ref);
      const context = useCollectionContext(ITEM_SLOT_NAME, scope);
      React__default.useEffect(() => {
        context.itemMap.set(ref, { ref, ...itemData });
        return () => void context.itemMap.delete(ref);
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Slot, { ...{ [ITEM_DATA_ATTR]: "" }, ref: composedRefs, children });
    }
  );
  CollectionItemSlot.displayName = ITEM_SLOT_NAME;
  function useCollection2(scope) {
    const context = useCollectionContext(name2 + "CollectionConsumer", scope);
    const getItems = React__default.useCallback(() => {
      const collectionNode = context.collectionRef.current;
      if (!collectionNode) return [];
      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));
      const items = Array.from(context.itemMap.values());
      const orderedItems = items.sort(
        (a, b) => orderedNodes.indexOf(a.ref.current) - orderedNodes.indexOf(b.ref.current)
      );
      return orderedItems;
    }, [context.collectionRef, context.itemMap]);
    return getItems;
  }
  return [
    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },
    useCollection2,
    createCollectionScope2
  ];
}
function composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler == null ? void 0 : originalEventHandler(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented) {
      return ourEventHandler == null ? void 0 : ourEventHandler(event);
    }
  };
}
function useCallbackRef$1(callback) {
  const callbackRef = React.useRef(callback);
  React.useEffect(() => {
    callbackRef.current = callback;
  });
  return React.useMemo(() => (...args) => {
    var _a;
    return (_a = callbackRef.current) == null ? void 0 : _a.call(callbackRef, ...args);
  }, []);
}
function useControllableState({
  prop,
  defaultProp,
  onChange = () => {
  }
}) {
  const [uncontrolledProp, setUncontrolledProp] = useUncontrolledState({ defaultProp, onChange });
  const isControlled = prop !== void 0;
  const value2 = isControlled ? prop : uncontrolledProp;
  const handleChange = useCallbackRef$1(onChange);
  const setValue = React.useCallback(
    (nextValue) => {
      if (isControlled) {
        const setter = nextValue;
        const value22 = typeof nextValue === "function" ? setter(prop) : nextValue;
        if (value22 !== prop) handleChange(value22);
      } else {
        setUncontrolledProp(nextValue);
      }
    },
    [isControlled, prop, setUncontrolledProp, handleChange]
  );
  return [value2, setValue];
}
function useUncontrolledState({
  defaultProp,
  onChange
}) {
  const uncontrolledState = React.useState(defaultProp);
  const [value2] = uncontrolledState;
  const prevValueRef = React.useRef(value2);
  const handleChange = useCallbackRef$1(onChange);
  React.useEffect(() => {
    if (prevValueRef.current !== value2) {
      handleChange(value2);
      prevValueRef.current = value2;
    }
  }, [value2, prevValueRef, handleChange]);
  return uncontrolledState;
}
var NODES = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
];
var Primitive = NODES.reduce((primitive, node) => {
  const Node2 = React.forwardRef((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? Slot : node;
    if (typeof window !== "undefined") {
      window[Symbol.for("radix-ui")] = true;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Comp, { ...primitiveProps, ref: forwardedRef });
  });
  Node2.displayName = `Primitive.${node}`;
  return { ...primitive, [node]: Node2 };
}, {});
function dispatchDiscreteCustomEvent(target2, event) {
  if (target2) ReactDOM.flushSync(() => target2.dispatchEvent(event));
}
var useLayoutEffect2 = Boolean(globalThis == null ? void 0 : globalThis.document) ? React.useLayoutEffect : () => {
};
function useStateMachine$1(initialState2, machine) {
  return React.useReducer((state, event) => {
    const nextState = machine[state][event];
    return nextState ?? state;
  }, initialState2);
}
var Presence = (props) => {
  const { present, children } = props;
  const presence = usePresence(present);
  const child = typeof children === "function" ? children({ present: presence.isPresent }) : React.Children.only(children);
  const ref = useComposedRefs(presence.ref, getElementRef(child));
  const forceMount = typeof children === "function";
  return forceMount || presence.isPresent ? React.cloneElement(child, { ref }) : null;
};
Presence.displayName = "Presence";
function usePresence(present) {
  const [node, setNode] = React.useState();
  const stylesRef = React.useRef({});
  const prevPresentRef = React.useRef(present);
  const prevAnimationNameRef = React.useRef("none");
  const initialState2 = present ? "mounted" : "unmounted";
  const [state, send] = useStateMachine$1(initialState2, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  React.useEffect(() => {
    const currentAnimationName = getAnimationName(stylesRef.current);
    prevAnimationNameRef.current = state === "mounted" ? currentAnimationName : "none";
  }, [state]);
  useLayoutEffect2(() => {
    const styles = stylesRef.current;
    const wasPresent = prevPresentRef.current;
    const hasPresentChanged = wasPresent !== present;
    if (hasPresentChanged) {
      const prevAnimationName = prevAnimationNameRef.current;
      const currentAnimationName = getAnimationName(styles);
      if (present) {
        send("MOUNT");
      } else if (currentAnimationName === "none" || (styles == null ? void 0 : styles.display) === "none") {
        send("UNMOUNT");
      } else {
        const isAnimating = prevAnimationName !== currentAnimationName;
        if (wasPresent && isAnimating) {
          send("ANIMATION_OUT");
        } else {
          send("UNMOUNT");
        }
      }
      prevPresentRef.current = present;
    }
  }, [present, send]);
  useLayoutEffect2(() => {
    if (node) {
      let timeoutId;
      const ownerWindow = node.ownerDocument.defaultView ?? window;
      const handleAnimationEnd = (event) => {
        const currentAnimationName = getAnimationName(stylesRef.current);
        const isCurrentAnimation = currentAnimationName.includes(event.animationName);
        if (event.target === node && isCurrentAnimation) {
          send("ANIMATION_END");
          if (!prevPresentRef.current) {
            const currentFillMode = node.style.animationFillMode;
            node.style.animationFillMode = "forwards";
            timeoutId = ownerWindow.setTimeout(() => {
              if (node.style.animationFillMode === "forwards") {
                node.style.animationFillMode = currentFillMode;
              }
            });
          }
        }
      };
      const handleAnimationStart = (event) => {
        if (event.target === node) {
          prevAnimationNameRef.current = getAnimationName(stylesRef.current);
        }
      };
      node.addEventListener("animationstart", handleAnimationStart);
      node.addEventListener("animationcancel", handleAnimationEnd);
      node.addEventListener("animationend", handleAnimationEnd);
      return () => {
        ownerWindow.clearTimeout(timeoutId);
        node.removeEventListener("animationstart", handleAnimationStart);
        node.removeEventListener("animationcancel", handleAnimationEnd);
        node.removeEventListener("animationend", handleAnimationEnd);
      };
    } else {
      send("ANIMATION_END");
    }
  }, [node, send]);
  return {
    isPresent: ["mounted", "unmountSuspended"].includes(state),
    ref: React.useCallback((node2) => {
      if (node2) stylesRef.current = getComputedStyle(node2);
      setNode(node2);
    }, [])
  };
}
function getAnimationName(styles) {
  return (styles == null ? void 0 : styles.animationName) || "none";
}
function getElementRef(element) {
  var _a, _b;
  let getter = (_a = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = (_b = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
var useReactId = React["useId".toString()] || (() => void 0);
var count$4 = 0;
function useId$1(deterministicId) {
  const [id2, setId] = React.useState(useReactId());
  useLayoutEffect2(() => {
    setId((reactId) => reactId ?? String(count$4++));
  }, [deterministicId]);
  return id2 ? `radix-${id2}` : "";
}
var COLLAPSIBLE_NAME = "Collapsible";
var [createCollapsibleContext, createCollapsibleScope] = createContextScope(COLLAPSIBLE_NAME);
var [CollapsibleProvider, useCollapsibleContext] = createCollapsibleContext(COLLAPSIBLE_NAME);
var Collapsible = React.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeCollapsible,
      open: openProp,
      defaultOpen,
      disabled,
      onOpenChange,
      ...collapsibleProps
    } = props;
    const [open = false, setOpen] = useControllableState({
      prop: openProp,
      defaultProp: defaultOpen,
      onChange: onOpenChange
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      CollapsibleProvider,
      {
        scope: __scopeCollapsible,
        disabled,
        contentId: useId$1(),
        open,
        onOpenToggle: React.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.div,
          {
            "data-state": getState$6(open),
            "data-disabled": disabled ? "" : void 0,
            ...collapsibleProps,
            ref: forwardedRef
          }
        )
      }
    );
  }
);
Collapsible.displayName = COLLAPSIBLE_NAME;
var TRIGGER_NAME$8 = "CollapsibleTrigger";
var CollapsibleTrigger = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeCollapsible, ...triggerProps } = props;
    const context = useCollapsibleContext(TRIGGER_NAME$8, __scopeCollapsible);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        "aria-controls": context.contentId,
        "aria-expanded": context.open || false,
        "data-state": getState$6(context.open),
        "data-disabled": context.disabled ? "" : void 0,
        disabled: context.disabled,
        ...triggerProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, context.onOpenToggle)
      }
    );
  }
);
CollapsibleTrigger.displayName = TRIGGER_NAME$8;
var CONTENT_NAME$a = "CollapsibleContent";
var CollapsibleContent = React.forwardRef(
  (props, forwardedRef) => {
    const { forceMount, ...contentProps } = props;
    const context = useCollapsibleContext(CONTENT_NAME$a, props.__scopeCollapsible);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: ({ present }) => /* @__PURE__ */ jsxRuntimeExports.jsx(CollapsibleContentImpl, { ...contentProps, ref: forwardedRef, present }) });
  }
);
CollapsibleContent.displayName = CONTENT_NAME$a;
var CollapsibleContentImpl = React.forwardRef((props, forwardedRef) => {
  const { __scopeCollapsible, present, children, ...contentProps } = props;
  const context = useCollapsibleContext(CONTENT_NAME$a, __scopeCollapsible);
  const [isPresent, setIsPresent] = React.useState(present);
  const ref = React.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  const heightRef = React.useRef(0);
  const height = heightRef.current;
  const widthRef = React.useRef(0);
  const width = widthRef.current;
  const isOpen = context.open || isPresent;
  const isMountAnimationPreventedRef = React.useRef(isOpen);
  const originalStylesRef = React.useRef(void 0);
  React.useEffect(() => {
    const rAF = requestAnimationFrame(() => isMountAnimationPreventedRef.current = false);
    return () => cancelAnimationFrame(rAF);
  }, []);
  useLayoutEffect2(() => {
    const node = ref.current;
    if (node) {
      originalStylesRef.current = originalStylesRef.current || {
        transitionDuration: node.style.transitionDuration,
        animationName: node.style.animationName
      };
      node.style.transitionDuration = "0s";
      node.style.animationName = "none";
      const rect = node.getBoundingClientRect();
      heightRef.current = rect.height;
      widthRef.current = rect.width;
      if (!isMountAnimationPreventedRef.current) {
        node.style.transitionDuration = originalStylesRef.current.transitionDuration;
        node.style.animationName = originalStylesRef.current.animationName;
      }
      setIsPresent(present);
    }
  }, [context.open, present]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive.div,
    {
      "data-state": getState$6(context.open),
      "data-disabled": context.disabled ? "" : void 0,
      id: context.contentId,
      hidden: !isOpen,
      ...contentProps,
      ref: composedRefs,
      style: {
        [`--radix-collapsible-content-height`]: height ? `${height}px` : void 0,
        [`--radix-collapsible-content-width`]: width ? `${width}px` : void 0,
        ...props.style
      },
      children: isOpen && children
    }
  );
});
function getState$6(open) {
  return open ? "open" : "closed";
}
var Root$b = Collapsible;
var Trigger$7 = CollapsibleTrigger;
var Content$4 = CollapsibleContent;
var DirectionContext = React.createContext(void 0);
function useDirection(localDir) {
  const globalDir = React.useContext(DirectionContext);
  return localDir || globalDir || "ltr";
}
var ACCORDION_NAME = "Accordion";
var ACCORDION_KEYS = ["Home", "End", "ArrowDown", "ArrowUp", "ArrowLeft", "ArrowRight"];
var [Collection$5, useCollection$5, createCollectionScope$5] = createCollection(ACCORDION_NAME);
var [createAccordionContext, createAccordionScope] = createContextScope(ACCORDION_NAME, [
  createCollectionScope$5,
  createCollapsibleScope
]);
var useCollapsibleScope = createCollapsibleScope();
var Accordion$1 = React__default.forwardRef(
  (props, forwardedRef) => {
    const { type: type2, ...accordionProps } = props;
    const singleProps = accordionProps;
    const multipleProps = accordionProps;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$5.Provider, { scope: props.__scopeAccordion, children: type2 === "multiple" ? /* @__PURE__ */ jsxRuntimeExports.jsx(AccordionImplMultiple, { ...multipleProps, ref: forwardedRef }) : /* @__PURE__ */ jsxRuntimeExports.jsx(AccordionImplSingle, { ...singleProps, ref: forwardedRef }) });
  }
);
Accordion$1.displayName = ACCORDION_NAME;
var [AccordionValueProvider, useAccordionValueContext] = createAccordionContext(ACCORDION_NAME);
var [AccordionCollapsibleProvider, useAccordionCollapsibleContext] = createAccordionContext(
  ACCORDION_NAME,
  { collapsible: false }
);
var AccordionImplSingle = React__default.forwardRef(
  (props, forwardedRef) => {
    const {
      value: valueProp,
      defaultValue,
      onValueChange = () => {
      },
      collapsible = false,
      ...accordionSingleProps
    } = props;
    const [value2, setValue] = useControllableState({
      prop: valueProp,
      defaultProp: defaultValue,
      onChange: onValueChange
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      AccordionValueProvider,
      {
        scope: props.__scopeAccordion,
        value: value2 ? [value2] : [],
        onItemOpen: setValue,
        onItemClose: React__default.useCallback(() => collapsible && setValue(""), [collapsible, setValue]),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(AccordionCollapsibleProvider, { scope: props.__scopeAccordion, collapsible, children: /* @__PURE__ */ jsxRuntimeExports.jsx(AccordionImpl, { ...accordionSingleProps, ref: forwardedRef }) })
      }
    );
  }
);
var AccordionImplMultiple = React__default.forwardRef((props, forwardedRef) => {
  const {
    value: valueProp,
    defaultValue,
    onValueChange = () => {
    },
    ...accordionMultipleProps
  } = props;
  const [value2 = [], setValue] = useControllableState({
    prop: valueProp,
    defaultProp: defaultValue,
    onChange: onValueChange
  });
  const handleItemOpen = React__default.useCallback(
    (itemValue) => setValue((prevValue = []) => [...prevValue, itemValue]),
    [setValue]
  );
  const handleItemClose = React__default.useCallback(
    (itemValue) => setValue((prevValue = []) => prevValue.filter((value22) => value22 !== itemValue)),
    [setValue]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    AccordionValueProvider,
    {
      scope: props.__scopeAccordion,
      value: value2,
      onItemOpen: handleItemOpen,
      onItemClose: handleItemClose,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(AccordionCollapsibleProvider, { scope: props.__scopeAccordion, collapsible: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(AccordionImpl, { ...accordionMultipleProps, ref: forwardedRef }) })
    }
  );
});
var [AccordionImplProvider, useAccordionContext] = createAccordionContext(ACCORDION_NAME);
var AccordionImpl = React__default.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAccordion, disabled, dir, orientation = "vertical", ...accordionProps } = props;
    const accordionRef = React__default.useRef(null);
    const composedRefs = useComposedRefs(accordionRef, forwardedRef);
    const getItems = useCollection$5(__scopeAccordion);
    const direction = useDirection(dir);
    const isDirectionLTR = direction === "ltr";
    const handleKeyDown = composeEventHandlers(props.onKeyDown, (event) => {
      var _a;
      if (!ACCORDION_KEYS.includes(event.key)) return;
      const target2 = event.target;
      const triggerCollection = getItems().filter((item) => {
        var _a2;
        return !((_a2 = item.ref.current) == null ? void 0 : _a2.disabled);
      });
      const triggerIndex = triggerCollection.findIndex((item) => item.ref.current === target2);
      const triggerCount = triggerCollection.length;
      if (triggerIndex === -1) return;
      event.preventDefault();
      let nextIndex = triggerIndex;
      const homeIndex = 0;
      const endIndex = triggerCount - 1;
      const moveNext = () => {
        nextIndex = triggerIndex + 1;
        if (nextIndex > endIndex) {
          nextIndex = homeIndex;
        }
      };
      const movePrev = () => {
        nextIndex = triggerIndex - 1;
        if (nextIndex < homeIndex) {
          nextIndex = endIndex;
        }
      };
      switch (event.key) {
        case "Home":
          nextIndex = homeIndex;
          break;
        case "End":
          nextIndex = endIndex;
          break;
        case "ArrowRight":
          if (orientation === "horizontal") {
            if (isDirectionLTR) {
              moveNext();
            } else {
              movePrev();
            }
          }
          break;
        case "ArrowDown":
          if (orientation === "vertical") {
            moveNext();
          }
          break;
        case "ArrowLeft":
          if (orientation === "horizontal") {
            if (isDirectionLTR) {
              movePrev();
            } else {
              moveNext();
            }
          }
          break;
        case "ArrowUp":
          if (orientation === "vertical") {
            movePrev();
          }
          break;
      }
      const clampedIndex = nextIndex % triggerCount;
      (_a = triggerCollection[clampedIndex].ref.current) == null ? void 0 : _a.focus();
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      AccordionImplProvider,
      {
        scope: __scopeAccordion,
        disabled,
        direction: dir,
        orientation,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$5.Slot, { scope: __scopeAccordion, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.div,
          {
            ...accordionProps,
            "data-orientation": orientation,
            ref: composedRefs,
            onKeyDown: disabled ? void 0 : handleKeyDown
          }
        ) })
      }
    );
  }
);
var ITEM_NAME$6 = "AccordionItem";
var [AccordionItemProvider, useAccordionItemContext] = createAccordionContext(ITEM_NAME$6);
var AccordionItem$1 = React__default.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAccordion, value: value2, ...accordionItemProps } = props;
    const accordionContext = useAccordionContext(ITEM_NAME$6, __scopeAccordion);
    const valueContext = useAccordionValueContext(ITEM_NAME$6, __scopeAccordion);
    const collapsibleScope = useCollapsibleScope(__scopeAccordion);
    const triggerId = useId$1();
    const open = value2 && valueContext.value.includes(value2) || false;
    const disabled = accordionContext.disabled || props.disabled;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      AccordionItemProvider,
      {
        scope: __scopeAccordion,
        open,
        disabled,
        triggerId,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Root$b,
          {
            "data-orientation": accordionContext.orientation,
            "data-state": getState$5(open),
            ...collapsibleScope,
            ...accordionItemProps,
            ref: forwardedRef,
            disabled,
            open,
            onOpenChange: (open2) => {
              if (open2) {
                valueContext.onItemOpen(value2);
              } else {
                valueContext.onItemClose(value2);
              }
            }
          }
        )
      }
    );
  }
);
AccordionItem$1.displayName = ITEM_NAME$6;
var HEADER_NAME = "AccordionHeader";
var AccordionHeader = React__default.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAccordion, ...headerProps } = props;
    const accordionContext = useAccordionContext(ACCORDION_NAME, __scopeAccordion);
    const itemContext = useAccordionItemContext(HEADER_NAME, __scopeAccordion);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.h3,
      {
        "data-orientation": accordionContext.orientation,
        "data-state": getState$5(itemContext.open),
        "data-disabled": itemContext.disabled ? "" : void 0,
        ...headerProps,
        ref: forwardedRef
      }
    );
  }
);
AccordionHeader.displayName = HEADER_NAME;
var TRIGGER_NAME$7 = "AccordionTrigger";
var AccordionTrigger$1 = React__default.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAccordion, ...triggerProps } = props;
    const accordionContext = useAccordionContext(ACCORDION_NAME, __scopeAccordion);
    const itemContext = useAccordionItemContext(TRIGGER_NAME$7, __scopeAccordion);
    const collapsibleContext = useAccordionCollapsibleContext(TRIGGER_NAME$7, __scopeAccordion);
    const collapsibleScope = useCollapsibleScope(__scopeAccordion);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$5.ItemSlot, { scope: __scopeAccordion, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Trigger$7,
      {
        "aria-disabled": itemContext.open && !collapsibleContext.collapsible || void 0,
        "data-orientation": accordionContext.orientation,
        id: itemContext.triggerId,
        ...collapsibleScope,
        ...triggerProps,
        ref: forwardedRef
      }
    ) });
  }
);
AccordionTrigger$1.displayName = TRIGGER_NAME$7;
var CONTENT_NAME$9 = "AccordionContent";
var AccordionContent$1 = React__default.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAccordion, ...contentProps } = props;
    const accordionContext = useAccordionContext(ACCORDION_NAME, __scopeAccordion);
    const itemContext = useAccordionItemContext(CONTENT_NAME$9, __scopeAccordion);
    const collapsibleScope = useCollapsibleScope(__scopeAccordion);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Content$4,
      {
        role: "region",
        "aria-labelledby": itemContext.triggerId,
        "data-orientation": accordionContext.orientation,
        ...collapsibleScope,
        ...contentProps,
        ref: forwardedRef,
        style: {
          ["--radix-accordion-content-height"]: "var(--radix-collapsible-content-height)",
          ["--radix-accordion-content-width"]: "var(--radix-collapsible-content-width)",
          ...props.style
        }
      }
    );
  }
);
AccordionContent$1.displayName = CONTENT_NAME$9;
function getState$5(open) {
  return open ? "open" : "closed";
}
var Root2$8 = Accordion$1;
var Item$3 = AccordionItem$1;
var Header$1 = AccordionHeader;
var Trigger2 = AccordionTrigger$1;
var Content2$5 = AccordionContent$1;
const Accordion = Root2$8;
const AccordionItem = forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(Item$3, { ref, className: cn("", className), ...props }));
AccordionItem.displayName = "AccordionItem";
const AccordionTrigger = forwardRef(
  ({ className, children, arrowDownIconWrap, arrowSize = "w-4 h-4", ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(Header$1, { className: "flex", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Trigger2,
    {
      ref,
      className: cn(
        "flex flex-1 items-center justify-between py-4 font-medium transition-all [&[data-state=open]>svg.arrow]:rotate-180",
        arrowDownIconWrap && "[&[data-state=open]>div>svg.arrow]:rotate-180",
        className
      ),
      ...props,
      children: [
        children,
        arrowDownIconWrap ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-3", children: /* @__PURE__ */ jsxRuntimeExports.jsx(SvgArrowDown, { className: "arrow h-6 w-6 shrink-0 transition-transform duration-200" }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
          SvgArrowDown,
          {
            className: cn(
              `${arrowSize} arrow shrink-0 transition-transform duration-200`
            )
          }
        )
      ]
    }
  ) })
);
AccordionTrigger.displayName = Trigger2.displayName;
const AccordionContent = forwardRef(
  ({ className, children, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    Content2$5,
    {
      ref,
      className: "overflow-hidden transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down",
      ...props,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cn("pt-0", className), children })
    }
  )
);
AccordionContent.displayName = Content2$5.displayName;
const falsyToString = (value2) => typeof value2 === "boolean" ? `${value2}` : value2 === 0 ? "0" : value2;
const cx = clsx$2;
const cva = (base, config) => (props) => {
  var _config_compoundVariants;
  if ((config === null || config === void 0 ? void 0 : config.variants) == null) return cx(base, props === null || props === void 0 ? void 0 : props.class, props === null || props === void 0 ? void 0 : props.className);
  const { variants, defaultVariants } = config;
  const getVariantClassNames = Object.keys(variants).map((variant) => {
    const variantProp = props === null || props === void 0 ? void 0 : props[variant];
    const defaultVariantProp = defaultVariants === null || defaultVariants === void 0 ? void 0 : defaultVariants[variant];
    if (variantProp === null) return null;
    const variantKey = falsyToString(variantProp) || falsyToString(defaultVariantProp);
    return variants[variant][variantKey];
  });
  const propsWithoutUndefined = props && Object.entries(props).reduce((acc, param) => {
    let [key, value2] = param;
    if (value2 === void 0) {
      return acc;
    }
    acc[key] = value2;
    return acc;
  }, {});
  const getCompoundVariantClassNames = config === null || config === void 0 ? void 0 : (_config_compoundVariants = config.compoundVariants) === null || _config_compoundVariants === void 0 ? void 0 : _config_compoundVariants.reduce((acc, param) => {
    let { class: cvClass, className: cvClassName, ...compoundVariantOptions } = param;
    return Object.entries(compoundVariantOptions).every((param2) => {
      let [key, value2] = param2;
      return Array.isArray(value2) ? value2.includes({
        ...defaultVariants,
        ...propsWithoutUndefined
      }[key]) : {
        ...defaultVariants,
        ...propsWithoutUndefined
      }[key] === value2;
    }) ? [
      ...acc,
      cvClass,
      cvClassName
    ] : acc;
  }, []);
  return cx(base, getVariantClassNames, getCompoundVariantClassNames, props === null || props === void 0 ? void 0 : props.class, props === null || props === void 0 ? void 0 : props.className);
};
const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default: "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary: "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive: "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
);
function Badge({ className, variant, ...props }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cn(badgeVariants({ variant }), className), ...props });
}
const buttonVariants = cva(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-bold ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-40",
  {
    variants: {
      variant: {
        default: "bg-primary text-grayscale-1000 hover:bg-primary/90",
        destructive: "bg-grayscale-600 dark:bg-dark-grayscale-600 dark:text-dark-grayscale-100 text-grayscale-100 hover:bg-grayscale-600/80",
        outline: "border text-primary dark:border-dark-primary border-primary bg-transparent hover:bg-accent hover:text-accent-foreground",
        secondary: "bg-primary-10 dark:bg-dark-primary-15 dark:text-dark-primary text-primary hover:bg-primary/20 dark:hover:bg-dark-primary/20",
        ghost: "hover:bg-dark-grayscale-600 text-primary hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline"
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3 text-xs",
        lg: "h-14 rounded-md px-8 text-lg",
        icon: "h-10 w-10"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
);
const Button$1 = forwardRef(
  ({ className, variant, size: size2, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button";
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Comp,
      {
        className: cn(buttonVariants({ variant, size: size2, className })),
        ref,
        ...props
      }
    );
  }
);
Button$1.displayName = "Button";
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p)) t2[p] = s2[p];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function __rest(s2, e) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0)
    t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2]))
        t2[p[i2]] = s2[p[i2]];
    }
  return t2;
}
function __spreadArray(to, from, pack) {
  for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
    if (ar || !(i2 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
      ar[i2] = from[i2];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
typeof SuppressedError === "function" ? SuppressedError : function(error2, suppressed, message2) {
  var e = new Error(message2);
  return e.name = "SuppressedError", e.error = error2, e.suppressed = suppressed, e;
};
function isDayPickerMultiple(props) {
  return props.mode === "multiple";
}
function isDayPickerRange(props) {
  return props.mode === "range";
}
function isDayPickerSingle(props) {
  return props.mode === "single";
}
var defaultClassNames = {
  root: "rdp",
  multiple_months: "rdp-multiple_months",
  with_weeknumber: "rdp-with_weeknumber",
  vhidden: "rdp-vhidden",
  button_reset: "rdp-button_reset",
  button: "rdp-button",
  caption: "rdp-caption",
  caption_start: "rdp-caption_start",
  caption_end: "rdp-caption_end",
  caption_between: "rdp-caption_between",
  caption_label: "rdp-caption_label",
  caption_dropdowns: "rdp-caption_dropdowns",
  dropdown: "rdp-dropdown",
  dropdown_month: "rdp-dropdown_month",
  dropdown_year: "rdp-dropdown_year",
  dropdown_icon: "rdp-dropdown_icon",
  months: "rdp-months",
  month: "rdp-month",
  table: "rdp-table",
  tbody: "rdp-tbody",
  tfoot: "rdp-tfoot",
  head: "rdp-head",
  head_row: "rdp-head_row",
  head_cell: "rdp-head_cell",
  nav: "rdp-nav",
  nav_button: "rdp-nav_button",
  nav_button_previous: "rdp-nav_button_previous",
  nav_button_next: "rdp-nav_button_next",
  nav_icon: "rdp-nav_icon",
  row: "rdp-row",
  weeknumber: "rdp-weeknumber",
  cell: "rdp-cell",
  day: "rdp-day",
  day_today: "rdp-day_today",
  day_outside: "rdp-day_outside",
  day_selected: "rdp-day_selected",
  day_disabled: "rdp-day_disabled",
  day_hidden: "rdp-day_hidden",
  day_range_start: "rdp-day_range_start",
  day_range_end: "rdp-day_range_end",
  day_range_middle: "rdp-day_range_middle"
};
function formatCaption(month2, options) {
  return format(month2, "LLLL y", options);
}
function formatDay(day2, options) {
  return format(day2, "d", options);
}
function formatMonthCaption(month2, options) {
  return format(month2, "LLLL", options);
}
function formatWeekNumber(weekNumber) {
  return "".concat(weekNumber);
}
function formatWeekdayName(weekday, options) {
  return format(weekday, "cccccc", options);
}
function formatYearCaption(year, options) {
  return format(year, "yyyy", options);
}
var formatters = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  formatCaption,
  formatDay,
  formatMonthCaption,
  formatWeekNumber,
  formatWeekdayName,
  formatYearCaption
});
var labelDay = function(day2, activeModifiers, options) {
  return format(day2, "do MMMM (EEEE)", options);
};
var labelMonthDropdown = function() {
  return "Month: ";
};
var labelNext = function() {
  return "Go to next month";
};
var labelPrevious = function() {
  return "Go to previous month";
};
var labelWeekday = function(day2, options) {
  return format(day2, "cccc", options);
};
var labelWeekNumber = function(n2) {
  return "Week n. ".concat(n2);
};
var labelYearDropdown = function() {
  return "Year: ";
};
var labels = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  labelDay,
  labelMonthDropdown,
  labelNext,
  labelPrevious,
  labelWeekNumber,
  labelWeekday,
  labelYearDropdown
});
function getDefaultContextValues() {
  var captionLayout = "buttons";
  var classNames = defaultClassNames;
  var locale = enUS;
  var modifiersClassNames = {};
  var modifiers = {};
  var numberOfMonths = 1;
  var styles = {};
  var today = /* @__PURE__ */ new Date();
  return {
    captionLayout,
    classNames,
    formatters,
    labels,
    locale,
    modifiersClassNames,
    modifiers,
    numberOfMonths,
    styles,
    today,
    mode: "default"
  };
}
function parseFromToProps(props) {
  var fromYear = props.fromYear, toYear = props.toYear, fromMonth = props.fromMonth, toMonth = props.toMonth;
  var fromDate = props.fromDate, toDate2 = props.toDate;
  if (fromMonth) {
    fromDate = startOfMonth(fromMonth);
  } else if (fromYear) {
    fromDate = new Date(fromYear, 0, 1);
  }
  if (toMonth) {
    toDate2 = endOfMonth(toMonth);
  } else if (toYear) {
    toDate2 = new Date(toYear, 11, 31);
  }
  return {
    fromDate: fromDate ? startOfDay(fromDate) : void 0,
    toDate: toDate2 ? startOfDay(toDate2) : void 0
  };
}
var DayPickerContext = createContext(void 0);
function DayPickerProvider(props) {
  var _a;
  var initialProps = props.initialProps;
  var defaultContextValues = getDefaultContextValues();
  var _b = parseFromToProps(initialProps), fromDate = _b.fromDate, toDate2 = _b.toDate;
  var captionLayout = (_a = initialProps.captionLayout) !== null && _a !== void 0 ? _a : defaultContextValues.captionLayout;
  if (captionLayout !== "buttons" && (!fromDate || !toDate2)) {
    captionLayout = "buttons";
  }
  var onSelect;
  if (isDayPickerSingle(initialProps) || isDayPickerMultiple(initialProps) || isDayPickerRange(initialProps)) {
    onSelect = initialProps.onSelect;
  }
  var value2 = __assign(__assign(__assign({}, defaultContextValues), initialProps), { captionLayout, classNames: __assign(__assign({}, defaultContextValues.classNames), initialProps.classNames), components: __assign({}, initialProps.components), formatters: __assign(__assign({}, defaultContextValues.formatters), initialProps.formatters), fromDate, labels: __assign(__assign({}, defaultContextValues.labels), initialProps.labels), mode: initialProps.mode || defaultContextValues.mode, modifiers: __assign(__assign({}, defaultContextValues.modifiers), initialProps.modifiers), modifiersClassNames: __assign(__assign({}, defaultContextValues.modifiersClassNames), initialProps.modifiersClassNames), onSelect, styles: __assign(__assign({}, defaultContextValues.styles), initialProps.styles), toDate: toDate2 });
  return jsxRuntimeExports.jsx(DayPickerContext.Provider, { value: value2, children: props.children });
}
function useDayPicker() {
  var context = useContext(DayPickerContext);
  if (!context) {
    throw new Error("useDayPicker must be used within a DayPickerProvider.");
  }
  return context;
}
function CaptionLabel(props) {
  var _a = useDayPicker(), locale = _a.locale, classNames = _a.classNames, styles = _a.styles, formatCaption2 = _a.formatters.formatCaption;
  return jsxRuntimeExports.jsx("div", { className: classNames.caption_label, style: styles.caption_label, "aria-live": "polite", role: "presentation", id: props.id, children: formatCaption2(props.displayMonth, { locale }) });
}
function IconDropdown(props) {
  return jsxRuntimeExports.jsx("svg", __assign({ width: "8px", height: "8px", viewBox: "0 0 120 120", "data-testid": "iconDropdown" }, props, { children: jsxRuntimeExports.jsx("path", { d: "M4.22182541,48.2218254 C8.44222828,44.0014225 15.2388494,43.9273804 19.5496459,47.9996989 L19.7781746,48.2218254 L60,88.443 L100.221825,48.2218254 C104.442228,44.0014225 111.238849,43.9273804 115.549646,47.9996989 L115.778175,48.2218254 C119.998577,52.4422283 120.07262,59.2388494 116.000301,63.5496459 L115.778175,63.7781746 L67.7781746,111.778175 C63.5577717,115.998577 56.7611506,116.07262 52.4503541,112.000301 L52.2218254,111.778175 L4.22182541,63.7781746 C-0.0739418023,59.4824074 -0.0739418023,52.5175926 4.22182541,48.2218254 Z", fill: "currentColor", fillRule: "nonzero" }) }));
}
function Dropdown(props) {
  var _a, _b;
  var onChange = props.onChange, value2 = props.value, children = props.children, caption = props.caption, className = props.className, style = props.style;
  var dayPicker = useDayPicker();
  var IconDropdownComponent = (_b = (_a = dayPicker.components) === null || _a === void 0 ? void 0 : _a.IconDropdown) !== null && _b !== void 0 ? _b : IconDropdown;
  return jsxRuntimeExports.jsxs("div", { className, style, children: [jsxRuntimeExports.jsx("span", { className: dayPicker.classNames.vhidden, children: props["aria-label"] }), jsxRuntimeExports.jsx("select", { name: props.name, "aria-label": props["aria-label"], className: dayPicker.classNames.dropdown, style: dayPicker.styles.dropdown, value: value2, onChange, children }), jsxRuntimeExports.jsxs("div", { className: dayPicker.classNames.caption_label, style: dayPicker.styles.caption_label, "aria-hidden": "true", children: [caption, jsxRuntimeExports.jsx(IconDropdownComponent, { className: dayPicker.classNames.dropdown_icon, style: dayPicker.styles.dropdown_icon })] })] });
}
function MonthsDropdown(props) {
  var _a;
  var _b = useDayPicker(), fromDate = _b.fromDate, toDate2 = _b.toDate, styles = _b.styles, locale = _b.locale, formatMonthCaption2 = _b.formatters.formatMonthCaption, classNames = _b.classNames, components = _b.components, labelMonthDropdown2 = _b.labels.labelMonthDropdown;
  if (!fromDate)
    return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});
  if (!toDate2)
    return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});
  var dropdownMonths = [];
  if (isSameYear(fromDate, toDate2)) {
    var date = startOfMonth(fromDate);
    for (var month2 = fromDate.getMonth(); month2 <= toDate2.getMonth(); month2++) {
      dropdownMonths.push(setMonth(date, month2));
    }
  } else {
    var date = startOfMonth(/* @__PURE__ */ new Date());
    for (var month2 = 0; month2 <= 11; month2++) {
      dropdownMonths.push(setMonth(date, month2));
    }
  }
  var handleChange = function(e) {
    var selectedMonth = Number(e.target.value);
    var newMonth = setMonth(startOfMonth(props.displayMonth), selectedMonth);
    props.onChange(newMonth);
  };
  var DropdownComponent = (_a = components === null || components === void 0 ? void 0 : components.Dropdown) !== null && _a !== void 0 ? _a : Dropdown;
  return jsxRuntimeExports.jsx(DropdownComponent, { name: "months", "aria-label": labelMonthDropdown2(), className: classNames.dropdown_month, style: styles.dropdown_month, onChange: handleChange, value: props.displayMonth.getMonth(), caption: formatMonthCaption2(props.displayMonth, { locale }), children: dropdownMonths.map(function(m) {
    return jsxRuntimeExports.jsx("option", { value: m.getMonth(), children: formatMonthCaption2(m, { locale }) }, m.getMonth());
  }) });
}
function YearsDropdown(props) {
  var _a;
  var displayMonth = props.displayMonth;
  var _b = useDayPicker(), fromDate = _b.fromDate, toDate2 = _b.toDate, locale = _b.locale, styles = _b.styles, classNames = _b.classNames, components = _b.components, formatYearCaption2 = _b.formatters.formatYearCaption, labelYearDropdown2 = _b.labels.labelYearDropdown;
  var years2 = [];
  if (!fromDate)
    return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});
  if (!toDate2)
    return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});
  var fromYear = fromDate.getFullYear();
  var toYear = toDate2.getFullYear();
  for (var year = fromYear; year <= toYear; year++) {
    years2.push(setYear(startOfYear(/* @__PURE__ */ new Date()), year));
  }
  var handleChange = function(e) {
    var newMonth = setYear(startOfMonth(displayMonth), Number(e.target.value));
    props.onChange(newMonth);
  };
  var DropdownComponent = (_a = components === null || components === void 0 ? void 0 : components.Dropdown) !== null && _a !== void 0 ? _a : Dropdown;
  return jsxRuntimeExports.jsx(DropdownComponent, { name: "years", "aria-label": labelYearDropdown2(), className: classNames.dropdown_year, style: styles.dropdown_year, onChange: handleChange, value: displayMonth.getFullYear(), caption: formatYearCaption2(displayMonth, { locale }), children: years2.map(function(year2) {
    return jsxRuntimeExports.jsx("option", { value: year2.getFullYear(), children: formatYearCaption2(year2, { locale }) }, year2.getFullYear());
  }) });
}
function useControlledValue(defaultValue, controlledValue) {
  var _a = useState(defaultValue), uncontrolledValue = _a[0], setValue = _a[1];
  var value2 = controlledValue === void 0 ? uncontrolledValue : controlledValue;
  return [value2, setValue];
}
function getInitialMonth(context) {
  var month2 = context.month, defaultMonth = context.defaultMonth, today = context.today;
  var initialMonth = month2 || defaultMonth || today || /* @__PURE__ */ new Date();
  var toDate2 = context.toDate, fromDate = context.fromDate, _a = context.numberOfMonths, numberOfMonths = _a === void 0 ? 1 : _a;
  if (toDate2 && differenceInCalendarMonths(toDate2, initialMonth) < 0) {
    var offset2 = -1 * (numberOfMonths - 1);
    initialMonth = addMonths(toDate2, offset2);
  }
  if (fromDate && differenceInCalendarMonths(initialMonth, fromDate) < 0) {
    initialMonth = fromDate;
  }
  return startOfMonth(initialMonth);
}
function useNavigationState() {
  var context = useDayPicker();
  var initialMonth = getInitialMonth(context);
  var _a = useControlledValue(initialMonth, context.month), month2 = _a[0], setMonth2 = _a[1];
  var goToMonth = function(date) {
    var _a2;
    if (context.disableNavigation)
      return;
    var month3 = startOfMonth(date);
    setMonth2(month3);
    (_a2 = context.onMonthChange) === null || _a2 === void 0 ? void 0 : _a2.call(context, month3);
  };
  return [month2, goToMonth];
}
function getDisplayMonths(month2, _a) {
  var reverseMonths = _a.reverseMonths, numberOfMonths = _a.numberOfMonths;
  var start2 = startOfMonth(month2);
  var end2 = startOfMonth(addMonths(start2, numberOfMonths));
  var monthsDiff = differenceInCalendarMonths(end2, start2);
  var months2 = [];
  for (var i2 = 0; i2 < monthsDiff; i2++) {
    var nextMonth = addMonths(start2, i2);
    months2.push(nextMonth);
  }
  if (reverseMonths)
    months2 = months2.reverse();
  return months2;
}
function getNextMonth(startingMonth, options) {
  if (options.disableNavigation) {
    return void 0;
  }
  var toDate2 = options.toDate, pagedNavigation = options.pagedNavigation, _a = options.numberOfMonths, numberOfMonths = _a === void 0 ? 1 : _a;
  var offset2 = pagedNavigation ? numberOfMonths : 1;
  var month2 = startOfMonth(startingMonth);
  if (!toDate2) {
    return addMonths(month2, offset2);
  }
  var monthsDiff = differenceInCalendarMonths(toDate2, startingMonth);
  if (monthsDiff < numberOfMonths) {
    return void 0;
  }
  return addMonths(month2, offset2);
}
function getPreviousMonth(startingMonth, options) {
  if (options.disableNavigation) {
    return void 0;
  }
  var fromDate = options.fromDate, pagedNavigation = options.pagedNavigation, _a = options.numberOfMonths, numberOfMonths = _a === void 0 ? 1 : _a;
  var offset2 = pagedNavigation ? numberOfMonths : 1;
  var month2 = startOfMonth(startingMonth);
  if (!fromDate) {
    return addMonths(month2, -offset2);
  }
  var monthsDiff = differenceInCalendarMonths(month2, fromDate);
  if (monthsDiff <= 0) {
    return void 0;
  }
  return addMonths(month2, -offset2);
}
var NavigationContext = createContext(void 0);
function NavigationProvider(props) {
  var dayPicker = useDayPicker();
  var _a = useNavigationState(), currentMonth = _a[0], goToMonth = _a[1];
  var displayMonths = getDisplayMonths(currentMonth, dayPicker);
  var nextMonth = getNextMonth(currentMonth, dayPicker);
  var previousMonth = getPreviousMonth(currentMonth, dayPicker);
  var isDateDisplayed = function(date) {
    return displayMonths.some(function(displayMonth) {
      return isSameMonth(date, displayMonth);
    });
  };
  var goToDate = function(date, refDate) {
    if (isDateDisplayed(date)) {
      return;
    }
    if (refDate && isBefore(date, refDate)) {
      goToMonth(addMonths(date, 1 + dayPicker.numberOfMonths * -1));
    } else {
      goToMonth(date);
    }
  };
  var value2 = {
    currentMonth,
    displayMonths,
    goToMonth,
    goToDate,
    previousMonth,
    nextMonth,
    isDateDisplayed
  };
  return jsxRuntimeExports.jsx(NavigationContext.Provider, { value: value2, children: props.children });
}
function useNavigation() {
  var context = useContext(NavigationContext);
  if (!context) {
    throw new Error("useNavigation must be used within a NavigationProvider");
  }
  return context;
}
function CaptionDropdowns(props) {
  var _a;
  var _b = useDayPicker(), classNames = _b.classNames, styles = _b.styles, components = _b.components;
  var goToMonth = useNavigation().goToMonth;
  var handleMonthChange = function(newMonth) {
    goToMonth(addMonths(newMonth, props.displayIndex ? -props.displayIndex : 0));
  };
  var CaptionLabelComponent = (_a = components === null || components === void 0 ? void 0 : components.CaptionLabel) !== null && _a !== void 0 ? _a : CaptionLabel;
  var captionLabel = jsxRuntimeExports.jsx(CaptionLabelComponent, { id: props.id, displayMonth: props.displayMonth });
  return jsxRuntimeExports.jsxs("div", { className: classNames.caption_dropdowns, style: styles.caption_dropdowns, children: [jsxRuntimeExports.jsx("div", { className: classNames.vhidden, children: captionLabel }), jsxRuntimeExports.jsx(MonthsDropdown, { onChange: handleMonthChange, displayMonth: props.displayMonth }), jsxRuntimeExports.jsx(YearsDropdown, { onChange: handleMonthChange, displayMonth: props.displayMonth })] });
}
function IconLeft(props) {
  return jsxRuntimeExports.jsx("svg", __assign({ width: "16px", height: "16px", viewBox: "0 0 120 120" }, props, { children: jsxRuntimeExports.jsx("path", { d: "M69.490332,3.34314575 C72.6145263,0.218951416 77.6798462,0.218951416 80.8040405,3.34314575 C83.8617626,6.40086786 83.9268205,11.3179931 80.9992143,14.4548388 L80.8040405,14.6568542 L35.461,60 L80.8040405,105.343146 C83.8617626,108.400868 83.9268205,113.317993 80.9992143,116.454839 L80.8040405,116.656854 C77.7463184,119.714576 72.8291931,119.779634 69.6923475,116.852028 L69.490332,116.656854 L18.490332,65.6568542 C15.4326099,62.5991321 15.367552,57.6820069 18.2951583,54.5451612 L18.490332,54.3431458 L69.490332,3.34314575 Z", fill: "currentColor", fillRule: "nonzero" }) }));
}
function IconRight(props) {
  return jsxRuntimeExports.jsx("svg", __assign({ width: "16px", height: "16px", viewBox: "0 0 120 120" }, props, { children: jsxRuntimeExports.jsx("path", { d: "M49.8040405,3.34314575 C46.6798462,0.218951416 41.6145263,0.218951416 38.490332,3.34314575 C35.4326099,6.40086786 35.367552,11.3179931 38.2951583,14.4548388 L38.490332,14.6568542 L83.8333725,60 L38.490332,105.343146 C35.4326099,108.400868 35.367552,113.317993 38.2951583,116.454839 L38.490332,116.656854 C41.5480541,119.714576 46.4651794,119.779634 49.602025,116.852028 L49.8040405,116.656854 L100.804041,65.6568542 C103.861763,62.5991321 103.926821,57.6820069 100.999214,54.5451612 L100.804041,54.3431458 L49.8040405,3.34314575 Z", fill: "currentColor" }) }));
}
var Button = forwardRef(function(props, ref) {
  var _a = useDayPicker(), classNames = _a.classNames, styles = _a.styles;
  var classNamesArr = [classNames.button_reset, classNames.button];
  if (props.className) {
    classNamesArr.push(props.className);
  }
  var className = classNamesArr.join(" ");
  var style = __assign(__assign({}, styles.button_reset), styles.button);
  if (props.style) {
    Object.assign(style, props.style);
  }
  return jsxRuntimeExports.jsx("button", __assign({}, props, { ref, type: "button", className, style }));
});
function Navigation(props) {
  var _a, _b;
  var _c = useDayPicker(), dir = _c.dir, locale = _c.locale, classNames = _c.classNames, styles = _c.styles, _d = _c.labels, labelPrevious2 = _d.labelPrevious, labelNext2 = _d.labelNext, components = _c.components;
  if (!props.nextMonth && !props.previousMonth) {
    return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});
  }
  var previousLabel = labelPrevious2(props.previousMonth, { locale });
  var previousClassName = [
    classNames.nav_button,
    classNames.nav_button_previous
  ].join(" ");
  var nextLabel = labelNext2(props.nextMonth, { locale });
  var nextClassName = [
    classNames.nav_button,
    classNames.nav_button_next
  ].join(" ");
  var IconRightComponent = (_a = components === null || components === void 0 ? void 0 : components.IconRight) !== null && _a !== void 0 ? _a : IconRight;
  var IconLeftComponent = (_b = components === null || components === void 0 ? void 0 : components.IconLeft) !== null && _b !== void 0 ? _b : IconLeft;
  return jsxRuntimeExports.jsxs("div", { className: classNames.nav, style: styles.nav, children: [!props.hidePrevious && jsxRuntimeExports.jsx(Button, { name: "previous-month", "aria-label": previousLabel, className: previousClassName, style: styles.nav_button_previous, disabled: !props.previousMonth, onClick: props.onPreviousClick, children: dir === "rtl" ? jsxRuntimeExports.jsx(IconRightComponent, { className: classNames.nav_icon, style: styles.nav_icon }) : jsxRuntimeExports.jsx(IconLeftComponent, { className: classNames.nav_icon, style: styles.nav_icon }) }), !props.hideNext && jsxRuntimeExports.jsx(Button, { name: "next-month", "aria-label": nextLabel, className: nextClassName, style: styles.nav_button_next, disabled: !props.nextMonth, onClick: props.onNextClick, children: dir === "rtl" ? jsxRuntimeExports.jsx(IconLeftComponent, { className: classNames.nav_icon, style: styles.nav_icon }) : jsxRuntimeExports.jsx(IconRightComponent, { className: classNames.nav_icon, style: styles.nav_icon }) })] });
}
function CaptionNavigation(props) {
  var numberOfMonths = useDayPicker().numberOfMonths;
  var _a = useNavigation(), previousMonth = _a.previousMonth, nextMonth = _a.nextMonth, goToMonth = _a.goToMonth, displayMonths = _a.displayMonths;
  var displayIndex = displayMonths.findIndex(function(month2) {
    return isSameMonth(props.displayMonth, month2);
  });
  var isFirst = displayIndex === 0;
  var isLast = displayIndex === displayMonths.length - 1;
  var hideNext = numberOfMonths > 1 && (isFirst || !isLast);
  var hidePrevious = numberOfMonths > 1 && (isLast || !isFirst);
  var handlePreviousClick = function() {
    if (!previousMonth)
      return;
    goToMonth(previousMonth);
  };
  var handleNextClick = function() {
    if (!nextMonth)
      return;
    goToMonth(nextMonth);
  };
  return jsxRuntimeExports.jsx(Navigation, { displayMonth: props.displayMonth, hideNext, hidePrevious, nextMonth, previousMonth, onPreviousClick: handlePreviousClick, onNextClick: handleNextClick });
}
function Caption(props) {
  var _a;
  var _b = useDayPicker(), classNames = _b.classNames, disableNavigation = _b.disableNavigation, styles = _b.styles, captionLayout = _b.captionLayout, components = _b.components;
  var CaptionLabelComponent = (_a = components === null || components === void 0 ? void 0 : components.CaptionLabel) !== null && _a !== void 0 ? _a : CaptionLabel;
  var caption;
  if (disableNavigation) {
    caption = jsxRuntimeExports.jsx(CaptionLabelComponent, { id: props.id, displayMonth: props.displayMonth });
  } else if (captionLayout === "dropdown") {
    caption = jsxRuntimeExports.jsx(CaptionDropdowns, { displayMonth: props.displayMonth, id: props.id });
  } else if (captionLayout === "dropdown-buttons") {
    caption = jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx(CaptionDropdowns, { displayMonth: props.displayMonth, displayIndex: props.displayIndex, id: props.id }), jsxRuntimeExports.jsx(CaptionNavigation, { displayMonth: props.displayMonth, displayIndex: props.displayIndex, id: props.id })] });
  } else {
    caption = jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx(CaptionLabelComponent, { id: props.id, displayMonth: props.displayMonth, displayIndex: props.displayIndex }), jsxRuntimeExports.jsx(CaptionNavigation, { displayMonth: props.displayMonth, id: props.id })] });
  }
  return jsxRuntimeExports.jsx("div", { className: classNames.caption, style: styles.caption, children: caption });
}
function Footer(props) {
  var _a = useDayPicker(), footer = _a.footer, styles = _a.styles, tfoot = _a.classNames.tfoot;
  if (!footer)
    return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});
  return jsxRuntimeExports.jsx("tfoot", { className: tfoot, style: styles.tfoot, children: jsxRuntimeExports.jsx("tr", { children: jsxRuntimeExports.jsx("td", { colSpan: 8, children: footer }) }) });
}
function getWeekdays(locale, weekStartsOn, ISOWeek) {
  var start2 = ISOWeek ? startOfISOWeek(/* @__PURE__ */ new Date()) : startOfWeek(/* @__PURE__ */ new Date(), { locale, weekStartsOn });
  var days2 = [];
  for (var i2 = 0; i2 < 7; i2++) {
    var day2 = addDays(start2, i2);
    days2.push(day2);
  }
  return days2;
}
function HeadRow() {
  var _a = useDayPicker(), classNames = _a.classNames, styles = _a.styles, showWeekNumber = _a.showWeekNumber, locale = _a.locale, weekStartsOn = _a.weekStartsOn, ISOWeek = _a.ISOWeek, formatWeekdayName2 = _a.formatters.formatWeekdayName, labelWeekday2 = _a.labels.labelWeekday;
  var weekdays = getWeekdays(locale, weekStartsOn, ISOWeek);
  return jsxRuntimeExports.jsxs("tr", { style: styles.head_row, className: classNames.head_row, children: [showWeekNumber && jsxRuntimeExports.jsx("td", { style: styles.head_cell, className: classNames.head_cell }), weekdays.map(function(weekday, i2) {
    return jsxRuntimeExports.jsx("th", { scope: "col", className: classNames.head_cell, style: styles.head_cell, "aria-label": labelWeekday2(weekday, { locale }), children: formatWeekdayName2(weekday, { locale }) }, i2);
  })] });
}
function Head() {
  var _a;
  var _b = useDayPicker(), classNames = _b.classNames, styles = _b.styles, components = _b.components;
  var HeadRowComponent = (_a = components === null || components === void 0 ? void 0 : components.HeadRow) !== null && _a !== void 0 ? _a : HeadRow;
  return jsxRuntimeExports.jsx("thead", { style: styles.head, className: classNames.head, children: jsxRuntimeExports.jsx(HeadRowComponent, {}) });
}
function DayContent(props) {
  var _a = useDayPicker(), locale = _a.locale, formatDay2 = _a.formatters.formatDay;
  return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: formatDay2(props.date, { locale }) });
}
var SelectMultipleContext = createContext(void 0);
function SelectMultipleProvider(props) {
  if (!isDayPickerMultiple(props.initialProps)) {
    var emptyContextValue = {
      selected: void 0,
      modifiers: {
        disabled: []
      }
    };
    return jsxRuntimeExports.jsx(SelectMultipleContext.Provider, { value: emptyContextValue, children: props.children });
  }
  return jsxRuntimeExports.jsx(SelectMultipleProviderInternal, { initialProps: props.initialProps, children: props.children });
}
function SelectMultipleProviderInternal(_a) {
  var initialProps = _a.initialProps, children = _a.children;
  var selected = initialProps.selected, min2 = initialProps.min, max2 = initialProps.max;
  var onDayClick = function(day2, activeModifiers, e) {
    var _a2, _b;
    (_a2 = initialProps.onDayClick) === null || _a2 === void 0 ? void 0 : _a2.call(initialProps, day2, activeModifiers, e);
    var isMinSelected = Boolean(activeModifiers.selected && min2 && (selected === null || selected === void 0 ? void 0 : selected.length) === min2);
    if (isMinSelected) {
      return;
    }
    var isMaxSelected = Boolean(!activeModifiers.selected && max2 && (selected === null || selected === void 0 ? void 0 : selected.length) === max2);
    if (isMaxSelected) {
      return;
    }
    var selectedDays = selected ? __spreadArray([], selected) : [];
    if (activeModifiers.selected) {
      var index2 = selectedDays.findIndex(function(selectedDay) {
        return isSameDay(day2, selectedDay);
      });
      selectedDays.splice(index2, 1);
    } else {
      selectedDays.push(day2);
    }
    (_b = initialProps.onSelect) === null || _b === void 0 ? void 0 : _b.call(initialProps, selectedDays, day2, activeModifiers, e);
  };
  var modifiers = {
    disabled: []
  };
  if (selected) {
    modifiers.disabled.push(function(day2) {
      var isMaxSelected = max2 && selected.length > max2 - 1;
      var isSelected = selected.some(function(selectedDay) {
        return isSameDay(selectedDay, day2);
      });
      return Boolean(isMaxSelected && !isSelected);
    });
  }
  var contextValue = {
    selected,
    onDayClick,
    modifiers
  };
  return jsxRuntimeExports.jsx(SelectMultipleContext.Provider, { value: contextValue, children });
}
function useSelectMultiple() {
  var context = useContext(SelectMultipleContext);
  if (!context) {
    throw new Error("useSelectMultiple must be used within a SelectMultipleProvider");
  }
  return context;
}
function addToRange(day2, range2) {
  var _a = range2 || {}, from = _a.from, to = _a.to;
  if (from && to) {
    if (isSameDay(to, day2) && isSameDay(from, day2)) {
      return void 0;
    }
    if (isSameDay(to, day2)) {
      return { from: to, to: void 0 };
    }
    if (isSameDay(from, day2)) {
      return void 0;
    }
    if (isAfter(from, day2)) {
      return { from: day2, to };
    }
    return { from, to: day2 };
  }
  if (to) {
    if (isAfter(day2, to)) {
      return { from: to, to: day2 };
    }
    return { from: day2, to };
  }
  if (from) {
    if (isBefore(day2, from)) {
      return { from: day2, to: from };
    }
    return { from, to: day2 };
  }
  return { from: day2, to: void 0 };
}
var SelectRangeContext = createContext(void 0);
function SelectRangeProvider(props) {
  if (!isDayPickerRange(props.initialProps)) {
    var emptyContextValue = {
      selected: void 0,
      modifiers: {
        range_start: [],
        range_end: [],
        range_middle: [],
        disabled: []
      }
    };
    return jsxRuntimeExports.jsx(SelectRangeContext.Provider, { value: emptyContextValue, children: props.children });
  }
  return jsxRuntimeExports.jsx(SelectRangeProviderInternal, { initialProps: props.initialProps, children: props.children });
}
function SelectRangeProviderInternal(_a) {
  var initialProps = _a.initialProps, children = _a.children;
  var selected = initialProps.selected;
  var _b = selected || {}, selectedFrom = _b.from, selectedTo = _b.to;
  var min2 = initialProps.min;
  var max2 = initialProps.max;
  var onDayClick = function(day2, activeModifiers, e) {
    var _a2, _b2;
    (_a2 = initialProps.onDayClick) === null || _a2 === void 0 ? void 0 : _a2.call(initialProps, day2, activeModifiers, e);
    var newRange = addToRange(day2, selected);
    (_b2 = initialProps.onSelect) === null || _b2 === void 0 ? void 0 : _b2.call(initialProps, newRange, day2, activeModifiers, e);
  };
  var modifiers = {
    range_start: [],
    range_end: [],
    range_middle: [],
    disabled: []
  };
  if (selectedFrom) {
    modifiers.range_start = [selectedFrom];
    if (!selectedTo) {
      modifiers.range_end = [selectedFrom];
    } else {
      modifiers.range_end = [selectedTo];
      if (!isSameDay(selectedFrom, selectedTo)) {
        modifiers.range_middle = [
          {
            after: selectedFrom,
            before: selectedTo
          }
        ];
      }
    }
  } else if (selectedTo) {
    modifiers.range_start = [selectedTo];
    modifiers.range_end = [selectedTo];
  }
  if (min2) {
    if (selectedFrom && !selectedTo) {
      modifiers.disabled.push({
        after: subDays(selectedFrom, min2 - 1),
        before: addDays(selectedFrom, min2 - 1)
      });
    }
    if (selectedFrom && selectedTo) {
      modifiers.disabled.push({
        after: selectedFrom,
        before: addDays(selectedFrom, min2 - 1)
      });
    }
    if (!selectedFrom && selectedTo) {
      modifiers.disabled.push({
        after: subDays(selectedTo, min2 - 1),
        before: addDays(selectedTo, min2 - 1)
      });
    }
  }
  if (max2) {
    if (selectedFrom && !selectedTo) {
      modifiers.disabled.push({
        before: addDays(selectedFrom, -max2 + 1)
      });
      modifiers.disabled.push({
        after: addDays(selectedFrom, max2 - 1)
      });
    }
    if (selectedFrom && selectedTo) {
      var selectedCount = differenceInCalendarDays(selectedTo, selectedFrom) + 1;
      var offset2 = max2 - selectedCount;
      modifiers.disabled.push({
        before: subDays(selectedFrom, offset2)
      });
      modifiers.disabled.push({
        after: addDays(selectedTo, offset2)
      });
    }
    if (!selectedFrom && selectedTo) {
      modifiers.disabled.push({
        before: addDays(selectedTo, -max2 + 1)
      });
      modifiers.disabled.push({
        after: addDays(selectedTo, max2 - 1)
      });
    }
  }
  return jsxRuntimeExports.jsx(SelectRangeContext.Provider, { value: { selected, onDayClick, modifiers }, children });
}
function useSelectRange() {
  var context = useContext(SelectRangeContext);
  if (!context) {
    throw new Error("useSelectRange must be used within a SelectRangeProvider");
  }
  return context;
}
function matcherToArray(matcher) {
  if (Array.isArray(matcher)) {
    return __spreadArray([], matcher);
  } else if (matcher !== void 0) {
    return [matcher];
  } else {
    return [];
  }
}
function getCustomModifiers(dayModifiers) {
  var customModifiers = {};
  Object.entries(dayModifiers).forEach(function(_a) {
    var modifier = _a[0], matcher = _a[1];
    customModifiers[modifier] = matcherToArray(matcher);
  });
  return customModifiers;
}
var InternalModifier;
(function(InternalModifier2) {
  InternalModifier2["Outside"] = "outside";
  InternalModifier2["Disabled"] = "disabled";
  InternalModifier2["Selected"] = "selected";
  InternalModifier2["Hidden"] = "hidden";
  InternalModifier2["Today"] = "today";
  InternalModifier2["RangeStart"] = "range_start";
  InternalModifier2["RangeEnd"] = "range_end";
  InternalModifier2["RangeMiddle"] = "range_middle";
})(InternalModifier || (InternalModifier = {}));
var Selected = InternalModifier.Selected, Disabled = InternalModifier.Disabled, Hidden = InternalModifier.Hidden, Today = InternalModifier.Today, RangeEnd = InternalModifier.RangeEnd, RangeMiddle = InternalModifier.RangeMiddle, RangeStart = InternalModifier.RangeStart, Outside = InternalModifier.Outside;
function getInternalModifiers(dayPicker, selectMultiple, selectRange) {
  var _a;
  var internalModifiers = (_a = {}, _a[Selected] = matcherToArray(dayPicker.selected), _a[Disabled] = matcherToArray(dayPicker.disabled), _a[Hidden] = matcherToArray(dayPicker.hidden), _a[Today] = [dayPicker.today], _a[RangeEnd] = [], _a[RangeMiddle] = [], _a[RangeStart] = [], _a[Outside] = [], _a);
  if (dayPicker.fromDate) {
    internalModifiers[Disabled].push({ before: dayPicker.fromDate });
  }
  if (dayPicker.toDate) {
    internalModifiers[Disabled].push({ after: dayPicker.toDate });
  }
  if (isDayPickerMultiple(dayPicker)) {
    internalModifiers[Disabled] = internalModifiers[Disabled].concat(selectMultiple.modifiers[Disabled]);
  } else if (isDayPickerRange(dayPicker)) {
    internalModifiers[Disabled] = internalModifiers[Disabled].concat(selectRange.modifiers[Disabled]);
    internalModifiers[RangeStart] = selectRange.modifiers[RangeStart];
    internalModifiers[RangeMiddle] = selectRange.modifiers[RangeMiddle];
    internalModifiers[RangeEnd] = selectRange.modifiers[RangeEnd];
  }
  return internalModifiers;
}
var ModifiersContext = createContext(void 0);
function ModifiersProvider(props) {
  var dayPicker = useDayPicker();
  var selectMultiple = useSelectMultiple();
  var selectRange = useSelectRange();
  var internalModifiers = getInternalModifiers(dayPicker, selectMultiple, selectRange);
  var customModifiers = getCustomModifiers(dayPicker.modifiers);
  var modifiers = __assign(__assign({}, internalModifiers), customModifiers);
  return jsxRuntimeExports.jsx(ModifiersContext.Provider, { value: modifiers, children: props.children });
}
function useModifiers() {
  var context = useContext(ModifiersContext);
  if (!context) {
    throw new Error("useModifiers must be used within a ModifiersProvider");
  }
  return context;
}
function isDateInterval(matcher) {
  return Boolean(matcher && typeof matcher === "object" && "before" in matcher && "after" in matcher);
}
function isDateRange(value2) {
  return Boolean(value2 && typeof value2 === "object" && "from" in value2);
}
function isDateAfterType(value2) {
  return Boolean(value2 && typeof value2 === "object" && "after" in value2);
}
function isDateBeforeType(value2) {
  return Boolean(value2 && typeof value2 === "object" && "before" in value2);
}
function isDayOfWeekType(value2) {
  return Boolean(value2 && typeof value2 === "object" && "dayOfWeek" in value2);
}
function isDateInRange(date, range2) {
  var _a;
  var from = range2.from, to = range2.to;
  if (from && to) {
    var isRangeInverted = differenceInCalendarDays(to, from) < 0;
    if (isRangeInverted) {
      _a = [to, from], from = _a[0], to = _a[1];
    }
    var isInRange = differenceInCalendarDays(date, from) >= 0 && differenceInCalendarDays(to, date) >= 0;
    return isInRange;
  }
  if (to) {
    return isSameDay(to, date);
  }
  if (from) {
    return isSameDay(from, date);
  }
  return false;
}
function isDateType(value2) {
  return isDate(value2);
}
function isArrayOfDates(value2) {
  return Array.isArray(value2) && value2.every(isDate);
}
function isMatch(day2, matchers) {
  return matchers.some(function(matcher) {
    if (typeof matcher === "boolean") {
      return matcher;
    }
    if (isDateType(matcher)) {
      return isSameDay(day2, matcher);
    }
    if (isArrayOfDates(matcher)) {
      return matcher.includes(day2);
    }
    if (isDateRange(matcher)) {
      return isDateInRange(day2, matcher);
    }
    if (isDayOfWeekType(matcher)) {
      return matcher.dayOfWeek.includes(day2.getDay());
    }
    if (isDateInterval(matcher)) {
      var diffBefore = differenceInCalendarDays(matcher.before, day2);
      var diffAfter = differenceInCalendarDays(matcher.after, day2);
      var isDayBefore = diffBefore > 0;
      var isDayAfter = diffAfter < 0;
      var isClosedInterval = isAfter(matcher.before, matcher.after);
      if (isClosedInterval) {
        return isDayAfter && isDayBefore;
      } else {
        return isDayBefore || isDayAfter;
      }
    }
    if (isDateAfterType(matcher)) {
      return differenceInCalendarDays(day2, matcher.after) > 0;
    }
    if (isDateBeforeType(matcher)) {
      return differenceInCalendarDays(matcher.before, day2) > 0;
    }
    if (typeof matcher === "function") {
      return matcher(day2);
    }
    return false;
  });
}
function getActiveModifiers(day2, modifiers, displayMonth) {
  var matchedModifiers = Object.keys(modifiers).reduce(function(result, key) {
    var modifier = modifiers[key];
    if (isMatch(day2, modifier)) {
      result.push(key);
    }
    return result;
  }, []);
  var activeModifiers = {};
  matchedModifiers.forEach(function(modifier) {
    return activeModifiers[modifier] = true;
  });
  if (displayMonth && !isSameMonth(day2, displayMonth)) {
    activeModifiers.outside = true;
  }
  return activeModifiers;
}
function getInitialFocusTarget(displayMonths, modifiers) {
  var firstDayInMonth = startOfMonth(displayMonths[0]);
  var lastDayInMonth = endOfMonth(displayMonths[displayMonths.length - 1]);
  var firstFocusableDay;
  var today;
  var date = firstDayInMonth;
  while (date <= lastDayInMonth) {
    var activeModifiers = getActiveModifiers(date, modifiers);
    var isFocusable = !activeModifiers.disabled && !activeModifiers.hidden;
    if (!isFocusable) {
      date = addDays(date, 1);
      continue;
    }
    if (activeModifiers.selected) {
      return date;
    }
    if (activeModifiers.today && !today) {
      today = date;
    }
    if (!firstFocusableDay) {
      firstFocusableDay = date;
    }
    date = addDays(date, 1);
  }
  if (today) {
    return today;
  } else {
    return firstFocusableDay;
  }
}
var MAX_RETRY = 365;
function getNextFocus(focusedDay, options) {
  var moveBy = options.moveBy, direction = options.direction, context = options.context, modifiers = options.modifiers, _a = options.retry, retry = _a === void 0 ? { count: 0, lastFocused: focusedDay } : _a;
  var weekStartsOn = context.weekStartsOn, fromDate = context.fromDate, toDate2 = context.toDate, locale = context.locale;
  var moveFns = {
    day: addDays,
    week: addWeeks,
    month: addMonths,
    year: addYears,
    startOfWeek: function(date) {
      return context.ISOWeek ? startOfISOWeek(date) : startOfWeek(date, { locale, weekStartsOn });
    },
    endOfWeek: function(date) {
      return context.ISOWeek ? endOfISOWeek(date) : endOfWeek(date, { locale, weekStartsOn });
    }
  };
  var newFocusedDay = moveFns[moveBy](focusedDay, direction === "after" ? 1 : -1);
  if (direction === "before" && fromDate) {
    newFocusedDay = max$4([fromDate, newFocusedDay]);
  } else if (direction === "after" && toDate2) {
    newFocusedDay = min$4([toDate2, newFocusedDay]);
  }
  var isFocusable = true;
  if (modifiers) {
    var activeModifiers = getActiveModifiers(newFocusedDay, modifiers);
    isFocusable = !activeModifiers.disabled && !activeModifiers.hidden;
  }
  if (isFocusable) {
    return newFocusedDay;
  } else {
    if (retry.count > MAX_RETRY) {
      return retry.lastFocused;
    }
    return getNextFocus(newFocusedDay, {
      moveBy,
      direction,
      context,
      modifiers,
      retry: __assign(__assign({}, retry), { count: retry.count + 1 })
    });
  }
}
var FocusContext = createContext(void 0);
function FocusProvider(props) {
  var navigation = useNavigation();
  var modifiers = useModifiers();
  var _a = useState(), focusedDay = _a[0], setFocusedDay = _a[1];
  var _b = useState(), lastFocused = _b[0], setLastFocused = _b[1];
  var initialFocusTarget = getInitialFocusTarget(navigation.displayMonths, modifiers);
  var focusTarget = (focusedDay !== null && focusedDay !== void 0 ? focusedDay : lastFocused && navigation.isDateDisplayed(lastFocused)) ? lastFocused : initialFocusTarget;
  var blur = function() {
    setLastFocused(focusedDay);
    setFocusedDay(void 0);
  };
  var focus2 = function(date) {
    setFocusedDay(date);
  };
  var context = useDayPicker();
  var moveFocus = function(moveBy, direction) {
    if (!focusedDay)
      return;
    var nextFocused = getNextFocus(focusedDay, {
      moveBy,
      direction,
      context,
      modifiers
    });
    if (isSameDay(focusedDay, nextFocused))
      return void 0;
    navigation.goToDate(nextFocused, focusedDay);
    focus2(nextFocused);
  };
  var value2 = {
    focusedDay,
    focusTarget,
    blur,
    focus: focus2,
    focusDayAfter: function() {
      return moveFocus("day", "after");
    },
    focusDayBefore: function() {
      return moveFocus("day", "before");
    },
    focusWeekAfter: function() {
      return moveFocus("week", "after");
    },
    focusWeekBefore: function() {
      return moveFocus("week", "before");
    },
    focusMonthBefore: function() {
      return moveFocus("month", "before");
    },
    focusMonthAfter: function() {
      return moveFocus("month", "after");
    },
    focusYearBefore: function() {
      return moveFocus("year", "before");
    },
    focusYearAfter: function() {
      return moveFocus("year", "after");
    },
    focusStartOfWeek: function() {
      return moveFocus("startOfWeek", "before");
    },
    focusEndOfWeek: function() {
      return moveFocus("endOfWeek", "after");
    }
  };
  return jsxRuntimeExports.jsx(FocusContext.Provider, { value: value2, children: props.children });
}
function useFocusContext() {
  var context = useContext(FocusContext);
  if (!context) {
    throw new Error("useFocusContext must be used within a FocusProvider");
  }
  return context;
}
function useActiveModifiers(day2, displayMonth) {
  var modifiers = useModifiers();
  var activeModifiers = getActiveModifiers(day2, modifiers, displayMonth);
  return activeModifiers;
}
var SelectSingleContext = createContext(void 0);
function SelectSingleProvider(props) {
  if (!isDayPickerSingle(props.initialProps)) {
    var emptyContextValue = {
      selected: void 0
    };
    return jsxRuntimeExports.jsx(SelectSingleContext.Provider, { value: emptyContextValue, children: props.children });
  }
  return jsxRuntimeExports.jsx(SelectSingleProviderInternal, { initialProps: props.initialProps, children: props.children });
}
function SelectSingleProviderInternal(_a) {
  var initialProps = _a.initialProps, children = _a.children;
  var onDayClick = function(day2, activeModifiers, e) {
    var _a2, _b, _c;
    (_a2 = initialProps.onDayClick) === null || _a2 === void 0 ? void 0 : _a2.call(initialProps, day2, activeModifiers, e);
    if (activeModifiers.selected && !initialProps.required) {
      (_b = initialProps.onSelect) === null || _b === void 0 ? void 0 : _b.call(initialProps, void 0, day2, activeModifiers, e);
      return;
    }
    (_c = initialProps.onSelect) === null || _c === void 0 ? void 0 : _c.call(initialProps, day2, day2, activeModifiers, e);
  };
  var contextValue = {
    selected: initialProps.selected,
    onDayClick
  };
  return jsxRuntimeExports.jsx(SelectSingleContext.Provider, { value: contextValue, children });
}
function useSelectSingle() {
  var context = useContext(SelectSingleContext);
  if (!context) {
    throw new Error("useSelectSingle must be used within a SelectSingleProvider");
  }
  return context;
}
function useDayEventHandlers(date, activeModifiers) {
  var dayPicker = useDayPicker();
  var single = useSelectSingle();
  var multiple = useSelectMultiple();
  var range2 = useSelectRange();
  var _a = useFocusContext(), focusDayAfter = _a.focusDayAfter, focusDayBefore = _a.focusDayBefore, focusWeekAfter = _a.focusWeekAfter, focusWeekBefore = _a.focusWeekBefore, blur = _a.blur, focus2 = _a.focus, focusMonthBefore = _a.focusMonthBefore, focusMonthAfter = _a.focusMonthAfter, focusYearBefore = _a.focusYearBefore, focusYearAfter = _a.focusYearAfter, focusStartOfWeek = _a.focusStartOfWeek, focusEndOfWeek = _a.focusEndOfWeek;
  var onClick = function(e) {
    var _a2, _b, _c, _d;
    if (isDayPickerSingle(dayPicker)) {
      (_a2 = single.onDayClick) === null || _a2 === void 0 ? void 0 : _a2.call(single, date, activeModifiers, e);
    } else if (isDayPickerMultiple(dayPicker)) {
      (_b = multiple.onDayClick) === null || _b === void 0 ? void 0 : _b.call(multiple, date, activeModifiers, e);
    } else if (isDayPickerRange(dayPicker)) {
      (_c = range2.onDayClick) === null || _c === void 0 ? void 0 : _c.call(range2, date, activeModifiers, e);
    } else {
      (_d = dayPicker.onDayClick) === null || _d === void 0 ? void 0 : _d.call(dayPicker, date, activeModifiers, e);
    }
  };
  var onFocus = function(e) {
    var _a2;
    focus2(date);
    (_a2 = dayPicker.onDayFocus) === null || _a2 === void 0 ? void 0 : _a2.call(dayPicker, date, activeModifiers, e);
  };
  var onBlur = function(e) {
    var _a2;
    blur();
    (_a2 = dayPicker.onDayBlur) === null || _a2 === void 0 ? void 0 : _a2.call(dayPicker, date, activeModifiers, e);
  };
  var onMouseEnter = function(e) {
    var _a2;
    (_a2 = dayPicker.onDayMouseEnter) === null || _a2 === void 0 ? void 0 : _a2.call(dayPicker, date, activeModifiers, e);
  };
  var onMouseLeave = function(e) {
    var _a2;
    (_a2 = dayPicker.onDayMouseLeave) === null || _a2 === void 0 ? void 0 : _a2.call(dayPicker, date, activeModifiers, e);
  };
  var onPointerEnter = function(e) {
    var _a2;
    (_a2 = dayPicker.onDayPointerEnter) === null || _a2 === void 0 ? void 0 : _a2.call(dayPicker, date, activeModifiers, e);
  };
  var onPointerLeave = function(e) {
    var _a2;
    (_a2 = dayPicker.onDayPointerLeave) === null || _a2 === void 0 ? void 0 : _a2.call(dayPicker, date, activeModifiers, e);
  };
  var onTouchCancel = function(e) {
    var _a2;
    (_a2 = dayPicker.onDayTouchCancel) === null || _a2 === void 0 ? void 0 : _a2.call(dayPicker, date, activeModifiers, e);
  };
  var onTouchEnd = function(e) {
    var _a2;
    (_a2 = dayPicker.onDayTouchEnd) === null || _a2 === void 0 ? void 0 : _a2.call(dayPicker, date, activeModifiers, e);
  };
  var onTouchMove = function(e) {
    var _a2;
    (_a2 = dayPicker.onDayTouchMove) === null || _a2 === void 0 ? void 0 : _a2.call(dayPicker, date, activeModifiers, e);
  };
  var onTouchStart = function(e) {
    var _a2;
    (_a2 = dayPicker.onDayTouchStart) === null || _a2 === void 0 ? void 0 : _a2.call(dayPicker, date, activeModifiers, e);
  };
  var onKeyUp = function(e) {
    var _a2;
    (_a2 = dayPicker.onDayKeyUp) === null || _a2 === void 0 ? void 0 : _a2.call(dayPicker, date, activeModifiers, e);
  };
  var onKeyDown = function(e) {
    var _a2;
    switch (e.key) {
      case "ArrowLeft":
        e.preventDefault();
        e.stopPropagation();
        dayPicker.dir === "rtl" ? focusDayAfter() : focusDayBefore();
        break;
      case "ArrowRight":
        e.preventDefault();
        e.stopPropagation();
        dayPicker.dir === "rtl" ? focusDayBefore() : focusDayAfter();
        break;
      case "ArrowDown":
        e.preventDefault();
        e.stopPropagation();
        focusWeekAfter();
        break;
      case "ArrowUp":
        e.preventDefault();
        e.stopPropagation();
        focusWeekBefore();
        break;
      case "PageUp":
        e.preventDefault();
        e.stopPropagation();
        e.shiftKey ? focusYearBefore() : focusMonthBefore();
        break;
      case "PageDown":
        e.preventDefault();
        e.stopPropagation();
        e.shiftKey ? focusYearAfter() : focusMonthAfter();
        break;
      case "Home":
        e.preventDefault();
        e.stopPropagation();
        focusStartOfWeek();
        break;
      case "End":
        e.preventDefault();
        e.stopPropagation();
        focusEndOfWeek();
        break;
    }
    (_a2 = dayPicker.onDayKeyDown) === null || _a2 === void 0 ? void 0 : _a2.call(dayPicker, date, activeModifiers, e);
  };
  var eventHandlers = {
    onClick,
    onFocus,
    onBlur,
    onKeyDown,
    onKeyUp,
    onMouseEnter,
    onMouseLeave,
    onPointerEnter,
    onPointerLeave,
    onTouchCancel,
    onTouchEnd,
    onTouchMove,
    onTouchStart
  };
  return eventHandlers;
}
function useSelectedDays() {
  var dayPicker = useDayPicker();
  var single = useSelectSingle();
  var multiple = useSelectMultiple();
  var range2 = useSelectRange();
  var selectedDays = isDayPickerSingle(dayPicker) ? single.selected : isDayPickerMultiple(dayPicker) ? multiple.selected : isDayPickerRange(dayPicker) ? range2.selected : void 0;
  return selectedDays;
}
function isInternalModifier(modifier) {
  return Object.values(InternalModifier).includes(modifier);
}
function getDayClassNames(dayPicker, activeModifiers) {
  var classNames = [dayPicker.classNames.day];
  Object.keys(activeModifiers).forEach(function(modifier) {
    var customClassName = dayPicker.modifiersClassNames[modifier];
    if (customClassName) {
      classNames.push(customClassName);
    } else if (isInternalModifier(modifier)) {
      var internalClassName = dayPicker.classNames["day_".concat(modifier)];
      if (internalClassName) {
        classNames.push(internalClassName);
      }
    }
  });
  return classNames;
}
function getDayStyle(dayPicker, activeModifiers) {
  var style = __assign({}, dayPicker.styles.day);
  Object.keys(activeModifiers).forEach(function(modifier) {
    var _a;
    style = __assign(__assign({}, style), (_a = dayPicker.modifiersStyles) === null || _a === void 0 ? void 0 : _a[modifier]);
  });
  return style;
}
function useDayRender(day2, displayMonth, buttonRef) {
  var _a;
  var _b, _c;
  var dayPicker = useDayPicker();
  var focusContext = useFocusContext();
  var activeModifiers = useActiveModifiers(day2, displayMonth);
  var eventHandlers = useDayEventHandlers(day2, activeModifiers);
  var selectedDays = useSelectedDays();
  var isButton = Boolean(dayPicker.onDayClick || dayPicker.mode !== "default");
  useEffect(function() {
    var _a2;
    if (activeModifiers.outside)
      return;
    if (!focusContext.focusedDay)
      return;
    if (!isButton)
      return;
    if (isSameDay(focusContext.focusedDay, day2)) {
      (_a2 = buttonRef.current) === null || _a2 === void 0 ? void 0 : _a2.focus();
    }
  }, [
    focusContext.focusedDay,
    day2,
    buttonRef,
    isButton,
    activeModifiers.outside
  ]);
  var className = getDayClassNames(dayPicker, activeModifiers).join(" ");
  var style = getDayStyle(dayPicker, activeModifiers);
  var isHidden2 = Boolean(activeModifiers.outside && !dayPicker.showOutsideDays || activeModifiers.hidden);
  var DayContentComponent = (_c = (_b = dayPicker.components) === null || _b === void 0 ? void 0 : _b.DayContent) !== null && _c !== void 0 ? _c : DayContent;
  var children = jsxRuntimeExports.jsx(DayContentComponent, { date: day2, displayMonth, activeModifiers });
  var divProps = {
    style,
    className,
    children,
    role: "gridcell"
  };
  var isFocusTarget = focusContext.focusTarget && isSameDay(focusContext.focusTarget, day2) && !activeModifiers.outside;
  var isFocused = focusContext.focusedDay && isSameDay(focusContext.focusedDay, day2);
  var buttonProps = __assign(__assign(__assign({}, divProps), (_a = { disabled: activeModifiers.disabled, role: "gridcell" }, _a["aria-selected"] = activeModifiers.selected, _a.tabIndex = isFocused || isFocusTarget ? 0 : -1, _a)), eventHandlers);
  var dayRender = {
    isButton,
    isHidden: isHidden2,
    activeModifiers,
    selectedDays,
    buttonProps,
    divProps
  };
  return dayRender;
}
function Day(props) {
  var buttonRef = useRef(null);
  var dayRender = useDayRender(props.date, props.displayMonth, buttonRef);
  if (dayRender.isHidden) {
    return jsxRuntimeExports.jsx("div", { role: "gridcell" });
  }
  if (!dayRender.isButton) {
    return jsxRuntimeExports.jsx("div", __assign({}, dayRender.divProps));
  }
  return jsxRuntimeExports.jsx(Button, __assign({ name: "day", ref: buttonRef }, dayRender.buttonProps));
}
function WeekNumber(props) {
  var weekNumber = props.number, dates = props.dates;
  var _a = useDayPicker(), onWeekNumberClick = _a.onWeekNumberClick, styles = _a.styles, classNames = _a.classNames, locale = _a.locale, labelWeekNumber2 = _a.labels.labelWeekNumber, formatWeekNumber2 = _a.formatters.formatWeekNumber;
  var content = formatWeekNumber2(Number(weekNumber), { locale });
  if (!onWeekNumberClick) {
    return jsxRuntimeExports.jsx("span", { className: classNames.weeknumber, style: styles.weeknumber, children: content });
  }
  var label2 = labelWeekNumber2(Number(weekNumber), { locale });
  var handleClick = function(e) {
    onWeekNumberClick(weekNumber, dates, e);
  };
  return jsxRuntimeExports.jsx(Button, { name: "week-number", "aria-label": label2, className: classNames.weeknumber, style: styles.weeknumber, onClick: handleClick, children: content });
}
function Row(props) {
  var _a, _b;
  var _c = useDayPicker(), styles = _c.styles, classNames = _c.classNames, showWeekNumber = _c.showWeekNumber, components = _c.components;
  var DayComponent = (_a = components === null || components === void 0 ? void 0 : components.Day) !== null && _a !== void 0 ? _a : Day;
  var WeeknumberComponent = (_b = components === null || components === void 0 ? void 0 : components.WeekNumber) !== null && _b !== void 0 ? _b : WeekNumber;
  var weekNumberCell;
  if (showWeekNumber) {
    weekNumberCell = jsxRuntimeExports.jsx("td", { className: classNames.cell, style: styles.cell, children: jsxRuntimeExports.jsx(WeeknumberComponent, { number: props.weekNumber, dates: props.dates }) });
  }
  return jsxRuntimeExports.jsxs("tr", { className: classNames.row, style: styles.row, children: [weekNumberCell, props.dates.map(function(date) {
    return jsxRuntimeExports.jsx("td", { className: classNames.cell, style: styles.cell, role: "presentation", children: jsxRuntimeExports.jsx(DayComponent, { displayMonth: props.displayMonth, date }) }, getUnixTime(date));
  })] });
}
function daysToMonthWeeks(fromDate, toDate2, options) {
  var toWeek = (options === null || options === void 0 ? void 0 : options.ISOWeek) ? endOfISOWeek(toDate2) : endOfWeek(toDate2, options);
  var fromWeek = (options === null || options === void 0 ? void 0 : options.ISOWeek) ? startOfISOWeek(fromDate) : startOfWeek(fromDate, options);
  var nOfDays = differenceInCalendarDays(toWeek, fromWeek);
  var days2 = [];
  for (var i2 = 0; i2 <= nOfDays; i2++) {
    days2.push(addDays(fromWeek, i2));
  }
  var weeksInMonth = days2.reduce(function(result, date) {
    var weekNumber = (options === null || options === void 0 ? void 0 : options.ISOWeek) ? getISOWeek(date) : getWeek(date, options);
    var existingWeek = result.find(function(value2) {
      return value2.weekNumber === weekNumber;
    });
    if (existingWeek) {
      existingWeek.dates.push(date);
      return result;
    }
    result.push({
      weekNumber,
      dates: [date]
    });
    return result;
  }, []);
  return weeksInMonth;
}
function getMonthWeeks(month2, options) {
  var weeksInMonth = daysToMonthWeeks(startOfMonth(month2), endOfMonth(month2), options);
  if (options === null || options === void 0 ? void 0 : options.useFixedWeeks) {
    var nrOfMonthWeeks = getWeeksInMonth(month2, options);
    if (nrOfMonthWeeks < 6) {
      var lastWeek = weeksInMonth[weeksInMonth.length - 1];
      var lastDate = lastWeek.dates[lastWeek.dates.length - 1];
      var toDate2 = addWeeks(lastDate, 6 - nrOfMonthWeeks);
      var extraWeeks = daysToMonthWeeks(addWeeks(lastDate, 1), toDate2, options);
      weeksInMonth.push.apply(weeksInMonth, extraWeeks);
    }
  }
  return weeksInMonth;
}
function Table$1(props) {
  var _a, _b, _c;
  var _d = useDayPicker(), locale = _d.locale, classNames = _d.classNames, styles = _d.styles, hideHead = _d.hideHead, fixedWeeks = _d.fixedWeeks, components = _d.components, weekStartsOn = _d.weekStartsOn, firstWeekContainsDate = _d.firstWeekContainsDate, ISOWeek = _d.ISOWeek;
  var weeks2 = getMonthWeeks(props.displayMonth, {
    useFixedWeeks: Boolean(fixedWeeks),
    ISOWeek,
    locale,
    weekStartsOn,
    firstWeekContainsDate
  });
  var HeadComponent = (_a = components === null || components === void 0 ? void 0 : components.Head) !== null && _a !== void 0 ? _a : Head;
  var RowComponent = (_b = components === null || components === void 0 ? void 0 : components.Row) !== null && _b !== void 0 ? _b : Row;
  var FooterComponent = (_c = components === null || components === void 0 ? void 0 : components.Footer) !== null && _c !== void 0 ? _c : Footer;
  return jsxRuntimeExports.jsxs("table", { id: props.id, className: classNames.table, style: styles.table, role: "grid", "aria-labelledby": props["aria-labelledby"], children: [!hideHead && jsxRuntimeExports.jsx(HeadComponent, {}), jsxRuntimeExports.jsx("tbody", { className: classNames.tbody, style: styles.tbody, children: weeks2.map(function(week2) {
    return jsxRuntimeExports.jsx(RowComponent, { displayMonth: props.displayMonth, dates: week2.dates, weekNumber: week2.weekNumber }, week2.weekNumber);
  }) }), jsxRuntimeExports.jsx(FooterComponent, { displayMonth: props.displayMonth })] });
}
function canUseDOM$1() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
var useIsomorphicLayoutEffect$1 = canUseDOM$1() ? useLayoutEffect : useEffect;
var serverHandoffComplete = false;
var id$2 = 0;
function genId() {
  return "react-day-picker-".concat(++id$2);
}
function useId(providedId) {
  var _a;
  var initialId = providedId !== null && providedId !== void 0 ? providedId : serverHandoffComplete ? genId() : null;
  var _b = useState(initialId), id2 = _b[0], setId = _b[1];
  useIsomorphicLayoutEffect$1(function() {
    if (id2 === null) {
      setId(genId());
    }
  }, []);
  useEffect(function() {
    if (serverHandoffComplete === false) {
      serverHandoffComplete = true;
    }
  }, []);
  return (_a = providedId !== null && providedId !== void 0 ? providedId : id2) !== null && _a !== void 0 ? _a : void 0;
}
function Month(props) {
  var _a;
  var _b;
  var dayPicker = useDayPicker();
  var dir = dayPicker.dir, classNames = dayPicker.classNames, styles = dayPicker.styles, components = dayPicker.components;
  var displayMonths = useNavigation().displayMonths;
  var captionId = useId(dayPicker.id ? "".concat(dayPicker.id, "-").concat(props.displayIndex) : void 0);
  var tableId = dayPicker.id ? "".concat(dayPicker.id, "-grid-").concat(props.displayIndex) : void 0;
  var className = [classNames.month];
  var style = styles.month;
  var isStart = props.displayIndex === 0;
  var isEnd = props.displayIndex === displayMonths.length - 1;
  var isCenter = !isStart && !isEnd;
  if (dir === "rtl") {
    _a = [isStart, isEnd], isEnd = _a[0], isStart = _a[1];
  }
  if (isStart) {
    className.push(classNames.caption_start);
    style = __assign(__assign({}, style), styles.caption_start);
  }
  if (isEnd) {
    className.push(classNames.caption_end);
    style = __assign(__assign({}, style), styles.caption_end);
  }
  if (isCenter) {
    className.push(classNames.caption_between);
    style = __assign(__assign({}, style), styles.caption_between);
  }
  var CaptionComponent = (_b = components === null || components === void 0 ? void 0 : components.Caption) !== null && _b !== void 0 ? _b : Caption;
  return jsxRuntimeExports.jsxs("div", { className: className.join(" "), style, children: [jsxRuntimeExports.jsx(CaptionComponent, { id: captionId, displayMonth: props.displayMonth, displayIndex: props.displayIndex }), jsxRuntimeExports.jsx(Table$1, { id: tableId, "aria-labelledby": captionId, displayMonth: props.displayMonth })] }, props.displayIndex);
}
function Months(props) {
  var _a = useDayPicker(), classNames = _a.classNames, styles = _a.styles;
  return jsxRuntimeExports.jsx("div", { className: classNames.months, style: styles.months, children: props.children });
}
function Root$a(_a) {
  var _b, _c;
  var initialProps = _a.initialProps;
  var dayPicker = useDayPicker();
  var focusContext = useFocusContext();
  var navigation = useNavigation();
  var _d = useState(false), hasInitialFocus = _d[0], setHasInitialFocus = _d[1];
  useEffect(function() {
    if (!dayPicker.initialFocus)
      return;
    if (!focusContext.focusTarget)
      return;
    if (hasInitialFocus)
      return;
    focusContext.focus(focusContext.focusTarget);
    setHasInitialFocus(true);
  }, [
    dayPicker.initialFocus,
    hasInitialFocus,
    focusContext.focus,
    focusContext.focusTarget,
    focusContext
  ]);
  var classNames = [dayPicker.classNames.root, dayPicker.className];
  if (dayPicker.numberOfMonths > 1) {
    classNames.push(dayPicker.classNames.multiple_months);
  }
  if (dayPicker.showWeekNumber) {
    classNames.push(dayPicker.classNames.with_weeknumber);
  }
  var style = __assign(__assign({}, dayPicker.styles.root), dayPicker.style);
  var dataAttributes = Object.keys(initialProps).filter(function(key) {
    return key.startsWith("data-");
  }).reduce(function(attrs, key) {
    var _a2;
    return __assign(__assign({}, attrs), (_a2 = {}, _a2[key] = initialProps[key], _a2));
  }, {});
  var MonthsComponent = (_c = (_b = initialProps.components) === null || _b === void 0 ? void 0 : _b.Months) !== null && _c !== void 0 ? _c : Months;
  return jsxRuntimeExports.jsx("div", __assign({ className: classNames.join(" "), style, dir: dayPicker.dir, id: dayPicker.id, nonce: initialProps.nonce, title: initialProps.title, lang: initialProps.lang }, dataAttributes, { children: jsxRuntimeExports.jsx(MonthsComponent, { children: navigation.displayMonths.map(function(month2, i2) {
    return jsxRuntimeExports.jsx(Month, { displayIndex: i2, displayMonth: month2 }, i2);
  }) }) }));
}
function RootProvider(props) {
  var children = props.children, initialProps = __rest(props, ["children"]);
  return jsxRuntimeExports.jsx(DayPickerProvider, { initialProps, children: jsxRuntimeExports.jsx(NavigationProvider, { children: jsxRuntimeExports.jsx(SelectSingleProvider, { initialProps, children: jsxRuntimeExports.jsx(SelectMultipleProvider, { initialProps, children: jsxRuntimeExports.jsx(SelectRangeProvider, { initialProps, children: jsxRuntimeExports.jsx(ModifiersProvider, { children: jsxRuntimeExports.jsx(FocusProvider, { children }) }) }) }) }) }) });
}
function DayPicker(props) {
  return jsxRuntimeExports.jsx(RootProvider, __assign({}, props, { children: jsxRuntimeExports.jsx(Root$a, { initialProps: props }) }));
}
function Calendar({ className, classNames, showOutsideDays = true, ...props }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    DayPicker,
    {
      showOutsideDays,
      className: cn("p-3", className),
      classNames: {
        months: "flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0",
        month: "space-y-4",
        caption: "flex justify-center pt-1 relative items-center",
        caption_label: "text-sm font-medium",
        nav: "space-x-1 flex items-center",
        nav_button: cn(
          buttonVariants({ variant: "outline" }),
          "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100"
        ),
        nav_button_previous: "absolute left-1",
        nav_button_next: "absolute right-1",
        table: "w-full border-collapse space-y-1",
        head_row: "flex",
        head_cell: "text-muted-foreground rounded-md w-9 font-normal text-[0.8rem]",
        row: "flex w-full mt-2",
        cell: "h-9 w-9 text-center text-sm p-0 relative [&:has([aria-selected].day-range-end)]:rounded-r-md [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected])]:bg-accent first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md focus-within:relative focus-within:z-20",
        day: cn(
          buttonVariants({ variant: "ghost" }),
          "h-9 w-9 p-0 font-normal aria-selected:opacity-100"
        ),
        day_range_end: "day-range-end",
        day_selected: "bg-primary text-white hover:bg-primary hover:text-white focus:bg-primary focus:text-primary-foreground",
        day_today: "bg-accent text-accent-foreground",
        day_outside: "day-outside text-muted-foreground opacity-50 aria-selected:bg-accent/50 aria-selected:text-muted-foreground aria-selected:opacity-30",
        day_disabled: "text-muted-foreground opacity-50",
        day_range_middle: "aria-selected:bg-accent aria-selected:text-accent-foreground",
        day_hidden: "invisible",
        ...classNames
      },
      components: {
        IconLeft: ({ ...props2 }) => /* @__PURE__ */ jsxRuntimeExports.jsx(SvgArrowLeft, { className: "h-4 w-4" }),
        IconRight: ({ ...props2 }) => /* @__PURE__ */ jsxRuntimeExports.jsx(SvgArrowRight, { className: "h-4 w-4" })
      },
      ...props
    }
  );
}
Calendar.displayName = "Calendar";
function isObject$1(subject) {
  return Object.prototype.toString.call(subject) === "[object Object]";
}
function isRecord(subject) {
  return isObject$1(subject) || Array.isArray(subject);
}
function canUseDOM() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
function areOptionsEqual(optionsA, optionsB) {
  const optionsAKeys = Object.keys(optionsA);
  const optionsBKeys = Object.keys(optionsB);
  if (optionsAKeys.length !== optionsBKeys.length) return false;
  const breakpointsA = JSON.stringify(Object.keys(optionsA.breakpoints || {}));
  const breakpointsB = JSON.stringify(Object.keys(optionsB.breakpoints || {}));
  if (breakpointsA !== breakpointsB) return false;
  return optionsAKeys.every((key) => {
    const valueA = optionsA[key];
    const valueB = optionsB[key];
    if (typeof valueA === "function") return `${valueA}` === `${valueB}`;
    if (!isRecord(valueA) || !isRecord(valueB)) return valueA === valueB;
    return areOptionsEqual(valueA, valueB);
  });
}
function sortAndMapPluginToOptions(plugins) {
  return plugins.concat().sort((a, b) => a.name > b.name ? 1 : -1).map((plugin) => plugin.options);
}
function arePluginsEqual(pluginsA, pluginsB) {
  if (pluginsA.length !== pluginsB.length) return false;
  const optionsA = sortAndMapPluginToOptions(pluginsA);
  const optionsB = sortAndMapPluginToOptions(pluginsB);
  return optionsA.every((optionA, index2) => {
    const optionB = optionsB[index2];
    return areOptionsEqual(optionA, optionB);
  });
}
function isNumber(subject) {
  return typeof subject === "number";
}
function isString(subject) {
  return typeof subject === "string";
}
function isBoolean(subject) {
  return typeof subject === "boolean";
}
function isObject(subject) {
  return Object.prototype.toString.call(subject) === "[object Object]";
}
function mathAbs(n2) {
  return Math.abs(n2);
}
function mathSign(n2) {
  return Math.sign(n2);
}
function deltaAbs(valueB, valueA) {
  return mathAbs(valueB - valueA);
}
function factorAbs(valueB, valueA) {
  if (valueB === 0 || valueA === 0) return 0;
  if (mathAbs(valueB) <= mathAbs(valueA)) return 0;
  const diff = deltaAbs(mathAbs(valueB), mathAbs(valueA));
  return mathAbs(diff / valueB);
}
function roundToTwoDecimals(num) {
  return Math.round(num * 100) / 100;
}
function arrayKeys(array) {
  return objectKeys(array).map(Number);
}
function arrayLast(array) {
  return array[arrayLastIndex(array)];
}
function arrayLastIndex(array) {
  return Math.max(0, array.length - 1);
}
function arrayIsLastIndex(array, index2) {
  return index2 === arrayLastIndex(array);
}
function arrayFromNumber(n2, startAt = 0) {
  return Array.from(Array(n2), (_, i2) => startAt + i2);
}
function objectKeys(object) {
  return Object.keys(object);
}
function objectsMergeDeep(objectA, objectB) {
  return [objectA, objectB].reduce((mergedObjects, currentObject) => {
    objectKeys(currentObject).forEach((key) => {
      const valueA = mergedObjects[key];
      const valueB = currentObject[key];
      const areObjects = isObject(valueA) && isObject(valueB);
      mergedObjects[key] = areObjects ? objectsMergeDeep(valueA, valueB) : valueB;
    });
    return mergedObjects;
  }, {});
}
function isMouseEvent(evt, ownerWindow) {
  return typeof ownerWindow.MouseEvent !== "undefined" && evt instanceof ownerWindow.MouseEvent;
}
function Alignment(align2, viewSize) {
  const predefined = {
    start: start2,
    center: center2,
    end: end2
  };
  function start2() {
    return 0;
  }
  function center2(n2) {
    return end2(n2) / 2;
  }
  function end2(n2) {
    return viewSize - n2;
  }
  function measure(n2, index2) {
    if (isString(align2)) return predefined[align2](n2);
    return align2(viewSize, n2, index2);
  }
  const self2 = {
    measure
  };
  return self2;
}
function EventStore() {
  let listeners2 = [];
  function add2(node, type2, handler, options = {
    passive: true
  }) {
    let removeListener;
    if ("addEventListener" in node) {
      node.addEventListener(type2, handler, options);
      removeListener = () => node.removeEventListener(type2, handler, options);
    } else {
      const legacyMediaQueryList = node;
      legacyMediaQueryList.addListener(handler);
      removeListener = () => legacyMediaQueryList.removeListener(handler);
    }
    listeners2.push(removeListener);
    return self2;
  }
  function clear() {
    listeners2 = listeners2.filter((remove2) => remove2());
  }
  const self2 = {
    add: add2,
    clear
  };
  return self2;
}
function Animations(ownerDocument, ownerWindow, update, render) {
  const documentVisibleHandler = EventStore();
  const fixedTimeStep = 1e3 / 60;
  let lastTimeStamp = null;
  let accumulatedTime = 0;
  let animationId = 0;
  function init() {
    documentVisibleHandler.add(ownerDocument, "visibilitychange", () => {
      if (ownerDocument.hidden) reset();
    });
  }
  function destroy() {
    stop();
    documentVisibleHandler.clear();
  }
  function animate(timeStamp) {
    if (!animationId) return;
    if (!lastTimeStamp) lastTimeStamp = timeStamp;
    const timeElapsed = timeStamp - lastTimeStamp;
    lastTimeStamp = timeStamp;
    accumulatedTime += timeElapsed;
    while (accumulatedTime >= fixedTimeStep) {
      update();
      accumulatedTime -= fixedTimeStep;
    }
    const alpha = accumulatedTime / fixedTimeStep;
    render(alpha);
    if (animationId) {
      animationId = ownerWindow.requestAnimationFrame(animate);
    }
  }
  function start2() {
    if (animationId) return;
    animationId = ownerWindow.requestAnimationFrame(animate);
  }
  function stop() {
    ownerWindow.cancelAnimationFrame(animationId);
    lastTimeStamp = null;
    accumulatedTime = 0;
    animationId = 0;
  }
  function reset() {
    lastTimeStamp = null;
    accumulatedTime = 0;
  }
  const self2 = {
    init,
    destroy,
    start: start2,
    stop,
    update,
    render
  };
  return self2;
}
function Axis(axis, contentDirection) {
  const isRightToLeft = contentDirection === "rtl";
  const isVertical = axis === "y";
  const scroll = isVertical ? "y" : "x";
  const cross = isVertical ? "x" : "y";
  const sign = !isVertical && isRightToLeft ? -1 : 1;
  const startEdge = getStartEdge();
  const endEdge = getEndEdge();
  function measureSize(nodeRect) {
    const {
      height,
      width
    } = nodeRect;
    return isVertical ? height : width;
  }
  function getStartEdge() {
    if (isVertical) return "top";
    return isRightToLeft ? "right" : "left";
  }
  function getEndEdge() {
    if (isVertical) return "bottom";
    return isRightToLeft ? "left" : "right";
  }
  function direction(n2) {
    return n2 * sign;
  }
  const self2 = {
    scroll,
    cross,
    startEdge,
    endEdge,
    measureSize,
    direction
  };
  return self2;
}
function Limit(min2 = 0, max2 = 0) {
  const length = mathAbs(min2 - max2);
  function reachedMin(n2) {
    return n2 < min2;
  }
  function reachedMax(n2) {
    return n2 > max2;
  }
  function reachedAny(n2) {
    return reachedMin(n2) || reachedMax(n2);
  }
  function constrain(n2) {
    if (!reachedAny(n2)) return n2;
    return reachedMin(n2) ? min2 : max2;
  }
  function removeOffset(n2) {
    if (!length) return n2;
    return n2 - length * Math.ceil((n2 - max2) / length);
  }
  const self2 = {
    length,
    max: max2,
    min: min2,
    constrain,
    reachedAny,
    reachedMax,
    reachedMin,
    removeOffset
  };
  return self2;
}
function Counter(max2, start2, loop) {
  const {
    constrain
  } = Limit(0, max2);
  const loopEnd = max2 + 1;
  let counter = withinLimit(start2);
  function withinLimit(n2) {
    return !loop ? constrain(n2) : mathAbs((loopEnd + n2) % loopEnd);
  }
  function get2() {
    return counter;
  }
  function set2(n2) {
    counter = withinLimit(n2);
    return self2;
  }
  function add2(n2) {
    return clone().set(get2() + n2);
  }
  function clone() {
    return Counter(max2, get2(), loop);
  }
  const self2 = {
    get: get2,
    set: set2,
    add: add2,
    clone
  };
  return self2;
}
function DragHandler(axis, rootNode, ownerDocument, ownerWindow, target2, dragTracker, location2, animation, scrollTo, scrollBody, scrollTarget, index2, eventHandler, percentOfView, dragFree, dragThreshold, skipSnaps, baseFriction, watchDrag) {
  const {
    cross: crossAxis,
    direction
  } = axis;
  const focusNodes = ["INPUT", "SELECT", "TEXTAREA"];
  const nonPassiveEvent = {
    passive: false
  };
  const initEvents = EventStore();
  const dragEvents = EventStore();
  const goToNextThreshold = Limit(50, 225).constrain(percentOfView.measure(20));
  const snapForceBoost = {
    mouse: 300,
    touch: 400
  };
  const freeForceBoost = {
    mouse: 500,
    touch: 600
  };
  const baseSpeed = dragFree ? 43 : 25;
  let isMoving = false;
  let startScroll = 0;
  let startCross = 0;
  let pointerIsDown = false;
  let preventScroll = false;
  let preventClick = false;
  let isMouse = false;
  function init(emblaApi) {
    if (!watchDrag) return;
    function downIfAllowed(evt) {
      if (isBoolean(watchDrag) || watchDrag(emblaApi, evt)) down(evt);
    }
    const node = rootNode;
    initEvents.add(node, "dragstart", (evt) => evt.preventDefault(), nonPassiveEvent).add(node, "touchmove", () => void 0, nonPassiveEvent).add(node, "touchend", () => void 0).add(node, "touchstart", downIfAllowed).add(node, "mousedown", downIfAllowed).add(node, "touchcancel", up).add(node, "contextmenu", up).add(node, "click", click, true);
  }
  function destroy() {
    initEvents.clear();
    dragEvents.clear();
  }
  function addDragEvents() {
    const node = isMouse ? ownerDocument : rootNode;
    dragEvents.add(node, "touchmove", move, nonPassiveEvent).add(node, "touchend", up).add(node, "mousemove", move, nonPassiveEvent).add(node, "mouseup", up);
  }
  function isFocusNode(node) {
    const nodeName = node.nodeName || "";
    return focusNodes.includes(nodeName);
  }
  function forceBoost() {
    const boost = dragFree ? freeForceBoost : snapForceBoost;
    const type2 = isMouse ? "mouse" : "touch";
    return boost[type2];
  }
  function allowedForce(force, targetChanged) {
    const next = index2.add(mathSign(force) * -1);
    const baseForce = scrollTarget.byDistance(force, !dragFree).distance;
    if (dragFree || mathAbs(force) < goToNextThreshold) return baseForce;
    if (skipSnaps && targetChanged) return baseForce * 0.5;
    return scrollTarget.byIndex(next.get(), 0).distance;
  }
  function down(evt) {
    const isMouseEvt = isMouseEvent(evt, ownerWindow);
    isMouse = isMouseEvt;
    preventClick = dragFree && isMouseEvt && !evt.buttons && isMoving;
    isMoving = deltaAbs(target2.get(), location2.get()) >= 2;
    if (isMouseEvt && evt.button !== 0) return;
    if (isFocusNode(evt.target)) return;
    pointerIsDown = true;
    dragTracker.pointerDown(evt);
    scrollBody.useFriction(0).useDuration(0);
    target2.set(location2);
    addDragEvents();
    startScroll = dragTracker.readPoint(evt);
    startCross = dragTracker.readPoint(evt, crossAxis);
    eventHandler.emit("pointerDown");
  }
  function move(evt) {
    const isTouchEvt = !isMouseEvent(evt, ownerWindow);
    if (isTouchEvt && evt.touches.length >= 2) return up(evt);
    const lastScroll = dragTracker.readPoint(evt);
    const lastCross = dragTracker.readPoint(evt, crossAxis);
    const diffScroll = deltaAbs(lastScroll, startScroll);
    const diffCross = deltaAbs(lastCross, startCross);
    if (!preventScroll && !isMouse) {
      if (!evt.cancelable) return up(evt);
      preventScroll = diffScroll > diffCross;
      if (!preventScroll) return up(evt);
    }
    const diff = dragTracker.pointerMove(evt);
    if (diffScroll > dragThreshold) preventClick = true;
    scrollBody.useFriction(0.3).useDuration(0.75);
    animation.start();
    target2.add(direction(diff));
    evt.preventDefault();
  }
  function up(evt) {
    const currentLocation = scrollTarget.byDistance(0, false);
    const targetChanged = currentLocation.index !== index2.get();
    const rawForce = dragTracker.pointerUp(evt) * forceBoost();
    const force = allowedForce(direction(rawForce), targetChanged);
    const forceFactor = factorAbs(rawForce, force);
    const speed = baseSpeed - 10 * forceFactor;
    const friction = baseFriction + forceFactor / 50;
    preventScroll = false;
    pointerIsDown = false;
    dragEvents.clear();
    scrollBody.useDuration(speed).useFriction(friction);
    scrollTo.distance(force, !dragFree);
    isMouse = false;
    eventHandler.emit("pointerUp");
  }
  function click(evt) {
    if (preventClick) {
      evt.stopPropagation();
      evt.preventDefault();
      preventClick = false;
    }
  }
  function pointerDown() {
    return pointerIsDown;
  }
  const self2 = {
    init,
    destroy,
    pointerDown
  };
  return self2;
}
function DragTracker(axis, ownerWindow) {
  const logInterval = 170;
  let startEvent;
  let lastEvent;
  function readTime(evt) {
    return evt.timeStamp;
  }
  function readPoint(evt, evtAxis) {
    const property2 = evtAxis || axis.scroll;
    const coord = `client${property2 === "x" ? "X" : "Y"}`;
    return (isMouseEvent(evt, ownerWindow) ? evt : evt.touches[0])[coord];
  }
  function pointerDown(evt) {
    startEvent = evt;
    lastEvent = evt;
    return readPoint(evt);
  }
  function pointerMove(evt) {
    const diff = readPoint(evt) - readPoint(lastEvent);
    const expired = readTime(evt) - readTime(startEvent) > logInterval;
    lastEvent = evt;
    if (expired) startEvent = evt;
    return diff;
  }
  function pointerUp(evt) {
    if (!startEvent || !lastEvent) return 0;
    const diffDrag = readPoint(lastEvent) - readPoint(startEvent);
    const diffTime = readTime(evt) - readTime(startEvent);
    const expired = readTime(evt) - readTime(lastEvent) > logInterval;
    const force = diffDrag / diffTime;
    const isFlick = diffTime && !expired && mathAbs(force) > 0.1;
    return isFlick ? force : 0;
  }
  const self2 = {
    pointerDown,
    pointerMove,
    pointerUp,
    readPoint
  };
  return self2;
}
function NodeRects() {
  function measure(node) {
    const {
      offsetTop,
      offsetLeft,
      offsetWidth,
      offsetHeight
    } = node;
    const offset2 = {
      top: offsetTop,
      right: offsetLeft + offsetWidth,
      bottom: offsetTop + offsetHeight,
      left: offsetLeft,
      width: offsetWidth,
      height: offsetHeight
    };
    return offset2;
  }
  const self2 = {
    measure
  };
  return self2;
}
function PercentOfView(viewSize) {
  function measure(n2) {
    return viewSize * (n2 / 100);
  }
  const self2 = {
    measure
  };
  return self2;
}
function ResizeHandler(container, eventHandler, ownerWindow, slides, axis, watchResize, nodeRects) {
  const observeNodes = [container].concat(slides);
  let resizeObserver;
  let containerSize;
  let slideSizes = [];
  let destroyed = false;
  function readSize(node) {
    return axis.measureSize(nodeRects.measure(node));
  }
  function init(emblaApi) {
    if (!watchResize) return;
    containerSize = readSize(container);
    slideSizes = slides.map(readSize);
    function defaultCallback(entries) {
      for (const entry of entries) {
        if (destroyed) return;
        const isContainer = entry.target === container;
        const slideIndex = slides.indexOf(entry.target);
        const lastSize = isContainer ? containerSize : slideSizes[slideIndex];
        const newSize = readSize(isContainer ? container : slides[slideIndex]);
        const diffSize = mathAbs(newSize - lastSize);
        if (diffSize >= 0.5) {
          emblaApi.reInit();
          eventHandler.emit("resize");
          break;
        }
      }
    }
    resizeObserver = new ResizeObserver((entries) => {
      if (isBoolean(watchResize) || watchResize(emblaApi, entries)) {
        defaultCallback(entries);
      }
    });
    ownerWindow.requestAnimationFrame(() => {
      observeNodes.forEach((node) => resizeObserver.observe(node));
    });
  }
  function destroy() {
    destroyed = true;
    if (resizeObserver) resizeObserver.disconnect();
  }
  const self2 = {
    init,
    destroy
  };
  return self2;
}
function ScrollBody(location2, offsetLocation, previousLocation, target2, baseDuration, baseFriction) {
  let scrollVelocity = 0;
  let scrollDirection = 0;
  let scrollDuration = baseDuration;
  let scrollFriction = baseFriction;
  let rawLocation = location2.get();
  let rawLocationPrevious = 0;
  function seek() {
    const displacement = target2.get() - location2.get();
    const isInstant = !scrollDuration;
    let scrollDistance = 0;
    if (isInstant) {
      scrollVelocity = 0;
      previousLocation.set(target2);
      location2.set(target2);
      scrollDistance = displacement;
    } else {
      previousLocation.set(location2);
      scrollVelocity += displacement / scrollDuration;
      scrollVelocity *= scrollFriction;
      rawLocation += scrollVelocity;
      location2.add(scrollVelocity);
      scrollDistance = rawLocation - rawLocationPrevious;
    }
    scrollDirection = mathSign(scrollDistance);
    rawLocationPrevious = rawLocation;
    return self2;
  }
  function settled() {
    const diff = target2.get() - offsetLocation.get();
    return mathAbs(diff) < 1e-3;
  }
  function duration() {
    return scrollDuration;
  }
  function direction() {
    return scrollDirection;
  }
  function velocity() {
    return scrollVelocity;
  }
  function useBaseDuration() {
    return useDuration(baseDuration);
  }
  function useBaseFriction() {
    return useFriction(baseFriction);
  }
  function useDuration(n2) {
    scrollDuration = n2;
    return self2;
  }
  function useFriction(n2) {
    scrollFriction = n2;
    return self2;
  }
  const self2 = {
    direction,
    duration,
    velocity,
    seek,
    settled,
    useBaseFriction,
    useBaseDuration,
    useFriction,
    useDuration
  };
  return self2;
}
function ScrollBounds(limit, location2, target2, scrollBody, percentOfView) {
  const pullBackThreshold = percentOfView.measure(10);
  const edgeOffsetTolerance = percentOfView.measure(50);
  const frictionLimit = Limit(0.1, 0.99);
  let disabled = false;
  function shouldConstrain() {
    if (disabled) return false;
    if (!limit.reachedAny(target2.get())) return false;
    if (!limit.reachedAny(location2.get())) return false;
    return true;
  }
  function constrain(pointerDown) {
    if (!shouldConstrain()) return;
    const edge = limit.reachedMin(location2.get()) ? "min" : "max";
    const diffToEdge = mathAbs(limit[edge] - location2.get());
    const diffToTarget = target2.get() - location2.get();
    const friction = frictionLimit.constrain(diffToEdge / edgeOffsetTolerance);
    target2.subtract(diffToTarget * friction);
    if (!pointerDown && mathAbs(diffToTarget) < pullBackThreshold) {
      target2.set(limit.constrain(target2.get()));
      scrollBody.useDuration(25).useBaseFriction();
    }
  }
  function toggleActive(active2) {
    disabled = !active2;
  }
  const self2 = {
    shouldConstrain,
    constrain,
    toggleActive
  };
  return self2;
}
function ScrollContain(viewSize, contentSize, snapsAligned, containScroll, pixelTolerance) {
  const scrollBounds = Limit(-contentSize + viewSize, 0);
  const snapsBounded = measureBounded();
  const scrollContainLimit = findScrollContainLimit();
  const snapsContained = measureContained();
  function usePixelTolerance(bound, snap) {
    return deltaAbs(bound, snap) < 1;
  }
  function findScrollContainLimit() {
    const startSnap = snapsBounded[0];
    const endSnap = arrayLast(snapsBounded);
    const min2 = snapsBounded.lastIndexOf(startSnap);
    const max2 = snapsBounded.indexOf(endSnap) + 1;
    return Limit(min2, max2);
  }
  function measureBounded() {
    return snapsAligned.map((snapAligned, index2) => {
      const {
        min: min2,
        max: max2
      } = scrollBounds;
      const snap = scrollBounds.constrain(snapAligned);
      const isFirst = !index2;
      const isLast = arrayIsLastIndex(snapsAligned, index2);
      if (isFirst) return max2;
      if (isLast) return min2;
      if (usePixelTolerance(min2, snap)) return min2;
      if (usePixelTolerance(max2, snap)) return max2;
      return snap;
    }).map((scrollBound) => parseFloat(scrollBound.toFixed(3)));
  }
  function measureContained() {
    if (contentSize <= viewSize + pixelTolerance) return [scrollBounds.max];
    if (containScroll === "keepSnaps") return snapsBounded;
    const {
      min: min2,
      max: max2
    } = scrollContainLimit;
    return snapsBounded.slice(min2, max2);
  }
  const self2 = {
    snapsContained,
    scrollContainLimit
  };
  return self2;
}
function ScrollLimit(contentSize, scrollSnaps, loop) {
  const max2 = scrollSnaps[0];
  const min2 = loop ? max2 - contentSize : arrayLast(scrollSnaps);
  const limit = Limit(min2, max2);
  const self2 = {
    limit
  };
  return self2;
}
function ScrollLooper(contentSize, limit, location2, vectors) {
  const jointSafety = 0.1;
  const min2 = limit.min + jointSafety;
  const max2 = limit.max + jointSafety;
  const {
    reachedMin,
    reachedMax
  } = Limit(min2, max2);
  function shouldLoop(direction) {
    if (direction === 1) return reachedMax(location2.get());
    if (direction === -1) return reachedMin(location2.get());
    return false;
  }
  function loop(direction) {
    if (!shouldLoop(direction)) return;
    const loopDistance = contentSize * (direction * -1);
    vectors.forEach((v) => v.add(loopDistance));
  }
  const self2 = {
    loop
  };
  return self2;
}
function ScrollProgress(limit) {
  const {
    max: max2,
    length
  } = limit;
  function get2(n2) {
    const currentLocation = n2 - max2;
    return length ? currentLocation / -length : 0;
  }
  const self2 = {
    get: get2
  };
  return self2;
}
function ScrollSnaps(axis, alignment, containerRect, slideRects, slidesToScroll) {
  const {
    startEdge,
    endEdge
  } = axis;
  const {
    groupSlides
  } = slidesToScroll;
  const alignments = measureSizes().map(alignment.measure);
  const snaps = measureUnaligned();
  const snapsAligned = measureAligned();
  function measureSizes() {
    return groupSlides(slideRects).map((rects) => arrayLast(rects)[endEdge] - rects[0][startEdge]).map(mathAbs);
  }
  function measureUnaligned() {
    return slideRects.map((rect) => containerRect[startEdge] - rect[startEdge]).map((snap) => -mathAbs(snap));
  }
  function measureAligned() {
    return groupSlides(snaps).map((g) => g[0]).map((snap, index2) => snap + alignments[index2]);
  }
  const self2 = {
    snaps,
    snapsAligned
  };
  return self2;
}
function SlideRegistry(containSnaps, containScroll, scrollSnaps, scrollContainLimit, slidesToScroll, slideIndexes) {
  const {
    groupSlides
  } = slidesToScroll;
  const {
    min: min2,
    max: max2
  } = scrollContainLimit;
  const slideRegistry = createSlideRegistry();
  function createSlideRegistry() {
    const groupedSlideIndexes = groupSlides(slideIndexes);
    const doNotContain = !containSnaps || containScroll === "keepSnaps";
    if (scrollSnaps.length === 1) return [slideIndexes];
    if (doNotContain) return groupedSlideIndexes;
    return groupedSlideIndexes.slice(min2, max2).map((group2, index2, groups) => {
      const isFirst = !index2;
      const isLast = arrayIsLastIndex(groups, index2);
      if (isFirst) {
        const range2 = arrayLast(groups[0]) + 1;
        return arrayFromNumber(range2);
      }
      if (isLast) {
        const range2 = arrayLastIndex(slideIndexes) - arrayLast(groups)[0] + 1;
        return arrayFromNumber(range2, arrayLast(groups)[0]);
      }
      return group2;
    });
  }
  const self2 = {
    slideRegistry
  };
  return self2;
}
function ScrollTarget(loop, scrollSnaps, contentSize, limit, targetVector) {
  const {
    reachedAny,
    removeOffset,
    constrain
  } = limit;
  function minDistance(distances) {
    return distances.concat().sort((a, b) => mathAbs(a) - mathAbs(b))[0];
  }
  function findTargetSnap(target2) {
    const distance2 = loop ? removeOffset(target2) : constrain(target2);
    const ascDiffsToSnaps = scrollSnaps.map((snap, index3) => ({
      diff: shortcut(snap - distance2, 0),
      index: index3
    })).sort((d1, d2) => mathAbs(d1.diff) - mathAbs(d2.diff));
    const {
      index: index2
    } = ascDiffsToSnaps[0];
    return {
      index: index2,
      distance: distance2
    };
  }
  function shortcut(target2, direction) {
    const targets = [target2, target2 + contentSize, target2 - contentSize];
    if (!loop) return target2;
    if (!direction) return minDistance(targets);
    const matchingTargets = targets.filter((t2) => mathSign(t2) === direction);
    if (matchingTargets.length) return minDistance(matchingTargets);
    return arrayLast(targets) - contentSize;
  }
  function byIndex(index2, direction) {
    const diffToSnap = scrollSnaps[index2] - targetVector.get();
    const distance2 = shortcut(diffToSnap, direction);
    return {
      index: index2,
      distance: distance2
    };
  }
  function byDistance(distance2, snap) {
    const target2 = targetVector.get() + distance2;
    const {
      index: index2,
      distance: targetSnapDistance
    } = findTargetSnap(target2);
    const reachedBound = !loop && reachedAny(target2);
    if (!snap || reachedBound) return {
      index: index2,
      distance: distance2
    };
    const diffToSnap = scrollSnaps[index2] - targetSnapDistance;
    const snapDistance = distance2 + shortcut(diffToSnap, 0);
    return {
      index: index2,
      distance: snapDistance
    };
  }
  const self2 = {
    byDistance,
    byIndex,
    shortcut
  };
  return self2;
}
function ScrollTo(animation, indexCurrent, indexPrevious, scrollBody, scrollTarget, targetVector, eventHandler) {
  function scrollTo(target2) {
    const distanceDiff = target2.distance;
    const indexDiff = target2.index !== indexCurrent.get();
    targetVector.add(distanceDiff);
    if (distanceDiff) {
      if (scrollBody.duration()) {
        animation.start();
      } else {
        animation.update();
        animation.render(1);
        animation.update();
      }
    }
    if (indexDiff) {
      indexPrevious.set(indexCurrent.get());
      indexCurrent.set(target2.index);
      eventHandler.emit("select");
    }
  }
  function distance2(n2, snap) {
    const target2 = scrollTarget.byDistance(n2, snap);
    scrollTo(target2);
  }
  function index2(n2, direction) {
    const targetIndex = indexCurrent.clone().set(n2);
    const target2 = scrollTarget.byIndex(targetIndex.get(), direction);
    scrollTo(target2);
  }
  const self2 = {
    distance: distance2,
    index: index2
  };
  return self2;
}
function SlideFocus(root2, slides, slideRegistry, scrollTo, scrollBody, eventStore, eventHandler, watchFocus) {
  const focusListenerOptions = {
    passive: true,
    capture: true
  };
  let lastTabPressTime = 0;
  function init(emblaApi) {
    if (!watchFocus) return;
    function defaultCallback(index2) {
      const nowTime = (/* @__PURE__ */ new Date()).getTime();
      const diffTime = nowTime - lastTabPressTime;
      if (diffTime > 10) return;
      eventHandler.emit("slideFocusStart");
      root2.scrollLeft = 0;
      const group2 = slideRegistry.findIndex((group3) => group3.includes(index2));
      if (!isNumber(group2)) return;
      scrollBody.useDuration(0);
      scrollTo.index(group2, 0);
      eventHandler.emit("slideFocus");
    }
    eventStore.add(document, "keydown", registerTabPress, false);
    slides.forEach((slide, slideIndex) => {
      eventStore.add(slide, "focus", (evt) => {
        if (isBoolean(watchFocus) || watchFocus(emblaApi, evt)) {
          defaultCallback(slideIndex);
        }
      }, focusListenerOptions);
    });
  }
  function registerTabPress(event) {
    if (event.code === "Tab") lastTabPressTime = (/* @__PURE__ */ new Date()).getTime();
  }
  const self2 = {
    init
  };
  return self2;
}
function Vector1D(initialValue) {
  let value2 = initialValue;
  function get2() {
    return value2;
  }
  function set2(n2) {
    value2 = normalizeInput(n2);
  }
  function add2(n2) {
    value2 += normalizeInput(n2);
  }
  function subtract(n2) {
    value2 -= normalizeInput(n2);
  }
  function normalizeInput(n2) {
    return isNumber(n2) ? n2 : n2.get();
  }
  const self2 = {
    get: get2,
    set: set2,
    add: add2,
    subtract
  };
  return self2;
}
function Translate(axis, container) {
  const translate2 = axis.scroll === "x" ? x : y;
  const containerStyle = container.style;
  let previousTarget = null;
  let disabled = false;
  function x(n2) {
    return `translate3d(${n2}px,0px,0px)`;
  }
  function y(n2) {
    return `translate3d(0px,${n2}px,0px)`;
  }
  function to(target2) {
    if (disabled) return;
    const newTarget = roundToTwoDecimals(axis.direction(target2));
    if (newTarget === previousTarget) return;
    containerStyle.transform = translate2(newTarget);
    previousTarget = newTarget;
  }
  function toggleActive(active2) {
    disabled = !active2;
  }
  function clear() {
    if (disabled) return;
    containerStyle.transform = "";
    if (!container.getAttribute("style")) container.removeAttribute("style");
  }
  const self2 = {
    clear,
    to,
    toggleActive
  };
  return self2;
}
function SlideLooper(axis, viewSize, contentSize, slideSizes, slideSizesWithGaps, snaps, scrollSnaps, location2, slides) {
  const roundingSafety = 0.5;
  const ascItems = arrayKeys(slideSizesWithGaps);
  const descItems = arrayKeys(slideSizesWithGaps).reverse();
  const loopPoints = startPoints().concat(endPoints());
  function removeSlideSizes(indexes, from) {
    return indexes.reduce((a, i2) => {
      return a - slideSizesWithGaps[i2];
    }, from);
  }
  function slidesInGap(indexes, gap) {
    return indexes.reduce((a, i2) => {
      const remainingGap = removeSlideSizes(a, gap);
      return remainingGap > 0 ? a.concat([i2]) : a;
    }, []);
  }
  function findSlideBounds(offset2) {
    return snaps.map((snap, index2) => ({
      start: snap - slideSizes[index2] + roundingSafety + offset2,
      end: snap + viewSize - roundingSafety + offset2
    }));
  }
  function findLoopPoints(indexes, offset2, isEndEdge) {
    const slideBounds = findSlideBounds(offset2);
    return indexes.map((index2) => {
      const initial = isEndEdge ? 0 : -contentSize;
      const altered = isEndEdge ? contentSize : 0;
      const boundEdge = isEndEdge ? "end" : "start";
      const loopPoint = slideBounds[index2][boundEdge];
      return {
        index: index2,
        loopPoint,
        slideLocation: Vector1D(-1),
        translate: Translate(axis, slides[index2]),
        target: () => location2.get() > loopPoint ? initial : altered
      };
    });
  }
  function startPoints() {
    const gap = scrollSnaps[0];
    const indexes = slidesInGap(descItems, gap);
    return findLoopPoints(indexes, contentSize, false);
  }
  function endPoints() {
    const gap = viewSize - scrollSnaps[0] - 1;
    const indexes = slidesInGap(ascItems, gap);
    return findLoopPoints(indexes, -contentSize, true);
  }
  function canLoop() {
    return loopPoints.every(({
      index: index2
    }) => {
      const otherIndexes = ascItems.filter((i2) => i2 !== index2);
      return removeSlideSizes(otherIndexes, viewSize) <= 0.1;
    });
  }
  function loop() {
    loopPoints.forEach((loopPoint) => {
      const {
        target: target2,
        translate: translate2,
        slideLocation
      } = loopPoint;
      const shiftLocation = target2();
      if (shiftLocation === slideLocation.get()) return;
      translate2.to(shiftLocation);
      slideLocation.set(shiftLocation);
    });
  }
  function clear() {
    loopPoints.forEach((loopPoint) => loopPoint.translate.clear());
  }
  const self2 = {
    canLoop,
    clear,
    loop,
    loopPoints
  };
  return self2;
}
function SlidesHandler(container, eventHandler, watchSlides) {
  let mutationObserver;
  let destroyed = false;
  function init(emblaApi) {
    if (!watchSlides) return;
    function defaultCallback(mutations) {
      for (const mutation of mutations) {
        if (mutation.type === "childList") {
          emblaApi.reInit();
          eventHandler.emit("slidesChanged");
          break;
        }
      }
    }
    mutationObserver = new MutationObserver((mutations) => {
      if (destroyed) return;
      if (isBoolean(watchSlides) || watchSlides(emblaApi, mutations)) {
        defaultCallback(mutations);
      }
    });
    mutationObserver.observe(container, {
      childList: true
    });
  }
  function destroy() {
    if (mutationObserver) mutationObserver.disconnect();
    destroyed = true;
  }
  const self2 = {
    init,
    destroy
  };
  return self2;
}
function SlidesInView(container, slides, eventHandler, threshold2) {
  const intersectionEntryMap = {};
  let inViewCache = null;
  let notInViewCache = null;
  let intersectionObserver;
  let destroyed = false;
  function init() {
    intersectionObserver = new IntersectionObserver((entries) => {
      if (destroyed) return;
      entries.forEach((entry) => {
        const index2 = slides.indexOf(entry.target);
        intersectionEntryMap[index2] = entry;
      });
      inViewCache = null;
      notInViewCache = null;
      eventHandler.emit("slidesInView");
    }, {
      root: container.parentElement,
      threshold: threshold2
    });
    slides.forEach((slide) => intersectionObserver.observe(slide));
  }
  function destroy() {
    if (intersectionObserver) intersectionObserver.disconnect();
    destroyed = true;
  }
  function createInViewList(inView) {
    return objectKeys(intersectionEntryMap).reduce((list, slideIndex) => {
      const index2 = parseInt(slideIndex);
      const {
        isIntersecting
      } = intersectionEntryMap[index2];
      const inViewMatch = inView && isIntersecting;
      const notInViewMatch = !inView && !isIntersecting;
      if (inViewMatch || notInViewMatch) list.push(index2);
      return list;
    }, []);
  }
  function get2(inView = true) {
    if (inView && inViewCache) return inViewCache;
    if (!inView && notInViewCache) return notInViewCache;
    const slideIndexes = createInViewList(inView);
    if (inView) inViewCache = slideIndexes;
    if (!inView) notInViewCache = slideIndexes;
    return slideIndexes;
  }
  const self2 = {
    init,
    destroy,
    get: get2
  };
  return self2;
}
function SlideSizes(axis, containerRect, slideRects, slides, readEdgeGap, ownerWindow) {
  const {
    measureSize,
    startEdge,
    endEdge
  } = axis;
  const withEdgeGap = slideRects[0] && readEdgeGap;
  const startGap = measureStartGap();
  const endGap = measureEndGap();
  const slideSizes = slideRects.map(measureSize);
  const slideSizesWithGaps = measureWithGaps();
  function measureStartGap() {
    if (!withEdgeGap) return 0;
    const slideRect = slideRects[0];
    return mathAbs(containerRect[startEdge] - slideRect[startEdge]);
  }
  function measureEndGap() {
    if (!withEdgeGap) return 0;
    const style = ownerWindow.getComputedStyle(arrayLast(slides));
    return parseFloat(style.getPropertyValue(`margin-${endEdge}`));
  }
  function measureWithGaps() {
    return slideRects.map((rect, index2, rects) => {
      const isFirst = !index2;
      const isLast = arrayIsLastIndex(rects, index2);
      if (isFirst) return slideSizes[index2] + startGap;
      if (isLast) return slideSizes[index2] + endGap;
      return rects[index2 + 1][startEdge] - rect[startEdge];
    }).map(mathAbs);
  }
  const self2 = {
    slideSizes,
    slideSizesWithGaps,
    startGap,
    endGap
  };
  return self2;
}
function SlidesToScroll(axis, viewSize, slidesToScroll, loop, containerRect, slideRects, startGap, endGap, pixelTolerance) {
  const {
    startEdge,
    endEdge,
    direction
  } = axis;
  const groupByNumber = isNumber(slidesToScroll);
  function byNumber(array, groupSize) {
    return arrayKeys(array).filter((i2) => i2 % groupSize === 0).map((i2) => array.slice(i2, i2 + groupSize));
  }
  function bySize(array) {
    if (!array.length) return [];
    return arrayKeys(array).reduce((groups, rectB, index2) => {
      const rectA = arrayLast(groups) || 0;
      const isFirst = rectA === 0;
      const isLast = rectB === arrayLastIndex(array);
      const edgeA = containerRect[startEdge] - slideRects[rectA][startEdge];
      const edgeB = containerRect[startEdge] - slideRects[rectB][endEdge];
      const gapA = !loop && isFirst ? direction(startGap) : 0;
      const gapB = !loop && isLast ? direction(endGap) : 0;
      const chunkSize = mathAbs(edgeB - gapB - (edgeA + gapA));
      if (index2 && chunkSize > viewSize + pixelTolerance) groups.push(rectB);
      if (isLast) groups.push(array.length);
      return groups;
    }, []).map((currentSize, index2, groups) => {
      const previousSize = Math.max(groups[index2 - 1] || 0);
      return array.slice(previousSize, currentSize);
    });
  }
  function groupSlides(array) {
    return groupByNumber ? byNumber(array, slidesToScroll) : bySize(array);
  }
  const self2 = {
    groupSlides
  };
  return self2;
}
function Engine(root2, container, slides, ownerDocument, ownerWindow, options, eventHandler) {
  const {
    align: align2,
    axis: scrollAxis,
    direction,
    startIndex,
    loop,
    duration,
    dragFree,
    dragThreshold,
    inViewThreshold,
    slidesToScroll: groupSlides,
    skipSnaps,
    containScroll,
    watchResize,
    watchSlides,
    watchDrag,
    watchFocus
  } = options;
  const pixelTolerance = 2;
  const nodeRects = NodeRects();
  const containerRect = nodeRects.measure(container);
  const slideRects = slides.map(nodeRects.measure);
  const axis = Axis(scrollAxis, direction);
  const viewSize = axis.measureSize(containerRect);
  const percentOfView = PercentOfView(viewSize);
  const alignment = Alignment(align2, viewSize);
  const containSnaps = !loop && !!containScroll;
  const readEdgeGap = loop || !!containScroll;
  const {
    slideSizes,
    slideSizesWithGaps,
    startGap,
    endGap
  } = SlideSizes(axis, containerRect, slideRects, slides, readEdgeGap, ownerWindow);
  const slidesToScroll = SlidesToScroll(axis, viewSize, groupSlides, loop, containerRect, slideRects, startGap, endGap, pixelTolerance);
  const {
    snaps,
    snapsAligned
  } = ScrollSnaps(axis, alignment, containerRect, slideRects, slidesToScroll);
  const contentSize = -arrayLast(snaps) + arrayLast(slideSizesWithGaps);
  const {
    snapsContained,
    scrollContainLimit
  } = ScrollContain(viewSize, contentSize, snapsAligned, containScroll, pixelTolerance);
  const scrollSnaps = containSnaps ? snapsContained : snapsAligned;
  const {
    limit
  } = ScrollLimit(contentSize, scrollSnaps, loop);
  const index2 = Counter(arrayLastIndex(scrollSnaps), startIndex, loop);
  const indexPrevious = index2.clone();
  const slideIndexes = arrayKeys(slides);
  const update = ({
    dragHandler,
    scrollBody: scrollBody2,
    scrollBounds,
    options: {
      loop: loop2
    }
  }) => {
    if (!loop2) scrollBounds.constrain(dragHandler.pointerDown());
    scrollBody2.seek();
  };
  const render = ({
    scrollBody: scrollBody2,
    translate: translate2,
    location: location3,
    offsetLocation: offsetLocation2,
    previousLocation: previousLocation2,
    scrollLooper,
    slideLooper,
    dragHandler,
    animation: animation2,
    eventHandler: eventHandler2,
    scrollBounds,
    options: {
      loop: loop2
    }
  }, alpha) => {
    const shouldSettle = scrollBody2.settled();
    const withinBounds = !scrollBounds.shouldConstrain();
    const hasSettled = loop2 ? shouldSettle : shouldSettle && withinBounds;
    if (hasSettled && !dragHandler.pointerDown()) {
      animation2.stop();
      eventHandler2.emit("settle");
    }
    if (!hasSettled) eventHandler2.emit("scroll");
    const interpolatedLocation = location3.get() * alpha + previousLocation2.get() * (1 - alpha);
    offsetLocation2.set(interpolatedLocation);
    if (loop2) {
      scrollLooper.loop(scrollBody2.direction());
      slideLooper.loop();
    }
    translate2.to(offsetLocation2.get());
  };
  const animation = Animations(ownerDocument, ownerWindow, () => update(engine), (alpha) => render(engine, alpha));
  const friction = 0.68;
  const startLocation = scrollSnaps[index2.get()];
  const location2 = Vector1D(startLocation);
  const previousLocation = Vector1D(startLocation);
  const offsetLocation = Vector1D(startLocation);
  const target2 = Vector1D(startLocation);
  const scrollBody = ScrollBody(location2, offsetLocation, previousLocation, target2, duration, friction);
  const scrollTarget = ScrollTarget(loop, scrollSnaps, contentSize, limit, target2);
  const scrollTo = ScrollTo(animation, index2, indexPrevious, scrollBody, scrollTarget, target2, eventHandler);
  const scrollProgress = ScrollProgress(limit);
  const eventStore = EventStore();
  const slidesInView = SlidesInView(container, slides, eventHandler, inViewThreshold);
  const {
    slideRegistry
  } = SlideRegistry(containSnaps, containScroll, scrollSnaps, scrollContainLimit, slidesToScroll, slideIndexes);
  const slideFocus = SlideFocus(root2, slides, slideRegistry, scrollTo, scrollBody, eventStore, eventHandler, watchFocus);
  const engine = {
    ownerDocument,
    ownerWindow,
    eventHandler,
    containerRect,
    slideRects,
    animation,
    axis,
    dragHandler: DragHandler(axis, root2, ownerDocument, ownerWindow, target2, DragTracker(axis, ownerWindow), location2, animation, scrollTo, scrollBody, scrollTarget, index2, eventHandler, percentOfView, dragFree, dragThreshold, skipSnaps, friction, watchDrag),
    eventStore,
    percentOfView,
    index: index2,
    indexPrevious,
    limit,
    location: location2,
    offsetLocation,
    previousLocation,
    options,
    resizeHandler: ResizeHandler(container, eventHandler, ownerWindow, slides, axis, watchResize, nodeRects),
    scrollBody,
    scrollBounds: ScrollBounds(limit, offsetLocation, target2, scrollBody, percentOfView),
    scrollLooper: ScrollLooper(contentSize, limit, offsetLocation, [location2, offsetLocation, previousLocation, target2]),
    scrollProgress,
    scrollSnapList: scrollSnaps.map(scrollProgress.get),
    scrollSnaps,
    scrollTarget,
    scrollTo,
    slideLooper: SlideLooper(axis, viewSize, contentSize, slideSizes, slideSizesWithGaps, snaps, scrollSnaps, offsetLocation, slides),
    slideFocus,
    slidesHandler: SlidesHandler(container, eventHandler, watchSlides),
    slidesInView,
    slideIndexes,
    slideRegistry,
    slidesToScroll,
    target: target2,
    translate: Translate(axis, container)
  };
  return engine;
}
function EventHandler() {
  let listeners2 = {};
  let api;
  function init(emblaApi) {
    api = emblaApi;
  }
  function getListeners(evt) {
    return listeners2[evt] || [];
  }
  function emit(evt) {
    getListeners(evt).forEach((e) => e(api, evt));
    return self2;
  }
  function on2(evt, cb) {
    listeners2[evt] = getListeners(evt).concat([cb]);
    return self2;
  }
  function off2(evt, cb) {
    listeners2[evt] = getListeners(evt).filter((e) => e !== cb);
    return self2;
  }
  function clear() {
    listeners2 = {};
  }
  const self2 = {
    init,
    emit,
    off: off2,
    on: on2,
    clear
  };
  return self2;
}
const defaultOptions = {
  align: "center",
  axis: "x",
  container: null,
  slides: null,
  containScroll: "trimSnaps",
  direction: "ltr",
  slidesToScroll: 1,
  inViewThreshold: 0,
  breakpoints: {},
  dragFree: false,
  dragThreshold: 10,
  loop: false,
  skipSnaps: false,
  duration: 25,
  startIndex: 0,
  active: true,
  watchDrag: true,
  watchResize: true,
  watchSlides: true,
  watchFocus: true
};
function OptionsHandler(ownerWindow) {
  function mergeOptions(optionsA, optionsB) {
    return objectsMergeDeep(optionsA, optionsB || {});
  }
  function optionsAtMedia(options) {
    const optionsAtMedia2 = options.breakpoints || {};
    const matchedMediaOptions = objectKeys(optionsAtMedia2).filter((media) => ownerWindow.matchMedia(media).matches).map((media) => optionsAtMedia2[media]).reduce((a, mediaOption) => mergeOptions(a, mediaOption), {});
    return mergeOptions(options, matchedMediaOptions);
  }
  function optionsMediaQueries(optionsList) {
    return optionsList.map((options) => objectKeys(options.breakpoints || {})).reduce((acc, mediaQueries) => acc.concat(mediaQueries), []).map(ownerWindow.matchMedia);
  }
  const self2 = {
    mergeOptions,
    optionsAtMedia,
    optionsMediaQueries
  };
  return self2;
}
function PluginsHandler(optionsHandler) {
  let activePlugins = [];
  function init(emblaApi, plugins) {
    activePlugins = plugins.filter(({
      options
    }) => optionsHandler.optionsAtMedia(options).active !== false);
    activePlugins.forEach((plugin) => plugin.init(emblaApi, optionsHandler));
    return plugins.reduce((map2, plugin) => Object.assign(map2, {
      [plugin.name]: plugin
    }), {});
  }
  function destroy() {
    activePlugins = activePlugins.filter((plugin) => plugin.destroy());
  }
  const self2 = {
    init,
    destroy
  };
  return self2;
}
function EmblaCarousel(root2, userOptions, userPlugins) {
  const ownerDocument = root2.ownerDocument;
  const ownerWindow = ownerDocument.defaultView;
  const optionsHandler = OptionsHandler(ownerWindow);
  const pluginsHandler = PluginsHandler(optionsHandler);
  const mediaHandlers = EventStore();
  const eventHandler = EventHandler();
  const {
    mergeOptions,
    optionsAtMedia,
    optionsMediaQueries
  } = optionsHandler;
  const {
    on: on2,
    off: off2,
    emit
  } = eventHandler;
  const reInit = reActivate;
  let destroyed = false;
  let engine;
  let optionsBase = mergeOptions(defaultOptions, EmblaCarousel.globalOptions);
  let options = mergeOptions(optionsBase);
  let pluginList = [];
  let pluginApis;
  let container;
  let slides;
  function storeElements() {
    const {
      container: userContainer,
      slides: userSlides
    } = options;
    const customContainer = isString(userContainer) ? root2.querySelector(userContainer) : userContainer;
    container = customContainer || root2.children[0];
    const customSlides = isString(userSlides) ? container.querySelectorAll(userSlides) : userSlides;
    slides = [].slice.call(customSlides || container.children);
  }
  function createEngine(options2) {
    const engine2 = Engine(root2, container, slides, ownerDocument, ownerWindow, options2, eventHandler);
    if (options2.loop && !engine2.slideLooper.canLoop()) {
      const optionsWithoutLoop = Object.assign({}, options2, {
        loop: false
      });
      return createEngine(optionsWithoutLoop);
    }
    return engine2;
  }
  function activate(withOptions, withPlugins) {
    if (destroyed) return;
    optionsBase = mergeOptions(optionsBase, withOptions);
    options = optionsAtMedia(optionsBase);
    pluginList = withPlugins || pluginList;
    storeElements();
    engine = createEngine(options);
    optionsMediaQueries([optionsBase, ...pluginList.map(({
      options: options2
    }) => options2)]).forEach((query) => mediaHandlers.add(query, "change", reActivate));
    if (!options.active) return;
    engine.translate.to(engine.location.get());
    engine.animation.init();
    engine.slidesInView.init();
    engine.slideFocus.init(self2);
    engine.eventHandler.init(self2);
    engine.resizeHandler.init(self2);
    engine.slidesHandler.init(self2);
    if (engine.options.loop) engine.slideLooper.loop();
    if (container.offsetParent && slides.length) engine.dragHandler.init(self2);
    pluginApis = pluginsHandler.init(self2, pluginList);
  }
  function reActivate(withOptions, withPlugins) {
    const startIndex = selectedScrollSnap();
    deActivate();
    activate(mergeOptions({
      startIndex
    }, withOptions), withPlugins);
    eventHandler.emit("reInit");
  }
  function deActivate() {
    engine.dragHandler.destroy();
    engine.eventStore.clear();
    engine.translate.clear();
    engine.slideLooper.clear();
    engine.resizeHandler.destroy();
    engine.slidesHandler.destroy();
    engine.slidesInView.destroy();
    engine.animation.destroy();
    pluginsHandler.destroy();
    mediaHandlers.clear();
  }
  function destroy() {
    if (destroyed) return;
    destroyed = true;
    mediaHandlers.clear();
    deActivate();
    eventHandler.emit("destroy");
    eventHandler.clear();
  }
  function scrollTo(index2, jump, direction) {
    if (!options.active || destroyed) return;
    engine.scrollBody.useBaseFriction().useDuration(jump === true ? 0 : options.duration);
    engine.scrollTo.index(index2, direction || 0);
  }
  function scrollNext(jump) {
    const next = engine.index.add(1).get();
    scrollTo(next, jump, -1);
  }
  function scrollPrev(jump) {
    const prev = engine.index.add(-1).get();
    scrollTo(prev, jump, 1);
  }
  function canScrollNext() {
    const next = engine.index.add(1).get();
    return next !== selectedScrollSnap();
  }
  function canScrollPrev() {
    const prev = engine.index.add(-1).get();
    return prev !== selectedScrollSnap();
  }
  function scrollSnapList() {
    return engine.scrollSnapList;
  }
  function scrollProgress() {
    return engine.scrollProgress.get(engine.location.get());
  }
  function selectedScrollSnap() {
    return engine.index.get();
  }
  function previousScrollSnap() {
    return engine.indexPrevious.get();
  }
  function slidesInView() {
    return engine.slidesInView.get();
  }
  function slidesNotInView() {
    return engine.slidesInView.get(false);
  }
  function plugins() {
    return pluginApis;
  }
  function internalEngine() {
    return engine;
  }
  function rootNode() {
    return root2;
  }
  function containerNode() {
    return container;
  }
  function slideNodes() {
    return slides;
  }
  const self2 = {
    canScrollNext,
    canScrollPrev,
    containerNode,
    internalEngine,
    destroy,
    off: off2,
    on: on2,
    emit,
    plugins,
    previousScrollSnap,
    reInit,
    rootNode,
    scrollNext,
    scrollPrev,
    scrollProgress,
    scrollSnapList,
    scrollTo,
    selectedScrollSnap,
    slideNodes,
    slidesInView,
    slidesNotInView
  };
  activate(userOptions, userPlugins);
  setTimeout(() => eventHandler.emit("init"), 0);
  return self2;
}
EmblaCarousel.globalOptions = void 0;
function useEmblaCarousel(options = {}, plugins = []) {
  const storedOptions = useRef(options);
  const storedPlugins = useRef(plugins);
  const [emblaApi, setEmblaApi] = useState();
  const [viewport, setViewport] = useState();
  const reInit = useCallback(() => {
    if (emblaApi) emblaApi.reInit(storedOptions.current, storedPlugins.current);
  }, [emblaApi]);
  useEffect(() => {
    if (areOptionsEqual(storedOptions.current, options)) return;
    storedOptions.current = options;
    reInit();
  }, [options, reInit]);
  useEffect(() => {
    if (arePluginsEqual(storedPlugins.current, plugins)) return;
    storedPlugins.current = plugins;
    reInit();
  }, [plugins, reInit]);
  useEffect(() => {
    if (canUseDOM() && viewport) {
      EmblaCarousel.globalOptions = useEmblaCarousel.globalOptions;
      const newEmblaApi = EmblaCarousel(viewport, storedOptions.current, storedPlugins.current);
      setEmblaApi(newEmblaApi);
      return () => newEmblaApi.destroy();
    } else {
      setEmblaApi(void 0);
    }
  }, [viewport, setEmblaApi]);
  return [setViewport, emblaApi];
}
useEmblaCarousel.globalOptions = void 0;
const CarouselContext = createContext(null);
function useCarousel() {
  const context = useContext(CarouselContext);
  if (!context) {
    throw new Error("useCarousel must be used within a <Carousel />");
  }
  return context;
}
const Carousel = forwardRef(
  ({
    orientation = "horizontal",
    opts,
    setApi,
    plugins,
    className,
    children,
    ...props
  }, ref) => {
    const [carouselRef, api] = useEmblaCarousel(
      {
        ...opts,
        axis: orientation === "horizontal" ? "x" : "y"
      },
      plugins
    );
    const [canScrollPrev, setCanScrollPrev] = useState(false);
    const [canScrollNext, setCanScrollNext] = useState(false);
    const onSelect = useCallback((api2) => {
      if (!api2) {
        return;
      }
      setCanScrollPrev(api2.canScrollPrev());
      setCanScrollNext(api2.canScrollNext());
    }, []);
    const scrollPrev = useCallback(() => {
      api == null ? void 0 : api.scrollPrev();
    }, [api]);
    const scrollNext = useCallback(() => {
      api == null ? void 0 : api.scrollNext();
    }, [api]);
    const handleKeyDown = useCallback(
      (event) => {
        if (event.key === "ArrowLeft") {
          event.preventDefault();
          scrollPrev();
        } else if (event.key === "ArrowRight") {
          event.preventDefault();
          scrollNext();
        }
      },
      [scrollPrev, scrollNext]
    );
    useEffect(() => {
      if (!api || !setApi) {
        return;
      }
      setApi(api);
    }, [api, setApi]);
    useEffect(() => {
      if (!api) {
        return;
      }
      onSelect(api);
      api.on("reInit", onSelect);
      api.on("select", onSelect);
      return () => {
        api == null ? void 0 : api.off("select", onSelect);
      };
    }, [api, onSelect]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      CarouselContext.Provider,
      {
        value: {
          carouselRef,
          api,
          opts,
          orientation: orientation || ((opts == null ? void 0 : opts.axis) === "y" ? "vertical" : "horizontal"),
          scrollPrev,
          scrollNext,
          canScrollPrev,
          canScrollNext
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            ref,
            onKeyDownCapture: handleKeyDown,
            className: cn("relative", className),
            role: "region",
            "aria-roledescription": "carousel",
            ...props,
            children: [
              children,
              canScrollPrev && /* @__PURE__ */ jsxRuntimeExports.jsx(CarouselPrevious, {}),
              canScrollNext && /* @__PURE__ */ jsxRuntimeExports.jsx(CarouselNext, {})
            ]
          }
        )
      }
    );
  }
);
Carousel.displayName = "Carousel";
const CarouselContent = forwardRef(({ className, ...props }, ref) => {
  const { carouselRef, orientation } = useCarousel();
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref: carouselRef, className: "overflow-hidden", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      ref,
      className: cn(
        "flex",
        orientation === "horizontal" ? "-ml-4" : "-mt-4 flex-col",
        className
      ),
      ...props
    }
  ) });
});
CarouselContent.displayName = "CarouselContent";
const CarouselItem = forwardRef(({ className, ...props }, ref) => {
  const { orientation } = useCarousel();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      ref,
      role: "group",
      "aria-roledescription": "slide",
      className: cn(
        "min-w-0 shrink-0 grow-0 basis-full",
        orientation === "horizontal" ? "pl-6" : "pt-4",
        className
      ),
      ...props
    }
  );
});
CarouselItem.displayName = "CarouselItem";
const CarouselPrevious = forwardRef(
  ({ className, size: size2 = "icon", ...props }, ref) => {
    const { orientation, scrollPrev, canScrollPrev } = useCarousel();
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "button",
      {
        ref,
        size: size2,
        type: "button",
        className: cn(
          "absolute left-0 h-10 w-20  bg-gradient-to-r from-grayscale-900 from-20% to-transparent pb-0.5 pt-1.5 dark:from-dark-grayscale-900 ",
          orientation === "horizontal" ? "top-1/2 -translate-y-1/2" : "-top-12 left-1/2 -translate-x-1/2 rotate-90",
          className
        ),
        disabled: !canScrollPrev,
        onClick: scrollPrev,
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(SvgArrowLeft, { className: "h-8 w-8 text-grayscale-300" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "sr-only", children: "Previous slide" })
        ]
      }
    );
  }
);
CarouselPrevious.displayName = "CarouselPrevious";
const CarouselNext = forwardRef(
  ({ className, variant = "ghost", size: size2 = "icon", ...props }, ref) => {
    const { orientation, scrollNext, canScrollNext } = useCarousel();
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "button",
      {
        ref,
        size: size2,
        type: "button",
        className: cn(
          "absolute right-0 h-10 w-20 cursor-pointer bg-gradient-to-l from-grayscale-900 from-20% to-transparent pb-0.5 pt-1.5 dark:from-dark-grayscale-900",
          orientation === "horizontal" ? "top-1/2 -translate-y-1/2" : "-bottom-12 left-1/2 -translate-x-1/2 rotate-90",
          className
        ),
        disabled: !canScrollNext,
        onClick: scrollNext,
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(SvgArrowRight, { className: "ml-auto h-8 w-8 text-grayscale-300" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "sr-only", children: "Next slide" })
        ]
      }
    );
  }
);
CarouselNext.displayName = "CarouselNext";
function usePrevious(value2) {
  const ref = React.useRef({ value: value2, previous: value2 });
  return React.useMemo(() => {
    if (ref.current.value !== value2) {
      ref.current.previous = ref.current.value;
      ref.current.value = value2;
    }
    return ref.current.previous;
  }, [value2]);
}
function useSize(element) {
  const [size2, setSize] = React.useState(void 0);
  useLayoutEffect2(() => {
    if (element) {
      setSize({ width: element.offsetWidth, height: element.offsetHeight });
      const resizeObserver = new ResizeObserver((entries) => {
        if (!Array.isArray(entries)) {
          return;
        }
        if (!entries.length) {
          return;
        }
        const entry = entries[0];
        let width;
        let height;
        if ("borderBoxSize" in entry) {
          const borderSizeEntry = entry["borderBoxSize"];
          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
          width = borderSize["inlineSize"];
          height = borderSize["blockSize"];
        } else {
          width = element.offsetWidth;
          height = element.offsetHeight;
        }
        setSize({ width, height });
      });
      resizeObserver.observe(element, { box: "border-box" });
      return () => resizeObserver.unobserve(element);
    } else {
      setSize(void 0);
    }
  }, [element]);
  return size2;
}
var CHECKBOX_NAME = "Checkbox";
var [createCheckboxContext, createCheckboxScope] = createContextScope(CHECKBOX_NAME);
var [CheckboxProvider, useCheckboxContext] = createCheckboxContext(CHECKBOX_NAME);
var Checkbox$1 = React.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeCheckbox,
      name: name2,
      checked: checkedProp,
      defaultChecked,
      required,
      disabled,
      value: value2 = "on",
      onCheckedChange,
      form,
      ...checkboxProps
    } = props;
    const [button, setButton] = React.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setButton(node));
    const hasConsumerStoppedPropagationRef = React.useRef(false);
    const isFormControl = button ? form || !!button.closest("form") : true;
    const [checked = false, setChecked] = useControllableState({
      prop: checkedProp,
      defaultProp: defaultChecked,
      onChange: onCheckedChange
    });
    const initialCheckedStateRef = React.useRef(checked);
    React.useEffect(() => {
      const form2 = button == null ? void 0 : button.form;
      if (form2) {
        const reset = () => setChecked(initialCheckedStateRef.current);
        form2.addEventListener("reset", reset);
        return () => form2.removeEventListener("reset", reset);
      }
    }, [button, setChecked]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(CheckboxProvider, { scope: __scopeCheckbox, state: checked, disabled, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.button,
        {
          type: "button",
          role: "checkbox",
          "aria-checked": isIndeterminate$1(checked) ? "mixed" : checked,
          "aria-required": required,
          "data-state": getState$4(checked),
          "data-disabled": disabled ? "" : void 0,
          disabled,
          value: value2,
          ...checkboxProps,
          ref: composedRefs,
          onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
            if (event.key === "Enter") event.preventDefault();
          }),
          onClick: composeEventHandlers(props.onClick, (event) => {
            setChecked((prevChecked) => isIndeterminate$1(prevChecked) ? true : !prevChecked);
            if (isFormControl) {
              hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();
              if (!hasConsumerStoppedPropagationRef.current) event.stopPropagation();
            }
          })
        }
      ),
      isFormControl && /* @__PURE__ */ jsxRuntimeExports.jsx(
        BubbleInput$2,
        {
          control: button,
          bubbles: !hasConsumerStoppedPropagationRef.current,
          name: name2,
          value: value2,
          checked,
          required,
          disabled,
          form,
          style: { transform: "translateX(-100%)" },
          defaultChecked: isIndeterminate$1(defaultChecked) ? false : defaultChecked
        }
      )
    ] });
  }
);
Checkbox$1.displayName = CHECKBOX_NAME;
var INDICATOR_NAME$3 = "CheckboxIndicator";
var CheckboxIndicator = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeCheckbox, forceMount, ...indicatorProps } = props;
    const context = useCheckboxContext(INDICATOR_NAME$3, __scopeCheckbox);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || isIndeterminate$1(context.state) || context.state === true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.span,
      {
        "data-state": getState$4(context.state),
        "data-disabled": context.disabled ? "" : void 0,
        ...indicatorProps,
        ref: forwardedRef,
        style: { pointerEvents: "none", ...props.style }
      }
    ) });
  }
);
CheckboxIndicator.displayName = INDICATOR_NAME$3;
var BubbleInput$2 = (props) => {
  const { control, checked, bubbles = true, defaultChecked, ...inputProps } = props;
  const ref = React.useRef(null);
  const prevChecked = usePrevious(checked);
  const controlSize = useSize(control);
  React.useEffect(() => {
    const input = ref.current;
    const inputProto = window.HTMLInputElement.prototype;
    const descriptor = Object.getOwnPropertyDescriptor(inputProto, "checked");
    const setChecked = descriptor.set;
    if (prevChecked !== checked && setChecked) {
      const event = new Event("click", { bubbles });
      input.indeterminate = isIndeterminate$1(checked);
      setChecked.call(input, isIndeterminate$1(checked) ? false : checked);
      input.dispatchEvent(event);
    }
  }, [prevChecked, checked, bubbles]);
  const defaultCheckedRef = React.useRef(isIndeterminate$1(checked) ? false : checked);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "input",
    {
      type: "checkbox",
      "aria-hidden": true,
      defaultChecked: defaultChecked ?? defaultCheckedRef.current,
      ...inputProps,
      tabIndex: -1,
      ref,
      style: {
        ...props.style,
        ...controlSize,
        position: "absolute",
        pointerEvents: "none",
        opacity: 0,
        margin: 0
      }
    }
  );
};
function isIndeterminate$1(checked) {
  return checked === "indeterminate";
}
function getState$4(checked) {
  return isIndeterminate$1(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
}
var Root$9 = Checkbox$1;
var Indicator$2 = CheckboxIndicator;
const Checkbox = forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Root$9,
  {
    ref,
    className: cn(
      "peer h-6 w-6 shrink-0 rounded border border-grayscale-500 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:border-grayscale-300 disabled:opacity-40 data-[state=checked]:bg-primary data-[state=checked]:text-grayscale-1000 dark:border-dark-grayscale-400 dark:data-[state=checked]:bg-dark-primary",
      className
    ),
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Indicator$2,
      {
        className: cn("flex items-center justify-center text-current"),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(SvgCheckbox, {})
      }
    )
  }
));
Checkbox.displayName = Root$9.displayName;
function useEscapeKeydown(onEscapeKeyDownProp, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const onEscapeKeyDown = useCallbackRef$1(onEscapeKeyDownProp);
  React.useEffect(() => {
    const handleKeyDown = (event) => {
      if (event.key === "Escape") {
        onEscapeKeyDown(event);
      }
    };
    ownerDocument.addEventListener("keydown", handleKeyDown, { capture: true });
    return () => ownerDocument.removeEventListener("keydown", handleKeyDown, { capture: true });
  }, [onEscapeKeyDown, ownerDocument]);
}
var DISMISSABLE_LAYER_NAME = "DismissableLayer";
var CONTEXT_UPDATE = "dismissableLayer.update";
var POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
var FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
var originalBodyPointerEvents;
var DismissableLayerContext = React.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
var DismissableLayer = React.forwardRef(
  (props, forwardedRef) => {
    const {
      disableOutsidePointerEvents = false,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      onDismiss,
      ...layerProps
    } = props;
    const context = React.useContext(DismissableLayerContext);
    const [node, setNode] = React.useState(null);
    const ownerDocument = (node == null ? void 0 : node.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document);
    const [, force] = React.useState({});
    const composedRefs = useComposedRefs(forwardedRef, (node2) => setNode(node2));
    const layers = Array.from(context.layers);
    const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1);
    const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
    const index2 = node ? layers.indexOf(node) : -1;
    const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
    const isPointerEventsEnabled = index2 >= highestLayerWithOutsidePointerEventsDisabledIndex;
    const pointerDownOutside = usePointerDownOutside((event) => {
      const target2 = event.target;
      const isPointerDownOnBranch = [...context.branches].some((branch) => branch.contains(target2));
      if (!isPointerEventsEnabled || isPointerDownOnBranch) return;
      onPointerDownOutside == null ? void 0 : onPointerDownOutside(event);
      onInteractOutside == null ? void 0 : onInteractOutside(event);
      if (!event.defaultPrevented) onDismiss == null ? void 0 : onDismiss();
    }, ownerDocument);
    const focusOutside = useFocusOutside((event) => {
      const target2 = event.target;
      const isFocusInBranch = [...context.branches].some((branch) => branch.contains(target2));
      if (isFocusInBranch) return;
      onFocusOutside == null ? void 0 : onFocusOutside(event);
      onInteractOutside == null ? void 0 : onInteractOutside(event);
      if (!event.defaultPrevented) onDismiss == null ? void 0 : onDismiss();
    }, ownerDocument);
    useEscapeKeydown((event) => {
      const isHighestLayer = index2 === context.layers.size - 1;
      if (!isHighestLayer) return;
      onEscapeKeyDown == null ? void 0 : onEscapeKeyDown(event);
      if (!event.defaultPrevented && onDismiss) {
        event.preventDefault();
        onDismiss();
      }
    }, ownerDocument);
    React.useEffect(() => {
      if (!node) return;
      if (disableOutsidePointerEvents) {
        if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
          originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;
          ownerDocument.body.style.pointerEvents = "none";
        }
        context.layersWithOutsidePointerEventsDisabled.add(node);
      }
      context.layers.add(node);
      dispatchUpdate();
      return () => {
        if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1) {
          ownerDocument.body.style.pointerEvents = originalBodyPointerEvents;
        }
      };
    }, [node, ownerDocument, disableOutsidePointerEvents, context]);
    React.useEffect(() => {
      return () => {
        if (!node) return;
        context.layers.delete(node);
        context.layersWithOutsidePointerEventsDisabled.delete(node);
        dispatchUpdate();
      };
    }, [node, context]);
    React.useEffect(() => {
      const handleUpdate = () => force({});
      document.addEventListener(CONTEXT_UPDATE, handleUpdate);
      return () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.div,
      {
        ...layerProps,
        ref: composedRefs,
        style: {
          pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0,
          ...props.style
        },
        onFocusCapture: composeEventHandlers(props.onFocusCapture, focusOutside.onFocusCapture),
        onBlurCapture: composeEventHandlers(props.onBlurCapture, focusOutside.onBlurCapture),
        onPointerDownCapture: composeEventHandlers(
          props.onPointerDownCapture,
          pointerDownOutside.onPointerDownCapture
        )
      }
    );
  }
);
DismissableLayer.displayName = DISMISSABLE_LAYER_NAME;
var BRANCH_NAME = "DismissableLayerBranch";
var DismissableLayerBranch = React.forwardRef((props, forwardedRef) => {
  const context = React.useContext(DismissableLayerContext);
  const ref = React.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  React.useEffect(() => {
    const node = ref.current;
    if (node) {
      context.branches.add(node);
      return () => {
        context.branches.delete(node);
      };
    }
  }, [context.branches]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...props, ref: composedRefs });
});
DismissableLayerBranch.displayName = BRANCH_NAME;
function usePointerDownOutside(onPointerDownOutside, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const handlePointerDownOutside = useCallbackRef$1(onPointerDownOutside);
  const isPointerInsideReactTreeRef = React.useRef(false);
  const handleClickRef = React.useRef(() => {
  });
  React.useEffect(() => {
    const handlePointerDown = (event) => {
      if (event.target && !isPointerInsideReactTreeRef.current) {
        let handleAndDispatchPointerDownOutsideEvent2 = function() {
          handleAndDispatchCustomEvent$1(
            POINTER_DOWN_OUTSIDE,
            handlePointerDownOutside,
            eventDetail,
            { discrete: true }
          );
        };
        const eventDetail = { originalEvent: event };
        if (event.pointerType === "touch") {
          ownerDocument.removeEventListener("click", handleClickRef.current);
          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent2;
          ownerDocument.addEventListener("click", handleClickRef.current, { once: true });
        } else {
          handleAndDispatchPointerDownOutsideEvent2();
        }
      } else {
        ownerDocument.removeEventListener("click", handleClickRef.current);
      }
      isPointerInsideReactTreeRef.current = false;
    };
    const timerId = window.setTimeout(() => {
      ownerDocument.addEventListener("pointerdown", handlePointerDown);
    }, 0);
    return () => {
      window.clearTimeout(timerId);
      ownerDocument.removeEventListener("pointerdown", handlePointerDown);
      ownerDocument.removeEventListener("click", handleClickRef.current);
    };
  }, [ownerDocument, handlePointerDownOutside]);
  return {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
  };
}
function useFocusOutside(onFocusOutside, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const handleFocusOutside = useCallbackRef$1(onFocusOutside);
  const isFocusInsideReactTreeRef = React.useRef(false);
  React.useEffect(() => {
    const handleFocus = (event) => {
      if (event.target && !isFocusInsideReactTreeRef.current) {
        const eventDetail = { originalEvent: event };
        handleAndDispatchCustomEvent$1(FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {
          discrete: false
        });
      }
    };
    ownerDocument.addEventListener("focusin", handleFocus);
    return () => ownerDocument.removeEventListener("focusin", handleFocus);
  }, [ownerDocument, handleFocusOutside]);
  return {
    onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
    onBlurCapture: () => isFocusInsideReactTreeRef.current = false
  };
}
function dispatchUpdate() {
  const event = new CustomEvent(CONTEXT_UPDATE);
  document.dispatchEvent(event);
}
function handleAndDispatchCustomEvent$1(name2, handler, detail, { discrete }) {
  const target2 = detail.originalEvent.target;
  const event = new CustomEvent(name2, { bubbles: false, cancelable: true, detail });
  if (handler) target2.addEventListener(name2, handler, { once: true });
  if (discrete) {
    dispatchDiscreteCustomEvent(target2, event);
  } else {
    target2.dispatchEvent(event);
  }
}
var Root$8 = DismissableLayer;
var Branch = DismissableLayerBranch;
var AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
var AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
var EVENT_OPTIONS$1 = { bubbles: false, cancelable: true };
var FOCUS_SCOPE_NAME = "FocusScope";
var FocusScope = React.forwardRef((props, forwardedRef) => {
  const {
    loop = false,
    trapped = false,
    onMountAutoFocus: onMountAutoFocusProp,
    onUnmountAutoFocus: onUnmountAutoFocusProp,
    ...scopeProps
  } = props;
  const [container, setContainer] = React.useState(null);
  const onMountAutoFocus = useCallbackRef$1(onMountAutoFocusProp);
  const onUnmountAutoFocus = useCallbackRef$1(onUnmountAutoFocusProp);
  const lastFocusedElementRef = React.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, (node) => setContainer(node));
  const focusScope = React.useRef({
    paused: false,
    pause() {
      this.paused = true;
    },
    resume() {
      this.paused = false;
    }
  }).current;
  React.useEffect(() => {
    if (trapped) {
      let handleFocusIn2 = function(event) {
        if (focusScope.paused || !container) return;
        const target2 = event.target;
        if (container.contains(target2)) {
          lastFocusedElementRef.current = target2;
        } else {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleFocusOut2 = function(event) {
        if (focusScope.paused || !container) return;
        const relatedTarget = event.relatedTarget;
        if (relatedTarget === null) return;
        if (!container.contains(relatedTarget)) {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleMutations2 = function(mutations) {
        const focusedElement = document.activeElement;
        if (focusedElement !== document.body) return;
        for (const mutation of mutations) {
          if (mutation.removedNodes.length > 0) focus(container);
        }
      };
      document.addEventListener("focusin", handleFocusIn2);
      document.addEventListener("focusout", handleFocusOut2);
      const mutationObserver = new MutationObserver(handleMutations2);
      if (container) mutationObserver.observe(container, { childList: true, subtree: true });
      return () => {
        document.removeEventListener("focusin", handleFocusIn2);
        document.removeEventListener("focusout", handleFocusOut2);
        mutationObserver.disconnect();
      };
    }
  }, [trapped, container, focusScope.paused]);
  React.useEffect(() => {
    if (container) {
      focusScopesStack.add(focusScope);
      const previouslyFocusedElement = document.activeElement;
      const hasFocusedCandidate = container.contains(previouslyFocusedElement);
      if (!hasFocusedCandidate) {
        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS$1);
        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        container.dispatchEvent(mountEvent);
        if (!mountEvent.defaultPrevented) {
          focusFirst$4(removeLinks(getTabbableCandidates$2(container)), { select: true });
          if (document.activeElement === previouslyFocusedElement) {
            focus(container);
          }
        }
      }
      return () => {
        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        setTimeout(() => {
          const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS$1);
          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          container.dispatchEvent(unmountEvent);
          if (!unmountEvent.defaultPrevented) {
            focus(previouslyFocusedElement ?? document.body, { select: true });
          }
          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          focusScopesStack.remove(focusScope);
        }, 0);
      };
    }
  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);
  const handleKeyDown = React.useCallback(
    (event) => {
      if (!loop && !trapped) return;
      if (focusScope.paused) return;
      const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
      const focusedElement = document.activeElement;
      if (isTabKey && focusedElement) {
        const container2 = event.currentTarget;
        const [first, last2] = getTabbableEdges(container2);
        const hasTabbableElementsInside = first && last2;
        if (!hasTabbableElementsInside) {
          if (focusedElement === container2) event.preventDefault();
        } else {
          if (!event.shiftKey && focusedElement === last2) {
            event.preventDefault();
            if (loop) focus(first, { select: true });
          } else if (event.shiftKey && focusedElement === first) {
            event.preventDefault();
            if (loop) focus(last2, { select: true });
          }
        }
      }
    },
    [loop, trapped, focusScope.paused]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { tabIndex: -1, ...scopeProps, ref: composedRefs, onKeyDown: handleKeyDown });
});
FocusScope.displayName = FOCUS_SCOPE_NAME;
function focusFirst$4(candidates, { select: select2 = false } = {}) {
  const previouslyFocusedElement = document.activeElement;
  for (const candidate of candidates) {
    focus(candidate, { select: select2 });
    if (document.activeElement !== previouslyFocusedElement) return;
  }
}
function getTabbableEdges(container) {
  const candidates = getTabbableCandidates$2(container);
  const first = findVisible(candidates, container);
  const last2 = findVisible(candidates.reverse(), container);
  return [first, last2];
}
function getTabbableCandidates$2(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode()) nodes.push(walker.currentNode);
  return nodes;
}
function findVisible(elements, container) {
  for (const element of elements) {
    if (!isHidden(element, { upTo: container })) return element;
  }
}
function isHidden(node, { upTo }) {
  if (getComputedStyle(node).visibility === "hidden") return true;
  while (node) {
    if (upTo !== void 0 && node === upTo) return false;
    if (getComputedStyle(node).display === "none") return true;
    node = node.parentElement;
  }
  return false;
}
function isSelectableInput(element) {
  return element instanceof HTMLInputElement && "select" in element;
}
function focus(element, { select: select2 = false } = {}) {
  if (element && element.focus) {
    const previouslyFocusedElement = document.activeElement;
    element.focus({ preventScroll: true });
    if (element !== previouslyFocusedElement && isSelectableInput(element) && select2)
      element.select();
  }
}
var focusScopesStack = createFocusScopesStack();
function createFocusScopesStack() {
  let stack = [];
  return {
    add(focusScope) {
      const activeFocusScope = stack[0];
      if (focusScope !== activeFocusScope) {
        activeFocusScope == null ? void 0 : activeFocusScope.pause();
      }
      stack = arrayRemove(stack, focusScope);
      stack.unshift(focusScope);
    },
    remove(focusScope) {
      var _a;
      stack = arrayRemove(stack, focusScope);
      (_a = stack[0]) == null ? void 0 : _a.resume();
    }
  };
}
function arrayRemove(array, item) {
  const updatedArray = [...array];
  const index2 = updatedArray.indexOf(item);
  if (index2 !== -1) {
    updatedArray.splice(index2, 1);
  }
  return updatedArray;
}
function removeLinks(items) {
  return items.filter((item) => item.tagName !== "A");
}
var PORTAL_NAME$6 = "Portal";
var Portal$4 = React.forwardRef((props, forwardedRef) => {
  var _a;
  const { container: containerProp, ...portalProps } = props;
  const [mounted, setMounted] = React.useState(false);
  useLayoutEffect2(() => setMounted(true), []);
  const container = containerProp || mounted && ((_a = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : _a.body);
  return container ? ReactDOM__default.createPortal(/* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...portalProps, ref: forwardedRef }), container) : null;
});
Portal$4.displayName = PORTAL_NAME$6;
var count$3 = 0;
function useFocusGuards() {
  React.useEffect(() => {
    const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", edgeGuards[0] ?? createFocusGuard());
    document.body.insertAdjacentElement("beforeend", edgeGuards[1] ?? createFocusGuard());
    count$3++;
    return () => {
      if (count$3 === 1) {
        document.querySelectorAll("[data-radix-focus-guard]").forEach((node) => node.remove());
      }
      count$3--;
    };
  }, []);
}
function createFocusGuard() {
  const element = document.createElement("span");
  element.setAttribute("data-radix-focus-guard", "");
  element.tabIndex = 0;
  element.style.outline = "none";
  element.style.opacity = "0";
  element.style.position = "fixed";
  element.style.pointerEvents = "none";
  return element;
}
var zeroRightClassName = "right-scroll-bar-position";
var fullWidthClassName = "width-before-scroll-bar";
var noScrollbarsClassName = "with-scroll-bars-hidden";
var removedBarSizeVariable = "--removed-body-scroll-bar-size";
function assignRef(ref, value2) {
  if (typeof ref === "function") {
    ref(value2);
  } else if (ref) {
    ref.current = value2;
  }
  return ref;
}
function useCallbackRef(initialValue, callback) {
  var ref = useState(function() {
    return {
      // value
      value: initialValue,
      // last callback
      callback,
      // "memoized" public interface
      facade: {
        get current() {
          return ref.value;
        },
        set current(value2) {
          var last2 = ref.value;
          if (last2 !== value2) {
            ref.value = value2;
            ref.callback(value2, last2);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}
var useIsomorphicLayoutEffect = typeof window !== "undefined" ? React.useLayoutEffect : React.useEffect;
var currentValues = /* @__PURE__ */ new WeakMap();
function useMergeRefs(refs, defaultValue) {
  var callbackRef = useCallbackRef(null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef(ref, newValue);
    });
  });
  useIsomorphicLayoutEffect(function() {
    var oldValue = currentValues.get(callbackRef);
    if (oldValue) {
      var prevRefs_1 = new Set(oldValue);
      var nextRefs_1 = new Set(refs);
      var current_1 = callbackRef.current;
      prevRefs_1.forEach(function(ref) {
        if (!nextRefs_1.has(ref)) {
          assignRef(ref, null);
        }
      });
      nextRefs_1.forEach(function(ref) {
        if (!prevRefs_1.has(ref)) {
          assignRef(ref, current_1);
        }
      });
    }
    currentValues.set(callbackRef, refs);
  }, [refs]);
  return callbackRef;
}
function ItoI(a) {
  return a;
}
function innerCreateMedium(defaults2, middleware) {
  if (middleware === void 0) {
    middleware = ItoI;
  }
  var buffer = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer.length) {
        return buffer[buffer.length - 1];
      }
      return defaults2;
    },
    useMedium: function(data) {
      var item = middleware(data, assigned);
      buffer.push(item);
      return function() {
        buffer = buffer.filter(function(x) {
          return x !== item;
        });
      };
    },
    assignSyncMedium: function(cb) {
      assigned = true;
      while (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
      }
      buffer = {
        push: function(x) {
          return cb(x);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb) {
      assigned = true;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
        pendingQueue = buffer;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer = {
        push: function(x) {
          pendingQueue.push(x);
          cycle();
        },
        filter: function(filter2) {
          pendingQueue = pendingQueue.filter(filter2);
          return buffer;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium(options) {
  if (options === void 0) {
    options = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign$1({ async: true, ssr: false }, options);
  return medium;
}
var SideCar$1 = function(_a) {
  var sideCar = _a.sideCar, rest = __rest$1(_a, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return React.createElement(Target, __assign$1({}, rest));
};
SideCar$1.isSideCarExport = true;
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar$1;
}
var effectCar = createSidecarMedium();
var nothing = function() {
  return;
};
var RemoveScroll = React.forwardRef(function(props, parentRef) {
  var ref = React.useRef(null);
  var _a = React.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a[0], setCallbacks = _a[1];
  var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled2 = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container = _b === void 0 ? "div" : _b, gapMode = props.gapMode, rest = __rest$1(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs([ref, parentRef]);
  var containerProps = __assign$1(__assign$1({}, rest), callbacks);
  return React.createElement(
    React.Fragment,
    null,
    enabled2 && React.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref, gapMode }),
    forwardProps ? React.cloneElement(React.Children.only(children), __assign$1(__assign$1({}, containerProps), { ref: containerRef })) : React.createElement(Container, __assign$1({}, containerProps, { className, ref: containerRef }), children)
  );
});
RemoveScroll.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};
var getNonce = function() {
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return void 0;
};
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce();
  if (nonce) {
    tag.setAttribute("nonce", nonce);
  }
  return tag;
}
function injectStyles(tag, css) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css;
  } else {
    tag.appendChild(document.createTextNode(css));
  }
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  var counter = 0;
  var stylesheet = null;
  return {
    add: function(style) {
      if (counter == 0) {
        if (stylesheet = makeStyleTag()) {
          injectStyles(stylesheet, style);
          insertStyleTag(stylesheet);
        }
      }
      counter++;
    },
    remove: function() {
      counter--;
      if (!counter && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};
var styleHookSingleton = function() {
  var sheet = stylesheetSingleton();
  return function(styles, isDynamic) {
    React.useEffect(function() {
      sheet.add(styles);
      return function() {
        sheet.remove();
      };
    }, [styles && isDynamic]);
  };
};
var styleSingleton = function() {
  var useStyle = styleHookSingleton();
  var Sheet = function(_a) {
    var styles = _a.styles, dynamic = _a.dynamic;
    useStyle(styles, dynamic);
    return null;
  };
  return Sheet;
};
var zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse = function(x) {
  return parseInt(x || "", 10) || 0;
};
var getOffset = function(gapMode) {
  var cs = window.getComputedStyle(document.body);
  var left2 = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right2 = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse(left2), parse(top), parse(right2)];
};
var getGapWidth = function(gapMode) {
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap;
  }
  var offsets = getOffset(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};
var Style = styleSingleton();
var lockAttribute = "data-scroll-locked";
var getStyles = function(_a, allowRelative, gapMode, important) {
  var left2 = _a.left, top = _a.top, right2 = _a.right, gap = _a.gap;
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body[").concat(lockAttribute, "] {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && "\n    padding-left: ".concat(left2, "px;\n    padding-top: ").concat(top, "px;\n    padding-right: ").concat(right2, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "),
    gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
  ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body[").concat(lockAttribute, "] {\n    ").concat(removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
};
var getCurrentUseCounter = function() {
  var counter = parseInt(document.body.getAttribute(lockAttribute) || "0", 10);
  return isFinite(counter) ? counter : 0;
};
var useLockAttribute = function() {
  React.useEffect(function() {
    document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString());
    return function() {
      var newCounter = getCurrentUseCounter() - 1;
      if (newCounter <= 0) {
        document.body.removeAttribute(lockAttribute);
      } else {
        document.body.setAttribute(lockAttribute, newCounter.toString());
      }
    };
  }, []);
};
var RemoveScrollBar = function(_a) {
  var noRelative = _a.noRelative, noImportant = _a.noImportant, _b = _a.gapMode, gapMode = _b === void 0 ? "margin" : _b;
  useLockAttribute();
  var gap = React.useMemo(function() {
    return getGapWidth(gapMode);
  }, [gapMode]);
  return React.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
};
var passiveSupported$1 = false;
if (typeof window !== "undefined") {
  try {
    var options = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported$1 = true;
        return true;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (err) {
    passiveSupported$1 = false;
  }
}
var nonPassive = passiveSupported$1 ? { passive: false } : false;
var alwaysContainsScroll = function(node) {
  return node.tagName === "TEXTAREA";
};
var elementCanBeScrolled = function(node, overflow) {
  if (!(node instanceof Element)) {
    return false;
  }
  var styles = window.getComputedStyle(node);
  return (
    // not-not-scrollable
    styles[overflow] !== "hidden" && // contains scroll inside self
    !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === "visible")
  );
};
var elementCouldBeVScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowY");
};
var elementCouldBeHScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowX");
};
var locationCouldBeScrolled = function(axis, node) {
  var ownerDocument = node.ownerDocument;
  var current2 = node;
  do {
    if (typeof ShadowRoot !== "undefined" && current2 instanceof ShadowRoot) {
      current2 = current2.host;
    }
    var isScrollable = elementCouldBeScrolled(axis, current2);
    if (isScrollable) {
      var _a = getScrollVariables(axis, current2), scrollHeight = _a[1], clientHeight = _a[2];
      if (scrollHeight > clientHeight) {
        return true;
      }
    }
    current2 = current2.parentNode;
  } while (current2 && current2 !== ownerDocument.body);
  return false;
};
var getVScrollVariables = function(_a) {
  var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
};
var getHScrollVariables = function(_a) {
  var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
};
var elementCouldBeScrolled = function(axis, node) {
  return axis === "v" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
};
var getScrollVariables = function(axis, node) {
  return axis === "v" ? getVScrollVariables(node) : getHScrollVariables(node);
};
var getDirectionFactor = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
};
var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target2 = event.target;
  var targetInLock = endTarget.contains(target2);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    var _a = getScrollVariables(axis, target2), position2 = _a[0], scroll_1 = _a[1], capacity = _a[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position2;
    if (position2 || elementScroll) {
      if (elementCouldBeScrolled(axis, target2)) {
        availableScroll += elementScroll;
        availableScrollTop += position2;
      }
    }
    if (target2 instanceof ShadowRoot) {
      target2 = target2.host;
    } else {
      target2 = target2.parentNode;
    }
  } while (
    // portaled content
    !targetInLock && target2 !== document.body || // self content
    targetInLock && (endTarget.contains(target2) || endTarget === target2)
  );
  if (isDeltaPositive && (Math.abs(availableScroll) < 1 || false)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (Math.abs(availableScrollTop) < 1 || false)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};
var getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare = function(x, y) {
  return x[0] === y[0] && x[1] === y[1];
};
var generateStyle = function(id2) {
  return "\n  .block-interactivity-".concat(id2, " {pointer-events: none;}\n  .allow-interactivity-").concat(id2, " {pointer-events: all;}\n");
};
var idCounter = 0;
var lockStack = [];
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = React.useRef([]);
  var touchStartRef = React.useRef([0, 0]);
  var activeAxis = React.useRef();
  var id2 = React.useState(idCounter++)[0];
  var Style2 = React.useState(styleSingleton)[0];
  var lastProps = React.useRef(props);
  React.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  React.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id2));
      var allow_1 = __spreadArray$1([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
      allow_1.forEach(function(el) {
        return el.classList.add("allow-interactivity-".concat(id2));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id2));
        allow_1.forEach(function(el) {
          return el.classList.remove("allow-interactivity-".concat(id2));
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = React.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2 || event.type === "wheel" && event.ctrlKey) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target2 = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target2.type === "range") {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target2);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target2);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY);
  }, []);
  var shouldPrevent = React.useCallback(function(_event) {
    var event = _event;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e) {
      return e.name === event.type && (e.target === event.target || event.target === e.shadowParent) && deltaCompare(e.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node) {
        return node.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = React.useCallback(function(name2, delta, target2, should) {
    var event = { name: name2, delta, target: target2, should, shadowParent: getOutermostShadowParent(target2) };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e) {
        return e !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = React.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = React.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = React.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  React.useEffect(function() {
    lockStack.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive);
    document.addEventListener("touchmove", shouldPrevent, nonPassive);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive);
    return function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return React.createElement(
    React.Fragment,
    null,
    inert ? React.createElement(Style2, { styles: generateStyle(id2) }) : null,
    removeScrollBar ? React.createElement(RemoveScrollBar, { gapMode: props.gapMode }) : null
  );
}
function getOutermostShadowParent(node) {
  var shadowParent = null;
  while (node !== null) {
    if (node instanceof ShadowRoot) {
      shadowParent = node.host;
      node = node.host;
    }
    node = node.parentNode;
  }
  return shadowParent;
}
const SideCar = exportSidecar(effectCar, RemoveScrollSideCar);
var ReactRemoveScroll = React.forwardRef(function(props, ref) {
  return React.createElement(RemoveScroll, __assign$1({}, props, { ref, sideCar: SideCar }));
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
var getDefaultParent = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = function(node) {
  return node && (node.host || unwrapHost(node.parentNode));
};
var correctTargets = function(parent, targets) {
  return targets.map(function(target2) {
    if (parent.contains(target2)) {
      return target2;
    }
    var correctedTarget = unwrapHost(target2);
    if (correctedTarget && parent.contains(correctedTarget)) {
      return correctedTarget;
    }
    console.error("aria-hidden", target2, "in not contained inside", parent, ". Doing nothing");
    return null;
  }).filter(function(x) {
    return Boolean(x);
  });
};
var applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
  var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  var markerCounter = markerMap[markerName];
  var hiddenNodes = [];
  var elementsToKeep = /* @__PURE__ */ new Set();
  var elementsToStop = new Set(targets);
  var keep = function(el) {
    if (!el || elementsToKeep.has(el)) {
      return;
    }
    elementsToKeep.add(el);
    keep(el.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, function(node) {
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        try {
          var attr = node.getAttribute(controlAttribute);
          var alreadyHidden = attr !== null && attr !== "false";
          var counterValue = (counterMap.get(node) || 0) + 1;
          var markerValue = (markerCounter.get(node) || 0) + 1;
          counterMap.set(node, counterValue);
          markerCounter.set(node, markerValue);
          hiddenNodes.push(node);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledNodes.set(node, true);
          }
          if (markerValue === 1) {
            node.setAttribute(markerName, "true");
          }
          if (!alreadyHidden) {
            node.setAttribute(controlAttribute, "true");
          }
        } catch (e) {
          console.error("aria-hidden: cannot operate on ", node, e);
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return function() {
    hiddenNodes.forEach(function(node) {
      var counterValue = counterMap.get(node) - 1;
      var markerValue = markerCounter.get(node) - 1;
      counterMap.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node)) {
          node.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node);
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
var hideOthers = function(originalTarget, parentNode, markerName) {
  if (markerName === void 0) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  var activeParentNode = getDefaultParent(originalTarget);
  if (!activeParentNode) {
    return function() {
      return null;
    };
  }
  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live]")));
  return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
};
var DIALOG_NAME = "Dialog";
var [createDialogContext, createDialogScope] = createContextScope(DIALOG_NAME);
var [DialogProvider, useDialogContext] = createDialogContext(DIALOG_NAME);
var Dialog$1 = (props) => {
  const {
    __scopeDialog,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = true
  } = props;
  const triggerRef = React.useRef(null);
  const contentRef = React.useRef(null);
  const [open = false, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    DialogProvider,
    {
      scope: __scopeDialog,
      triggerRef,
      contentRef,
      contentId: useId$1(),
      titleId: useId$1(),
      descriptionId: useId$1(),
      open,
      onOpenChange: setOpen,
      onOpenToggle: React.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      modal,
      children
    }
  );
};
Dialog$1.displayName = DIALOG_NAME;
var TRIGGER_NAME$6 = "DialogTrigger";
var DialogTrigger$1 = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...triggerProps } = props;
    const context = useDialogContext(TRIGGER_NAME$6, __scopeDialog);
    const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": context.open,
        "aria-controls": context.contentId,
        "data-state": getState$3(context.open),
        ...triggerProps,
        ref: composedTriggerRef,
        onClick: composeEventHandlers(props.onClick, context.onOpenToggle)
      }
    );
  }
);
DialogTrigger$1.displayName = TRIGGER_NAME$6;
var PORTAL_NAME$5 = "DialogPortal";
var [PortalProvider$3, usePortalContext$3] = createDialogContext(PORTAL_NAME$5, {
  forceMount: void 0
});
var DialogPortal$1 = (props) => {
  const { __scopeDialog, forceMount, children, container } = props;
  const context = useDialogContext(PORTAL_NAME$5, __scopeDialog);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PortalProvider$3, { scope: __scopeDialog, forceMount, children: React.Children.map(children, (child) => /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$4, { asChild: true, container, children: child }) })) });
};
DialogPortal$1.displayName = PORTAL_NAME$5;
var OVERLAY_NAME = "DialogOverlay";
var DialogOverlay$1 = React.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext$3(OVERLAY_NAME, props.__scopeDialog);
    const { forceMount = portalContext.forceMount, ...overlayProps } = props;
    const context = useDialogContext(OVERLAY_NAME, props.__scopeDialog);
    return context.modal ? /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogOverlayImpl, { ...overlayProps, ref: forwardedRef }) }) : null;
  }
);
DialogOverlay$1.displayName = OVERLAY_NAME;
var DialogOverlayImpl = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...overlayProps } = props;
    const context = useDialogContext(OVERLAY_NAME, __scopeDialog);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      /* @__PURE__ */ jsxRuntimeExports.jsx(ReactRemoveScroll, { as: Slot, allowPinchZoom: true, shards: [context.contentRef], children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.div,
        {
          "data-state": getState$3(context.open),
          ...overlayProps,
          ref: forwardedRef,
          style: { pointerEvents: "auto", ...overlayProps.style }
        }
      ) })
    );
  }
);
var CONTENT_NAME$8 = "DialogContent";
var DialogContent$1 = React.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext$3(CONTENT_NAME$8, props.__scopeDialog);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context = useDialogContext(CONTENT_NAME$8, props.__scopeDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: context.modal ? /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentModal, { ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentNonModal, { ...contentProps, ref: forwardedRef }) });
  }
);
DialogContent$1.displayName = CONTENT_NAME$8;
var DialogContentModal = React.forwardRef(
  (props, forwardedRef) => {
    const context = useDialogContext(CONTENT_NAME$8, props.__scopeDialog);
    const contentRef = React.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, context.contentRef, contentRef);
    React.useEffect(() => {
      const content = contentRef.current;
      if (content) return hideOthers(content);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      DialogContentImpl,
      {
        ...props,
        ref: composedRefs,
        trapFocus: context.open,
        disableOutsidePointerEvents: true,
        onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
          var _a;
          event.preventDefault();
          (_a = context.triggerRef.current) == null ? void 0 : _a.focus();
        }),
        onPointerDownOutside: composeEventHandlers(props.onPointerDownOutside, (event) => {
          const originalEvent = event.detail.originalEvent;
          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          if (isRightClick) event.preventDefault();
        }),
        onFocusOutside: composeEventHandlers(
          props.onFocusOutside,
          (event) => event.preventDefault()
        )
      }
    );
  }
);
var DialogContentNonModal = React.forwardRef(
  (props, forwardedRef) => {
    const context = useDialogContext(CONTENT_NAME$8, props.__scopeDialog);
    const hasInteractedOutsideRef = React.useRef(false);
    const hasPointerDownOutsideRef = React.useRef(false);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      DialogContentImpl,
      {
        ...props,
        ref: forwardedRef,
        trapFocus: false,
        disableOutsidePointerEvents: false,
        onCloseAutoFocus: (event) => {
          var _a, _b;
          (_a = props.onCloseAutoFocus) == null ? void 0 : _a.call(props, event);
          if (!event.defaultPrevented) {
            if (!hasInteractedOutsideRef.current) (_b = context.triggerRef.current) == null ? void 0 : _b.focus();
            event.preventDefault();
          }
          hasInteractedOutsideRef.current = false;
          hasPointerDownOutsideRef.current = false;
        },
        onInteractOutside: (event) => {
          var _a, _b;
          (_a = props.onInteractOutside) == null ? void 0 : _a.call(props, event);
          if (!event.defaultPrevented) {
            hasInteractedOutsideRef.current = true;
            if (event.detail.originalEvent.type === "pointerdown") {
              hasPointerDownOutsideRef.current = true;
            }
          }
          const target2 = event.target;
          const targetIsTrigger = (_b = context.triggerRef.current) == null ? void 0 : _b.contains(target2);
          if (targetIsTrigger) event.preventDefault();
          if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current) {
            event.preventDefault();
          }
        }
      }
    );
  }
);
var DialogContentImpl = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, trapFocus, onOpenAutoFocus, onCloseAutoFocus, ...contentProps } = props;
    const context = useDialogContext(CONTENT_NAME$8, __scopeDialog);
    const contentRef = React.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef);
    useFocusGuards();
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        FocusScope,
        {
          asChild: true,
          loop: true,
          trapped: trapFocus,
          onMountAutoFocus: onOpenAutoFocus,
          onUnmountAutoFocus: onCloseAutoFocus,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            DismissableLayer,
            {
              role: "dialog",
              id: context.contentId,
              "aria-describedby": context.descriptionId,
              "aria-labelledby": context.titleId,
              "data-state": getState$3(context.open),
              ...contentProps,
              ref: composedRefs,
              onDismiss: () => context.onOpenChange(false)
            }
          )
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TitleWarning, { titleId: context.titleId }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DescriptionWarning, { contentRef, descriptionId: context.descriptionId })
      ] })
    ] });
  }
);
var TITLE_NAME$1 = "DialogTitle";
var DialogTitle$1 = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...titleProps } = props;
    const context = useDialogContext(TITLE_NAME$1, __scopeDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.h2, { id: context.titleId, ...titleProps, ref: forwardedRef });
  }
);
DialogTitle$1.displayName = TITLE_NAME$1;
var DESCRIPTION_NAME$1 = "DialogDescription";
var DialogDescription$1 = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...descriptionProps } = props;
    const context = useDialogContext(DESCRIPTION_NAME$1, __scopeDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.p, { id: context.descriptionId, ...descriptionProps, ref: forwardedRef });
  }
);
DialogDescription$1.displayName = DESCRIPTION_NAME$1;
var CLOSE_NAME$2 = "DialogClose";
var DialogClose$1 = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...closeProps } = props;
    const context = useDialogContext(CLOSE_NAME$2, __scopeDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        ...closeProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, () => context.onOpenChange(false))
      }
    );
  }
);
DialogClose$1.displayName = CLOSE_NAME$2;
function getState$3(open) {
  return open ? "open" : "closed";
}
var TITLE_WARNING_NAME = "DialogTitleWarning";
var [WarningProvider, useWarningContext] = createContext2(TITLE_WARNING_NAME, {
  contentName: CONTENT_NAME$8,
  titleName: TITLE_NAME$1,
  docsSlug: "dialog"
});
var TitleWarning = ({ titleId }) => {
  const titleWarningContext = useWarningContext(TITLE_WARNING_NAME);
  const MESSAGE = `\`${titleWarningContext.contentName}\` requires a \`${titleWarningContext.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${titleWarningContext.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${titleWarningContext.docsSlug}`;
  React.useEffect(() => {
    if (titleId) {
      const hasTitle = document.getElementById(titleId);
      if (!hasTitle) console.error(MESSAGE);
    }
  }, [MESSAGE, titleId]);
  return null;
};
var DESCRIPTION_WARNING_NAME = "DialogDescriptionWarning";
var DescriptionWarning = ({ contentRef, descriptionId }) => {
  const descriptionWarningContext = useWarningContext(DESCRIPTION_WARNING_NAME);
  const MESSAGE = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${descriptionWarningContext.contentName}}.`;
  React.useEffect(() => {
    var _a;
    const describedById = (_a = contentRef.current) == null ? void 0 : _a.getAttribute("aria-describedby");
    if (descriptionId && describedById) {
      const hasDescription = document.getElementById(descriptionId);
      if (!hasDescription) console.warn(MESSAGE);
    }
  }, [MESSAGE, contentRef, descriptionId]);
  return null;
};
var Root$7 = Dialog$1;
var Trigger$6 = DialogTrigger$1;
var Portal$3 = DialogPortal$1;
var Overlay = DialogOverlay$1;
var Content$3 = DialogContent$1;
var Title$1 = DialogTitle$1;
var Description$1 = DialogDescription$1;
var Close$1 = DialogClose$1;
const Dialog = Root$7;
const DialogTrigger = Trigger$6;
const DialogPortal = Portal$3;
const DialogClose = Close$1;
const DialogOverlay = forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Overlay,
  {
    ref,
    className: cn(
      "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-grayscale-100/70 backdrop-blur-sm",
      className
    ),
    ...props
  }
));
DialogOverlay.displayName = Overlay.displayName;
const DialogContent = forwardRef(
  ({
    className,
    overlayClassName = "",
    children,
    overlay = true,
    closeButton = true,
    disableOutsideClick = true,
    ...props
  }, ref) => {
    const { t: t2 } = useTranslation();
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogPortal, { children: [
      overlay && /* @__PURE__ */ jsxRuntimeExports.jsx(DialogOverlay, { className: overlayClassName }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Content$3,
        {
          ref,
          onInteractOutside: (e) => {
            if (disableOutsideClick) {
              e.preventDefault();
            }
          },
          className: cn(
            "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] fixed left-[50%] top-[50%] z-50 grid w-full translate-x-[-50%] translate-y-[-50%] gap-4 bg-grayscale-1000 px-6 shadow-xl duration-200 dark:bg-dark-bg-444 sm:max-w-lg sm:rounded-2xl",
            className
          ),
          ...props,
          children: [
            children,
            closeButton && /* @__PURE__ */ jsxRuntimeExports.jsxs(Close$1, { className: "absolute right-4 top-6 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(SvgPopClose, { className: "h-8 w-8" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "sr-only", children: t2("Close") })
            ] })
          ]
        }
      )
    ] });
  }
);
DialogContent.displayName = Content$3.displayName;
const DialogHeader = ({ className, ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "div",
  {
    className: cn("flex flex-col space-y-1.5 sm:text-left", className),
    ...props
  }
);
DialogHeader.displayName = "DialogHeader";
const DialogFooter = ({ className, ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "div",
  {
    className: cn("flex flex-row justify-end space-x-4 pb-8 pt-6", className),
    ...props
  }
);
DialogFooter.displayName = "DialogFooter";
const DialogTitle = forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Title$1,
  {
    ref,
    className: cn(
      "pb-4 pt-6 text-xl font-extrabold leading-none tracking-tight",
      className
    ),
    ...props
  }
));
DialogTitle.displayName = Title$1.displayName;
const DialogDescription = forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Description$1,
  {
    ref,
    className: cn("text-sm text-muted-foreground", className),
    ...props
  }
));
DialogDescription.displayName = Description$1.displayName;
const sides = ["top", "right", "bottom", "left"];
const min$3 = Math.min;
const max$3 = Math.max;
const round = Math.round;
const floor = Math.floor;
const createCoords = (v) => ({
  x: v,
  y: v
});
const oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
const oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp$1(start2, value2, end2) {
  return max$3(start2, min$3(value2, end2));
}
function evaluate(value2, param) {
  return typeof value2 === "function" ? value2(param) : value2;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition$1 = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i2 = 0; i2 < validMiddleware.length; i2++) {
    const {
      name: name2,
      fn
    } = validMiddleware[i2];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name2]: {
        ...middlewareData[name2],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i2 = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
const arrow$3 = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x,
      y,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x,
      y
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min$3(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min$3(paddingObject[maxProp], largestPossiblePadding);
    const min$12 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center2 = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset2 = clamp$1(min$12, center2, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center2 !== offset2 && rects.reference[length] / 2 - (center2 < min$12 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center2 < min$12 ? center2 - min$12 : center2 - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset2,
        centerOffset: center2 - offset2 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
const flip$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
const hide$4 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
const offset$2 = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
const shift$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp$1(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp$1(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
const limitShift$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const {
        x,
        y,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset: offset2 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset2, state);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = ["top", "left"].includes(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
const size$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply: apply2 = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min$3(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min$3(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max$3(overflow.left, 0);
        const xMax = max$3(overflow.right, 0);
        const yMin = max$3(overflow.top, 0);
        const yMax = max$3(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max$3(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max$3(overflow.top, overflow.bottom));
        }
      }
      await apply2({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value2) {
  if (!hasWindow()) {
    return false;
  }
  return value2 instanceof Node || value2 instanceof getWindow(value2).Node;
}
function isElement(value2) {
  if (!hasWindow()) {
    return false;
  }
  return value2 instanceof Element || value2 instanceof getWindow(value2).Element;
}
function isHTMLElement$1(value2) {
  if (!hasWindow()) {
    return false;
  }
  return value2 instanceof HTMLElement || value2 instanceof getWindow(value2).HTMLElement;
}
function isShadowRoot(value2) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value2 instanceof ShadowRoot || value2 instanceof getWindow(value2).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display: display2
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display2);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isTopLayer(element) {
  return [":popover-open", ":modal"].some((selector) => {
    try {
      return element.matches(selector);
    } catch (e) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle$1(elementOrCss) : elementOrCss;
  return css.transform !== "none" || css.perspective !== "none" || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value2) => (css.willChange || "").includes(value2)) || ["paint", "layout", "strict", "content"].some((value2) => (css.contain || "").includes(value2));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement$1(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement$1(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}
function getCssDimensions(element) {
  const css = getComputedStyle$1(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement$1(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement$1(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle$1(currentIFrame);
      const left2 = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left2;
      y += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
  if (ignoreScrollbarX === void 0) {
    ignoreScrollbarX = false;
  }
  const htmlRect = documentElement.getBoundingClientRect();
  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (
    // RTL <body> scrollbar.
    getWindowScrollBarX(documentElement, htmlRect)
  ));
  const y = htmlRect.top + scroll.scrollTop;
  return {
    x,
    y
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement$1(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement$1(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max$3(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max$3(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle$1(body).direction === "rtl") {
    x += max$3(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left2 = clientRect.left + element.clientLeft;
  const scale = isHTMLElement$1(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left2 * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle$1(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max$3(rect.top, accRect.top);
    accRect.right = min$3(rect.right, accRect.right);
    accRect.bottom = min$3(rect.bottom, accRect.bottom);
    accRect.left = max$3(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement$1(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle$1(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement$1(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement$1(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
const getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle$1(element).direction === "rtl";
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root2 = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold2) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold2 === void 0) {
      threshold2 = 1;
    }
    cleanup();
    const {
      left: left2,
      top,
      width,
      height
    } = element.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root2.clientWidth - (left2 + width));
    const insetBottom = floor(root2.clientHeight - (top + height));
    const insetLeft = floor(left2);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max$3(0, min$3(1, threshold2)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold2) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root2.ownerDocument
      });
    } catch (e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
const offset$1 = offset$2;
const shift$1 = shift$2;
const flip$1 = flip$2;
const size$1 = size$2;
const hide$3 = hide$4;
const arrow$2 = arrow$3;
const limitShift$1 = limitShift$2;
const computePosition = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition$1(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};
var index$1 = typeof document !== "undefined" ? useLayoutEffect : useEffect;
function deepEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (typeof a !== typeof b) {
    return false;
  }
  if (typeof a === "function" && a.toString() === b.toString()) {
    return true;
  }
  let length;
  let i2;
  let keys2;
  if (a && b && typeof a === "object") {
    if (Array.isArray(a)) {
      length = a.length;
      if (length !== b.length) return false;
      for (i2 = length; i2-- !== 0; ) {
        if (!deepEqual(a[i2], b[i2])) {
          return false;
        }
      }
      return true;
    }
    keys2 = Object.keys(a);
    length = keys2.length;
    if (length !== Object.keys(b).length) {
      return false;
    }
    for (i2 = length; i2-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b, keys2[i2])) {
        return false;
      }
    }
    for (i2 = length; i2-- !== 0; ) {
      const key = keys2[i2];
      if (key === "_owner" && a.$$typeof) {
        continue;
      }
      if (!deepEqual(a[key], b[key])) {
        return false;
      }
    }
    return true;
  }
  return a !== a && b !== b;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value2) {
  const dpr = getDPR(element);
  return Math.round(value2 * dpr) / dpr;
}
function useLatestRef(value2) {
  const ref = React.useRef(value2);
  index$1(() => {
    ref.current = value2;
  });
  return ref;
}
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = React.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = React.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = React.useState(null);
  const [_floating, _setFloating] = React.useState(null);
  const setReference = React.useCallback((node) => {
    if (node !== referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = React.useCallback((node) => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = React.useRef(null);
  const floatingRef = React.useRef(null);
  const dataRef = React.useRef(data);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const openRef = useLatestRef(open);
  const update = React.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    computePosition(referenceRef.current, floatingRef.current, config).then((data2) => {
      const fullData = {
        ...data2,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: openRef.current !== false
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        ReactDOM.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef, openRef]);
  index$1(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = React.useRef(false);
  index$1(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index$1(() => {
    if (referenceEl) referenceRef.current = referenceEl;
    if (floatingEl) floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = React.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = React.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = React.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x = roundByDPR(elements.floating, data.x);
    const y = roundByDPR(elements.floating, data.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x + "px, " + y + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x,
      top: y
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return React.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}
const arrow$1 = (options) => {
  function isRef(value2) {
    return {}.hasOwnProperty.call(value2, "current");
  }
  return {
    name: "arrow",
    options,
    fn(state) {
      const {
        element,
        padding
      } = typeof options === "function" ? options(state) : options;
      if (element && isRef(element)) {
        if (element.current != null) {
          return arrow$2({
            element: element.current,
            padding
          }).fn(state);
        }
        return {};
      }
      if (element) {
        return arrow$2({
          element,
          padding
        }).fn(state);
      }
      return {};
    }
  };
};
const offset = (options, deps) => ({
  ...offset$1(options),
  options: [options, deps]
});
const shift = (options, deps) => ({
  ...shift$1(options),
  options: [options, deps]
});
const limitShift = (options, deps) => ({
  ...limitShift$1(options),
  options: [options, deps]
});
const flip = (options, deps) => ({
  ...flip$1(options),
  options: [options, deps]
});
const size = (options, deps) => ({
  ...size$1(options),
  options: [options, deps]
});
const hide$2 = (options, deps) => ({
  ...hide$3(options),
  options: [options, deps]
});
const arrow = (options, deps) => ({
  ...arrow$1(options),
  options: [options, deps]
});
var NAME$3 = "Arrow";
var Arrow$1 = React.forwardRef((props, forwardedRef) => {
  const { children, width = 10, height = 5, ...arrowProps } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive.svg,
    {
      ...arrowProps,
      ref: forwardedRef,
      width,
      height,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: props.asChild ? children : /* @__PURE__ */ jsxRuntimeExports.jsx("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
Arrow$1.displayName = NAME$3;
var Root$6 = Arrow$1;
var POPPER_NAME = "Popper";
var [createPopperContext, createPopperScope] = createContextScope(POPPER_NAME);
var [PopperProvider, usePopperContext] = createPopperContext(POPPER_NAME);
var Popper = (props) => {
  const { __scopePopper, children } = props;
  const [anchor, setAnchor] = React.useState(null);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PopperProvider, { scope: __scopePopper, anchor, onAnchorChange: setAnchor, children });
};
Popper.displayName = POPPER_NAME;
var ANCHOR_NAME$2 = "PopperAnchor";
var PopperAnchor = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopper, virtualRef, ...anchorProps } = props;
    const context = usePopperContext(ANCHOR_NAME$2, __scopePopper);
    const ref = React.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    React.useEffect(() => {
      context.onAnchorChange((virtualRef == null ? void 0 : virtualRef.current) || ref.current);
    });
    return virtualRef ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...anchorProps, ref: composedRefs });
  }
);
PopperAnchor.displayName = ANCHOR_NAME$2;
var CONTENT_NAME$7 = "PopperContent";
var [PopperContentProvider, useContentContext] = createPopperContext(CONTENT_NAME$7);
var PopperContent = React.forwardRef(
  (props, forwardedRef) => {
    var _a, _b, _c, _d, _e, _f;
    const {
      __scopePopper,
      side = "bottom",
      sideOffset = 0,
      align: align2 = "center",
      alignOffset = 0,
      arrowPadding = 0,
      avoidCollisions = true,
      collisionBoundary = [],
      collisionPadding: collisionPaddingProp = 0,
      sticky = "partial",
      hideWhenDetached = false,
      updatePositionStrategy = "optimized",
      onPlaced,
      ...contentProps
    } = props;
    const context = usePopperContext(CONTENT_NAME$7, __scopePopper);
    const [content, setContent] = React.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
    const [arrow$12, setArrow] = React.useState(null);
    const arrowSize = useSize(arrow$12);
    const arrowWidth = (arrowSize == null ? void 0 : arrowSize.width) ?? 0;
    const arrowHeight = (arrowSize == null ? void 0 : arrowSize.height) ?? 0;
    const desiredPlacement = side + (align2 !== "center" ? "-" + align2 : "");
    const collisionPadding = typeof collisionPaddingProp === "number" ? collisionPaddingProp : { top: 0, right: 0, bottom: 0, left: 0, ...collisionPaddingProp };
    const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary];
    const hasExplicitBoundaries = boundary.length > 0;
    const detectOverflowOptions = {
      padding: collisionPadding,
      boundary: boundary.filter(isNotNull),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: hasExplicitBoundaries
    };
    const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: desiredPlacement,
      whileElementsMounted: (...args) => {
        const cleanup = autoUpdate(...args, {
          animationFrame: updatePositionStrategy === "always"
        });
        return cleanup;
      },
      elements: {
        reference: context.anchor
      },
      middleware: [
        offset({ mainAxis: sideOffset + arrowHeight, alignmentAxis: alignOffset }),
        avoidCollisions && shift({
          mainAxis: true,
          crossAxis: false,
          limiter: sticky === "partial" ? limitShift() : void 0,
          ...detectOverflowOptions
        }),
        avoidCollisions && flip({ ...detectOverflowOptions }),
        size({
          ...detectOverflowOptions,
          apply: ({ elements, rects, availableWidth, availableHeight }) => {
            const { width: anchorWidth, height: anchorHeight } = rects.reference;
            const contentStyle = elements.floating.style;
            contentStyle.setProperty("--radix-popper-available-width", `${availableWidth}px`);
            contentStyle.setProperty("--radix-popper-available-height", `${availableHeight}px`);
            contentStyle.setProperty("--radix-popper-anchor-width", `${anchorWidth}px`);
            contentStyle.setProperty("--radix-popper-anchor-height", `${anchorHeight}px`);
          }
        }),
        arrow$12 && arrow({ element: arrow$12, padding: arrowPadding }),
        transformOrigin({ arrowWidth, arrowHeight }),
        hideWhenDetached && hide$2({ strategy: "referenceHidden", ...detectOverflowOptions })
      ]
    });
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const handlePlaced = useCallbackRef$1(onPlaced);
    useLayoutEffect2(() => {
      if (isPositioned) {
        handlePlaced == null ? void 0 : handlePlaced();
      }
    }, [isPositioned, handlePlaced]);
    const arrowX = (_a = middlewareData.arrow) == null ? void 0 : _a.x;
    const arrowY = (_b = middlewareData.arrow) == null ? void 0 : _b.y;
    const cannotCenterArrow = ((_c = middlewareData.arrow) == null ? void 0 : _c.centerOffset) !== 0;
    const [contentZIndex, setContentZIndex] = React.useState();
    useLayoutEffect2(() => {
      if (content) setContentZIndex(window.getComputedStyle(content).zIndex);
    }, [content]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        ref: refs.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...floatingStyles,
          transform: isPositioned ? floatingStyles.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: contentZIndex,
          ["--radix-popper-transform-origin"]: [
            (_d = middlewareData.transformOrigin) == null ? void 0 : _d.x,
            (_e = middlewareData.transformOrigin) == null ? void 0 : _e.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...((_f = middlewareData.hide) == null ? void 0 : _f.referenceHidden) && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: props.dir,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          PopperContentProvider,
          {
            scope: __scopePopper,
            placedSide,
            onArrowChange: setArrow,
            arrowX,
            arrowY,
            shouldHideArrow: cannotCenterArrow,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Primitive.div,
              {
                "data-side": placedSide,
                "data-align": placedAlign,
                ...contentProps,
                ref: composedRefs,
                style: {
                  ...contentProps.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: !isPositioned ? "none" : void 0
                }
              }
            )
          }
        )
      }
    );
  }
);
PopperContent.displayName = CONTENT_NAME$7;
var ARROW_NAME$5 = "PopperArrow";
var OPPOSITE_SIDE = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var PopperArrow = React.forwardRef(function PopperArrow2(props, forwardedRef) {
  const { __scopePopper, ...arrowProps } = props;
  const contentContext = useContentContext(ARROW_NAME$5, __scopePopper);
  const baseSide = OPPOSITE_SIDE[contentContext.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "span",
      {
        ref: contentContext.onArrowChange,
        style: {
          position: "absolute",
          left: contentContext.arrowX,
          top: contentContext.arrowY,
          [baseSide]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[contentContext.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: `rotate(180deg)`,
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[contentContext.placedSide],
          visibility: contentContext.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Root$6,
          {
            ...arrowProps,
            ref: forwardedRef,
            style: {
              ...arrowProps.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
PopperArrow.displayName = ARROW_NAME$5;
function isNotNull(value2) {
  return value2 !== null;
}
var transformOrigin = (options) => ({
  name: "transformOrigin",
  options,
  fn(data) {
    var _a, _b, _c;
    const { placement, rects, middlewareData } = data;
    const cannotCenterArrow = ((_a = middlewareData.arrow) == null ? void 0 : _a.centerOffset) !== 0;
    const isArrowHidden = cannotCenterArrow;
    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const noArrowAlign = { start: "0%", center: "50%", end: "100%" }[placedAlign];
    const arrowXCenter = (((_b = middlewareData.arrow) == null ? void 0 : _b.x) ?? 0) + arrowWidth / 2;
    const arrowYCenter = (((_c = middlewareData.arrow) == null ? void 0 : _c.y) ?? 0) + arrowHeight / 2;
    let x = "";
    let y = "";
    if (placedSide === "bottom") {
      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y = `${-arrowHeight}px`;
    } else if (placedSide === "top") {
      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y = `${rects.floating.height + arrowHeight}px`;
    } else if (placedSide === "right") {
      x = `${-arrowHeight}px`;
      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    } else if (placedSide === "left") {
      x = `${rects.floating.width + arrowHeight}px`;
      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    }
    return { data: { x, y } };
  }
});
function getSideAndAlignFromPlacement(placement) {
  const [side, align2 = "center"] = placement.split("-");
  return [side, align2];
}
var Root2$7 = Popper;
var Anchor = PopperAnchor;
var Content$2 = PopperContent;
var Arrow = PopperArrow;
var ENTRY_FOCUS = "rovingFocusGroup.onEntryFocus";
var EVENT_OPTIONS = { bubbles: false, cancelable: true };
var GROUP_NAME$3 = "RovingFocusGroup";
var [Collection$4, useCollection$4, createCollectionScope$4] = createCollection(GROUP_NAME$3);
var [createRovingFocusGroupContext, createRovingFocusGroupScope] = createContextScope(
  GROUP_NAME$3,
  [createCollectionScope$4]
);
var [RovingFocusProvider, useRovingFocusContext] = createRovingFocusGroupContext(GROUP_NAME$3);
var RovingFocusGroup = React.forwardRef(
  (props, forwardedRef) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$4.Provider, { scope: props.__scopeRovingFocusGroup, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$4.Slot, { scope: props.__scopeRovingFocusGroup, children: /* @__PURE__ */ jsxRuntimeExports.jsx(RovingFocusGroupImpl, { ...props, ref: forwardedRef }) }) });
  }
);
RovingFocusGroup.displayName = GROUP_NAME$3;
var RovingFocusGroupImpl = React.forwardRef((props, forwardedRef) => {
  const {
    __scopeRovingFocusGroup,
    orientation,
    loop = false,
    dir,
    currentTabStopId: currentTabStopIdProp,
    defaultCurrentTabStopId,
    onCurrentTabStopIdChange,
    onEntryFocus,
    preventScrollOnEntryFocus = false,
    ...groupProps
  } = props;
  const ref = React.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  const direction = useDirection(dir);
  const [currentTabStopId = null, setCurrentTabStopId] = useControllableState({
    prop: currentTabStopIdProp,
    defaultProp: defaultCurrentTabStopId,
    onChange: onCurrentTabStopIdChange
  });
  const [isTabbingBackOut, setIsTabbingBackOut] = React.useState(false);
  const handleEntryFocus = useCallbackRef$1(onEntryFocus);
  const getItems = useCollection$4(__scopeRovingFocusGroup);
  const isClickFocusRef = React.useRef(false);
  const [focusableItemsCount, setFocusableItemsCount] = React.useState(0);
  React.useEffect(() => {
    const node = ref.current;
    if (node) {
      node.addEventListener(ENTRY_FOCUS, handleEntryFocus);
      return () => node.removeEventListener(ENTRY_FOCUS, handleEntryFocus);
    }
  }, [handleEntryFocus]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    RovingFocusProvider,
    {
      scope: __scopeRovingFocusGroup,
      orientation,
      dir: direction,
      loop,
      currentTabStopId,
      onItemFocus: React.useCallback(
        (tabStopId) => setCurrentTabStopId(tabStopId),
        [setCurrentTabStopId]
      ),
      onItemShiftTab: React.useCallback(() => setIsTabbingBackOut(true), []),
      onFocusableItemAdd: React.useCallback(
        () => setFocusableItemsCount((prevCount) => prevCount + 1),
        []
      ),
      onFocusableItemRemove: React.useCallback(
        () => setFocusableItemsCount((prevCount) => prevCount - 1),
        []
      ),
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.div,
        {
          tabIndex: isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0,
          "data-orientation": orientation,
          ...groupProps,
          ref: composedRefs,
          style: { outline: "none", ...props.style },
          onMouseDown: composeEventHandlers(props.onMouseDown, () => {
            isClickFocusRef.current = true;
          }),
          onFocus: composeEventHandlers(props.onFocus, (event) => {
            const isKeyboardFocus = !isClickFocusRef.current;
            if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {
              const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS);
              event.currentTarget.dispatchEvent(entryFocusEvent);
              if (!entryFocusEvent.defaultPrevented) {
                const items = getItems().filter((item) => item.focusable);
                const activeItem = items.find((item) => item.active);
                const currentItem = items.find((item) => item.id === currentTabStopId);
                const candidateItems = [activeItem, currentItem, ...items].filter(
                  Boolean
                );
                const candidateNodes = candidateItems.map((item) => item.ref.current);
                focusFirst$3(candidateNodes, preventScrollOnEntryFocus);
              }
            }
            isClickFocusRef.current = false;
          }),
          onBlur: composeEventHandlers(props.onBlur, () => setIsTabbingBackOut(false))
        }
      )
    }
  );
});
var ITEM_NAME$5 = "RovingFocusGroupItem";
var RovingFocusGroupItem = React.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeRovingFocusGroup,
      focusable = true,
      active: active2 = false,
      tabStopId,
      ...itemProps
    } = props;
    const autoId = useId$1();
    const id2 = tabStopId || autoId;
    const context = useRovingFocusContext(ITEM_NAME$5, __scopeRovingFocusGroup);
    const isCurrentTabStop = context.currentTabStopId === id2;
    const getItems = useCollection$4(__scopeRovingFocusGroup);
    const { onFocusableItemAdd, onFocusableItemRemove } = context;
    React.useEffect(() => {
      if (focusable) {
        onFocusableItemAdd();
        return () => onFocusableItemRemove();
      }
    }, [focusable, onFocusableItemAdd, onFocusableItemRemove]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Collection$4.ItemSlot,
      {
        scope: __scopeRovingFocusGroup,
        id: id2,
        focusable,
        active: active2,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.span,
          {
            tabIndex: isCurrentTabStop ? 0 : -1,
            "data-orientation": context.orientation,
            ...itemProps,
            ref: forwardedRef,
            onMouseDown: composeEventHandlers(props.onMouseDown, (event) => {
              if (!focusable) event.preventDefault();
              else context.onItemFocus(id2);
            }),
            onFocus: composeEventHandlers(props.onFocus, () => context.onItemFocus(id2)),
            onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
              if (event.key === "Tab" && event.shiftKey) {
                context.onItemShiftTab();
                return;
              }
              if (event.target !== event.currentTarget) return;
              const focusIntent = getFocusIntent(event, context.orientation, context.dir);
              if (focusIntent !== void 0) {
                if (event.metaKey || event.ctrlKey || event.altKey || event.shiftKey) return;
                event.preventDefault();
                const items = getItems().filter((item) => item.focusable);
                let candidateNodes = items.map((item) => item.ref.current);
                if (focusIntent === "last") candidateNodes.reverse();
                else if (focusIntent === "prev" || focusIntent === "next") {
                  if (focusIntent === "prev") candidateNodes.reverse();
                  const currentIndex = candidateNodes.indexOf(event.currentTarget);
                  candidateNodes = context.loop ? wrapArray$2(candidateNodes, currentIndex + 1) : candidateNodes.slice(currentIndex + 1);
                }
                setTimeout(() => focusFirst$3(candidateNodes));
              }
            })
          }
        )
      }
    );
  }
);
RovingFocusGroupItem.displayName = ITEM_NAME$5;
var MAP_KEY_TO_FOCUS_INTENT = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function getDirectionAwareKey(key, dir) {
  if (dir !== "rtl") return key;
  return key === "ArrowLeft" ? "ArrowRight" : key === "ArrowRight" ? "ArrowLeft" : key;
}
function getFocusIntent(event, orientation, dir) {
  const key = getDirectionAwareKey(event.key, dir);
  if (orientation === "vertical" && ["ArrowLeft", "ArrowRight"].includes(key)) return void 0;
  if (orientation === "horizontal" && ["ArrowUp", "ArrowDown"].includes(key)) return void 0;
  return MAP_KEY_TO_FOCUS_INTENT[key];
}
function focusFirst$3(candidates, preventScroll = false) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
    candidate.focus({ preventScroll });
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
  }
}
function wrapArray$2(array, startIndex) {
  return array.map((_, index2) => array[(startIndex + index2) % array.length]);
}
var Root$5 = RovingFocusGroup;
var Item$2 = RovingFocusGroupItem;
var SELECTION_KEYS$1 = ["Enter", " "];
var FIRST_KEYS = ["ArrowDown", "PageUp", "Home"];
var LAST_KEYS = ["ArrowUp", "PageDown", "End"];
var FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];
var SUB_OPEN_KEYS = {
  ltr: [...SELECTION_KEYS$1, "ArrowRight"],
  rtl: [...SELECTION_KEYS$1, "ArrowLeft"]
};
var SUB_CLOSE_KEYS = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
};
var MENU_NAME = "Menu";
var [Collection$3, useCollection$3, createCollectionScope$3] = createCollection(MENU_NAME);
var [createMenuContext, createMenuScope] = createContextScope(MENU_NAME, [
  createCollectionScope$3,
  createPopperScope,
  createRovingFocusGroupScope
]);
var usePopperScope$3 = createPopperScope();
var useRovingFocusGroupScope$2 = createRovingFocusGroupScope();
var [MenuProvider, useMenuContext] = createMenuContext(MENU_NAME);
var [MenuRootProvider, useMenuRootContext] = createMenuContext(MENU_NAME);
var Menu = (props) => {
  const { __scopeMenu, open = false, children, dir, onOpenChange, modal = true } = props;
  const popperScope = usePopperScope$3(__scopeMenu);
  const [content, setContent] = React.useState(null);
  const isUsingKeyboardRef = React.useRef(false);
  const handleOpenChange = useCallbackRef$1(onOpenChange);
  const direction = useDirection(dir);
  React.useEffect(() => {
    const handleKeyDown = () => {
      isUsingKeyboardRef.current = true;
      document.addEventListener("pointerdown", handlePointer, { capture: true, once: true });
      document.addEventListener("pointermove", handlePointer, { capture: true, once: true });
    };
    const handlePointer = () => isUsingKeyboardRef.current = false;
    document.addEventListener("keydown", handleKeyDown, { capture: true });
    return () => {
      document.removeEventListener("keydown", handleKeyDown, { capture: true });
      document.removeEventListener("pointerdown", handlePointer, { capture: true });
      document.removeEventListener("pointermove", handlePointer, { capture: true });
    };
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root2$7, { ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    MenuProvider,
    {
      scope: __scopeMenu,
      open,
      onOpenChange: handleOpenChange,
      content,
      onContentChange: setContent,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        MenuRootProvider,
        {
          scope: __scopeMenu,
          onClose: React.useCallback(() => handleOpenChange(false), [handleOpenChange]),
          isUsingKeyboardRef,
          dir: direction,
          modal,
          children
        }
      )
    }
  ) });
};
Menu.displayName = MENU_NAME;
var ANCHOR_NAME$1 = "MenuAnchor";
var MenuAnchor = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...anchorProps } = props;
    const popperScope = usePopperScope$3(__scopeMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor, { ...popperScope, ...anchorProps, ref: forwardedRef });
  }
);
MenuAnchor.displayName = ANCHOR_NAME$1;
var PORTAL_NAME$4 = "MenuPortal";
var [PortalProvider$2, usePortalContext$2] = createMenuContext(PORTAL_NAME$4, {
  forceMount: void 0
});
var MenuPortal = (props) => {
  const { __scopeMenu, forceMount, children, container } = props;
  const context = useMenuContext(PORTAL_NAME$4, __scopeMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PortalProvider$2, { scope: __scopeMenu, forceMount, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$4, { asChild: true, container, children }) }) });
};
MenuPortal.displayName = PORTAL_NAME$4;
var CONTENT_NAME$6 = "MenuContent";
var [MenuContentProvider, useMenuContentContext] = createMenuContext(CONTENT_NAME$6);
var MenuContent = React.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext$2(CONTENT_NAME$6, props.__scopeMenu);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context = useMenuContext(CONTENT_NAME$6, props.__scopeMenu);
    const rootContext = useMenuRootContext(CONTENT_NAME$6, props.__scopeMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$3.Provider, { scope: props.__scopeMenu, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$3.Slot, { scope: props.__scopeMenu, children: rootContext.modal ? /* @__PURE__ */ jsxRuntimeExports.jsx(MenuRootContentModal, { ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsxRuntimeExports.jsx(MenuRootContentNonModal, { ...contentProps, ref: forwardedRef }) }) }) });
  }
);
var MenuRootContentModal = React.forwardRef(
  (props, forwardedRef) => {
    const context = useMenuContext(CONTENT_NAME$6, props.__scopeMenu);
    const ref = React.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    React.useEffect(() => {
      const content = ref.current;
      if (content) return hideOthers(content);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuContentImpl,
      {
        ...props,
        ref: composedRefs,
        trapFocus: context.open,
        disableOutsidePointerEvents: context.open,
        disableOutsideScroll: true,
        onFocusOutside: composeEventHandlers(
          props.onFocusOutside,
          (event) => event.preventDefault(),
          { checkForDefaultPrevented: false }
        ),
        onDismiss: () => context.onOpenChange(false)
      }
    );
  }
);
var MenuRootContentNonModal = React.forwardRef((props, forwardedRef) => {
  const context = useMenuContext(CONTENT_NAME$6, props.__scopeMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    MenuContentImpl,
    {
      ...props,
      ref: forwardedRef,
      trapFocus: false,
      disableOutsidePointerEvents: false,
      disableOutsideScroll: false,
      onDismiss: () => context.onOpenChange(false)
    }
  );
});
var MenuContentImpl = React.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeMenu,
      loop = false,
      trapFocus,
      onOpenAutoFocus,
      onCloseAutoFocus,
      disableOutsidePointerEvents,
      onEntryFocus,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      onDismiss,
      disableOutsideScroll,
      ...contentProps
    } = props;
    const context = useMenuContext(CONTENT_NAME$6, __scopeMenu);
    const rootContext = useMenuRootContext(CONTENT_NAME$6, __scopeMenu);
    const popperScope = usePopperScope$3(__scopeMenu);
    const rovingFocusGroupScope = useRovingFocusGroupScope$2(__scopeMenu);
    const getItems = useCollection$3(__scopeMenu);
    const [currentItemId, setCurrentItemId] = React.useState(null);
    const contentRef = React.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef, context.onContentChange);
    const timerRef = React.useRef(0);
    const searchRef = React.useRef("");
    const pointerGraceTimerRef = React.useRef(0);
    const pointerGraceIntentRef = React.useRef(null);
    const pointerDirRef = React.useRef("right");
    const lastPointerXRef = React.useRef(0);
    const ScrollLockWrapper = disableOutsideScroll ? ReactRemoveScroll : React.Fragment;
    const scrollLockWrapperProps = disableOutsideScroll ? { as: Slot, allowPinchZoom: true } : void 0;
    const handleTypeaheadSearch = (key) => {
      var _a, _b;
      const search = searchRef.current + key;
      const items = getItems().filter((item) => !item.disabled);
      const currentItem = document.activeElement;
      const currentMatch = (_a = items.find((item) => item.ref.current === currentItem)) == null ? void 0 : _a.textValue;
      const values = items.map((item) => item.textValue);
      const nextMatch = getNextMatch(values, search, currentMatch);
      const newItem = (_b = items.find((item) => item.textValue === nextMatch)) == null ? void 0 : _b.ref.current;
      (function updateSearch(value2) {
        searchRef.current = value2;
        window.clearTimeout(timerRef.current);
        if (value2 !== "") timerRef.current = window.setTimeout(() => updateSearch(""), 1e3);
      })(search);
      if (newItem) {
        setTimeout(() => newItem.focus());
      }
    };
    React.useEffect(() => {
      return () => window.clearTimeout(timerRef.current);
    }, []);
    useFocusGuards();
    const isPointerMovingToSubmenu = React.useCallback((event) => {
      var _a, _b;
      const isMovingTowards = pointerDirRef.current === ((_a = pointerGraceIntentRef.current) == null ? void 0 : _a.side);
      return isMovingTowards && isPointerInGraceArea(event, (_b = pointerGraceIntentRef.current) == null ? void 0 : _b.area);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuContentProvider,
      {
        scope: __scopeMenu,
        searchRef,
        onItemEnter: React.useCallback(
          (event) => {
            if (isPointerMovingToSubmenu(event)) event.preventDefault();
          },
          [isPointerMovingToSubmenu]
        ),
        onItemLeave: React.useCallback(
          (event) => {
            var _a;
            if (isPointerMovingToSubmenu(event)) return;
            (_a = contentRef.current) == null ? void 0 : _a.focus();
            setCurrentItemId(null);
          },
          [isPointerMovingToSubmenu]
        ),
        onTriggerLeave: React.useCallback(
          (event) => {
            if (isPointerMovingToSubmenu(event)) event.preventDefault();
          },
          [isPointerMovingToSubmenu]
        ),
        pointerGraceTimerRef,
        onPointerGraceIntentChange: React.useCallback((intent) => {
          pointerGraceIntentRef.current = intent;
        }, []),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollLockWrapper, { ...scrollLockWrapperProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          FocusScope,
          {
            asChild: true,
            trapped: trapFocus,
            onMountAutoFocus: composeEventHandlers(onOpenAutoFocus, (event) => {
              var _a;
              event.preventDefault();
              (_a = contentRef.current) == null ? void 0 : _a.focus({ preventScroll: true });
            }),
            onUnmountAutoFocus: onCloseAutoFocus,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              DismissableLayer,
              {
                asChild: true,
                disableOutsidePointerEvents,
                onEscapeKeyDown,
                onPointerDownOutside,
                onFocusOutside,
                onInteractOutside,
                onDismiss,
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Root$5,
                  {
                    asChild: true,
                    ...rovingFocusGroupScope,
                    dir: rootContext.dir,
                    orientation: "vertical",
                    loop,
                    currentTabStopId: currentItemId,
                    onCurrentTabStopIdChange: setCurrentItemId,
                    onEntryFocus: composeEventHandlers(onEntryFocus, (event) => {
                      if (!rootContext.isUsingKeyboardRef.current) event.preventDefault();
                    }),
                    preventScrollOnEntryFocus: true,
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Content$2,
                      {
                        role: "menu",
                        "aria-orientation": "vertical",
                        "data-state": getOpenState$1(context.open),
                        "data-radix-menu-content": "",
                        dir: rootContext.dir,
                        ...popperScope,
                        ...contentProps,
                        ref: composedRefs,
                        style: { outline: "none", ...contentProps.style },
                        onKeyDown: composeEventHandlers(contentProps.onKeyDown, (event) => {
                          const target2 = event.target;
                          const isKeyDownInside = target2.closest("[data-radix-menu-content]") === event.currentTarget;
                          const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
                          const isCharacterKey = event.key.length === 1;
                          if (isKeyDownInside) {
                            if (event.key === "Tab") event.preventDefault();
                            if (!isModifierKey && isCharacterKey) handleTypeaheadSearch(event.key);
                          }
                          const content = contentRef.current;
                          if (event.target !== content) return;
                          if (!FIRST_LAST_KEYS.includes(event.key)) return;
                          event.preventDefault();
                          const items = getItems().filter((item) => !item.disabled);
                          const candidateNodes = items.map((item) => item.ref.current);
                          if (LAST_KEYS.includes(event.key)) candidateNodes.reverse();
                          focusFirst$2(candidateNodes);
                        }),
                        onBlur: composeEventHandlers(props.onBlur, (event) => {
                          if (!event.currentTarget.contains(event.target)) {
                            window.clearTimeout(timerRef.current);
                            searchRef.current = "";
                          }
                        }),
                        onPointerMove: composeEventHandlers(
                          props.onPointerMove,
                          whenMouse$1((event) => {
                            const target2 = event.target;
                            const pointerXHasChanged = lastPointerXRef.current !== event.clientX;
                            if (event.currentTarget.contains(target2) && pointerXHasChanged) {
                              const newDir = event.clientX > lastPointerXRef.current ? "right" : "left";
                              pointerDirRef.current = newDir;
                              lastPointerXRef.current = event.clientX;
                            }
                          })
                        )
                      }
                    )
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
MenuContent.displayName = CONTENT_NAME$6;
var GROUP_NAME$2 = "MenuGroup";
var MenuGroup = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...groupProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { role: "group", ...groupProps, ref: forwardedRef });
  }
);
MenuGroup.displayName = GROUP_NAME$2;
var LABEL_NAME$2 = "MenuLabel";
var MenuLabel = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...labelProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...labelProps, ref: forwardedRef });
  }
);
MenuLabel.displayName = LABEL_NAME$2;
var ITEM_NAME$4 = "MenuItem";
var ITEM_SELECT = "menu.itemSelect";
var MenuItem = React.forwardRef(
  (props, forwardedRef) => {
    const { disabled = false, onSelect, ...itemProps } = props;
    const ref = React.useRef(null);
    const rootContext = useMenuRootContext(ITEM_NAME$4, props.__scopeMenu);
    const contentContext = useMenuContentContext(ITEM_NAME$4, props.__scopeMenu);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const isPointerDownRef = React.useRef(false);
    const handleSelect = () => {
      const menuItem = ref.current;
      if (!disabled && menuItem) {
        const itemSelectEvent = new CustomEvent(ITEM_SELECT, { bubbles: true, cancelable: true });
        menuItem.addEventListener(ITEM_SELECT, (event) => onSelect == null ? void 0 : onSelect(event), { once: true });
        dispatchDiscreteCustomEvent(menuItem, itemSelectEvent);
        if (itemSelectEvent.defaultPrevented) {
          isPointerDownRef.current = false;
        } else {
          rootContext.onClose();
        }
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuItemImpl,
      {
        ...itemProps,
        ref: composedRefs,
        disabled,
        onClick: composeEventHandlers(props.onClick, handleSelect),
        onPointerDown: (event) => {
          var _a;
          (_a = props.onPointerDown) == null ? void 0 : _a.call(props, event);
          isPointerDownRef.current = true;
        },
        onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {
          var _a;
          if (!isPointerDownRef.current) (_a = event.currentTarget) == null ? void 0 : _a.click();
        }),
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          const isTypingAhead = contentContext.searchRef.current !== "";
          if (disabled || isTypingAhead && event.key === " ") return;
          if (SELECTION_KEYS$1.includes(event.key)) {
            event.currentTarget.click();
            event.preventDefault();
          }
        })
      }
    );
  }
);
MenuItem.displayName = ITEM_NAME$4;
var MenuItemImpl = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, disabled = false, textValue, ...itemProps } = props;
    const contentContext = useMenuContentContext(ITEM_NAME$4, __scopeMenu);
    const rovingFocusGroupScope = useRovingFocusGroupScope$2(__scopeMenu);
    const ref = React.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const [isFocused, setIsFocused] = React.useState(false);
    const [textContent, setTextContent] = React.useState("");
    React.useEffect(() => {
      const menuItem = ref.current;
      if (menuItem) {
        setTextContent((menuItem.textContent ?? "").trim());
      }
    }, [itemProps.children]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Collection$3.ItemSlot,
      {
        scope: __scopeMenu,
        disabled,
        textValue: textValue ?? textContent,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Item$2, { asChild: true, ...rovingFocusGroupScope, focusable: !disabled, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.div,
          {
            role: "menuitem",
            "data-highlighted": isFocused ? "" : void 0,
            "aria-disabled": disabled || void 0,
            "data-disabled": disabled ? "" : void 0,
            ...itemProps,
            ref: composedRefs,
            onPointerMove: composeEventHandlers(
              props.onPointerMove,
              whenMouse$1((event) => {
                if (disabled) {
                  contentContext.onItemLeave(event);
                } else {
                  contentContext.onItemEnter(event);
                  if (!event.defaultPrevented) {
                    const item = event.currentTarget;
                    item.focus({ preventScroll: true });
                  }
                }
              })
            ),
            onPointerLeave: composeEventHandlers(
              props.onPointerLeave,
              whenMouse$1((event) => contentContext.onItemLeave(event))
            ),
            onFocus: composeEventHandlers(props.onFocus, () => setIsFocused(true)),
            onBlur: composeEventHandlers(props.onBlur, () => setIsFocused(false))
          }
        ) })
      }
    );
  }
);
var CHECKBOX_ITEM_NAME$1 = "MenuCheckboxItem";
var MenuCheckboxItem = React.forwardRef(
  (props, forwardedRef) => {
    const { checked = false, onCheckedChange, ...checkboxItemProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ItemIndicatorProvider, { scope: props.__scopeMenu, checked, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuItem,
      {
        role: "menuitemcheckbox",
        "aria-checked": isIndeterminate(checked) ? "mixed" : checked,
        ...checkboxItemProps,
        ref: forwardedRef,
        "data-state": getCheckedState(checked),
        onSelect: composeEventHandlers(
          checkboxItemProps.onSelect,
          () => onCheckedChange == null ? void 0 : onCheckedChange(isIndeterminate(checked) ? true : !checked),
          { checkForDefaultPrevented: false }
        )
      }
    ) });
  }
);
MenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME$1;
var RADIO_GROUP_NAME$2 = "MenuRadioGroup";
var [RadioGroupProvider$1, useRadioGroupContext$1] = createMenuContext(
  RADIO_GROUP_NAME$2,
  { value: void 0, onValueChange: () => {
  } }
);
var MenuRadioGroup = React.forwardRef(
  (props, forwardedRef) => {
    const { value: value2, onValueChange, ...groupProps } = props;
    const handleValueChange = useCallbackRef$1(onValueChange);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(RadioGroupProvider$1, { scope: props.__scopeMenu, value: value2, onValueChange: handleValueChange, children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuGroup, { ...groupProps, ref: forwardedRef }) });
  }
);
MenuRadioGroup.displayName = RADIO_GROUP_NAME$2;
var RADIO_ITEM_NAME$1 = "MenuRadioItem";
var MenuRadioItem = React.forwardRef(
  (props, forwardedRef) => {
    const { value: value2, ...radioItemProps } = props;
    const context = useRadioGroupContext$1(RADIO_ITEM_NAME$1, props.__scopeMenu);
    const checked = value2 === context.value;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ItemIndicatorProvider, { scope: props.__scopeMenu, checked, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuItem,
      {
        role: "menuitemradio",
        "aria-checked": checked,
        ...radioItemProps,
        ref: forwardedRef,
        "data-state": getCheckedState(checked),
        onSelect: composeEventHandlers(
          radioItemProps.onSelect,
          () => {
            var _a;
            return (_a = context.onValueChange) == null ? void 0 : _a.call(context, value2);
          },
          { checkForDefaultPrevented: false }
        )
      }
    ) });
  }
);
MenuRadioItem.displayName = RADIO_ITEM_NAME$1;
var ITEM_INDICATOR_NAME$1 = "MenuItemIndicator";
var [ItemIndicatorProvider, useItemIndicatorContext] = createMenuContext(
  ITEM_INDICATOR_NAME$1,
  { checked: false }
);
var MenuItemIndicator = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, forceMount, ...itemIndicatorProps } = props;
    const indicatorContext = useItemIndicatorContext(ITEM_INDICATOR_NAME$1, __scopeMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Presence,
      {
        present: forceMount || isIndeterminate(indicatorContext.checked) || indicatorContext.checked === true,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.span,
          {
            ...itemIndicatorProps,
            ref: forwardedRef,
            "data-state": getCheckedState(indicatorContext.checked)
          }
        )
      }
    );
  }
);
MenuItemIndicator.displayName = ITEM_INDICATOR_NAME$1;
var SEPARATOR_NAME$2 = "MenuSeparator";
var MenuSeparator = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...separatorProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.div,
      {
        role: "separator",
        "aria-orientation": "horizontal",
        ...separatorProps,
        ref: forwardedRef
      }
    );
  }
);
MenuSeparator.displayName = SEPARATOR_NAME$2;
var ARROW_NAME$4 = "MenuArrow";
var MenuArrow = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...arrowProps } = props;
    const popperScope = usePopperScope$3(__scopeMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow, { ...popperScope, ...arrowProps, ref: forwardedRef });
  }
);
MenuArrow.displayName = ARROW_NAME$4;
var SUB_NAME$1 = "MenuSub";
var [MenuSubProvider, useMenuSubContext] = createMenuContext(SUB_NAME$1);
var MenuSub = (props) => {
  const { __scopeMenu, children, open = false, onOpenChange } = props;
  const parentMenuContext = useMenuContext(SUB_NAME$1, __scopeMenu);
  const popperScope = usePopperScope$3(__scopeMenu);
  const [trigger, setTrigger] = React.useState(null);
  const [content, setContent] = React.useState(null);
  const handleOpenChange = useCallbackRef$1(onOpenChange);
  React.useEffect(() => {
    if (parentMenuContext.open === false) handleOpenChange(false);
    return () => handleOpenChange(false);
  }, [parentMenuContext.open, handleOpenChange]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root2$7, { ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    MenuProvider,
    {
      scope: __scopeMenu,
      open,
      onOpenChange: handleOpenChange,
      content,
      onContentChange: setContent,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        MenuSubProvider,
        {
          scope: __scopeMenu,
          contentId: useId$1(),
          triggerId: useId$1(),
          trigger,
          onTriggerChange: setTrigger,
          children
        }
      )
    }
  ) });
};
MenuSub.displayName = SUB_NAME$1;
var SUB_TRIGGER_NAME$1 = "MenuSubTrigger";
var MenuSubTrigger = React.forwardRef(
  (props, forwardedRef) => {
    const context = useMenuContext(SUB_TRIGGER_NAME$1, props.__scopeMenu);
    const rootContext = useMenuRootContext(SUB_TRIGGER_NAME$1, props.__scopeMenu);
    const subContext = useMenuSubContext(SUB_TRIGGER_NAME$1, props.__scopeMenu);
    const contentContext = useMenuContentContext(SUB_TRIGGER_NAME$1, props.__scopeMenu);
    const openTimerRef = React.useRef(null);
    const { pointerGraceTimerRef, onPointerGraceIntentChange } = contentContext;
    const scope = { __scopeMenu: props.__scopeMenu };
    const clearOpenTimer = React.useCallback(() => {
      if (openTimerRef.current) window.clearTimeout(openTimerRef.current);
      openTimerRef.current = null;
    }, []);
    React.useEffect(() => clearOpenTimer, [clearOpenTimer]);
    React.useEffect(() => {
      const pointerGraceTimer = pointerGraceTimerRef.current;
      return () => {
        window.clearTimeout(pointerGraceTimer);
        onPointerGraceIntentChange(null);
      };
    }, [pointerGraceTimerRef, onPointerGraceIntentChange]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(MenuAnchor, { asChild: true, ...scope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuItemImpl,
      {
        id: subContext.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": context.open,
        "aria-controls": subContext.contentId,
        "data-state": getOpenState$1(context.open),
        ...props,
        ref: composeRefs(forwardedRef, subContext.onTriggerChange),
        onClick: (event) => {
          var _a;
          (_a = props.onClick) == null ? void 0 : _a.call(props, event);
          if (props.disabled || event.defaultPrevented) return;
          event.currentTarget.focus();
          if (!context.open) context.onOpenChange(true);
        },
        onPointerMove: composeEventHandlers(
          props.onPointerMove,
          whenMouse$1((event) => {
            contentContext.onItemEnter(event);
            if (event.defaultPrevented) return;
            if (!props.disabled && !context.open && !openTimerRef.current) {
              contentContext.onPointerGraceIntentChange(null);
              openTimerRef.current = window.setTimeout(() => {
                context.onOpenChange(true);
                clearOpenTimer();
              }, 100);
            }
          })
        ),
        onPointerLeave: composeEventHandlers(
          props.onPointerLeave,
          whenMouse$1((event) => {
            var _a, _b;
            clearOpenTimer();
            const contentRect = (_a = context.content) == null ? void 0 : _a.getBoundingClientRect();
            if (contentRect) {
              const side = (_b = context.content) == null ? void 0 : _b.dataset.side;
              const rightSide = side === "right";
              const bleed = rightSide ? -5 : 5;
              const contentNearEdge = contentRect[rightSide ? "left" : "right"];
              const contentFarEdge = contentRect[rightSide ? "right" : "left"];
              contentContext.onPointerGraceIntentChange({
                area: [
                  // Apply a bleed on clientX to ensure that our exit point is
                  // consistently within polygon bounds
                  { x: event.clientX + bleed, y: event.clientY },
                  { x: contentNearEdge, y: contentRect.top },
                  { x: contentFarEdge, y: contentRect.top },
                  { x: contentFarEdge, y: contentRect.bottom },
                  { x: contentNearEdge, y: contentRect.bottom }
                ],
                side
              });
              window.clearTimeout(pointerGraceTimerRef.current);
              pointerGraceTimerRef.current = window.setTimeout(
                () => contentContext.onPointerGraceIntentChange(null),
                300
              );
            } else {
              contentContext.onTriggerLeave(event);
              if (event.defaultPrevented) return;
              contentContext.onPointerGraceIntentChange(null);
            }
          })
        ),
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          var _a;
          const isTypingAhead = contentContext.searchRef.current !== "";
          if (props.disabled || isTypingAhead && event.key === " ") return;
          if (SUB_OPEN_KEYS[rootContext.dir].includes(event.key)) {
            context.onOpenChange(true);
            (_a = context.content) == null ? void 0 : _a.focus();
            event.preventDefault();
          }
        })
      }
    ) });
  }
);
MenuSubTrigger.displayName = SUB_TRIGGER_NAME$1;
var SUB_CONTENT_NAME$1 = "MenuSubContent";
var MenuSubContent = React.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext$2(CONTENT_NAME$6, props.__scopeMenu);
    const { forceMount = portalContext.forceMount, ...subContentProps } = props;
    const context = useMenuContext(CONTENT_NAME$6, props.__scopeMenu);
    const rootContext = useMenuRootContext(CONTENT_NAME$6, props.__scopeMenu);
    const subContext = useMenuSubContext(SUB_CONTENT_NAME$1, props.__scopeMenu);
    const ref = React.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$3.Provider, { scope: props.__scopeMenu, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$3.Slot, { scope: props.__scopeMenu, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuContentImpl,
      {
        id: subContext.contentId,
        "aria-labelledby": subContext.triggerId,
        ...subContentProps,
        ref: composedRefs,
        align: "start",
        side: rootContext.dir === "rtl" ? "left" : "right",
        disableOutsidePointerEvents: false,
        disableOutsideScroll: false,
        trapFocus: false,
        onOpenAutoFocus: (event) => {
          var _a;
          if (rootContext.isUsingKeyboardRef.current) (_a = ref.current) == null ? void 0 : _a.focus();
          event.preventDefault();
        },
        onCloseAutoFocus: (event) => event.preventDefault(),
        onFocusOutside: composeEventHandlers(props.onFocusOutside, (event) => {
          if (event.target !== subContext.trigger) context.onOpenChange(false);
        }),
        onEscapeKeyDown: composeEventHandlers(props.onEscapeKeyDown, (event) => {
          rootContext.onClose();
          event.preventDefault();
        }),
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          var _a;
          const isKeyDownInside = event.currentTarget.contains(event.target);
          const isCloseKey = SUB_CLOSE_KEYS[rootContext.dir].includes(event.key);
          if (isKeyDownInside && isCloseKey) {
            context.onOpenChange(false);
            (_a = subContext.trigger) == null ? void 0 : _a.focus();
            event.preventDefault();
          }
        })
      }
    ) }) }) });
  }
);
MenuSubContent.displayName = SUB_CONTENT_NAME$1;
function getOpenState$1(open) {
  return open ? "open" : "closed";
}
function isIndeterminate(checked) {
  return checked === "indeterminate";
}
function getCheckedState(checked) {
  return isIndeterminate(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
}
function focusFirst$2(candidates) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
    candidate.focus();
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
  }
}
function wrapArray$1(array, startIndex) {
  return array.map((_, index2) => array[(startIndex + index2) % array.length]);
}
function getNextMatch(values, search, currentMatch) {
  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
  const normalizedSearch = isRepeated ? search[0] : search;
  const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1;
  let wrappedValues = wrapArray$1(values, Math.max(currentMatchIndex, 0));
  const excludeCurrentMatch = normalizedSearch.length === 1;
  if (excludeCurrentMatch) wrappedValues = wrappedValues.filter((v) => v !== currentMatch);
  const nextMatch = wrappedValues.find(
    (value2) => value2.toLowerCase().startsWith(normalizedSearch.toLowerCase())
  );
  return nextMatch !== currentMatch ? nextMatch : void 0;
}
function isPointInPolygon$1(point2, polygon) {
  const { x, y } = point2;
  let inside = false;
  for (let i2 = 0, j = polygon.length - 1; i2 < polygon.length; j = i2++) {
    const xi = polygon[i2].x;
    const yi = polygon[i2].y;
    const xj = polygon[j].x;
    const yj = polygon[j].y;
    const intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
    if (intersect) inside = !inside;
  }
  return inside;
}
function isPointerInGraceArea(event, area) {
  if (!area) return false;
  const cursorPos = { x: event.clientX, y: event.clientY };
  return isPointInPolygon$1(cursorPos, area);
}
function whenMouse$1(handler) {
  return (event) => event.pointerType === "mouse" ? handler(event) : void 0;
}
var Root3$1 = Menu;
var Anchor2 = MenuAnchor;
var Portal$2 = MenuPortal;
var Content2$4 = MenuContent;
var Group$1 = MenuGroup;
var Label$3 = MenuLabel;
var Item2$2 = MenuItem;
var CheckboxItem = MenuCheckboxItem;
var RadioGroup$2 = MenuRadioGroup;
var RadioItem = MenuRadioItem;
var ItemIndicator$1 = MenuItemIndicator;
var Separator$3 = MenuSeparator;
var Arrow2 = MenuArrow;
var Sub = MenuSub;
var SubTrigger = MenuSubTrigger;
var SubContent = MenuSubContent;
var DROPDOWN_MENU_NAME = "DropdownMenu";
var [createDropdownMenuContext, createDropdownMenuScope] = createContextScope(
  DROPDOWN_MENU_NAME,
  [createMenuScope]
);
var useMenuScope = createMenuScope();
var [DropdownMenuProvider, useDropdownMenuContext] = createDropdownMenuContext(DROPDOWN_MENU_NAME);
var DropdownMenu$1 = (props) => {
  const {
    __scopeDropdownMenu,
    children,
    dir,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = true
  } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  const triggerRef = React.useRef(null);
  const [open = false, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    DropdownMenuProvider,
    {
      scope: __scopeDropdownMenu,
      triggerId: useId$1(),
      triggerRef,
      contentId: useId$1(),
      open,
      onOpenChange: setOpen,
      onOpenToggle: React.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      modal,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Root3$1, { ...menuScope, open, onOpenChange: setOpen, dir, modal, children })
    }
  );
};
DropdownMenu$1.displayName = DROPDOWN_MENU_NAME;
var TRIGGER_NAME$5 = "DropdownMenuTrigger";
var DropdownMenuTrigger$1 = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, disabled = false, ...triggerProps } = props;
    const context = useDropdownMenuContext(TRIGGER_NAME$5, __scopeDropdownMenu);
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor2, { asChild: true, ...menuScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        id: context.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": context.open,
        "aria-controls": context.open ? context.contentId : void 0,
        "data-state": context.open ? "open" : "closed",
        "data-disabled": disabled ? "" : void 0,
        disabled,
        ...triggerProps,
        ref: composeRefs(forwardedRef, context.triggerRef),
        onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
          if (!disabled && event.button === 0 && event.ctrlKey === false) {
            context.onOpenToggle();
            if (!context.open) event.preventDefault();
          }
        }),
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          if (disabled) return;
          if (["Enter", " "].includes(event.key)) context.onOpenToggle();
          if (event.key === "ArrowDown") context.onOpenChange(true);
          if (["Enter", " ", "ArrowDown"].includes(event.key)) event.preventDefault();
        })
      }
    ) });
  }
);
DropdownMenuTrigger$1.displayName = TRIGGER_NAME$5;
var PORTAL_NAME$3 = "DropdownMenuPortal";
var DropdownMenuPortal$1 = (props) => {
  const { __scopeDropdownMenu, ...portalProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$2, { ...menuScope, ...portalProps });
};
DropdownMenuPortal$1.displayName = PORTAL_NAME$3;
var CONTENT_NAME$5 = "DropdownMenuContent";
var DropdownMenuContent$1 = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...contentProps } = props;
    const context = useDropdownMenuContext(CONTENT_NAME$5, __scopeDropdownMenu);
    const menuScope = useMenuScope(__scopeDropdownMenu);
    const hasInteractedOutsideRef = React.useRef(false);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Content2$4,
      {
        id: context.contentId,
        "aria-labelledby": context.triggerId,
        ...menuScope,
        ...contentProps,
        ref: forwardedRef,
        onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
          var _a;
          if (!hasInteractedOutsideRef.current) (_a = context.triggerRef.current) == null ? void 0 : _a.focus();
          hasInteractedOutsideRef.current = false;
          event.preventDefault();
        }),
        onInteractOutside: composeEventHandlers(props.onInteractOutside, (event) => {
          const originalEvent = event.detail.originalEvent;
          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          if (!context.modal || isRightClick) hasInteractedOutsideRef.current = true;
        }),
        style: {
          ...props.style,
          // re-namespace exposed content custom properties
          ...{
            "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
            "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
            "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
            "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
          }
        }
      }
    );
  }
);
DropdownMenuContent$1.displayName = CONTENT_NAME$5;
var GROUP_NAME$1 = "DropdownMenuGroup";
var DropdownMenuGroup$1 = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...groupProps } = props;
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Group$1, { ...menuScope, ...groupProps, ref: forwardedRef });
  }
);
DropdownMenuGroup$1.displayName = GROUP_NAME$1;
var LABEL_NAME$1 = "DropdownMenuLabel";
var DropdownMenuLabel$1 = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...labelProps } = props;
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Label$3, { ...menuScope, ...labelProps, ref: forwardedRef });
  }
);
DropdownMenuLabel$1.displayName = LABEL_NAME$1;
var ITEM_NAME$3 = "DropdownMenuItem";
var DropdownMenuItem$1 = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...itemProps } = props;
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Item2$2, { ...menuScope, ...itemProps, ref: forwardedRef });
  }
);
DropdownMenuItem$1.displayName = ITEM_NAME$3;
var CHECKBOX_ITEM_NAME = "DropdownMenuCheckboxItem";
var DropdownMenuCheckboxItem$1 = React.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...checkboxItemProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CheckboxItem, { ...menuScope, ...checkboxItemProps, ref: forwardedRef });
});
DropdownMenuCheckboxItem$1.displayName = CHECKBOX_ITEM_NAME;
var RADIO_GROUP_NAME$1 = "DropdownMenuRadioGroup";
var DropdownMenuRadioGroup$1 = React.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...radioGroupProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(RadioGroup$2, { ...menuScope, ...radioGroupProps, ref: forwardedRef });
});
DropdownMenuRadioGroup$1.displayName = RADIO_GROUP_NAME$1;
var RADIO_ITEM_NAME = "DropdownMenuRadioItem";
var DropdownMenuRadioItem$1 = React.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...radioItemProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(RadioItem, { ...menuScope, ...radioItemProps, ref: forwardedRef });
});
DropdownMenuRadioItem$1.displayName = RADIO_ITEM_NAME;
var INDICATOR_NAME$2 = "DropdownMenuItemIndicator";
var DropdownMenuItemIndicator = React.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...itemIndicatorProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ItemIndicator$1, { ...menuScope, ...itemIndicatorProps, ref: forwardedRef });
});
DropdownMenuItemIndicator.displayName = INDICATOR_NAME$2;
var SEPARATOR_NAME$1 = "DropdownMenuSeparator";
var DropdownMenuSeparator$1 = React.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...separatorProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Separator$3, { ...menuScope, ...separatorProps, ref: forwardedRef });
});
DropdownMenuSeparator$1.displayName = SEPARATOR_NAME$1;
var ARROW_NAME$3 = "DropdownMenuArrow";
var DropdownMenuArrow = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...arrowProps } = props;
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow2, { ...menuScope, ...arrowProps, ref: forwardedRef });
  }
);
DropdownMenuArrow.displayName = ARROW_NAME$3;
var DropdownMenuSub$1 = (props) => {
  const { __scopeDropdownMenu, children, open: openProp, onOpenChange, defaultOpen } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  const [open = false, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Sub, { ...menuScope, open, onOpenChange: setOpen, children });
};
var SUB_TRIGGER_NAME = "DropdownMenuSubTrigger";
var DropdownMenuSubTrigger$1 = React.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...subTriggerProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SubTrigger, { ...menuScope, ...subTriggerProps, ref: forwardedRef });
});
DropdownMenuSubTrigger$1.displayName = SUB_TRIGGER_NAME;
var SUB_CONTENT_NAME = "DropdownMenuSubContent";
var DropdownMenuSubContent$1 = React.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...subContentProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SubContent,
    {
      ...menuScope,
      ...subContentProps,
      ref: forwardedRef,
      style: {
        ...props.style,
        // re-namespace exposed content custom properties
        ...{
          "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    }
  );
});
DropdownMenuSubContent$1.displayName = SUB_CONTENT_NAME;
var Root2$6 = DropdownMenu$1;
var Trigger$5 = DropdownMenuTrigger$1;
var Portal2 = DropdownMenuPortal$1;
var Content2$3 = DropdownMenuContent$1;
var Group2 = DropdownMenuGroup$1;
var Label2 = DropdownMenuLabel$1;
var Item2$1 = DropdownMenuItem$1;
var CheckboxItem2 = DropdownMenuCheckboxItem$1;
var RadioGroup2 = DropdownMenuRadioGroup$1;
var RadioItem2 = DropdownMenuRadioItem$1;
var ItemIndicator2 = DropdownMenuItemIndicator;
var Separator2 = DropdownMenuSeparator$1;
var Sub2 = DropdownMenuSub$1;
var SubTrigger2 = DropdownMenuSubTrigger$1;
var SubContent2 = DropdownMenuSubContent$1;
const DropdownMenu = Root2$6;
const DropdownMenuTrigger = Trigger$5;
const DropdownMenuGroup = Group2;
const DropdownMenuPortal = Portal2;
const DropdownMenuSub = Sub2;
const DropdownMenuRadioGroup = RadioGroup2;
const DropdownMenuSubTrigger = forwardRef(
  ({ className, inset, children, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
    SubTrigger2,
    {
      ref,
      className: cn(
        "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-grayscale-700 data-[state=open]:bg-accent dark:focus:bg-dark-grayscale-700",
        inset && "pl-8",
        className
      ),
      ...props,
      children: [
        children,
        /* @__PURE__ */ jsxRuntimeExports.jsx(SvgArrowRight, { className: "ml-auto h-4 w-4" })
      ]
    }
  )
);
DropdownMenuSubTrigger.displayName = SubTrigger2.displayName;
const DropdownMenuSubContent = forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  SubContent2,
  {
    ref,
    className: cn(
      "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] overflow-hidden rounded-md border border-grayscale-700 bg-grayscale-1000 p-1 text-grayscale-200 shadow-lg dark:border-dark-grayscale-400 dark:text-dark-grayscale-200",
      className
    ),
    ...props
  }
));
DropdownMenuSubContent.displayName = SubContent2.displayName;
const DropdownMenuContent = forwardRef(
  ({ className, sideOffset = 4, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(Portal2, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Content2$3,
    {
      ref,
      sideOffset,
      className: cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] overflow-hidden rounded-md border border-grayscale-700 bg-grayscale-1000 p-1 text-grayscale-200 shadow-md dark:border-dark-grayscale-400 dark:text-dark-grayscale-200",
        className
      ),
      ...props
    }
  ) })
);
DropdownMenuContent.displayName = Content2$3.displayName;
const DropdownMenuItem = forwardRef(({ className, inset, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Item2$1,
  {
    ref,
    className: cn(
      "relative flex cursor-pointer select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-grayscale-700 focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 dark:focus:bg-dark-grayscale-700",
      inset && "pl-8",
      className
    ),
    ...props
  }
));
DropdownMenuItem.displayName = Item2$1.displayName;
const DropdownMenuCheckboxItem = forwardRef(
  ({ className, children, checked, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
    CheckboxItem2,
    {
      ref,
      className: cn(
        "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-grayscale-700 focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 dark:focus:bg-dark-grayscale-700",
        className
      ),
      checked,
      ...props,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ItemIndicator2, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SvgCheckbox, { className: "h-4 w-4" }) }) }),
        children
      ]
    }
  )
);
DropdownMenuCheckboxItem.displayName = CheckboxItem2.displayName;
const DropdownMenuRadioItem = forwardRef(
  ({ className, children, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
    RadioItem2,
    {
      ref,
      className: cn(
        "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-grayscale-700 focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 dark:focus:bg-dark-grayscale-700",
        className
      ),
      ...props,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ItemIndicator2, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SvgCircle, { className: "h-2 w-2 fill-current stroke-current" }) }) }),
        children
      ]
    }
  )
);
DropdownMenuRadioItem.displayName = RadioItem2.displayName;
const DropdownMenuLabel = forwardRef(({ className, inset, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Label2,
  {
    ref,
    className: cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    ),
    ...props
  }
));
DropdownMenuLabel.displayName = Label2.displayName;
const DropdownMenuSeparator = forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Separator2,
  {
    ref,
    className: cn("-mx-1 my-1 h-px bg-muted", className),
    ...props
  }
));
DropdownMenuSeparator.displayName = Separator2.displayName;
const DropdownMenuShortcut = ({ className, ...props }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "span",
    {
      className: cn("ml-auto text-xs tracking-widest opacity-60", className),
      ...props
    }
  );
};
DropdownMenuShortcut.displayName = "DropdownMenuShortcut";
const Form = FormProvider;
const FormFieldContext = createContext({});
const FormField = ({ ...props }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(FormFieldContext.Provider, { value: { name: props.name }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Controller, { ...props }) });
};
const useFormField = () => {
  const fieldContext = useContext(FormFieldContext);
  const itemContext = useContext(FormItemContext);
  const { getFieldState, formState } = useFormContext();
  const fieldState = getFieldState(fieldContext.name, formState);
  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>");
  }
  const { id: id2 } = itemContext;
  return {
    id: id2,
    name: fieldContext.name,
    formItemId: `${id2}-form-item`,
    formDescriptionId: `${id2}-form-item-description`,
    formMessageId: `${id2}-form-item-message`,
    ...fieldState
  };
};
const FormItemContext = createContext({});
const FormItem = forwardRef(({ className, ...props }, ref) => {
  const id2 = useId$2();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(FormItemContext.Provider, { value: { id: id2 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref, className: cn("space-y-1.5", className), ...props }) });
});
FormItem.displayName = "FormItem";
const FormLabel = forwardRef(({ className, ...props }, ref) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { ref, className, ...props });
});
FormLabel.displayName = "FormLabel";
const FormControl = forwardRef(({ ...props }, ref) => {
  const { error: error2, formItemId, formDescriptionId, formMessageId } = useFormField();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Slot,
    {
      ref,
      id: formItemId,
      "aria-describedby": !error2 ? `${formDescriptionId}` : `${formDescriptionId} ${formMessageId}`,
      "aria-invalid": !!error2,
      ...props
    }
  );
});
FormControl.displayName = "FormControl";
const FormDescription = forwardRef(({ className, ...props }, ref) => {
  const { formDescriptionId } = useFormField();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "p",
    {
      ref,
      id: formDescriptionId,
      className: cn("text-sm text-muted-foreground", className),
      ...props
    }
  );
});
FormDescription.displayName = "FormDescription";
const FormMessage = forwardRef(({ className, children, ...props }, ref) => {
  const { error: error2, formMessageId } = useFormField();
  const { t: t2 } = useTranslation();
  const body = error2 ? String(error2 == null ? void 0 : error2.message) : children;
  if (!body) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "p",
    {
      ref,
      id: formMessageId,
      className: cn("text-xs text-destructive", className),
      ...props,
      children: t2(body)
    }
  );
});
FormMessage.displayName = "FormMessage";
const Input = forwardRef(
  ({ className, type: type2, onChange, clearable = false, ...props }, ref) => {
    const [value2, setValue] = useState(props.value || "");
    const inputRef = useRef();
    useEffect(() => {
      if (ref) {
        if (typeof ref === "function") {
          ref(inputRef.current);
        } else {
          ref.current = inputRef.current;
        }
      }
    }, [ref]);
    const handleClear = () => {
      setValue("");
      if (onChange) onChange({ target: { value: "" } });
    };
    const handleInputChange = (e) => {
      setValue(e.target.value);
      if (onChange) onChange(e);
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative w-full", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          type: type2,
          onChange: handleInputChange,
          className: cn(
            "flex h-14 w-full rounded-md border border-grayscale-600 bg-grayscale-1000 px-4 py-2 text-sm ring-inset ring-offset-background file:h-10 file:border-0 file:bg-transparent file:text-sm file:font-bold file:text-grayscale-100 placeholder:text-grayscale-400 focus:border-primary focus:ring-2 focus-visible:outline-none disabled:cursor-not-allowed disabled:border-grayscale-600 disabled:bg-grayscale-800 disabled:text-grayscale-400  dark:border-dark-grayscale-400 dark:bg-dark-bg-444 dark:text-dark-grayscale-100 dark:file:text-dark-grayscale-100 dark:placeholder:text-dark-grayscale-400",
            clearable && "pr-12",
            className
          ),
          ref: inputRef,
          ...props
        }
      ),
      clearable && value2 && /* @__PURE__ */ jsxRuntimeExports.jsx(
        SvgInputDelete,
        {
          type: "button",
          onClick: handleClear,
          className: "absolute right-0 top-1/2 flex h-6 w-6 -translate-x-1/2 -translate-y-1/2 cursor-pointer items-center"
        }
      )
    ] });
  }
);
Input.displayName = "Input";
var NAME$2 = "Label";
var Label$2 = React.forwardRef((props, forwardedRef) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive.label,
    {
      ...props,
      ref: forwardedRef,
      onMouseDown: (event) => {
        var _a;
        const target2 = event.target;
        if (target2.closest("button, input, select, textarea")) return;
        (_a = props.onMouseDown) == null ? void 0 : _a.call(props, event);
        if (!event.defaultPrevented && event.detail > 1) event.preventDefault();
      }
    }
  );
});
Label$2.displayName = NAME$2;
var Root$4 = Label$2;
const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
);
const Label$1 = forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Root$4,
  {
    ref,
    className: cn(labelVariants(), className),
    ...props
  }
));
Label$1.displayName = Root$4.displayName;
var NAME$1 = "VisuallyHidden";
var VisuallyHidden = React.forwardRef(
  (props, forwardedRef) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.span,
      {
        ...props,
        ref: forwardedRef,
        style: {
          // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss
          position: "absolute",
          border: 0,
          width: 1,
          height: 1,
          padding: 0,
          margin: -1,
          overflow: "hidden",
          clip: "rect(0, 0, 0, 0)",
          whiteSpace: "nowrap",
          wordWrap: "normal",
          ...props.style
        }
      }
    );
  }
);
VisuallyHidden.displayName = NAME$1;
var Root$3 = VisuallyHidden;
var NAVIGATION_MENU_NAME = "NavigationMenu";
var [Collection$2, useCollection$2, createCollectionScope$2] = createCollection(NAVIGATION_MENU_NAME);
var [FocusGroupCollection, useFocusGroupCollection, createFocusGroupCollectionScope] = createCollection(NAVIGATION_MENU_NAME);
var [createNavigationMenuContext, createNavigationMenuScope] = createContextScope(
  NAVIGATION_MENU_NAME,
  [createCollectionScope$2, createFocusGroupCollectionScope]
);
var [NavigationMenuProviderImpl, useNavigationMenuContext] = createNavigationMenuContext(NAVIGATION_MENU_NAME);
var [ViewportContentProvider, useViewportContentContext] = createNavigationMenuContext(NAVIGATION_MENU_NAME);
var NavigationMenu$1 = React.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeNavigationMenu,
      value: valueProp,
      onValueChange,
      defaultValue,
      delayDuration = 200,
      skipDelayDuration = 300,
      orientation = "horizontal",
      dir,
      ...NavigationMenuProps
    } = props;
    const [navigationMenu, setNavigationMenu] = React.useState(null);
    const composedRef = useComposedRefs(forwardedRef, (node) => setNavigationMenu(node));
    const direction = useDirection(dir);
    const openTimerRef = React.useRef(0);
    const closeTimerRef = React.useRef(0);
    const skipDelayTimerRef = React.useRef(0);
    const [isOpenDelayed, setIsOpenDelayed] = React.useState(true);
    const [value2 = "", setValue] = useControllableState({
      prop: valueProp,
      onChange: (value22) => {
        const isOpen = value22 !== "";
        const hasSkipDelayDuration = skipDelayDuration > 0;
        if (isOpen) {
          window.clearTimeout(skipDelayTimerRef.current);
          if (hasSkipDelayDuration) setIsOpenDelayed(false);
        } else {
          window.clearTimeout(skipDelayTimerRef.current);
          skipDelayTimerRef.current = window.setTimeout(
            () => setIsOpenDelayed(true),
            skipDelayDuration
          );
        }
        onValueChange == null ? void 0 : onValueChange(value22);
      },
      defaultProp: defaultValue
    });
    const startCloseTimer = React.useCallback(() => {
      window.clearTimeout(closeTimerRef.current);
      closeTimerRef.current = window.setTimeout(() => setValue(""), 150);
    }, [setValue]);
    const handleOpen = React.useCallback(
      (itemValue) => {
        window.clearTimeout(closeTimerRef.current);
        setValue(itemValue);
      },
      [setValue]
    );
    const handleDelayedOpen = React.useCallback(
      (itemValue) => {
        const isOpenItem = value2 === itemValue;
        if (isOpenItem) {
          window.clearTimeout(closeTimerRef.current);
        } else {
          openTimerRef.current = window.setTimeout(() => {
            window.clearTimeout(closeTimerRef.current);
            setValue(itemValue);
          }, delayDuration);
        }
      },
      [value2, setValue, delayDuration]
    );
    React.useEffect(() => {
      return () => {
        window.clearTimeout(openTimerRef.current);
        window.clearTimeout(closeTimerRef.current);
        window.clearTimeout(skipDelayTimerRef.current);
      };
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      NavigationMenuProvider,
      {
        scope: __scopeNavigationMenu,
        isRootMenu: true,
        value: value2,
        dir: direction,
        orientation,
        rootNavigationMenu: navigationMenu,
        onTriggerEnter: (itemValue) => {
          window.clearTimeout(openTimerRef.current);
          if (isOpenDelayed) handleDelayedOpen(itemValue);
          else handleOpen(itemValue);
        },
        onTriggerLeave: () => {
          window.clearTimeout(openTimerRef.current);
          startCloseTimer();
        },
        onContentEnter: () => window.clearTimeout(closeTimerRef.current),
        onContentLeave: startCloseTimer,
        onItemSelect: (itemValue) => {
          setValue((prevValue) => prevValue === itemValue ? "" : itemValue);
        },
        onItemDismiss: () => setValue(""),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.nav,
          {
            "aria-label": "Main",
            "data-orientation": orientation,
            dir: direction,
            ...NavigationMenuProps,
            ref: composedRef
          }
        )
      }
    );
  }
);
NavigationMenu$1.displayName = NAVIGATION_MENU_NAME;
var SUB_NAME = "NavigationMenuSub";
var NavigationMenuSub = React.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeNavigationMenu,
      value: valueProp,
      onValueChange,
      defaultValue,
      orientation = "horizontal",
      ...subProps
    } = props;
    const context = useNavigationMenuContext(SUB_NAME, __scopeNavigationMenu);
    const [value2 = "", setValue] = useControllableState({
      prop: valueProp,
      onChange: onValueChange,
      defaultProp: defaultValue
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      NavigationMenuProvider,
      {
        scope: __scopeNavigationMenu,
        isRootMenu: false,
        value: value2,
        dir: context.dir,
        orientation,
        rootNavigationMenu: context.rootNavigationMenu,
        onTriggerEnter: (itemValue) => setValue(itemValue),
        onItemSelect: (itemValue) => setValue(itemValue),
        onItemDismiss: () => setValue(""),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { "data-orientation": orientation, ...subProps, ref: forwardedRef })
      }
    );
  }
);
NavigationMenuSub.displayName = SUB_NAME;
var NavigationMenuProvider = (props) => {
  const {
    scope,
    isRootMenu,
    rootNavigationMenu,
    dir,
    orientation,
    children,
    value: value2,
    onItemSelect,
    onItemDismiss,
    onTriggerEnter,
    onTriggerLeave,
    onContentEnter,
    onContentLeave
  } = props;
  const [viewport, setViewport] = React.useState(null);
  const [viewportContent, setViewportContent] = React.useState(/* @__PURE__ */ new Map());
  const [indicatorTrack, setIndicatorTrack] = React.useState(null);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    NavigationMenuProviderImpl,
    {
      scope,
      isRootMenu,
      rootNavigationMenu,
      value: value2,
      previousValue: usePrevious(value2),
      baseId: useId$1(),
      dir,
      orientation,
      viewport,
      onViewportChange: setViewport,
      indicatorTrack,
      onIndicatorTrackChange: setIndicatorTrack,
      onTriggerEnter: useCallbackRef$1(onTriggerEnter),
      onTriggerLeave: useCallbackRef$1(onTriggerLeave),
      onContentEnter: useCallbackRef$1(onContentEnter),
      onContentLeave: useCallbackRef$1(onContentLeave),
      onItemSelect: useCallbackRef$1(onItemSelect),
      onItemDismiss: useCallbackRef$1(onItemDismiss),
      onViewportContentChange: React.useCallback((contentValue, contentData) => {
        setViewportContent((prevContent) => {
          prevContent.set(contentValue, contentData);
          return new Map(prevContent);
        });
      }, []),
      onViewportContentRemove: React.useCallback((contentValue) => {
        setViewportContent((prevContent) => {
          if (!prevContent.has(contentValue)) return prevContent;
          prevContent.delete(contentValue);
          return new Map(prevContent);
        });
      }, []),
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$2.Provider, { scope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ViewportContentProvider, { scope, items: viewportContent, children }) })
    }
  );
};
var LIST_NAME = "NavigationMenuList";
var NavigationMenuList$1 = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeNavigationMenu, ...listProps } = props;
    const context = useNavigationMenuContext(LIST_NAME, __scopeNavigationMenu);
    const list = /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.ul, { "data-orientation": context.orientation, ...listProps, ref: forwardedRef });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { style: { position: "relative" }, ref: context.onIndicatorTrackChange, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$2.Slot, { scope: __scopeNavigationMenu, children: context.isRootMenu ? /* @__PURE__ */ jsxRuntimeExports.jsx(FocusGroup, { asChild: true, children: list }) : list }) });
  }
);
NavigationMenuList$1.displayName = LIST_NAME;
var ITEM_NAME$2 = "NavigationMenuItem";
var [NavigationMenuItemContextProvider, useNavigationMenuItemContext] = createNavigationMenuContext(ITEM_NAME$2);
var NavigationMenuItem$1 = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeNavigationMenu, value: valueProp, ...itemProps } = props;
    const autoValue = useId$1();
    const value2 = valueProp || autoValue || "LEGACY_REACT_AUTO_VALUE";
    const contentRef = React.useRef(null);
    const triggerRef = React.useRef(null);
    const focusProxyRef = React.useRef(null);
    const restoreContentTabOrderRef = React.useRef(() => {
    });
    const wasEscapeCloseRef = React.useRef(false);
    const handleContentEntry = React.useCallback((side = "start") => {
      if (contentRef.current) {
        restoreContentTabOrderRef.current();
        const candidates = getTabbableCandidates$1(contentRef.current);
        if (candidates.length) focusFirst$1(side === "start" ? candidates : candidates.reverse());
      }
    }, []);
    const handleContentExit = React.useCallback(() => {
      if (contentRef.current) {
        const candidates = getTabbableCandidates$1(contentRef.current);
        if (candidates.length) restoreContentTabOrderRef.current = removeFromTabOrder(candidates);
      }
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      NavigationMenuItemContextProvider,
      {
        scope: __scopeNavigationMenu,
        value: value2,
        triggerRef,
        contentRef,
        focusProxyRef,
        wasEscapeCloseRef,
        onEntryKeyDown: handleContentEntry,
        onFocusProxyEnter: handleContentEntry,
        onRootContentClose: handleContentExit,
        onContentFocusOutside: handleContentExit,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.li, { ...itemProps, ref: forwardedRef })
      }
    );
  }
);
NavigationMenuItem$1.displayName = ITEM_NAME$2;
var TRIGGER_NAME$4 = "NavigationMenuTrigger";
var NavigationMenuTrigger$1 = React.forwardRef((props, forwardedRef) => {
  const { __scopeNavigationMenu, disabled, ...triggerProps } = props;
  const context = useNavigationMenuContext(TRIGGER_NAME$4, props.__scopeNavigationMenu);
  const itemContext = useNavigationMenuItemContext(TRIGGER_NAME$4, props.__scopeNavigationMenu);
  const ref = React.useRef(null);
  const composedRefs = useComposedRefs(ref, itemContext.triggerRef, forwardedRef);
  const triggerId = makeTriggerId$1(context.baseId, itemContext.value);
  const contentId = makeContentId$1(context.baseId, itemContext.value);
  const hasPointerMoveOpenedRef = React.useRef(false);
  const wasClickCloseRef = React.useRef(false);
  const open = itemContext.value === context.value;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$2.ItemSlot, { scope: __scopeNavigationMenu, value: itemContext.value, children: /* @__PURE__ */ jsxRuntimeExports.jsx(FocusGroupItem, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        id: triggerId,
        disabled,
        "data-disabled": disabled ? "" : void 0,
        "data-state": getOpenState(open),
        "aria-expanded": open,
        "aria-controls": contentId,
        ...triggerProps,
        ref: composedRefs,
        onPointerEnter: composeEventHandlers(props.onPointerEnter, () => {
          wasClickCloseRef.current = false;
          itemContext.wasEscapeCloseRef.current = false;
        }),
        onPointerMove: composeEventHandlers(
          props.onPointerMove,
          whenMouse(() => {
            if (disabled || wasClickCloseRef.current || itemContext.wasEscapeCloseRef.current || hasPointerMoveOpenedRef.current)
              return;
            context.onTriggerEnter(itemContext.value);
            hasPointerMoveOpenedRef.current = true;
          })
        ),
        onPointerLeave: composeEventHandlers(
          props.onPointerLeave,
          whenMouse(() => {
            if (disabled) return;
            context.onTriggerLeave();
            hasPointerMoveOpenedRef.current = false;
          })
        ),
        onClick: composeEventHandlers(props.onClick, () => {
          context.onItemSelect(itemContext.value);
          wasClickCloseRef.current = open;
        }),
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          const verticalEntryKey = context.dir === "rtl" ? "ArrowLeft" : "ArrowRight";
          const entryKey = { horizontal: "ArrowDown", vertical: verticalEntryKey }[context.orientation];
          if (open && event.key === entryKey) {
            itemContext.onEntryKeyDown();
            event.preventDefault();
          }
        })
      }
    ) }) }),
    open && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Root$3,
        {
          "aria-hidden": true,
          tabIndex: 0,
          ref: itemContext.focusProxyRef,
          onFocus: (event) => {
            const content = itemContext.contentRef.current;
            const prevFocusedElement = event.relatedTarget;
            const wasTriggerFocused = prevFocusedElement === ref.current;
            const wasFocusFromContent = content == null ? void 0 : content.contains(prevFocusedElement);
            if (wasTriggerFocused || !wasFocusFromContent) {
              itemContext.onFocusProxyEnter(wasTriggerFocused ? "start" : "end");
            }
          }
        }
      ),
      context.viewport && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { "aria-owns": contentId })
    ] })
  ] });
});
NavigationMenuTrigger$1.displayName = TRIGGER_NAME$4;
var LINK_NAME = "NavigationMenuLink";
var LINK_SELECT = "navigationMenu.linkSelect";
var NavigationMenuLink$1 = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeNavigationMenu, active: active2, onSelect, ...linkProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(FocusGroupItem, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.a,
      {
        "data-active": active2 ? "" : void 0,
        "aria-current": active2 ? "page" : void 0,
        ...linkProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(
          props.onClick,
          (event) => {
            const target2 = event.target;
            const linkSelectEvent = new CustomEvent(LINK_SELECT, {
              bubbles: true,
              cancelable: true
            });
            target2.addEventListener(LINK_SELECT, (event2) => onSelect == null ? void 0 : onSelect(event2), { once: true });
            dispatchDiscreteCustomEvent(target2, linkSelectEvent);
            if (!linkSelectEvent.defaultPrevented && !event.metaKey) {
              const rootContentDismissEvent = new CustomEvent(ROOT_CONTENT_DISMISS, {
                bubbles: true,
                cancelable: true
              });
              dispatchDiscreteCustomEvent(target2, rootContentDismissEvent);
            }
          },
          { checkForDefaultPrevented: false }
        )
      }
    ) });
  }
);
NavigationMenuLink$1.displayName = LINK_NAME;
var INDICATOR_NAME$1 = "NavigationMenuIndicator";
var NavigationMenuIndicator$1 = React.forwardRef((props, forwardedRef) => {
  const { forceMount, ...indicatorProps } = props;
  const context = useNavigationMenuContext(INDICATOR_NAME$1, props.__scopeNavigationMenu);
  const isVisible = Boolean(context.value);
  return context.indicatorTrack ? ReactDOM__default.createPortal(
    /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || isVisible, children: /* @__PURE__ */ jsxRuntimeExports.jsx(NavigationMenuIndicatorImpl, { ...indicatorProps, ref: forwardedRef }) }),
    context.indicatorTrack
  ) : null;
});
NavigationMenuIndicator$1.displayName = INDICATOR_NAME$1;
var NavigationMenuIndicatorImpl = React.forwardRef((props, forwardedRef) => {
  const { __scopeNavigationMenu, ...indicatorProps } = props;
  const context = useNavigationMenuContext(INDICATOR_NAME$1, __scopeNavigationMenu);
  const getItems = useCollection$2(__scopeNavigationMenu);
  const [activeTrigger, setActiveTrigger] = React.useState(
    null
  );
  const [position2, setPosition] = React.useState(null);
  const isHorizontal = context.orientation === "horizontal";
  const isVisible = Boolean(context.value);
  React.useEffect(() => {
    var _a;
    const items = getItems();
    const triggerNode = (_a = items.find((item) => item.value === context.value)) == null ? void 0 : _a.ref.current;
    if (triggerNode) setActiveTrigger(triggerNode);
  }, [getItems, context.value]);
  const handlePositionChange = () => {
    if (activeTrigger) {
      setPosition({
        size: isHorizontal ? activeTrigger.offsetWidth : activeTrigger.offsetHeight,
        offset: isHorizontal ? activeTrigger.offsetLeft : activeTrigger.offsetTop
      });
    }
  };
  useResizeObserver$1(activeTrigger, handlePositionChange);
  useResizeObserver$1(context.indicatorTrack, handlePositionChange);
  return position2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive.div,
    {
      "aria-hidden": true,
      "data-state": isVisible ? "visible" : "hidden",
      "data-orientation": context.orientation,
      ...indicatorProps,
      ref: forwardedRef,
      style: {
        position: "absolute",
        ...isHorizontal ? {
          left: 0,
          width: position2.size + "px",
          transform: `translateX(${position2.offset}px)`
        } : {
          top: 0,
          height: position2.size + "px",
          transform: `translateY(${position2.offset}px)`
        },
        ...indicatorProps.style
      }
    }
  ) : null;
});
var CONTENT_NAME$4 = "NavigationMenuContent";
var NavigationMenuContent$1 = React.forwardRef((props, forwardedRef) => {
  const { forceMount, ...contentProps } = props;
  const context = useNavigationMenuContext(CONTENT_NAME$4, props.__scopeNavigationMenu);
  const itemContext = useNavigationMenuItemContext(CONTENT_NAME$4, props.__scopeNavigationMenu);
  const composedRefs = useComposedRefs(itemContext.contentRef, forwardedRef);
  const open = itemContext.value === context.value;
  const commonProps = {
    value: itemContext.value,
    triggerRef: itemContext.triggerRef,
    focusProxyRef: itemContext.focusProxyRef,
    wasEscapeCloseRef: itemContext.wasEscapeCloseRef,
    onContentFocusOutside: itemContext.onContentFocusOutside,
    onRootContentClose: itemContext.onRootContentClose,
    ...contentProps
  };
  return !context.viewport ? /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    NavigationMenuContentImpl,
    {
      "data-state": getOpenState(open),
      ...commonProps,
      ref: composedRefs,
      onPointerEnter: composeEventHandlers(props.onPointerEnter, context.onContentEnter),
      onPointerLeave: composeEventHandlers(
        props.onPointerLeave,
        whenMouse(context.onContentLeave)
      ),
      style: {
        // Prevent interaction when animating out
        pointerEvents: !open && context.isRootMenu ? "none" : void 0,
        ...commonProps.style
      }
    }
  ) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(ViewportContentMounter, { forceMount, ...commonProps, ref: composedRefs });
});
NavigationMenuContent$1.displayName = CONTENT_NAME$4;
var ViewportContentMounter = React.forwardRef((props, forwardedRef) => {
  const context = useNavigationMenuContext(CONTENT_NAME$4, props.__scopeNavigationMenu);
  const { onViewportContentChange, onViewportContentRemove } = context;
  useLayoutEffect2(() => {
    onViewportContentChange(props.value, {
      ref: forwardedRef,
      ...props
    });
  }, [props, forwardedRef, onViewportContentChange]);
  useLayoutEffect2(() => {
    return () => onViewportContentRemove(props.value);
  }, [props.value, onViewportContentRemove]);
  return null;
});
var ROOT_CONTENT_DISMISS = "navigationMenu.rootContentDismiss";
var NavigationMenuContentImpl = React.forwardRef((props, forwardedRef) => {
  const {
    __scopeNavigationMenu,
    value: value2,
    triggerRef,
    focusProxyRef,
    wasEscapeCloseRef,
    onRootContentClose,
    onContentFocusOutside,
    ...contentProps
  } = props;
  const context = useNavigationMenuContext(CONTENT_NAME$4, __scopeNavigationMenu);
  const ref = React.useRef(null);
  const composedRefs = useComposedRefs(ref, forwardedRef);
  const triggerId = makeTriggerId$1(context.baseId, value2);
  const contentId = makeContentId$1(context.baseId, value2);
  const getItems = useCollection$2(__scopeNavigationMenu);
  const prevMotionAttributeRef = React.useRef(null);
  const { onItemDismiss } = context;
  React.useEffect(() => {
    const content = ref.current;
    if (context.isRootMenu && content) {
      const handleClose = () => {
        var _a;
        onItemDismiss();
        onRootContentClose();
        if (content.contains(document.activeElement)) (_a = triggerRef.current) == null ? void 0 : _a.focus();
      };
      content.addEventListener(ROOT_CONTENT_DISMISS, handleClose);
      return () => content.removeEventListener(ROOT_CONTENT_DISMISS, handleClose);
    }
  }, [context.isRootMenu, props.value, triggerRef, onItemDismiss, onRootContentClose]);
  const motionAttribute = React.useMemo(() => {
    const items = getItems();
    const values = items.map((item) => item.value);
    if (context.dir === "rtl") values.reverse();
    const index2 = values.indexOf(context.value);
    const prevIndex = values.indexOf(context.previousValue);
    const isSelected = value2 === context.value;
    const wasSelected = prevIndex === values.indexOf(value2);
    if (!isSelected && !wasSelected) return prevMotionAttributeRef.current;
    const attribute = (() => {
      if (index2 !== prevIndex) {
        if (isSelected && prevIndex !== -1) return index2 > prevIndex ? "from-end" : "from-start";
        if (wasSelected && index2 !== -1) return index2 > prevIndex ? "to-start" : "to-end";
      }
      return null;
    })();
    prevMotionAttributeRef.current = attribute;
    return attribute;
  }, [context.previousValue, context.value, context.dir, getItems, value2]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(FocusGroup, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    DismissableLayer,
    {
      id: contentId,
      "aria-labelledby": triggerId,
      "data-motion": motionAttribute,
      "data-orientation": context.orientation,
      ...contentProps,
      ref: composedRefs,
      disableOutsidePointerEvents: false,
      onDismiss: () => {
        var _a;
        const rootContentDismissEvent = new Event(ROOT_CONTENT_DISMISS, {
          bubbles: true,
          cancelable: true
        });
        (_a = ref.current) == null ? void 0 : _a.dispatchEvent(rootContentDismissEvent);
      },
      onFocusOutside: composeEventHandlers(props.onFocusOutside, (event) => {
        var _a;
        onContentFocusOutside();
        const target2 = event.target;
        if ((_a = context.rootNavigationMenu) == null ? void 0 : _a.contains(target2)) event.preventDefault();
      }),
      onPointerDownOutside: composeEventHandlers(props.onPointerDownOutside, (event) => {
        var _a;
        const target2 = event.target;
        const isTrigger = getItems().some((item) => {
          var _a2;
          return (_a2 = item.ref.current) == null ? void 0 : _a2.contains(target2);
        });
        const isRootViewport = context.isRootMenu && ((_a = context.viewport) == null ? void 0 : _a.contains(target2));
        if (isTrigger || isRootViewport || !context.isRootMenu) event.preventDefault();
      }),
      onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
        var _a;
        const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;
        const isTabKey = event.key === "Tab" && !isMetaKey;
        if (isTabKey) {
          const candidates = getTabbableCandidates$1(event.currentTarget);
          const focusedElement = document.activeElement;
          const index2 = candidates.findIndex((candidate) => candidate === focusedElement);
          const isMovingBackwards = event.shiftKey;
          const nextCandidates = isMovingBackwards ? candidates.slice(0, index2).reverse() : candidates.slice(index2 + 1, candidates.length);
          if (focusFirst$1(nextCandidates)) {
            event.preventDefault();
          } else {
            (_a = focusProxyRef.current) == null ? void 0 : _a.focus();
          }
        }
      }),
      onEscapeKeyDown: composeEventHandlers(props.onEscapeKeyDown, (event) => {
        wasEscapeCloseRef.current = true;
      })
    }
  ) });
});
var VIEWPORT_NAME$3 = "NavigationMenuViewport";
var NavigationMenuViewport$1 = React.forwardRef((props, forwardedRef) => {
  const { forceMount, ...viewportProps } = props;
  const context = useNavigationMenuContext(VIEWPORT_NAME$3, props.__scopeNavigationMenu);
  const open = Boolean(context.value);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(NavigationMenuViewportImpl, { ...viewportProps, ref: forwardedRef }) });
});
NavigationMenuViewport$1.displayName = VIEWPORT_NAME$3;
var NavigationMenuViewportImpl = React.forwardRef((props, forwardedRef) => {
  const { __scopeNavigationMenu, children, ...viewportImplProps } = props;
  const context = useNavigationMenuContext(VIEWPORT_NAME$3, __scopeNavigationMenu);
  const composedRefs = useComposedRefs(forwardedRef, context.onViewportChange);
  const viewportContentContext = useViewportContentContext(
    CONTENT_NAME$4,
    props.__scopeNavigationMenu
  );
  const [size2, setSize] = React.useState(null);
  const [content, setContent] = React.useState(null);
  const viewportWidth = size2 ? (size2 == null ? void 0 : size2.width) + "px" : void 0;
  const viewportHeight = size2 ? (size2 == null ? void 0 : size2.height) + "px" : void 0;
  const open = Boolean(context.value);
  const activeContentValue = open ? context.value : context.previousValue;
  const handleSizeChange = () => {
    if (content) setSize({ width: content.offsetWidth, height: content.offsetHeight });
  };
  useResizeObserver$1(content, handleSizeChange);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive.div,
    {
      "data-state": getOpenState(open),
      "data-orientation": context.orientation,
      ...viewportImplProps,
      ref: composedRefs,
      style: {
        // Prevent interaction when animating out
        pointerEvents: !open && context.isRootMenu ? "none" : void 0,
        ["--radix-navigation-menu-viewport-width"]: viewportWidth,
        ["--radix-navigation-menu-viewport-height"]: viewportHeight,
        ...viewportImplProps.style
      },
      onPointerEnter: composeEventHandlers(props.onPointerEnter, context.onContentEnter),
      onPointerLeave: composeEventHandlers(props.onPointerLeave, whenMouse(context.onContentLeave)),
      children: Array.from(viewportContentContext.items).map(([value2, { ref, forceMount, ...props2 }]) => {
        const isActive = activeContentValue === value2;
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || isActive, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          NavigationMenuContentImpl,
          {
            ...props2,
            ref: composeRefs(ref, (node) => {
              if (isActive && node) setContent(node);
            })
          }
        ) }, value2);
      })
    }
  );
});
var FOCUS_GROUP_NAME = "FocusGroup";
var FocusGroup = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeNavigationMenu, ...groupProps } = props;
    const context = useNavigationMenuContext(FOCUS_GROUP_NAME, __scopeNavigationMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(FocusGroupCollection.Provider, { scope: __scopeNavigationMenu, children: /* @__PURE__ */ jsxRuntimeExports.jsx(FocusGroupCollection.Slot, { scope: __scopeNavigationMenu, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { dir: context.dir, ...groupProps, ref: forwardedRef }) }) });
  }
);
var ARROW_KEYS$1 = ["ArrowRight", "ArrowLeft", "ArrowUp", "ArrowDown"];
var FOCUS_GROUP_ITEM_NAME = "FocusGroupItem";
var FocusGroupItem = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeNavigationMenu, ...groupProps } = props;
    const getItems = useFocusGroupCollection(__scopeNavigationMenu);
    const context = useNavigationMenuContext(FOCUS_GROUP_ITEM_NAME, __scopeNavigationMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(FocusGroupCollection.ItemSlot, { scope: __scopeNavigationMenu, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        ...groupProps,
        ref: forwardedRef,
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          const isFocusNavigationKey = ["Home", "End", ...ARROW_KEYS$1].includes(event.key);
          if (isFocusNavigationKey) {
            let candidateNodes = getItems().map((item) => item.ref.current);
            const prevItemKey = context.dir === "rtl" ? "ArrowRight" : "ArrowLeft";
            const prevKeys = [prevItemKey, "ArrowUp", "End"];
            if (prevKeys.includes(event.key)) candidateNodes.reverse();
            if (ARROW_KEYS$1.includes(event.key)) {
              const currentIndex = candidateNodes.indexOf(event.currentTarget);
              candidateNodes = candidateNodes.slice(currentIndex + 1);
            }
            setTimeout(() => focusFirst$1(candidateNodes));
            event.preventDefault();
          }
        })
      }
    ) });
  }
);
function getTabbableCandidates$1(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode()) nodes.push(walker.currentNode);
  return nodes;
}
function focusFirst$1(candidates) {
  const previouslyFocusedElement = document.activeElement;
  return candidates.some((candidate) => {
    if (candidate === previouslyFocusedElement) return true;
    candidate.focus();
    return document.activeElement !== previouslyFocusedElement;
  });
}
function removeFromTabOrder(candidates) {
  candidates.forEach((candidate) => {
    candidate.dataset.tabindex = candidate.getAttribute("tabindex") || "";
    candidate.setAttribute("tabindex", "-1");
  });
  return () => {
    candidates.forEach((candidate) => {
      const prevTabIndex = candidate.dataset.tabindex;
      candidate.setAttribute("tabindex", prevTabIndex);
    });
  };
}
function useResizeObserver$1(element, onResize) {
  const handleResize = useCallbackRef$1(onResize);
  useLayoutEffect2(() => {
    let rAF = 0;
    if (element) {
      const resizeObserver = new ResizeObserver(() => {
        cancelAnimationFrame(rAF);
        rAF = window.requestAnimationFrame(handleResize);
      });
      resizeObserver.observe(element);
      return () => {
        window.cancelAnimationFrame(rAF);
        resizeObserver.unobserve(element);
      };
    }
  }, [element, handleResize]);
}
function getOpenState(open) {
  return open ? "open" : "closed";
}
function makeTriggerId$1(baseId, value2) {
  return `${baseId}-trigger-${value2}`;
}
function makeContentId$1(baseId, value2) {
  return `${baseId}-content-${value2}`;
}
function whenMouse(handler) {
  return (event) => event.pointerType === "mouse" ? handler(event) : void 0;
}
var Root2$5 = NavigationMenu$1;
var List$1 = NavigationMenuList$1;
var Item$1 = NavigationMenuItem$1;
var Trigger$4 = NavigationMenuTrigger$1;
var Link = NavigationMenuLink$1;
var Indicator$1 = NavigationMenuIndicator$1;
var Content$1 = NavigationMenuContent$1;
var Viewport$3 = NavigationMenuViewport$1;
const NavigationMenu = forwardRef(
  ({ className, viewportClassNames, children, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Root2$5,
    {
      ref,
      className: cn(
        "relative z-10 flex max-w-max flex-1 items-center justify-center",
        className
      ),
      ...props,
      children: [
        children,
        /* @__PURE__ */ jsxRuntimeExports.jsx(NavigationMenuViewport, { viewportClassNames })
      ]
    }
  )
);
NavigationMenu.displayName = Root2$5.displayName;
const NavigationMenuList = forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  List$1,
  {
    ref,
    className: cn(
      "group flex flex-1 list-none items-center justify-center space-x-1",
      className
    ),
    ...props
  }
));
NavigationMenuList.displayName = List$1.displayName;
const NavigationMenuItem = Item$1;
const navigationMenuTriggerStyle = cva(
  "group inline-flex h-10 w-max items-center justify-center rounded-md px-4 py-2 text-sm font-medium transition-colors hover:bg-transparent hover:text-accent-foreground focus:bg-transparent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[active]:bg-transparent date-[active]:text-primary data-[state=open]:bg-transparent"
);
const NavigationMenuTrigger = forwardRef(
  ({ className, children, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    Trigger$4,
    {
      ref,
      className: cn(navigationMenuTriggerStyle(), "group", className),
      ...props,
      children
    }
  )
);
NavigationMenuTrigger.displayName = Trigger$4.displayName;
const NavigationMenuContent = forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Content$1,
  {
    ref,
    className: cn(
      "data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 left-0 top-0 w-full sm:absolute sm:w-auto ",
      className
    ),
    ...props
  }
));
NavigationMenuContent.displayName = Content$1.displayName;
const NavigationMenuLink = Link;
const NavigationMenuViewport = forwardRef(
  ({ className, viewportClassNames, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: cn(
        `absolute left-auto right-0 top-full flex justify-center ${viewportClassNames}`
      ),
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Viewport$3,
        {
          className: cn(
            "origin-top-center grayscale-400 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-none border bg-popover text-popover-foreground shadow-lg dark:bg-dark-bg-444 sm:w-[var(--radix-navigation-menu-viewport-width)]",
            className
          ),
          ref,
          ...props
        }
      )
    }
  )
);
NavigationMenuViewport.displayName = Viewport$3.displayName;
const NavigationMenuIndicator = forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Indicator$1,
  {
    ref,
    className: cn(
      "data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in top-full z-[49] flex h-1.5 items-end justify-center overflow-hidden",
      className
    ),
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm bg-border shadow-md" })
  }
));
NavigationMenuIndicator.displayName = Indicator$1.displayName;
var POPOVER_NAME = "Popover";
var [createPopoverContext, createPopoverScope] = createContextScope(POPOVER_NAME, [
  createPopperScope
]);
var usePopperScope$2 = createPopperScope();
var [PopoverProvider, usePopoverContext] = createPopoverContext(POPOVER_NAME);
var Popover$1 = (props) => {
  const {
    __scopePopover,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = false
  } = props;
  const popperScope = usePopperScope$2(__scopePopover);
  const triggerRef = React.useRef(null);
  const [hasCustomAnchor, setHasCustomAnchor] = React.useState(false);
  const [open = false, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root2$7, { ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    PopoverProvider,
    {
      scope: __scopePopover,
      contentId: useId$1(),
      triggerRef,
      open,
      onOpenChange: setOpen,
      onOpenToggle: React.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      hasCustomAnchor,
      onCustomAnchorAdd: React.useCallback(() => setHasCustomAnchor(true), []),
      onCustomAnchorRemove: React.useCallback(() => setHasCustomAnchor(false), []),
      modal,
      children
    }
  ) });
};
Popover$1.displayName = POPOVER_NAME;
var ANCHOR_NAME = "PopoverAnchor";
var PopoverAnchor = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...anchorProps } = props;
    const context = usePopoverContext(ANCHOR_NAME, __scopePopover);
    const popperScope = usePopperScope$2(__scopePopover);
    const { onCustomAnchorAdd, onCustomAnchorRemove } = context;
    React.useEffect(() => {
      onCustomAnchorAdd();
      return () => onCustomAnchorRemove();
    }, [onCustomAnchorAdd, onCustomAnchorRemove]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor, { ...popperScope, ...anchorProps, ref: forwardedRef });
  }
);
PopoverAnchor.displayName = ANCHOR_NAME;
var TRIGGER_NAME$3 = "PopoverTrigger";
var PopoverTrigger$1 = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...triggerProps } = props;
    const context = usePopoverContext(TRIGGER_NAME$3, __scopePopover);
    const popperScope = usePopperScope$2(__scopePopover);
    const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);
    const trigger = /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": context.open,
        "aria-controls": context.contentId,
        "data-state": getState$2(context.open),
        ...triggerProps,
        ref: composedTriggerRef,
        onClick: composeEventHandlers(props.onClick, context.onOpenToggle)
      }
    );
    return context.hasCustomAnchor ? trigger : /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor, { asChild: true, ...popperScope, children: trigger });
  }
);
PopoverTrigger$1.displayName = TRIGGER_NAME$3;
var PORTAL_NAME$2 = "PopoverPortal";
var [PortalProvider$1, usePortalContext$1] = createPopoverContext(PORTAL_NAME$2, {
  forceMount: void 0
});
var PopoverPortal = (props) => {
  const { __scopePopover, forceMount, children, container } = props;
  const context = usePopoverContext(PORTAL_NAME$2, __scopePopover);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PortalProvider$1, { scope: __scopePopover, forceMount, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$4, { asChild: true, container, children }) }) });
};
PopoverPortal.displayName = PORTAL_NAME$2;
var CONTENT_NAME$3 = "PopoverContent";
var PopoverContent$1 = React.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext$1(CONTENT_NAME$3, props.__scopePopover);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context = usePopoverContext(CONTENT_NAME$3, props.__scopePopover);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: context.modal ? /* @__PURE__ */ jsxRuntimeExports.jsx(PopoverContentModal, { ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsxRuntimeExports.jsx(PopoverContentNonModal, { ...contentProps, ref: forwardedRef }) });
  }
);
PopoverContent$1.displayName = CONTENT_NAME$3;
var PopoverContentModal = React.forwardRef(
  (props, forwardedRef) => {
    const context = usePopoverContext(CONTENT_NAME$3, props.__scopePopover);
    const contentRef = React.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef);
    const isRightClickOutsideRef = React.useRef(false);
    React.useEffect(() => {
      const content = contentRef.current;
      if (content) return hideOthers(content);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ReactRemoveScroll, { as: Slot, allowPinchZoom: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      PopoverContentImpl,
      {
        ...props,
        ref: composedRefs,
        trapFocus: context.open,
        disableOutsidePointerEvents: true,
        onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
          var _a;
          event.preventDefault();
          if (!isRightClickOutsideRef.current) (_a = context.triggerRef.current) == null ? void 0 : _a.focus();
        }),
        onPointerDownOutside: composeEventHandlers(
          props.onPointerDownOutside,
          (event) => {
            const originalEvent = event.detail.originalEvent;
            const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
            const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
            isRightClickOutsideRef.current = isRightClick;
          },
          { checkForDefaultPrevented: false }
        ),
        onFocusOutside: composeEventHandlers(
          props.onFocusOutside,
          (event) => event.preventDefault(),
          { checkForDefaultPrevented: false }
        )
      }
    ) });
  }
);
var PopoverContentNonModal = React.forwardRef(
  (props, forwardedRef) => {
    const context = usePopoverContext(CONTENT_NAME$3, props.__scopePopover);
    const hasInteractedOutsideRef = React.useRef(false);
    const hasPointerDownOutsideRef = React.useRef(false);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      PopoverContentImpl,
      {
        ...props,
        ref: forwardedRef,
        trapFocus: false,
        disableOutsidePointerEvents: false,
        onCloseAutoFocus: (event) => {
          var _a, _b;
          (_a = props.onCloseAutoFocus) == null ? void 0 : _a.call(props, event);
          if (!event.defaultPrevented) {
            if (!hasInteractedOutsideRef.current) (_b = context.triggerRef.current) == null ? void 0 : _b.focus();
            event.preventDefault();
          }
          hasInteractedOutsideRef.current = false;
          hasPointerDownOutsideRef.current = false;
        },
        onInteractOutside: (event) => {
          var _a, _b;
          (_a = props.onInteractOutside) == null ? void 0 : _a.call(props, event);
          if (!event.defaultPrevented) {
            hasInteractedOutsideRef.current = true;
            if (event.detail.originalEvent.type === "pointerdown") {
              hasPointerDownOutsideRef.current = true;
            }
          }
          const target2 = event.target;
          const targetIsTrigger = (_b = context.triggerRef.current) == null ? void 0 : _b.contains(target2);
          if (targetIsTrigger) event.preventDefault();
          if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current) {
            event.preventDefault();
          }
        }
      }
    );
  }
);
var PopoverContentImpl = React.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopePopover,
      trapFocus,
      onOpenAutoFocus,
      onCloseAutoFocus,
      disableOutsidePointerEvents,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      ...contentProps
    } = props;
    const context = usePopoverContext(CONTENT_NAME$3, __scopePopover);
    const popperScope = usePopperScope$2(__scopePopover);
    useFocusGuards();
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      FocusScope,
      {
        asChild: true,
        loop: true,
        trapped: trapFocus,
        onMountAutoFocus: onOpenAutoFocus,
        onUnmountAutoFocus: onCloseAutoFocus,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          DismissableLayer,
          {
            asChild: true,
            disableOutsidePointerEvents,
            onInteractOutside,
            onEscapeKeyDown,
            onPointerDownOutside,
            onFocusOutside,
            onDismiss: () => context.onOpenChange(false),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Content$2,
              {
                "data-state": getState$2(context.open),
                role: "dialog",
                id: context.contentId,
                ...popperScope,
                ...contentProps,
                ref: forwardedRef,
                style: {
                  ...contentProps.style,
                  // re-namespace exposed content custom properties
                  ...{
                    "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
                    "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
                    "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
                    "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
                    "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
                  }
                }
              }
            )
          }
        )
      }
    );
  }
);
var CLOSE_NAME$1 = "PopoverClose";
var PopoverClose = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...closeProps } = props;
    const context = usePopoverContext(CLOSE_NAME$1, __scopePopover);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        ...closeProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, () => context.onOpenChange(false))
      }
    );
  }
);
PopoverClose.displayName = CLOSE_NAME$1;
var ARROW_NAME$2 = "PopoverArrow";
var PopoverArrow = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...arrowProps } = props;
    const popperScope = usePopperScope$2(__scopePopover);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow, { ...popperScope, ...arrowProps, ref: forwardedRef });
  }
);
PopoverArrow.displayName = ARROW_NAME$2;
function getState$2(open) {
  return open ? "open" : "closed";
}
var Root2$4 = Popover$1;
var Trigger$3 = PopoverTrigger$1;
var Portal$1 = PopoverPortal;
var Content2$2 = PopoverContent$1;
const Popover = Root2$4;
const PopoverTrigger = Trigger$3;
const PopoverContent = forwardRef(
  ({ className, align: align2 = "center", sideOffset = 4, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Content2$2,
    {
      ref,
      align: align2,
      sideOffset,
      className: cn(
        "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      ),
      ...props
    }
  ) })
);
PopoverContent.displayName = Content2$2.displayName;
var RADIO_NAME = "Radio";
var [createRadioContext, createRadioScope] = createContextScope(RADIO_NAME);
var [RadioProvider, useRadioContext] = createRadioContext(RADIO_NAME);
var Radio = React.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeRadio,
      name: name2,
      checked = false,
      required,
      disabled,
      value: value2 = "on",
      onCheck,
      form,
      ...radioProps
    } = props;
    const [button, setButton] = React.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setButton(node));
    const hasConsumerStoppedPropagationRef = React.useRef(false);
    const isFormControl = button ? form || !!button.closest("form") : true;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(RadioProvider, { scope: __scopeRadio, checked, disabled, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.button,
        {
          type: "button",
          role: "radio",
          "aria-checked": checked,
          "data-state": getState$1(checked),
          "data-disabled": disabled ? "" : void 0,
          disabled,
          value: value2,
          ...radioProps,
          ref: composedRefs,
          onClick: composeEventHandlers(props.onClick, (event) => {
            if (!checked) onCheck == null ? void 0 : onCheck();
            if (isFormControl) {
              hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();
              if (!hasConsumerStoppedPropagationRef.current) event.stopPropagation();
            }
          })
        }
      ),
      isFormControl && /* @__PURE__ */ jsxRuntimeExports.jsx(
        BubbleInput$1,
        {
          control: button,
          bubbles: !hasConsumerStoppedPropagationRef.current,
          name: name2,
          value: value2,
          checked,
          required,
          disabled,
          form,
          style: { transform: "translateX(-100%)" }
        }
      )
    ] });
  }
);
Radio.displayName = RADIO_NAME;
var INDICATOR_NAME = "RadioIndicator";
var RadioIndicator = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeRadio, forceMount, ...indicatorProps } = props;
    const context = useRadioContext(INDICATOR_NAME, __scopeRadio);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.checked, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.span,
      {
        "data-state": getState$1(context.checked),
        "data-disabled": context.disabled ? "" : void 0,
        ...indicatorProps,
        ref: forwardedRef
      }
    ) });
  }
);
RadioIndicator.displayName = INDICATOR_NAME;
var BubbleInput$1 = (props) => {
  const { control, checked, bubbles = true, ...inputProps } = props;
  const ref = React.useRef(null);
  const prevChecked = usePrevious(checked);
  const controlSize = useSize(control);
  React.useEffect(() => {
    const input = ref.current;
    const inputProto = window.HTMLInputElement.prototype;
    const descriptor = Object.getOwnPropertyDescriptor(inputProto, "checked");
    const setChecked = descriptor.set;
    if (prevChecked !== checked && setChecked) {
      const event = new Event("click", { bubbles });
      setChecked.call(input, checked);
      input.dispatchEvent(event);
    }
  }, [prevChecked, checked, bubbles]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "input",
    {
      type: "radio",
      "aria-hidden": true,
      defaultChecked: checked,
      ...inputProps,
      tabIndex: -1,
      ref,
      style: {
        ...props.style,
        ...controlSize,
        position: "absolute",
        pointerEvents: "none",
        opacity: 0,
        margin: 0
      }
    }
  );
};
function getState$1(checked) {
  return checked ? "checked" : "unchecked";
}
var ARROW_KEYS = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"];
var RADIO_GROUP_NAME = "RadioGroup";
var [createRadioGroupContext, createRadioGroupScope] = createContextScope(RADIO_GROUP_NAME, [
  createRovingFocusGroupScope,
  createRadioScope
]);
var useRovingFocusGroupScope$1 = createRovingFocusGroupScope();
var useRadioScope = createRadioScope();
var [RadioGroupProvider, useRadioGroupContext] = createRadioGroupContext(RADIO_GROUP_NAME);
var RadioGroup$1 = React.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeRadioGroup,
      name: name2,
      defaultValue,
      value: valueProp,
      required = false,
      disabled = false,
      orientation,
      dir,
      loop = true,
      onValueChange,
      ...groupProps
    } = props;
    const rovingFocusGroupScope = useRovingFocusGroupScope$1(__scopeRadioGroup);
    const direction = useDirection(dir);
    const [value2, setValue] = useControllableState({
      prop: valueProp,
      defaultProp: defaultValue,
      onChange: onValueChange
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      RadioGroupProvider,
      {
        scope: __scopeRadioGroup,
        name: name2,
        required,
        disabled,
        value: value2,
        onValueChange: setValue,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Root$5,
          {
            asChild: true,
            ...rovingFocusGroupScope,
            orientation,
            dir: direction,
            loop,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Primitive.div,
              {
                role: "radiogroup",
                "aria-required": required,
                "aria-orientation": orientation,
                "data-disabled": disabled ? "" : void 0,
                dir: direction,
                ...groupProps,
                ref: forwardedRef
              }
            )
          }
        )
      }
    );
  }
);
RadioGroup$1.displayName = RADIO_GROUP_NAME;
var ITEM_NAME$1 = "RadioGroupItem";
var RadioGroupItem$1 = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeRadioGroup, disabled, ...itemProps } = props;
    const context = useRadioGroupContext(ITEM_NAME$1, __scopeRadioGroup);
    const isDisabled = context.disabled || disabled;
    const rovingFocusGroupScope = useRovingFocusGroupScope$1(__scopeRadioGroup);
    const radioScope = useRadioScope(__scopeRadioGroup);
    const ref = React.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const checked = context.value === itemProps.value;
    const isArrowKeyPressedRef = React.useRef(false);
    React.useEffect(() => {
      const handleKeyDown = (event) => {
        if (ARROW_KEYS.includes(event.key)) {
          isArrowKeyPressedRef.current = true;
        }
      };
      const handleKeyUp = () => isArrowKeyPressedRef.current = false;
      document.addEventListener("keydown", handleKeyDown);
      document.addEventListener("keyup", handleKeyUp);
      return () => {
        document.removeEventListener("keydown", handleKeyDown);
        document.removeEventListener("keyup", handleKeyUp);
      };
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Item$2,
      {
        asChild: true,
        ...rovingFocusGroupScope,
        focusable: !isDisabled,
        active: checked,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Radio,
          {
            disabled: isDisabled,
            required: context.required,
            checked,
            ...radioScope,
            ...itemProps,
            name: context.name,
            ref: composedRefs,
            onCheck: () => context.onValueChange(itemProps.value),
            onKeyDown: composeEventHandlers((event) => {
              if (event.key === "Enter") event.preventDefault();
            }),
            onFocus: composeEventHandlers(itemProps.onFocus, () => {
              var _a;
              if (isArrowKeyPressedRef.current) (_a = ref.current) == null ? void 0 : _a.click();
            })
          }
        )
      }
    );
  }
);
RadioGroupItem$1.displayName = ITEM_NAME$1;
var INDICATOR_NAME2 = "RadioGroupIndicator";
var RadioGroupIndicator = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeRadioGroup, ...indicatorProps } = props;
    const radioScope = useRadioScope(__scopeRadioGroup);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(RadioIndicator, { ...radioScope, ...indicatorProps, ref: forwardedRef });
  }
);
RadioGroupIndicator.displayName = INDICATOR_NAME2;
var Root2$3 = RadioGroup$1;
var Item2 = RadioGroupItem$1;
var Indicator = RadioGroupIndicator;
const RadioGroup = forwardRef(({ className, ...props }, ref) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Root2$3,
    {
      className: cn("grid gap-2", className),
      ...props,
      ref
    }
  );
});
RadioGroup.displayName = Root2$3.displayName;
const RadioGroupItem = forwardRef(({ className, ...props }, ref) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Item2,
    {
      ref,
      className: cn(
        "flex aspect-square h-4 items-center justify-center rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        className
      ),
      ...props,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Indicator, { className: "flex items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(SvgCircle, { className: "h-2.5 w-2.5 fill-current stroke-current text-current" }) })
    }
  );
});
RadioGroupItem.displayName = Item2.displayName;
function clamp(value2, [min2, max2]) {
  return Math.min(max2, Math.max(min2, value2));
}
function useStateMachine(initialState2, machine) {
  return React.useReducer((state, event) => {
    const nextState = machine[state][event];
    return nextState ?? state;
  }, initialState2);
}
var SCROLL_AREA_NAME = "ScrollArea";
var [createScrollAreaContext, createScrollAreaScope] = createContextScope(SCROLL_AREA_NAME);
var [ScrollAreaProvider, useScrollAreaContext] = createScrollAreaContext(SCROLL_AREA_NAME);
var ScrollArea$1 = React.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeScrollArea,
      type: type2 = "hover",
      dir,
      scrollHideDelay = 600,
      ...scrollAreaProps
    } = props;
    const [scrollArea, setScrollArea] = React.useState(null);
    const [viewport, setViewport] = React.useState(null);
    const [content, setContent] = React.useState(null);
    const [scrollbarX, setScrollbarX] = React.useState(null);
    const [scrollbarY, setScrollbarY] = React.useState(null);
    const [cornerWidth, setCornerWidth] = React.useState(0);
    const [cornerHeight, setCornerHeight] = React.useState(0);
    const [scrollbarXEnabled, setScrollbarXEnabled] = React.useState(false);
    const [scrollbarYEnabled, setScrollbarYEnabled] = React.useState(false);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setScrollArea(node));
    const direction = useDirection(dir);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      ScrollAreaProvider,
      {
        scope: __scopeScrollArea,
        type: type2,
        dir: direction,
        scrollHideDelay,
        scrollArea,
        viewport,
        onViewportChange: setViewport,
        content,
        onContentChange: setContent,
        scrollbarX,
        onScrollbarXChange: setScrollbarX,
        scrollbarXEnabled,
        onScrollbarXEnabledChange: setScrollbarXEnabled,
        scrollbarY,
        onScrollbarYChange: setScrollbarY,
        scrollbarYEnabled,
        onScrollbarYEnabledChange: setScrollbarYEnabled,
        onCornerWidthChange: setCornerWidth,
        onCornerHeightChange: setCornerHeight,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.div,
          {
            dir: direction,
            ...scrollAreaProps,
            ref: composedRefs,
            style: {
              position: "relative",
              // Pass corner sizes as CSS vars to reduce re-renders of context consumers
              ["--radix-scroll-area-corner-width"]: cornerWidth + "px",
              ["--radix-scroll-area-corner-height"]: cornerHeight + "px",
              ...props.style
            }
          }
        )
      }
    );
  }
);
ScrollArea$1.displayName = SCROLL_AREA_NAME;
var VIEWPORT_NAME$2 = "ScrollAreaViewport";
var ScrollAreaViewport = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeScrollArea, children, nonce, ...viewportProps } = props;
    const context = useScrollAreaContext(VIEWPORT_NAME$2, __scopeScrollArea);
    const ref = React.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref, context.onViewportChange);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: `[data-radix-scroll-area-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-scroll-area-viewport]::-webkit-scrollbar{display:none}`
          },
          nonce
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.div,
        {
          "data-radix-scroll-area-viewport": "",
          ...viewportProps,
          ref: composedRefs,
          style: {
            /**
             * We don't support `visible` because the intention is to have at least one scrollbar
             * if this component is used and `visible` will behave like `auto` in that case
             * https://developer.mozilla.org/en-US/docs/Web/CSS/overflow#description
             *
             * We don't handle `auto` because the intention is for the native implementation
             * to be hidden if using this component. We just want to ensure the node is scrollable
             * so could have used either `scroll` or `auto` here. We picked `scroll` to prevent
             * the browser from having to work out whether to render native scrollbars or not,
             * we tell it to with the intention of hiding them in CSS.
             */
            overflowX: context.scrollbarXEnabled ? "scroll" : "hidden",
            overflowY: context.scrollbarYEnabled ? "scroll" : "hidden",
            ...props.style
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref: context.onContentChange, style: { minWidth: "100%", display: "table" }, children })
        }
      )
    ] });
  }
);
ScrollAreaViewport.displayName = VIEWPORT_NAME$2;
var SCROLLBAR_NAME = "ScrollAreaScrollbar";
var ScrollAreaScrollbar = React.forwardRef(
  (props, forwardedRef) => {
    const { forceMount, ...scrollbarProps } = props;
    const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
    const { onScrollbarXEnabledChange, onScrollbarYEnabledChange } = context;
    const isHorizontal = props.orientation === "horizontal";
    React.useEffect(() => {
      isHorizontal ? onScrollbarXEnabledChange(true) : onScrollbarYEnabledChange(true);
      return () => {
        isHorizontal ? onScrollbarXEnabledChange(false) : onScrollbarYEnabledChange(false);
      };
    }, [isHorizontal, onScrollbarXEnabledChange, onScrollbarYEnabledChange]);
    return context.type === "hover" ? /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollAreaScrollbarHover, { ...scrollbarProps, ref: forwardedRef, forceMount }) : context.type === "scroll" ? /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollAreaScrollbarScroll, { ...scrollbarProps, ref: forwardedRef, forceMount }) : context.type === "auto" ? /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollAreaScrollbarAuto, { ...scrollbarProps, ref: forwardedRef, forceMount }) : context.type === "always" ? /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollAreaScrollbarVisible, { ...scrollbarProps, ref: forwardedRef }) : null;
  }
);
ScrollAreaScrollbar.displayName = SCROLLBAR_NAME;
var ScrollAreaScrollbarHover = React.forwardRef((props, forwardedRef) => {
  const { forceMount, ...scrollbarProps } = props;
  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
  const [visible, setVisible] = React.useState(false);
  React.useEffect(() => {
    const scrollArea = context.scrollArea;
    let hideTimer = 0;
    if (scrollArea) {
      const handlePointerEnter = () => {
        window.clearTimeout(hideTimer);
        setVisible(true);
      };
      const handlePointerLeave = () => {
        hideTimer = window.setTimeout(() => setVisible(false), context.scrollHideDelay);
      };
      scrollArea.addEventListener("pointerenter", handlePointerEnter);
      scrollArea.addEventListener("pointerleave", handlePointerLeave);
      return () => {
        window.clearTimeout(hideTimer);
        scrollArea.removeEventListener("pointerenter", handlePointerEnter);
        scrollArea.removeEventListener("pointerleave", handlePointerLeave);
      };
    }
  }, [context.scrollArea, context.scrollHideDelay]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || visible, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    ScrollAreaScrollbarAuto,
    {
      "data-state": visible ? "visible" : "hidden",
      ...scrollbarProps,
      ref: forwardedRef
    }
  ) });
});
var ScrollAreaScrollbarScroll = React.forwardRef((props, forwardedRef) => {
  const { forceMount, ...scrollbarProps } = props;
  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
  const isHorizontal = props.orientation === "horizontal";
  const debounceScrollEnd = useDebounceCallback(() => send("SCROLL_END"), 100);
  const [state, send] = useStateMachine("hidden", {
    hidden: {
      SCROLL: "scrolling"
    },
    scrolling: {
      SCROLL_END: "idle",
      POINTER_ENTER: "interacting"
    },
    interacting: {
      SCROLL: "interacting",
      POINTER_LEAVE: "idle"
    },
    idle: {
      HIDE: "hidden",
      SCROLL: "scrolling",
      POINTER_ENTER: "interacting"
    }
  });
  React.useEffect(() => {
    if (state === "idle") {
      const hideTimer = window.setTimeout(() => send("HIDE"), context.scrollHideDelay);
      return () => window.clearTimeout(hideTimer);
    }
  }, [state, context.scrollHideDelay, send]);
  React.useEffect(() => {
    const viewport = context.viewport;
    const scrollDirection = isHorizontal ? "scrollLeft" : "scrollTop";
    if (viewport) {
      let prevScrollPos = viewport[scrollDirection];
      const handleScroll2 = () => {
        const scrollPos = viewport[scrollDirection];
        const hasScrollInDirectionChanged = prevScrollPos !== scrollPos;
        if (hasScrollInDirectionChanged) {
          send("SCROLL");
          debounceScrollEnd();
        }
        prevScrollPos = scrollPos;
      };
      viewport.addEventListener("scroll", handleScroll2);
      return () => viewport.removeEventListener("scroll", handleScroll2);
    }
  }, [context.viewport, isHorizontal, send, debounceScrollEnd]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || state !== "hidden", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    ScrollAreaScrollbarVisible,
    {
      "data-state": state === "hidden" ? "hidden" : "visible",
      ...scrollbarProps,
      ref: forwardedRef,
      onPointerEnter: composeEventHandlers(props.onPointerEnter, () => send("POINTER_ENTER")),
      onPointerLeave: composeEventHandlers(props.onPointerLeave, () => send("POINTER_LEAVE"))
    }
  ) });
});
var ScrollAreaScrollbarAuto = React.forwardRef((props, forwardedRef) => {
  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
  const { forceMount, ...scrollbarProps } = props;
  const [visible, setVisible] = React.useState(false);
  const isHorizontal = props.orientation === "horizontal";
  const handleResize = useDebounceCallback(() => {
    if (context.viewport) {
      const isOverflowX = context.viewport.offsetWidth < context.viewport.scrollWidth;
      const isOverflowY = context.viewport.offsetHeight < context.viewport.scrollHeight;
      setVisible(isHorizontal ? isOverflowX : isOverflowY);
    }
  }, 10);
  useResizeObserver(context.viewport, handleResize);
  useResizeObserver(context.content, handleResize);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || visible, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    ScrollAreaScrollbarVisible,
    {
      "data-state": visible ? "visible" : "hidden",
      ...scrollbarProps,
      ref: forwardedRef
    }
  ) });
});
var ScrollAreaScrollbarVisible = React.forwardRef((props, forwardedRef) => {
  const { orientation = "vertical", ...scrollbarProps } = props;
  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
  const thumbRef = React.useRef(null);
  const pointerOffsetRef = React.useRef(0);
  const [sizes, setSizes] = React.useState({
    content: 0,
    viewport: 0,
    scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 }
  });
  const thumbRatio = getThumbRatio(sizes.viewport, sizes.content);
  const commonProps = {
    ...scrollbarProps,
    sizes,
    onSizesChange: setSizes,
    hasThumb: Boolean(thumbRatio > 0 && thumbRatio < 1),
    onThumbChange: (thumb) => thumbRef.current = thumb,
    onThumbPointerUp: () => pointerOffsetRef.current = 0,
    onThumbPointerDown: (pointerPos) => pointerOffsetRef.current = pointerPos
  };
  function getScrollPosition(pointerPos, dir) {
    return getScrollPositionFromPointer(pointerPos, pointerOffsetRef.current, sizes, dir);
  }
  if (orientation === "horizontal") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      ScrollAreaScrollbarX,
      {
        ...commonProps,
        ref: forwardedRef,
        onThumbPositionChange: () => {
          if (context.viewport && thumbRef.current) {
            const scrollPos = context.viewport.scrollLeft;
            const offset2 = getThumbOffsetFromScroll(scrollPos, sizes, context.dir);
            thumbRef.current.style.transform = `translate3d(${offset2}px, 0, 0)`;
          }
        },
        onWheelScroll: (scrollPos) => {
          if (context.viewport) context.viewport.scrollLeft = scrollPos;
        },
        onDragScroll: (pointerPos) => {
          if (context.viewport) {
            context.viewport.scrollLeft = getScrollPosition(pointerPos, context.dir);
          }
        }
      }
    );
  }
  if (orientation === "vertical") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      ScrollAreaScrollbarY,
      {
        ...commonProps,
        ref: forwardedRef,
        onThumbPositionChange: () => {
          if (context.viewport && thumbRef.current) {
            const scrollPos = context.viewport.scrollTop;
            const offset2 = getThumbOffsetFromScroll(scrollPos, sizes);
            thumbRef.current.style.transform = `translate3d(0, ${offset2}px, 0)`;
          }
        },
        onWheelScroll: (scrollPos) => {
          if (context.viewport) context.viewport.scrollTop = scrollPos;
        },
        onDragScroll: (pointerPos) => {
          if (context.viewport) context.viewport.scrollTop = getScrollPosition(pointerPos);
        }
      }
    );
  }
  return null;
});
var ScrollAreaScrollbarX = React.forwardRef((props, forwardedRef) => {
  const { sizes, onSizesChange, ...scrollbarProps } = props;
  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
  const [computedStyle, setComputedStyle] = React.useState();
  const ref = React.useRef(null);
  const composeRefs2 = useComposedRefs(forwardedRef, ref, context.onScrollbarXChange);
  React.useEffect(() => {
    if (ref.current) setComputedStyle(getComputedStyle(ref.current));
  }, [ref]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    ScrollAreaScrollbarImpl,
    {
      "data-orientation": "horizontal",
      ...scrollbarProps,
      ref: composeRefs2,
      sizes,
      style: {
        bottom: 0,
        left: context.dir === "rtl" ? "var(--radix-scroll-area-corner-width)" : 0,
        right: context.dir === "ltr" ? "var(--radix-scroll-area-corner-width)" : 0,
        ["--radix-scroll-area-thumb-width"]: getThumbSize(sizes) + "px",
        ...props.style
      },
      onThumbPointerDown: (pointerPos) => props.onThumbPointerDown(pointerPos.x),
      onDragScroll: (pointerPos) => props.onDragScroll(pointerPos.x),
      onWheelScroll: (event, maxScrollPos) => {
        if (context.viewport) {
          const scrollPos = context.viewport.scrollLeft + event.deltaX;
          props.onWheelScroll(scrollPos);
          if (isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos)) {
            event.preventDefault();
          }
        }
      },
      onResize: () => {
        if (ref.current && context.viewport && computedStyle) {
          onSizesChange({
            content: context.viewport.scrollWidth,
            viewport: context.viewport.offsetWidth,
            scrollbar: {
              size: ref.current.clientWidth,
              paddingStart: toInt(computedStyle.paddingLeft),
              paddingEnd: toInt(computedStyle.paddingRight)
            }
          });
        }
      }
    }
  );
});
var ScrollAreaScrollbarY = React.forwardRef((props, forwardedRef) => {
  const { sizes, onSizesChange, ...scrollbarProps } = props;
  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
  const [computedStyle, setComputedStyle] = React.useState();
  const ref = React.useRef(null);
  const composeRefs2 = useComposedRefs(forwardedRef, ref, context.onScrollbarYChange);
  React.useEffect(() => {
    if (ref.current) setComputedStyle(getComputedStyle(ref.current));
  }, [ref]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    ScrollAreaScrollbarImpl,
    {
      "data-orientation": "vertical",
      ...scrollbarProps,
      ref: composeRefs2,
      sizes,
      style: {
        top: 0,
        right: context.dir === "ltr" ? 0 : void 0,
        left: context.dir === "rtl" ? 0 : void 0,
        bottom: "var(--radix-scroll-area-corner-height)",
        ["--radix-scroll-area-thumb-height"]: getThumbSize(sizes) + "px",
        ...props.style
      },
      onThumbPointerDown: (pointerPos) => props.onThumbPointerDown(pointerPos.y),
      onDragScroll: (pointerPos) => props.onDragScroll(pointerPos.y),
      onWheelScroll: (event, maxScrollPos) => {
        if (context.viewport) {
          const scrollPos = context.viewport.scrollTop + event.deltaY;
          props.onWheelScroll(scrollPos);
          if (isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos)) {
            event.preventDefault();
          }
        }
      },
      onResize: () => {
        if (ref.current && context.viewport && computedStyle) {
          onSizesChange({
            content: context.viewport.scrollHeight,
            viewport: context.viewport.offsetHeight,
            scrollbar: {
              size: ref.current.clientHeight,
              paddingStart: toInt(computedStyle.paddingTop),
              paddingEnd: toInt(computedStyle.paddingBottom)
            }
          });
        }
      }
    }
  );
});
var [ScrollbarProvider, useScrollbarContext] = createScrollAreaContext(SCROLLBAR_NAME);
var ScrollAreaScrollbarImpl = React.forwardRef((props, forwardedRef) => {
  const {
    __scopeScrollArea,
    sizes,
    hasThumb,
    onThumbChange,
    onThumbPointerUp,
    onThumbPointerDown,
    onThumbPositionChange,
    onDragScroll,
    onWheelScroll,
    onResize,
    ...scrollbarProps
  } = props;
  const context = useScrollAreaContext(SCROLLBAR_NAME, __scopeScrollArea);
  const [scrollbar, setScrollbar] = React.useState(null);
  const composeRefs2 = useComposedRefs(forwardedRef, (node) => setScrollbar(node));
  const rectRef = React.useRef(null);
  const prevWebkitUserSelectRef = React.useRef("");
  const viewport = context.viewport;
  const maxScrollPos = sizes.content - sizes.viewport;
  const handleWheelScroll = useCallbackRef$1(onWheelScroll);
  const handleThumbPositionChange = useCallbackRef$1(onThumbPositionChange);
  const handleResize = useDebounceCallback(onResize, 10);
  function handleDragScroll(event) {
    if (rectRef.current) {
      const x = event.clientX - rectRef.current.left;
      const y = event.clientY - rectRef.current.top;
      onDragScroll({ x, y });
    }
  }
  React.useEffect(() => {
    const handleWheel = (event) => {
      const element = event.target;
      const isScrollbarWheel = scrollbar == null ? void 0 : scrollbar.contains(element);
      if (isScrollbarWheel) handleWheelScroll(event, maxScrollPos);
    };
    document.addEventListener("wheel", handleWheel, { passive: false });
    return () => document.removeEventListener("wheel", handleWheel, { passive: false });
  }, [viewport, scrollbar, maxScrollPos, handleWheelScroll]);
  React.useEffect(handleThumbPositionChange, [sizes, handleThumbPositionChange]);
  useResizeObserver(scrollbar, handleResize);
  useResizeObserver(context.content, handleResize);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    ScrollbarProvider,
    {
      scope: __scopeScrollArea,
      scrollbar,
      hasThumb,
      onThumbChange: useCallbackRef$1(onThumbChange),
      onThumbPointerUp: useCallbackRef$1(onThumbPointerUp),
      onThumbPositionChange: handleThumbPositionChange,
      onThumbPointerDown: useCallbackRef$1(onThumbPointerDown),
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.div,
        {
          ...scrollbarProps,
          ref: composeRefs2,
          style: { position: "absolute", ...scrollbarProps.style },
          onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
            const mainPointer = 0;
            if (event.button === mainPointer) {
              const element = event.target;
              element.setPointerCapture(event.pointerId);
              rectRef.current = scrollbar.getBoundingClientRect();
              prevWebkitUserSelectRef.current = document.body.style.webkitUserSelect;
              document.body.style.webkitUserSelect = "none";
              if (context.viewport) context.viewport.style.scrollBehavior = "auto";
              handleDragScroll(event);
            }
          }),
          onPointerMove: composeEventHandlers(props.onPointerMove, handleDragScroll),
          onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {
            const element = event.target;
            if (element.hasPointerCapture(event.pointerId)) {
              element.releasePointerCapture(event.pointerId);
            }
            document.body.style.webkitUserSelect = prevWebkitUserSelectRef.current;
            if (context.viewport) context.viewport.style.scrollBehavior = "";
            rectRef.current = null;
          })
        }
      )
    }
  );
});
var THUMB_NAME$1 = "ScrollAreaThumb";
var ScrollAreaThumb = React.forwardRef(
  (props, forwardedRef) => {
    const { forceMount, ...thumbProps } = props;
    const scrollbarContext = useScrollbarContext(THUMB_NAME$1, props.__scopeScrollArea);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || scrollbarContext.hasThumb, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollAreaThumbImpl, { ref: forwardedRef, ...thumbProps }) });
  }
);
var ScrollAreaThumbImpl = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeScrollArea, style, ...thumbProps } = props;
    const scrollAreaContext = useScrollAreaContext(THUMB_NAME$1, __scopeScrollArea);
    const scrollbarContext = useScrollbarContext(THUMB_NAME$1, __scopeScrollArea);
    const { onThumbPositionChange } = scrollbarContext;
    const composedRef = useComposedRefs(
      forwardedRef,
      (node) => scrollbarContext.onThumbChange(node)
    );
    const removeUnlinkedScrollListenerRef = React.useRef(void 0);
    const debounceScrollEnd = useDebounceCallback(() => {
      if (removeUnlinkedScrollListenerRef.current) {
        removeUnlinkedScrollListenerRef.current();
        removeUnlinkedScrollListenerRef.current = void 0;
      }
    }, 100);
    React.useEffect(() => {
      const viewport = scrollAreaContext.viewport;
      if (viewport) {
        const handleScroll2 = () => {
          debounceScrollEnd();
          if (!removeUnlinkedScrollListenerRef.current) {
            const listener = addUnlinkedScrollListener(viewport, onThumbPositionChange);
            removeUnlinkedScrollListenerRef.current = listener;
            onThumbPositionChange();
          }
        };
        onThumbPositionChange();
        viewport.addEventListener("scroll", handleScroll2);
        return () => viewport.removeEventListener("scroll", handleScroll2);
      }
    }, [scrollAreaContext.viewport, debounceScrollEnd, onThumbPositionChange]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.div,
      {
        "data-state": scrollbarContext.hasThumb ? "visible" : "hidden",
        ...thumbProps,
        ref: composedRef,
        style: {
          width: "var(--radix-scroll-area-thumb-width)",
          height: "var(--radix-scroll-area-thumb-height)",
          ...style
        },
        onPointerDownCapture: composeEventHandlers(props.onPointerDownCapture, (event) => {
          const thumb = event.target;
          const thumbRect = thumb.getBoundingClientRect();
          const x = event.clientX - thumbRect.left;
          const y = event.clientY - thumbRect.top;
          scrollbarContext.onThumbPointerDown({ x, y });
        }),
        onPointerUp: composeEventHandlers(props.onPointerUp, scrollbarContext.onThumbPointerUp)
      }
    );
  }
);
ScrollAreaThumb.displayName = THUMB_NAME$1;
var CORNER_NAME = "ScrollAreaCorner";
var ScrollAreaCorner = React.forwardRef(
  (props, forwardedRef) => {
    const context = useScrollAreaContext(CORNER_NAME, props.__scopeScrollArea);
    const hasBothScrollbarsVisible = Boolean(context.scrollbarX && context.scrollbarY);
    const hasCorner = context.type !== "scroll" && hasBothScrollbarsVisible;
    return hasCorner ? /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollAreaCornerImpl, { ...props, ref: forwardedRef }) : null;
  }
);
ScrollAreaCorner.displayName = CORNER_NAME;
var ScrollAreaCornerImpl = React.forwardRef((props, forwardedRef) => {
  const { __scopeScrollArea, ...cornerProps } = props;
  const context = useScrollAreaContext(CORNER_NAME, __scopeScrollArea);
  const [width, setWidth] = React.useState(0);
  const [height, setHeight] = React.useState(0);
  const hasSize = Boolean(width && height);
  useResizeObserver(context.scrollbarX, () => {
    var _a;
    const height2 = ((_a = context.scrollbarX) == null ? void 0 : _a.offsetHeight) || 0;
    context.onCornerHeightChange(height2);
    setHeight(height2);
  });
  useResizeObserver(context.scrollbarY, () => {
    var _a;
    const width2 = ((_a = context.scrollbarY) == null ? void 0 : _a.offsetWidth) || 0;
    context.onCornerWidthChange(width2);
    setWidth(width2);
  });
  return hasSize ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive.div,
    {
      ...cornerProps,
      ref: forwardedRef,
      style: {
        width,
        height,
        position: "absolute",
        right: context.dir === "ltr" ? 0 : void 0,
        left: context.dir === "rtl" ? 0 : void 0,
        bottom: 0,
        ...props.style
      }
    }
  ) : null;
});
function toInt(value2) {
  return value2 ? parseInt(value2, 10) : 0;
}
function getThumbRatio(viewportSize, contentSize) {
  const ratio = viewportSize / contentSize;
  return isNaN(ratio) ? 0 : ratio;
}
function getThumbSize(sizes) {
  const ratio = getThumbRatio(sizes.viewport, sizes.content);
  const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;
  const thumbSize = (sizes.scrollbar.size - scrollbarPadding) * ratio;
  return Math.max(thumbSize, 18);
}
function getScrollPositionFromPointer(pointerPos, pointerOffset, sizes, dir = "ltr") {
  const thumbSizePx = getThumbSize(sizes);
  const thumbCenter = thumbSizePx / 2;
  const offset2 = pointerOffset || thumbCenter;
  const thumbOffsetFromEnd = thumbSizePx - offset2;
  const minPointerPos = sizes.scrollbar.paddingStart + offset2;
  const maxPointerPos = sizes.scrollbar.size - sizes.scrollbar.paddingEnd - thumbOffsetFromEnd;
  const maxScrollPos = sizes.content - sizes.viewport;
  const scrollRange = dir === "ltr" ? [0, maxScrollPos] : [maxScrollPos * -1, 0];
  const interpolate = linearScale([minPointerPos, maxPointerPos], scrollRange);
  return interpolate(pointerPos);
}
function getThumbOffsetFromScroll(scrollPos, sizes, dir = "ltr") {
  const thumbSizePx = getThumbSize(sizes);
  const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;
  const scrollbar = sizes.scrollbar.size - scrollbarPadding;
  const maxScrollPos = sizes.content - sizes.viewport;
  const maxThumbPos = scrollbar - thumbSizePx;
  const scrollClampRange = dir === "ltr" ? [0, maxScrollPos] : [maxScrollPos * -1, 0];
  const scrollWithoutMomentum = clamp(scrollPos, scrollClampRange);
  const interpolate = linearScale([0, maxScrollPos], [0, maxThumbPos]);
  return interpolate(scrollWithoutMomentum);
}
function linearScale(input, output) {
  return (value2) => {
    if (input[0] === input[1] || output[0] === output[1]) return output[0];
    const ratio = (output[1] - output[0]) / (input[1] - input[0]);
    return output[0] + ratio * (value2 - input[0]);
  };
}
function isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos) {
  return scrollPos > 0 && scrollPos < maxScrollPos;
}
var addUnlinkedScrollListener = (node, handler = () => {
}) => {
  let prevPosition = { left: node.scrollLeft, top: node.scrollTop };
  let rAF = 0;
  (function loop() {
    const position2 = { left: node.scrollLeft, top: node.scrollTop };
    const isHorizontalScroll = prevPosition.left !== position2.left;
    const isVerticalScroll = prevPosition.top !== position2.top;
    if (isHorizontalScroll || isVerticalScroll) handler();
    prevPosition = position2;
    rAF = window.requestAnimationFrame(loop);
  })();
  return () => window.cancelAnimationFrame(rAF);
};
function useDebounceCallback(callback, delay) {
  const handleCallback = useCallbackRef$1(callback);
  const debounceTimerRef = React.useRef(0);
  React.useEffect(() => () => window.clearTimeout(debounceTimerRef.current), []);
  return React.useCallback(() => {
    window.clearTimeout(debounceTimerRef.current);
    debounceTimerRef.current = window.setTimeout(handleCallback, delay);
  }, [handleCallback, delay]);
}
function useResizeObserver(element, onResize) {
  const handleResize = useCallbackRef$1(onResize);
  useLayoutEffect2(() => {
    let rAF = 0;
    if (element) {
      const resizeObserver = new ResizeObserver(() => {
        cancelAnimationFrame(rAF);
        rAF = window.requestAnimationFrame(handleResize);
      });
      resizeObserver.observe(element);
      return () => {
        window.cancelAnimationFrame(rAF);
        resizeObserver.unobserve(element);
      };
    }
  }, [element, handleResize]);
}
var Root$2 = ScrollArea$1;
var Viewport$2 = ScrollAreaViewport;
var Corner = ScrollAreaCorner;
const ScrollArea = forwardRef(
  ({ className, children, scrollBar = true, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Root$2,
    {
      ref,
      className: cn("relative overflow-hidden", className),
      ...props,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Viewport$2,
          {
            className: "!block h-full w-full rounded",
            asChild: true,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-full w-full rounded", children })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollBar, { visible: scrollBar }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Corner, {})
      ]
    }
  )
);
ScrollArea.displayName = Root$2.displayName;
const ScrollBar = forwardRef(
  ({ className, orientation = "vertical", visible, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    ScrollAreaScrollbar,
    {
      ref,
      orientation,
      className: cn(
        "mx-auto flex w-1 touch-none select-none rounded bg-grayscale-700 transition-colors dark:bg-dark-grayscale-700",
        orientation === "vertical" && "h-[95%] ",
        orientation === "horizontal" && "h-1 w-[95%] flex-col border-t border-t-transparent",
        visible ? "visible" : "invisible",
        className
      ),
      ...props,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollAreaThumb, { className: "relative flex-1 rounded-full bg-grayscale-500 dark:bg-dark-grayscale-500 " })
    }
  )
);
ScrollBar.displayName = ScrollAreaScrollbar.displayName;
var OPEN_KEYS = [" ", "Enter", "ArrowUp", "ArrowDown"];
var SELECTION_KEYS = [" ", "Enter"];
var SELECT_NAME = "Select";
var [Collection$1, useCollection$1, createCollectionScope$1] = createCollection(SELECT_NAME);
var [createSelectContext, createSelectScope] = createContextScope(SELECT_NAME, [
  createCollectionScope$1,
  createPopperScope
]);
var usePopperScope$1 = createPopperScope();
var [SelectProvider, useSelectContext] = createSelectContext(SELECT_NAME);
var [SelectNativeOptionsProvider, useSelectNativeOptionsContext] = createSelectContext(SELECT_NAME);
var Select$1 = (props) => {
  const {
    __scopeSelect,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    value: valueProp,
    defaultValue,
    onValueChange,
    dir,
    name: name2,
    autoComplete,
    disabled,
    required,
    form
  } = props;
  const popperScope = usePopperScope$1(__scopeSelect);
  const [trigger, setTrigger] = React.useState(null);
  const [valueNode, setValueNode] = React.useState(null);
  const [valueNodeHasChildren, setValueNodeHasChildren] = React.useState(false);
  const direction = useDirection(dir);
  const [open = false, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  const [value2, setValue] = useControllableState({
    prop: valueProp,
    defaultProp: defaultValue,
    onChange: onValueChange
  });
  const triggerPointerDownPosRef = React.useRef(null);
  const isFormControl = trigger ? form || !!trigger.closest("form") : true;
  const [nativeOptionsSet, setNativeOptionsSet] = React.useState(/* @__PURE__ */ new Set());
  const nativeSelectKey = Array.from(nativeOptionsSet).map((option) => option.props.value).join(";");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root2$7, { ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    SelectProvider,
    {
      required,
      scope: __scopeSelect,
      trigger,
      onTriggerChange: setTrigger,
      valueNode,
      onValueNodeChange: setValueNode,
      valueNodeHasChildren,
      onValueNodeHasChildrenChange: setValueNodeHasChildren,
      contentId: useId$1(),
      value: value2,
      onValueChange: setValue,
      open,
      onOpenChange: setOpen,
      dir: direction,
      triggerPointerDownPosRef,
      disabled,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$1.Provider, { scope: __scopeSelect, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          SelectNativeOptionsProvider,
          {
            scope: props.__scopeSelect,
            onNativeOptionAdd: React.useCallback((option) => {
              setNativeOptionsSet((prev) => new Set(prev).add(option));
            }, []),
            onNativeOptionRemove: React.useCallback((option) => {
              setNativeOptionsSet((prev) => {
                const optionsSet = new Set(prev);
                optionsSet.delete(option);
                return optionsSet;
              });
            }, []),
            children
          }
        ) }),
        isFormControl ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
          BubbleSelect,
          {
            "aria-hidden": true,
            required,
            tabIndex: -1,
            name: name2,
            autoComplete,
            value: value2,
            onChange: (event) => setValue(event.target.value),
            disabled,
            form,
            children: [
              value2 === void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "" }) : null,
              Array.from(nativeOptionsSet)
            ]
          },
          nativeSelectKey
        ) : null
      ]
    }
  ) });
};
Select$1.displayName = SELECT_NAME;
var TRIGGER_NAME$2 = "SelectTrigger";
var SelectTrigger$1 = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, disabled = false, ...triggerProps } = props;
    const popperScope = usePopperScope$1(__scopeSelect);
    const context = useSelectContext(TRIGGER_NAME$2, __scopeSelect);
    const isDisabled = context.disabled || disabled;
    const composedRefs = useComposedRefs(forwardedRef, context.onTriggerChange);
    const getItems = useCollection$1(__scopeSelect);
    const pointerTypeRef = React.useRef("touch");
    const [searchRef, handleTypeaheadSearch, resetTypeahead] = useTypeaheadSearch((search) => {
      const enabledItems = getItems().filter((item) => !item.disabled);
      const currentItem = enabledItems.find((item) => item.value === context.value);
      const nextItem = findNextItem(enabledItems, search, currentItem);
      if (nextItem !== void 0) {
        context.onValueChange(nextItem.value);
      }
    });
    const handleOpen = (pointerEvent) => {
      if (!isDisabled) {
        context.onOpenChange(true);
        resetTypeahead();
      }
      if (pointerEvent) {
        context.triggerPointerDownPosRef.current = {
          x: Math.round(pointerEvent.pageX),
          y: Math.round(pointerEvent.pageY)
        };
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor, { asChild: true, ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        role: "combobox",
        "aria-controls": context.contentId,
        "aria-expanded": context.open,
        "aria-required": context.required,
        "aria-autocomplete": "none",
        dir: context.dir,
        "data-state": context.open ? "open" : "closed",
        disabled: isDisabled,
        "data-disabled": isDisabled ? "" : void 0,
        "data-placeholder": shouldShowPlaceholder(context.value) ? "" : void 0,
        ...triggerProps,
        ref: composedRefs,
        onClick: composeEventHandlers(triggerProps.onClick, (event) => {
          event.currentTarget.focus();
          if (pointerTypeRef.current !== "mouse") {
            handleOpen(event);
          }
        }),
        onPointerDown: composeEventHandlers(triggerProps.onPointerDown, (event) => {
          pointerTypeRef.current = event.pointerType;
          const target2 = event.target;
          if (target2.hasPointerCapture(event.pointerId)) {
            target2.releasePointerCapture(event.pointerId);
          }
          if (event.button === 0 && event.ctrlKey === false && event.pointerType === "mouse") {
            handleOpen(event);
            event.preventDefault();
          }
        }),
        onKeyDown: composeEventHandlers(triggerProps.onKeyDown, (event) => {
          const isTypingAhead = searchRef.current !== "";
          const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
          if (!isModifierKey && event.key.length === 1) handleTypeaheadSearch(event.key);
          if (isTypingAhead && event.key === " ") return;
          if (OPEN_KEYS.includes(event.key)) {
            handleOpen();
            event.preventDefault();
          }
        })
      }
    ) });
  }
);
SelectTrigger$1.displayName = TRIGGER_NAME$2;
var VALUE_NAME = "SelectValue";
var SelectValue$1 = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, className, style, children, placeholder: placeholder2 = "", ...valueProps } = props;
    const context = useSelectContext(VALUE_NAME, __scopeSelect);
    const { onValueNodeHasChildrenChange } = context;
    const hasChildren = children !== void 0;
    const composedRefs = useComposedRefs(forwardedRef, context.onValueNodeChange);
    useLayoutEffect2(() => {
      onValueNodeHasChildrenChange(hasChildren);
    }, [onValueNodeHasChildrenChange, hasChildren]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.span,
      {
        ...valueProps,
        ref: composedRefs,
        style: { pointerEvents: "none" },
        children: shouldShowPlaceholder(context.value) ? /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: placeholder2 }) : children
      }
    );
  }
);
SelectValue$1.displayName = VALUE_NAME;
var ICON_NAME = "SelectIcon";
var SelectIcon = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, children, ...iconProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.span, { "aria-hidden": true, ...iconProps, ref: forwardedRef, children: children || "" });
  }
);
SelectIcon.displayName = ICON_NAME;
var PORTAL_NAME$1 = "SelectPortal";
var SelectPortal = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$4, { asChild: true, ...props });
};
SelectPortal.displayName = PORTAL_NAME$1;
var CONTENT_NAME$2 = "SelectContent";
var SelectContent$1 = React.forwardRef(
  (props, forwardedRef) => {
    const context = useSelectContext(CONTENT_NAME$2, props.__scopeSelect);
    const [fragment2, setFragment] = React.useState();
    useLayoutEffect2(() => {
      setFragment(new DocumentFragment());
    }, []);
    if (!context.open) {
      const frag = fragment2;
      return frag ? ReactDOM.createPortal(
        /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContentProvider, { scope: props.__scopeSelect, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$1.Slot, { scope: props.__scopeSelect, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: props.children }) }) }),
        frag
      ) : null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContentImpl, { ...props, ref: forwardedRef });
  }
);
SelectContent$1.displayName = CONTENT_NAME$2;
var CONTENT_MARGIN = 10;
var [SelectContentProvider, useSelectContentContext] = createSelectContext(CONTENT_NAME$2);
var CONTENT_IMPL_NAME = "SelectContentImpl";
var SelectContentImpl = React.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeSelect,
      position: position2 = "item-aligned",
      onCloseAutoFocus,
      onEscapeKeyDown,
      onPointerDownOutside,
      //
      // PopperContent props
      side,
      sideOffset,
      align: align2,
      alignOffset,
      arrowPadding,
      collisionBoundary,
      collisionPadding,
      sticky,
      hideWhenDetached,
      avoidCollisions,
      //
      ...contentProps
    } = props;
    const context = useSelectContext(CONTENT_NAME$2, __scopeSelect);
    const [content, setContent] = React.useState(null);
    const [viewport, setViewport] = React.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
    const [selectedItem, setSelectedItem] = React.useState(null);
    const [selectedItemText, setSelectedItemText] = React.useState(
      null
    );
    const getItems = useCollection$1(__scopeSelect);
    const [isPositioned, setIsPositioned] = React.useState(false);
    const firstValidItemFoundRef = React.useRef(false);
    React.useEffect(() => {
      if (content) return hideOthers(content);
    }, [content]);
    useFocusGuards();
    const focusFirst2 = React.useCallback(
      (candidates) => {
        const [firstItem, ...restItems] = getItems().map((item) => item.ref.current);
        const [lastItem] = restItems.slice(-1);
        const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
        for (const candidate of candidates) {
          if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
          candidate == null ? void 0 : candidate.scrollIntoView({ block: "nearest" });
          if (candidate === firstItem && viewport) viewport.scrollTop = 0;
          if (candidate === lastItem && viewport) viewport.scrollTop = viewport.scrollHeight;
          candidate == null ? void 0 : candidate.focus();
          if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
        }
      },
      [getItems, viewport]
    );
    const focusSelectedItem = React.useCallback(
      () => focusFirst2([selectedItem, content]),
      [focusFirst2, selectedItem, content]
    );
    React.useEffect(() => {
      if (isPositioned) {
        focusSelectedItem();
      }
    }, [isPositioned, focusSelectedItem]);
    const { onOpenChange, triggerPointerDownPosRef } = context;
    React.useEffect(() => {
      if (content) {
        let pointerMoveDelta = { x: 0, y: 0 };
        const handlePointerMove = (event) => {
          var _a, _b;
          pointerMoveDelta = {
            x: Math.abs(Math.round(event.pageX) - (((_a = triggerPointerDownPosRef.current) == null ? void 0 : _a.x) ?? 0)),
            y: Math.abs(Math.round(event.pageY) - (((_b = triggerPointerDownPosRef.current) == null ? void 0 : _b.y) ?? 0))
          };
        };
        const handlePointerUp = (event) => {
          if (pointerMoveDelta.x <= 10 && pointerMoveDelta.y <= 10) {
            event.preventDefault();
          } else {
            if (!content.contains(event.target)) {
              onOpenChange(false);
            }
          }
          document.removeEventListener("pointermove", handlePointerMove);
          triggerPointerDownPosRef.current = null;
        };
        if (triggerPointerDownPosRef.current !== null) {
          document.addEventListener("pointermove", handlePointerMove);
          document.addEventListener("pointerup", handlePointerUp, { capture: true, once: true });
        }
        return () => {
          document.removeEventListener("pointermove", handlePointerMove);
          document.removeEventListener("pointerup", handlePointerUp, { capture: true });
        };
      }
    }, [content, onOpenChange, triggerPointerDownPosRef]);
    React.useEffect(() => {
      const close2 = () => onOpenChange(false);
      window.addEventListener("blur", close2);
      window.addEventListener("resize", close2);
      return () => {
        window.removeEventListener("blur", close2);
        window.removeEventListener("resize", close2);
      };
    }, [onOpenChange]);
    const [searchRef, handleTypeaheadSearch] = useTypeaheadSearch((search) => {
      const enabledItems = getItems().filter((item) => !item.disabled);
      const currentItem = enabledItems.find((item) => item.ref.current === document.activeElement);
      const nextItem = findNextItem(enabledItems, search, currentItem);
      if (nextItem) {
        setTimeout(() => nextItem.ref.current.focus());
      }
    });
    const itemRefCallback = React.useCallback(
      (node, value2, disabled) => {
        const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;
        const isSelectedItem = context.value !== void 0 && context.value === value2;
        if (isSelectedItem || isFirstValidItem) {
          setSelectedItem(node);
          if (isFirstValidItem) firstValidItemFoundRef.current = true;
        }
      },
      [context.value]
    );
    const handleItemLeave = React.useCallback(() => content == null ? void 0 : content.focus(), [content]);
    const itemTextRefCallback = React.useCallback(
      (node, value2, disabled) => {
        const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;
        const isSelectedItem = context.value !== void 0 && context.value === value2;
        if (isSelectedItem || isFirstValidItem) {
          setSelectedItemText(node);
        }
      },
      [context.value]
    );
    const SelectPosition = position2 === "popper" ? SelectPopperPosition : SelectItemAlignedPosition;
    const popperContentProps = SelectPosition === SelectPopperPosition ? {
      side,
      sideOffset,
      align: align2,
      alignOffset,
      arrowPadding,
      collisionBoundary,
      collisionPadding,
      sticky,
      hideWhenDetached,
      avoidCollisions
    } : {};
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      SelectContentProvider,
      {
        scope: __scopeSelect,
        content,
        viewport,
        onViewportChange: setViewport,
        itemRefCallback,
        selectedItem,
        onItemLeave: handleItemLeave,
        itemTextRefCallback,
        focusSelectedItem,
        selectedItemText,
        position: position2,
        isPositioned,
        searchRef,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(ReactRemoveScroll, { as: Slot, allowPinchZoom: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          FocusScope,
          {
            asChild: true,
            trapped: context.open,
            onMountAutoFocus: (event) => {
              event.preventDefault();
            },
            onUnmountAutoFocus: composeEventHandlers(onCloseAutoFocus, (event) => {
              var _a;
              (_a = context.trigger) == null ? void 0 : _a.focus({ preventScroll: true });
              event.preventDefault();
            }),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              DismissableLayer,
              {
                asChild: true,
                disableOutsidePointerEvents: true,
                onEscapeKeyDown,
                onPointerDownOutside,
                onFocusOutside: (event) => event.preventDefault(),
                onDismiss: () => context.onOpenChange(false),
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  SelectPosition,
                  {
                    role: "listbox",
                    id: context.contentId,
                    "data-state": context.open ? "open" : "closed",
                    dir: context.dir,
                    onContextMenu: (event) => event.preventDefault(),
                    ...contentProps,
                    ...popperContentProps,
                    onPlaced: () => setIsPositioned(true),
                    ref: composedRefs,
                    style: {
                      // flex layout so we can place the scroll buttons properly
                      display: "flex",
                      flexDirection: "column",
                      // reset the outline by default as the content MAY get focused
                      outline: "none",
                      ...contentProps.style
                    },
                    onKeyDown: composeEventHandlers(contentProps.onKeyDown, (event) => {
                      const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
                      if (event.key === "Tab") event.preventDefault();
                      if (!isModifierKey && event.key.length === 1) handleTypeaheadSearch(event.key);
                      if (["ArrowUp", "ArrowDown", "Home", "End"].includes(event.key)) {
                        const items = getItems().filter((item) => !item.disabled);
                        let candidateNodes = items.map((item) => item.ref.current);
                        if (["ArrowUp", "End"].includes(event.key)) {
                          candidateNodes = candidateNodes.slice().reverse();
                        }
                        if (["ArrowUp", "ArrowDown"].includes(event.key)) {
                          const currentElement = event.target;
                          const currentIndex = candidateNodes.indexOf(currentElement);
                          candidateNodes = candidateNodes.slice(currentIndex + 1);
                        }
                        setTimeout(() => focusFirst2(candidateNodes));
                        event.preventDefault();
                      }
                    })
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
SelectContentImpl.displayName = CONTENT_IMPL_NAME;
var ITEM_ALIGNED_POSITION_NAME = "SelectItemAlignedPosition";
var SelectItemAlignedPosition = React.forwardRef((props, forwardedRef) => {
  const { __scopeSelect, onPlaced, ...popperProps } = props;
  const context = useSelectContext(CONTENT_NAME$2, __scopeSelect);
  const contentContext = useSelectContentContext(CONTENT_NAME$2, __scopeSelect);
  const [contentWrapper, setContentWrapper] = React.useState(null);
  const [content, setContent] = React.useState(null);
  const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
  const getItems = useCollection$1(__scopeSelect);
  const shouldExpandOnScrollRef = React.useRef(false);
  const shouldRepositionRef = React.useRef(true);
  const { viewport, selectedItem, selectedItemText, focusSelectedItem } = contentContext;
  const position2 = React.useCallback(() => {
    if (context.trigger && context.valueNode && contentWrapper && content && viewport && selectedItem && selectedItemText) {
      const triggerRect = context.trigger.getBoundingClientRect();
      const contentRect = content.getBoundingClientRect();
      const valueNodeRect = context.valueNode.getBoundingClientRect();
      const itemTextRect = selectedItemText.getBoundingClientRect();
      if (context.dir !== "rtl") {
        const itemTextOffset = itemTextRect.left - contentRect.left;
        const left2 = valueNodeRect.left - itemTextOffset;
        const leftDelta = triggerRect.left - left2;
        const minContentWidth = triggerRect.width + leftDelta;
        const contentWidth = Math.max(minContentWidth, contentRect.width);
        const rightEdge = window.innerWidth - CONTENT_MARGIN;
        const clampedLeft = clamp(left2, [
          CONTENT_MARGIN,
          // Prevents the content from going off the starting edge of the
          // viewport. It may still go off the ending edge, but this can be
          // controlled by the user since they may want to manage overflow in a
          // specific way.
          // https://github.com/radix-ui/primitives/issues/2049
          Math.max(CONTENT_MARGIN, rightEdge - contentWidth)
        ]);
        contentWrapper.style.minWidth = minContentWidth + "px";
        contentWrapper.style.left = clampedLeft + "px";
      } else {
        const itemTextOffset = contentRect.right - itemTextRect.right;
        const right2 = window.innerWidth - valueNodeRect.right - itemTextOffset;
        const rightDelta = window.innerWidth - triggerRect.right - right2;
        const minContentWidth = triggerRect.width + rightDelta;
        const contentWidth = Math.max(minContentWidth, contentRect.width);
        const leftEdge = window.innerWidth - CONTENT_MARGIN;
        const clampedRight = clamp(right2, [
          CONTENT_MARGIN,
          Math.max(CONTENT_MARGIN, leftEdge - contentWidth)
        ]);
        contentWrapper.style.minWidth = minContentWidth + "px";
        contentWrapper.style.right = clampedRight + "px";
      }
      const items = getItems();
      const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;
      const itemsHeight = viewport.scrollHeight;
      const contentStyles = window.getComputedStyle(content);
      const contentBorderTopWidth = parseInt(contentStyles.borderTopWidth, 10);
      const contentPaddingTop = parseInt(contentStyles.paddingTop, 10);
      const contentBorderBottomWidth = parseInt(contentStyles.borderBottomWidth, 10);
      const contentPaddingBottom = parseInt(contentStyles.paddingBottom, 10);
      const fullContentHeight = contentBorderTopWidth + contentPaddingTop + itemsHeight + contentPaddingBottom + contentBorderBottomWidth;
      const minContentHeight = Math.min(selectedItem.offsetHeight * 5, fullContentHeight);
      const viewportStyles = window.getComputedStyle(viewport);
      const viewportPaddingTop = parseInt(viewportStyles.paddingTop, 10);
      const viewportPaddingBottom = parseInt(viewportStyles.paddingBottom, 10);
      const topEdgeToTriggerMiddle = triggerRect.top + triggerRect.height / 2 - CONTENT_MARGIN;
      const triggerMiddleToBottomEdge = availableHeight - topEdgeToTriggerMiddle;
      const selectedItemHalfHeight = selectedItem.offsetHeight / 2;
      const itemOffsetMiddle = selectedItem.offsetTop + selectedItemHalfHeight;
      const contentTopToItemMiddle = contentBorderTopWidth + contentPaddingTop + itemOffsetMiddle;
      const itemMiddleToContentBottom = fullContentHeight - contentTopToItemMiddle;
      const willAlignWithoutTopOverflow = contentTopToItemMiddle <= topEdgeToTriggerMiddle;
      if (willAlignWithoutTopOverflow) {
        const isLastItem = items.length > 0 && selectedItem === items[items.length - 1].ref.current;
        contentWrapper.style.bottom = "0px";
        const viewportOffsetBottom = content.clientHeight - viewport.offsetTop - viewport.offsetHeight;
        const clampedTriggerMiddleToBottomEdge = Math.max(
          triggerMiddleToBottomEdge,
          selectedItemHalfHeight + // viewport might have padding bottom, include it to avoid a scrollable viewport
          (isLastItem ? viewportPaddingBottom : 0) + viewportOffsetBottom + contentBorderBottomWidth
        );
        const height = contentTopToItemMiddle + clampedTriggerMiddleToBottomEdge;
        contentWrapper.style.height = height + "px";
      } else {
        const isFirstItem = items.length > 0 && selectedItem === items[0].ref.current;
        contentWrapper.style.top = "0px";
        const clampedTopEdgeToTriggerMiddle = Math.max(
          topEdgeToTriggerMiddle,
          contentBorderTopWidth + viewport.offsetTop + // viewport might have padding top, include it to avoid a scrollable viewport
          (isFirstItem ? viewportPaddingTop : 0) + selectedItemHalfHeight
        );
        const height = clampedTopEdgeToTriggerMiddle + itemMiddleToContentBottom;
        contentWrapper.style.height = height + "px";
        viewport.scrollTop = contentTopToItemMiddle - topEdgeToTriggerMiddle + viewport.offsetTop;
      }
      contentWrapper.style.margin = `${CONTENT_MARGIN}px 0`;
      contentWrapper.style.minHeight = minContentHeight + "px";
      contentWrapper.style.maxHeight = availableHeight + "px";
      onPlaced == null ? void 0 : onPlaced();
      requestAnimationFrame(() => shouldExpandOnScrollRef.current = true);
    }
  }, [
    getItems,
    context.trigger,
    context.valueNode,
    contentWrapper,
    content,
    viewport,
    selectedItem,
    selectedItemText,
    context.dir,
    onPlaced
  ]);
  useLayoutEffect2(() => position2(), [position2]);
  const [contentZIndex, setContentZIndex] = React.useState();
  useLayoutEffect2(() => {
    if (content) setContentZIndex(window.getComputedStyle(content).zIndex);
  }, [content]);
  const handleScrollButtonChange = React.useCallback(
    (node) => {
      if (node && shouldRepositionRef.current === true) {
        position2();
        focusSelectedItem == null ? void 0 : focusSelectedItem();
        shouldRepositionRef.current = false;
      }
    },
    [position2, focusSelectedItem]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SelectViewportProvider,
    {
      scope: __scopeSelect,
      contentWrapper,
      shouldExpandOnScrollRef,
      onScrollButtonChange: handleScrollButtonChange,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          ref: setContentWrapper,
          style: {
            display: "flex",
            flexDirection: "column",
            position: "fixed",
            zIndex: contentZIndex
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Primitive.div,
            {
              ...popperProps,
              ref: composedRefs,
              style: {
                // When we get the height of the content, it includes borders. If we were to set
                // the height without having `boxSizing: 'border-box'` it would be too big.
                boxSizing: "border-box",
                // We need to ensure the content doesn't get taller than the wrapper
                maxHeight: "100%",
                ...popperProps.style
              }
            }
          )
        }
      )
    }
  );
});
SelectItemAlignedPosition.displayName = ITEM_ALIGNED_POSITION_NAME;
var POPPER_POSITION_NAME = "SelectPopperPosition";
var SelectPopperPosition = React.forwardRef((props, forwardedRef) => {
  const {
    __scopeSelect,
    align: align2 = "start",
    collisionPadding = CONTENT_MARGIN,
    ...popperProps
  } = props;
  const popperScope = usePopperScope$1(__scopeSelect);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Content$2,
    {
      ...popperScope,
      ...popperProps,
      ref: forwardedRef,
      align: align2,
      collisionPadding,
      style: {
        // Ensure border-box for floating-ui calculations
        boxSizing: "border-box",
        ...popperProps.style,
        // re-namespace exposed content custom properties
        ...{
          "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-select-content-available-width": "var(--radix-popper-available-width)",
          "--radix-select-content-available-height": "var(--radix-popper-available-height)",
          "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    }
  );
});
SelectPopperPosition.displayName = POPPER_POSITION_NAME;
var [SelectViewportProvider, useSelectViewportContext] = createSelectContext(CONTENT_NAME$2, {});
var VIEWPORT_NAME$1 = "SelectViewport";
var SelectViewport = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, nonce, ...viewportProps } = props;
    const contentContext = useSelectContentContext(VIEWPORT_NAME$1, __scopeSelect);
    const viewportContext = useSelectViewportContext(VIEWPORT_NAME$1, __scopeSelect);
    const composedRefs = useComposedRefs(forwardedRef, contentContext.onViewportChange);
    const prevScrollTopRef = React.useRef(0);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: `[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}`
          },
          nonce
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$1.Slot, { scope: __scopeSelect, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.div,
        {
          "data-radix-select-viewport": "",
          role: "presentation",
          ...viewportProps,
          ref: composedRefs,
          style: {
            // we use position: 'relative' here on the `viewport` so that when we call
            // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
            // (independent of the scrollUpButton).
            position: "relative",
            flex: 1,
            // Viewport should only be scrollable in the vertical direction.
            // This won't work in vertical writing modes, so we'll need to
            // revisit this if/when that is supported
            // https://developer.chrome.com/blog/vertical-form-controls
            overflow: "hidden auto",
            ...viewportProps.style
          },
          onScroll: composeEventHandlers(viewportProps.onScroll, (event) => {
            const viewport = event.currentTarget;
            const { contentWrapper, shouldExpandOnScrollRef } = viewportContext;
            if ((shouldExpandOnScrollRef == null ? void 0 : shouldExpandOnScrollRef.current) && contentWrapper) {
              const scrolledBy = Math.abs(prevScrollTopRef.current - viewport.scrollTop);
              if (scrolledBy > 0) {
                const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;
                const cssMinHeight = parseFloat(contentWrapper.style.minHeight);
                const cssHeight = parseFloat(contentWrapper.style.height);
                const prevHeight = Math.max(cssMinHeight, cssHeight);
                if (prevHeight < availableHeight) {
                  const nextHeight = prevHeight + scrolledBy;
                  const clampedNextHeight = Math.min(availableHeight, nextHeight);
                  const heightDiff = nextHeight - clampedNextHeight;
                  contentWrapper.style.height = clampedNextHeight + "px";
                  if (contentWrapper.style.bottom === "0px") {
                    viewport.scrollTop = heightDiff > 0 ? heightDiff : 0;
                    contentWrapper.style.justifyContent = "flex-end";
                  }
                }
              }
            }
            prevScrollTopRef.current = viewport.scrollTop;
          })
        }
      ) })
    ] });
  }
);
SelectViewport.displayName = VIEWPORT_NAME$1;
var GROUP_NAME = "SelectGroup";
var [SelectGroupContextProvider, useSelectGroupContext] = createSelectContext(GROUP_NAME);
var SelectGroup$1 = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...groupProps } = props;
    const groupId = useId$1();
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectGroupContextProvider, { scope: __scopeSelect, id: groupId, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { role: "group", "aria-labelledby": groupId, ...groupProps, ref: forwardedRef }) });
  }
);
SelectGroup$1.displayName = GROUP_NAME;
var LABEL_NAME = "SelectLabel";
var SelectLabel$1 = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...labelProps } = props;
    const groupContext = useSelectGroupContext(LABEL_NAME, __scopeSelect);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { id: groupContext.id, ...labelProps, ref: forwardedRef });
  }
);
SelectLabel$1.displayName = LABEL_NAME;
var ITEM_NAME = "SelectItem";
var [SelectItemContextProvider, useSelectItemContext] = createSelectContext(ITEM_NAME);
var SelectItem$1 = React.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeSelect,
      value: value2,
      disabled = false,
      textValue: textValueProp,
      ...itemProps
    } = props;
    const context = useSelectContext(ITEM_NAME, __scopeSelect);
    const contentContext = useSelectContentContext(ITEM_NAME, __scopeSelect);
    const isSelected = context.value === value2;
    const [textValue, setTextValue] = React.useState(textValueProp ?? "");
    const [isFocused, setIsFocused] = React.useState(false);
    const composedRefs = useComposedRefs(
      forwardedRef,
      (node) => {
        var _a;
        return (_a = contentContext.itemRefCallback) == null ? void 0 : _a.call(contentContext, node, value2, disabled);
      }
    );
    const textId = useId$1();
    const pointerTypeRef = React.useRef("touch");
    const handleSelect = () => {
      if (!disabled) {
        context.onValueChange(value2);
        context.onOpenChange(false);
      }
    };
    if (value2 === "") {
      throw new Error(
        "A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."
      );
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      SelectItemContextProvider,
      {
        scope: __scopeSelect,
        value: value2,
        disabled,
        textId,
        isSelected,
        onItemTextChange: React.useCallback((node) => {
          setTextValue((prevTextValue) => prevTextValue || ((node == null ? void 0 : node.textContent) ?? "").trim());
        }, []),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Collection$1.ItemSlot,
          {
            scope: __scopeSelect,
            value: value2,
            disabled,
            textValue,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Primitive.div,
              {
                role: "option",
                "aria-labelledby": textId,
                "data-highlighted": isFocused ? "" : void 0,
                "aria-selected": isSelected && isFocused,
                "data-state": isSelected ? "checked" : "unchecked",
                "aria-disabled": disabled || void 0,
                "data-disabled": disabled ? "" : void 0,
                tabIndex: disabled ? void 0 : -1,
                ...itemProps,
                ref: composedRefs,
                onFocus: composeEventHandlers(itemProps.onFocus, () => setIsFocused(true)),
                onBlur: composeEventHandlers(itemProps.onBlur, () => setIsFocused(false)),
                onClick: composeEventHandlers(itemProps.onClick, () => {
                  if (pointerTypeRef.current !== "mouse") handleSelect();
                }),
                onPointerUp: composeEventHandlers(itemProps.onPointerUp, () => {
                  if (pointerTypeRef.current === "mouse") handleSelect();
                }),
                onPointerDown: composeEventHandlers(itemProps.onPointerDown, (event) => {
                  pointerTypeRef.current = event.pointerType;
                }),
                onPointerMove: composeEventHandlers(itemProps.onPointerMove, (event) => {
                  var _a;
                  pointerTypeRef.current = event.pointerType;
                  if (disabled) {
                    (_a = contentContext.onItemLeave) == null ? void 0 : _a.call(contentContext);
                  } else if (pointerTypeRef.current === "mouse") {
                    event.currentTarget.focus({ preventScroll: true });
                  }
                }),
                onPointerLeave: composeEventHandlers(itemProps.onPointerLeave, (event) => {
                  var _a;
                  if (event.currentTarget === document.activeElement) {
                    (_a = contentContext.onItemLeave) == null ? void 0 : _a.call(contentContext);
                  }
                }),
                onKeyDown: composeEventHandlers(itemProps.onKeyDown, (event) => {
                  var _a;
                  const isTypingAhead = ((_a = contentContext.searchRef) == null ? void 0 : _a.current) !== "";
                  if (isTypingAhead && event.key === " ") return;
                  if (SELECTION_KEYS.includes(event.key)) handleSelect();
                  if (event.key === " ") event.preventDefault();
                })
              }
            )
          }
        )
      }
    );
  }
);
SelectItem$1.displayName = ITEM_NAME;
var ITEM_TEXT_NAME = "SelectItemText";
var SelectItemText = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, className, style, ...itemTextProps } = props;
    const context = useSelectContext(ITEM_TEXT_NAME, __scopeSelect);
    const contentContext = useSelectContentContext(ITEM_TEXT_NAME, __scopeSelect);
    const itemContext = useSelectItemContext(ITEM_TEXT_NAME, __scopeSelect);
    const nativeOptionsContext = useSelectNativeOptionsContext(ITEM_TEXT_NAME, __scopeSelect);
    const [itemTextNode, setItemTextNode] = React.useState(null);
    const composedRefs = useComposedRefs(
      forwardedRef,
      (node) => setItemTextNode(node),
      itemContext.onItemTextChange,
      (node) => {
        var _a;
        return (_a = contentContext.itemTextRefCallback) == null ? void 0 : _a.call(contentContext, node, itemContext.value, itemContext.disabled);
      }
    );
    const textContent = itemTextNode == null ? void 0 : itemTextNode.textContent;
    const nativeOption = React.useMemo(
      () => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: itemContext.value, disabled: itemContext.disabled, children: textContent }, itemContext.value),
      [itemContext.disabled, itemContext.value, textContent]
    );
    const { onNativeOptionAdd, onNativeOptionRemove } = nativeOptionsContext;
    useLayoutEffect2(() => {
      onNativeOptionAdd(nativeOption);
      return () => onNativeOptionRemove(nativeOption);
    }, [onNativeOptionAdd, onNativeOptionRemove, nativeOption]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.span, { id: itemContext.textId, ...itemTextProps, ref: composedRefs }),
      itemContext.isSelected && context.valueNode && !context.valueNodeHasChildren ? ReactDOM.createPortal(itemTextProps.children, context.valueNode) : null
    ] });
  }
);
SelectItemText.displayName = ITEM_TEXT_NAME;
var ITEM_INDICATOR_NAME = "SelectItemIndicator";
var SelectItemIndicator = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...itemIndicatorProps } = props;
    const itemContext = useSelectItemContext(ITEM_INDICATOR_NAME, __scopeSelect);
    return itemContext.isSelected ? /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.span, { "aria-hidden": true, ...itemIndicatorProps, ref: forwardedRef }) : null;
  }
);
SelectItemIndicator.displayName = ITEM_INDICATOR_NAME;
var SCROLL_UP_BUTTON_NAME = "SelectScrollUpButton";
var SelectScrollUpButton$1 = React.forwardRef((props, forwardedRef) => {
  const contentContext = useSelectContentContext(SCROLL_UP_BUTTON_NAME, props.__scopeSelect);
  const viewportContext = useSelectViewportContext(SCROLL_UP_BUTTON_NAME, props.__scopeSelect);
  const [canScrollUp, setCanScrollUp] = React.useState(false);
  const composedRefs = useComposedRefs(forwardedRef, viewportContext.onScrollButtonChange);
  useLayoutEffect2(() => {
    if (contentContext.viewport && contentContext.isPositioned) {
      let handleScroll2 = function() {
        const canScrollUp2 = viewport.scrollTop > 0;
        setCanScrollUp(canScrollUp2);
      };
      const viewport = contentContext.viewport;
      handleScroll2();
      viewport.addEventListener("scroll", handleScroll2);
      return () => viewport.removeEventListener("scroll", handleScroll2);
    }
  }, [contentContext.viewport, contentContext.isPositioned]);
  return canScrollUp ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    SelectScrollButtonImpl,
    {
      ...props,
      ref: composedRefs,
      onAutoScroll: () => {
        const { viewport, selectedItem } = contentContext;
        if (viewport && selectedItem) {
          viewport.scrollTop = viewport.scrollTop - selectedItem.offsetHeight;
        }
      }
    }
  ) : null;
});
SelectScrollUpButton$1.displayName = SCROLL_UP_BUTTON_NAME;
var SCROLL_DOWN_BUTTON_NAME = "SelectScrollDownButton";
var SelectScrollDownButton$1 = React.forwardRef((props, forwardedRef) => {
  const contentContext = useSelectContentContext(SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect);
  const viewportContext = useSelectViewportContext(SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect);
  const [canScrollDown, setCanScrollDown] = React.useState(false);
  const composedRefs = useComposedRefs(forwardedRef, viewportContext.onScrollButtonChange);
  useLayoutEffect2(() => {
    if (contentContext.viewport && contentContext.isPositioned) {
      let handleScroll2 = function() {
        const maxScroll = viewport.scrollHeight - viewport.clientHeight;
        const canScrollDown2 = Math.ceil(viewport.scrollTop) < maxScroll;
        setCanScrollDown(canScrollDown2);
      };
      const viewport = contentContext.viewport;
      handleScroll2();
      viewport.addEventListener("scroll", handleScroll2);
      return () => viewport.removeEventListener("scroll", handleScroll2);
    }
  }, [contentContext.viewport, contentContext.isPositioned]);
  return canScrollDown ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    SelectScrollButtonImpl,
    {
      ...props,
      ref: composedRefs,
      onAutoScroll: () => {
        const { viewport, selectedItem } = contentContext;
        if (viewport && selectedItem) {
          viewport.scrollTop = viewport.scrollTop + selectedItem.offsetHeight;
        }
      }
    }
  ) : null;
});
SelectScrollDownButton$1.displayName = SCROLL_DOWN_BUTTON_NAME;
var SelectScrollButtonImpl = React.forwardRef((props, forwardedRef) => {
  const { __scopeSelect, onAutoScroll, ...scrollIndicatorProps } = props;
  const contentContext = useSelectContentContext("SelectScrollButton", __scopeSelect);
  const autoScrollTimerRef = React.useRef(null);
  const getItems = useCollection$1(__scopeSelect);
  const clearAutoScrollTimer = React.useCallback(() => {
    if (autoScrollTimerRef.current !== null) {
      window.clearInterval(autoScrollTimerRef.current);
      autoScrollTimerRef.current = null;
    }
  }, []);
  React.useEffect(() => {
    return () => clearAutoScrollTimer();
  }, [clearAutoScrollTimer]);
  useLayoutEffect2(() => {
    var _a;
    const activeItem = getItems().find((item) => item.ref.current === document.activeElement);
    (_a = activeItem == null ? void 0 : activeItem.ref.current) == null ? void 0 : _a.scrollIntoView({ block: "nearest" });
  }, [getItems]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive.div,
    {
      "aria-hidden": true,
      ...scrollIndicatorProps,
      ref: forwardedRef,
      style: { flexShrink: 0, ...scrollIndicatorProps.style },
      onPointerDown: composeEventHandlers(scrollIndicatorProps.onPointerDown, () => {
        if (autoScrollTimerRef.current === null) {
          autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);
        }
      }),
      onPointerMove: composeEventHandlers(scrollIndicatorProps.onPointerMove, () => {
        var _a;
        (_a = contentContext.onItemLeave) == null ? void 0 : _a.call(contentContext);
        if (autoScrollTimerRef.current === null) {
          autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);
        }
      }),
      onPointerLeave: composeEventHandlers(scrollIndicatorProps.onPointerLeave, () => {
        clearAutoScrollTimer();
      })
    }
  );
});
var SEPARATOR_NAME = "SelectSeparator";
var SelectSeparator$1 = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...separatorProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { "aria-hidden": true, ...separatorProps, ref: forwardedRef });
  }
);
SelectSeparator$1.displayName = SEPARATOR_NAME;
var ARROW_NAME$1 = "SelectArrow";
var SelectArrow = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...arrowProps } = props;
    const popperScope = usePopperScope$1(__scopeSelect);
    const context = useSelectContext(ARROW_NAME$1, __scopeSelect);
    const contentContext = useSelectContentContext(ARROW_NAME$1, __scopeSelect);
    return context.open && contentContext.position === "popper" ? /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow, { ...popperScope, ...arrowProps, ref: forwardedRef }) : null;
  }
);
SelectArrow.displayName = ARROW_NAME$1;
function shouldShowPlaceholder(value2) {
  return value2 === "" || value2 === void 0;
}
var BubbleSelect = React.forwardRef(
  (props, forwardedRef) => {
    const { value: value2, ...selectProps } = props;
    const ref = React.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const prevValue = usePrevious(value2);
    React.useEffect(() => {
      const select2 = ref.current;
      const selectProto = window.HTMLSelectElement.prototype;
      const descriptor = Object.getOwnPropertyDescriptor(
        selectProto,
        "value"
      );
      const setValue = descriptor.set;
      if (prevValue !== value2 && setValue) {
        const event = new Event("change", { bubbles: true });
        setValue.call(select2, value2);
        select2.dispatchEvent(event);
      }
    }, [prevValue, value2]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(VisuallyHidden, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx("select", { ...selectProps, ref: composedRefs, defaultValue: value2 }) });
  }
);
BubbleSelect.displayName = "BubbleSelect";
function useTypeaheadSearch(onSearchChange) {
  const handleSearchChange = useCallbackRef$1(onSearchChange);
  const searchRef = React.useRef("");
  const timerRef = React.useRef(0);
  const handleTypeaheadSearch = React.useCallback(
    (key) => {
      const search = searchRef.current + key;
      handleSearchChange(search);
      (function updateSearch(value2) {
        searchRef.current = value2;
        window.clearTimeout(timerRef.current);
        if (value2 !== "") timerRef.current = window.setTimeout(() => updateSearch(""), 1e3);
      })(search);
    },
    [handleSearchChange]
  );
  const resetTypeahead = React.useCallback(() => {
    searchRef.current = "";
    window.clearTimeout(timerRef.current);
  }, []);
  React.useEffect(() => {
    return () => window.clearTimeout(timerRef.current);
  }, []);
  return [searchRef, handleTypeaheadSearch, resetTypeahead];
}
function findNextItem(items, search, currentItem) {
  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
  const normalizedSearch = isRepeated ? search[0] : search;
  const currentItemIndex = currentItem ? items.indexOf(currentItem) : -1;
  let wrappedItems = wrapArray(items, Math.max(currentItemIndex, 0));
  const excludeCurrentItem = normalizedSearch.length === 1;
  if (excludeCurrentItem) wrappedItems = wrappedItems.filter((v) => v !== currentItem);
  const nextItem = wrappedItems.find(
    (item) => item.textValue.toLowerCase().startsWith(normalizedSearch.toLowerCase())
  );
  return nextItem !== currentItem ? nextItem : void 0;
}
function wrapArray(array, startIndex) {
  return array.map((_, index2) => array[(startIndex + index2) % array.length]);
}
var Root2$2 = Select$1;
var Trigger$2 = SelectTrigger$1;
var Value = SelectValue$1;
var Icon = SelectIcon;
var Portal = SelectPortal;
var Content2$1 = SelectContent$1;
var Viewport$1 = SelectViewport;
var Group = SelectGroup$1;
var Label = SelectLabel$1;
var Item = SelectItem$1;
var ItemText = SelectItemText;
var ItemIndicator = SelectItemIndicator;
var ScrollUpButton = SelectScrollUpButton$1;
var ScrollDownButton = SelectScrollDownButton$1;
var Separator$2 = SelectSeparator$1;
const Select = Root2$2;
const SelectGroup = Group;
const SelectValue = Value;
const SelectTrigger = forwardRef(
  ({ className, children, check = true, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Trigger$2,
    {
      ref,
      className: cn(
        "flex h-14 w-full items-center justify-between rounded-md border border-grayscale-600 bg-grayscale-1000 px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:border-primary focus:outline-primary focus:ring-offset-2 disabled:cursor-not-allowed disabled:bg-grayscale-800 disabled:opacity-40 dark:border-dark-grayscale-400 dark:bg-dark-bg-444 [&>span]:line-clamp-1",
        className
      ),
      ...props,
      children: [
        children,
        /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { asChild: true, children: check && /* @__PURE__ */ jsxRuntimeExports.jsx(SvgArrowDown, { className: "h-4 w-4" }) })
      ]
    }
  )
);
SelectTrigger.displayName = Trigger$2.displayName;
const SelectScrollUpButton = forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  ScrollUpButton,
  {
    ref,
    className: cn(
      "flex cursor-default items-center justify-center py-1",
      className
    ),
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(SvgArrowUp, { className: "h-4 w-4" })
  }
));
SelectScrollUpButton.displayName = ScrollUpButton.displayName;
const SelectScrollDownButton = forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  ScrollDownButton,
  {
    ref,
    className: cn(
      "flex cursor-default items-center justify-center py-1",
      className
    ),
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(SvgArrowDown, { className: "h-4 w-4" })
  }
));
SelectScrollDownButton.displayName = ScrollDownButton.displayName;
const SelectContent = forwardRef(
  ({ className, children, position: position2 = "popper", ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Content2$1,
    {
      ref,
      className: cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border border-grayscale-600 bg-popover text-popover-foreground shadow-md dark:border-grayscale-400 dark:bg-dark-bg-444",
        position2 === "popper" && "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      ),
      position: position2,
      ...props,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(SelectScrollUpButton, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Viewport$1,
          {
            className: cn(
              "p-1",
              position2 === "popper" && "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
            ),
            children
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(SelectScrollDownButton, {})
      ]
    }
  ) })
);
SelectContent.displayName = Content2$1.displayName;
const SelectLabel = forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Label,
  {
    ref,
    className: cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className),
    ...props
  }
));
SelectLabel.displayName = Label.displayName;
const SelectItem = forwardRef(
  ({ className, children, check = true, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Item,
    {
      ref,
      className: cn(
        "relative flex w-full cursor-default select-none items-center rounded-lg px-2 py-1.5 text-sm outline-none focus:bg-primary-10 focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 dark:focus:bg-dark-primary-15",
        className
      ),
      ...props,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "absolute right-2 flex h-3.5 w-3.5 items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ItemIndicator, { children: check && /* @__PURE__ */ jsxRuntimeExports.jsx(SvgCheckbox, { className: "h-4 w-4" }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ItemText, { children })
      ]
    }
  )
);
SelectItem.displayName = Item.displayName;
const SelectSeparator = forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Separator$2,
  {
    ref,
    className: cn("-mx-1 my-1 h-px bg-muted", className),
    ...props
  }
));
SelectSeparator.displayName = Separator$2.displayName;
var NAME = "Separator";
var DEFAULT_ORIENTATION = "horizontal";
var ORIENTATIONS = ["horizontal", "vertical"];
var Separator$1 = React.forwardRef((props, forwardedRef) => {
  const { decorative, orientation: orientationProp = DEFAULT_ORIENTATION, ...domProps } = props;
  const orientation = isValidOrientation(orientationProp) ? orientationProp : DEFAULT_ORIENTATION;
  const ariaOrientation = orientation === "vertical" ? orientation : void 0;
  const semanticProps = decorative ? { role: "none" } : { "aria-orientation": ariaOrientation, role: "separator" };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive.div,
    {
      "data-orientation": orientation,
      ...semanticProps,
      ...domProps,
      ref: forwardedRef
    }
  );
});
Separator$1.displayName = NAME;
function isValidOrientation(orientation) {
  return ORIENTATIONS.includes(orientation);
}
var Root$1 = Separator$1;
const Separator = forwardRef(
  ({ className, orientation = "horizontal", decorative = true, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    Root$1,
    {
      ref,
      decorative,
      orientation,
      className: cn(
        "shrink-0 bg-grayscale-700 dark:bg-dark-grayscale-400",
        orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        className
      ),
      ...props
    }
  )
);
Separator.displayName = Root$1.displayName;
const StatusContainerVariants = cva(
  "flex items-center justify-center gap-x-1 h-[23px] max-w-fit rounded-[20px] bg-opacity-10 px-2.5 py-1 cursor-pointer",
  {
    variants: {
      variant: {
        cleared: "bg-system-success",
        active: "bg-system-fail",
        acknowledged: "bg-system-warning"
      }
    }
  }
);
const DotIndicatorVariants = cva("h-1.5 w-1.5 rounded-full", {
  variants: {
    variant: {
      cleared: "bg-system-success",
      active: "bg-system-fail",
      acknowledged: "bg-system-warning"
    }
  }
});
const TextLabelVariants = cva("text-xs font-bold whitespace-nowrap", {
  variants: {
    variant: {
      cleared: "text-system-success",
      active: "text-system-fail",
      acknowledged: "text-system-warning"
    }
  }
});
const Status = ({ status: status2, variant, ...props }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: StatusContainerVariants({ variant }), ...props, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: DotIndicatorVariants({ variant }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: TextLabelVariants({ variant }), children: t2(status2) })
  ] });
};
var SWITCH_NAME = "Switch";
var [createSwitchContext, createSwitchScope] = createContextScope(SWITCH_NAME);
var [SwitchProvider, useSwitchContext] = createSwitchContext(SWITCH_NAME);
var Switch$1 = React.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeSwitch,
      name: name2,
      checked: checkedProp,
      defaultChecked,
      required,
      disabled,
      value: value2 = "on",
      onCheckedChange,
      form,
      ...switchProps
    } = props;
    const [button, setButton] = React.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setButton(node));
    const hasConsumerStoppedPropagationRef = React.useRef(false);
    const isFormControl = button ? form || !!button.closest("form") : true;
    const [checked = false, setChecked] = useControllableState({
      prop: checkedProp,
      defaultProp: defaultChecked,
      onChange: onCheckedChange
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(SwitchProvider, { scope: __scopeSwitch, checked, disabled, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.button,
        {
          type: "button",
          role: "switch",
          "aria-checked": checked,
          "aria-required": required,
          "data-state": getState(checked),
          "data-disabled": disabled ? "" : void 0,
          disabled,
          value: value2,
          ...switchProps,
          ref: composedRefs,
          onClick: composeEventHandlers(props.onClick, (event) => {
            setChecked((prevChecked) => !prevChecked);
            if (isFormControl) {
              hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();
              if (!hasConsumerStoppedPropagationRef.current) event.stopPropagation();
            }
          })
        }
      ),
      isFormControl && /* @__PURE__ */ jsxRuntimeExports.jsx(
        BubbleInput,
        {
          control: button,
          bubbles: !hasConsumerStoppedPropagationRef.current,
          name: name2,
          value: value2,
          checked,
          required,
          disabled,
          form,
          style: { transform: "translateX(-100%)" }
        }
      )
    ] });
  }
);
Switch$1.displayName = SWITCH_NAME;
var THUMB_NAME = "SwitchThumb";
var SwitchThumb = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSwitch, ...thumbProps } = props;
    const context = useSwitchContext(THUMB_NAME, __scopeSwitch);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.span,
      {
        "data-state": getState(context.checked),
        "data-disabled": context.disabled ? "" : void 0,
        ...thumbProps,
        ref: forwardedRef
      }
    );
  }
);
SwitchThumb.displayName = THUMB_NAME;
var BubbleInput = (props) => {
  const { control, checked, bubbles = true, ...inputProps } = props;
  const ref = React.useRef(null);
  const prevChecked = usePrevious(checked);
  const controlSize = useSize(control);
  React.useEffect(() => {
    const input = ref.current;
    const inputProto = window.HTMLInputElement.prototype;
    const descriptor = Object.getOwnPropertyDescriptor(inputProto, "checked");
    const setChecked = descriptor.set;
    if (prevChecked !== checked && setChecked) {
      const event = new Event("click", { bubbles });
      setChecked.call(input, checked);
      input.dispatchEvent(event);
    }
  }, [prevChecked, checked, bubbles]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "input",
    {
      type: "checkbox",
      "aria-hidden": true,
      defaultChecked: checked,
      ...inputProps,
      tabIndex: -1,
      ref,
      style: {
        ...props.style,
        ...controlSize,
        position: "absolute",
        pointerEvents: "none",
        opacity: 0,
        margin: 0
      }
    }
  );
};
function getState(checked) {
  return checked ? "checked" : "unchecked";
}
var Root = Switch$1;
var Thumb = SwitchThumb;
const Switch = forwardRef(({ className, icon: icon2, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Root,
  {
    className: cn(
      "peer inline-flex h-5 w-9 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-grayscale-500 dark:data-[state=checked]:bg-dark-primary dark:data-[state=unchecked]:bg-dark-grayscale-500",
      className
    ),
    ...props,
    ref,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Thumb,
      {
        className: cn(
          "pointer-events-none block h-4 w-4 rounded-full bg-grayscale-1000 shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-4 data-[state=unchecked]:translate-x-0",
          icon2
        )
      }
    )
  }
));
Switch.displayName = Root.displayName;
const Table = forwardRef(
  ({ showWrapper = true, className, ...props }, ref) => showWrapper ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative w-full overflow-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    "table",
    {
      ref,
      className: cn("w-full caption-bottom text-sm", className),
      ...props
    }
  ) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
    "table",
    {
      ref,
      className: cn("w-full caption-bottom text-sm", className),
      ...props
    }
  )
);
Table.displayName = "Table";
const TableHeader = forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { ref, className: cn("[&_tr]:border-b", className), ...props }));
TableHeader.displayName = "TableHeader";
const TableBody = forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "tbody",
  {
    ref,
    ...props
  }
));
TableBody.displayName = "TableBody";
const TableFooter = forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "tfoot",
  {
    ref,
    className: cn(
      "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
      className
    ),
    ...props
  }
));
TableFooter.displayName = "TableFooter";
const TableRow = forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "tr",
  {
    ref,
    className: cn(
      "border-b transition-colors hover:bg-grayscale-900 data-[state=selected]:bg-muted hover:dark:bg-dark-bg-444",
      className
    ),
    ...props
  }
));
TableRow.displayName = "TableRow";
const TableHead = forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "th",
  {
    ref,
    className: cn(
      "h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0",
      className
    ),
    ...props
  }
));
TableHead.displayName = "TableHead";
const TableCell = forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "td",
  {
    ref,
    className: cn("p-4 align-middle [&:has([role=checkbox])]:pr-0", className),
    ...props
  }
));
TableCell.displayName = "TableCell";
const TableCaption = forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "caption",
  {
    ref,
    className: cn("mt-4 text-sm text-muted-foreground", className),
    ...props
  }
));
TableCaption.displayName = "TableCaption";
var TABS_NAME = "Tabs";
var [createTabsContext, createTabsScope] = createContextScope(TABS_NAME, [
  createRovingFocusGroupScope
]);
var useRovingFocusGroupScope = createRovingFocusGroupScope();
var [TabsProvider, useTabsContext] = createTabsContext(TABS_NAME);
var Tabs$2 = React.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeTabs,
      value: valueProp,
      onValueChange,
      defaultValue,
      orientation = "horizontal",
      dir,
      activationMode = "automatic",
      ...tabsProps
    } = props;
    const direction = useDirection(dir);
    const [value2, setValue] = useControllableState({
      prop: valueProp,
      onChange: onValueChange,
      defaultProp: defaultValue
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      TabsProvider,
      {
        scope: __scopeTabs,
        baseId: useId$1(),
        value: value2,
        onValueChange: setValue,
        orientation,
        dir: direction,
        activationMode,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.div,
          {
            dir: direction,
            "data-orientation": orientation,
            ...tabsProps,
            ref: forwardedRef
          }
        )
      }
    );
  }
);
Tabs$2.displayName = TABS_NAME;
var TAB_LIST_NAME = "TabsList";
var TabsList$1 = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTabs, loop = true, ...listProps } = props;
    const context = useTabsContext(TAB_LIST_NAME, __scopeTabs);
    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeTabs);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Root$5,
      {
        asChild: true,
        ...rovingFocusGroupScope,
        orientation: context.orientation,
        dir: context.dir,
        loop,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.div,
          {
            role: "tablist",
            "aria-orientation": context.orientation,
            ...listProps,
            ref: forwardedRef
          }
        )
      }
    );
  }
);
TabsList$1.displayName = TAB_LIST_NAME;
var TRIGGER_NAME$1 = "TabsTrigger";
var TabsTrigger$1 = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTabs, value: value2, disabled = false, ...triggerProps } = props;
    const context = useTabsContext(TRIGGER_NAME$1, __scopeTabs);
    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeTabs);
    const triggerId = makeTriggerId(context.baseId, value2);
    const contentId = makeContentId(context.baseId, value2);
    const isSelected = value2 === context.value;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Item$2,
      {
        asChild: true,
        ...rovingFocusGroupScope,
        focusable: !disabled,
        active: isSelected,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.button,
          {
            type: "button",
            role: "tab",
            "aria-selected": isSelected,
            "aria-controls": contentId,
            "data-state": isSelected ? "active" : "inactive",
            "data-disabled": disabled ? "" : void 0,
            disabled,
            id: triggerId,
            ...triggerProps,
            ref: forwardedRef,
            onMouseDown: composeEventHandlers(props.onMouseDown, (event) => {
              if (!disabled && event.button === 0 && event.ctrlKey === false) {
                context.onValueChange(value2);
              } else {
                event.preventDefault();
              }
            }),
            onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
              if ([" ", "Enter"].includes(event.key)) context.onValueChange(value2);
            }),
            onFocus: composeEventHandlers(props.onFocus, () => {
              const isAutomaticActivation = context.activationMode !== "manual";
              if (!isSelected && !disabled && isAutomaticActivation) {
                context.onValueChange(value2);
              }
            })
          }
        )
      }
    );
  }
);
TabsTrigger$1.displayName = TRIGGER_NAME$1;
var CONTENT_NAME$1 = "TabsContent";
var TabsContent$1 = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTabs, value: value2, forceMount, children, ...contentProps } = props;
    const context = useTabsContext(CONTENT_NAME$1, __scopeTabs);
    const triggerId = makeTriggerId(context.baseId, value2);
    const contentId = makeContentId(context.baseId, value2);
    const isSelected = value2 === context.value;
    const isMountAnimationPreventedRef = React.useRef(isSelected);
    React.useEffect(() => {
      const rAF = requestAnimationFrame(() => isMountAnimationPreventedRef.current = false);
      return () => cancelAnimationFrame(rAF);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || isSelected, children: ({ present }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.div,
      {
        "data-state": isSelected ? "active" : "inactive",
        "data-orientation": context.orientation,
        role: "tabpanel",
        "aria-labelledby": triggerId,
        hidden: !present,
        id: contentId,
        tabIndex: 0,
        ...contentProps,
        ref: forwardedRef,
        style: {
          ...props.style,
          animationDuration: isMountAnimationPreventedRef.current ? "0s" : void 0
        },
        children: present && children
      }
    ) });
  }
);
TabsContent$1.displayName = CONTENT_NAME$1;
function makeTriggerId(baseId, value2) {
  return `${baseId}-trigger-${value2}`;
}
function makeContentId(baseId, value2) {
  return `${baseId}-content-${value2}`;
}
var Root2$1 = Tabs$2;
var List = TabsList$1;
var Trigger$1 = TabsTrigger$1;
var Content = TabsContent$1;
const Tabs$1 = Root2$1;
const TabsList = forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  List,
  {
    ref,
    className: cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className
    ),
    ...props
  }
));
TabsList.displayName = List.displayName;
const TabsTrigger = forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Trigger$1,
  {
    ref,
    className: cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:rounded-none data-[state=active]:border-b-4 data-[state=active]:border-primary data-[state=active]:pb-2 data-[state=active]:font-bold data-[state=active]:text-primary dark:data-[state=active]:border-dark-primary dark:data-[state=active]:text-dark-primary",
      className
    ),
    ...props
  }
));
TabsTrigger.displayName = Trigger$1.displayName;
const TabsContent = forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Content,
  {
    ref,
    className: cn(
      "ring-offset-background focus-visible:outline-none focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    ),
    ...props
  }
));
TabsContent.displayName = Content.displayName;
const Textarea = forwardRef(({ className, ...props }, ref) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "textarea",
    {
      className: cn(
        "flex min-h-[80px] w-full rounded-md border border-grayscale-600 bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50  dark:bg-dark-bg-444 dark:text-dark-grayscale-100 dark:placeholder:text-dark-grayscale-400",
        className
      ),
      ref,
      ...props
    }
  );
});
Textarea.displayName = "Textarea";
var PROVIDER_NAME$1 = "ToastProvider";
var [Collection, useCollection, createCollectionScope] = createCollection("Toast");
var [createToastContext, createToastScope] = createContextScope("Toast", [createCollectionScope]);
var [ToastProviderProvider, useToastProviderContext] = createToastContext(PROVIDER_NAME$1);
var ToastProvider$1 = (props) => {
  const {
    __scopeToast,
    label: label2 = "Notification",
    duration = 5e3,
    swipeDirection = "right",
    swipeThreshold = 50,
    children
  } = props;
  const [viewport, setViewport] = React.useState(null);
  const [toastCount, setToastCount] = React.useState(0);
  const isFocusedToastEscapeKeyDownRef = React.useRef(false);
  const isClosePausedRef = React.useRef(false);
  if (!label2.trim()) {
    console.error(
      `Invalid prop \`label\` supplied to \`${PROVIDER_NAME$1}\`. Expected non-empty \`string\`.`
    );
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.Provider, { scope: __scopeToast, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    ToastProviderProvider,
    {
      scope: __scopeToast,
      label: label2,
      duration,
      swipeDirection,
      swipeThreshold,
      toastCount,
      viewport,
      onViewportChange: setViewport,
      onToastAdd: React.useCallback(() => setToastCount((prevCount) => prevCount + 1), []),
      onToastRemove: React.useCallback(() => setToastCount((prevCount) => prevCount - 1), []),
      isFocusedToastEscapeKeyDownRef,
      isClosePausedRef,
      children
    }
  ) });
};
ToastProvider$1.displayName = PROVIDER_NAME$1;
var VIEWPORT_NAME = "ToastViewport";
var VIEWPORT_DEFAULT_HOTKEY = ["F8"];
var VIEWPORT_PAUSE = "toast.viewportPause";
var VIEWPORT_RESUME = "toast.viewportResume";
var ToastViewport$1 = React.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeToast,
      hotkey = VIEWPORT_DEFAULT_HOTKEY,
      label: label2 = "Notifications ({hotkey})",
      ...viewportProps
    } = props;
    const context = useToastProviderContext(VIEWPORT_NAME, __scopeToast);
    const getItems = useCollection(__scopeToast);
    const wrapperRef = React.useRef(null);
    const headFocusProxyRef = React.useRef(null);
    const tailFocusProxyRef = React.useRef(null);
    const ref = React.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref, context.onViewportChange);
    const hotkeyLabel = hotkey.join("+").replace(/Key/g, "").replace(/Digit/g, "");
    const hasToasts = context.toastCount > 0;
    React.useEffect(() => {
      const handleKeyDown = (event) => {
        var _a;
        const isHotkeyPressed = hotkey.length !== 0 && hotkey.every((key) => event[key] || event.code === key);
        if (isHotkeyPressed) (_a = ref.current) == null ? void 0 : _a.focus();
      };
      document.addEventListener("keydown", handleKeyDown);
      return () => document.removeEventListener("keydown", handleKeyDown);
    }, [hotkey]);
    React.useEffect(() => {
      const wrapper = wrapperRef.current;
      const viewport = ref.current;
      if (hasToasts && wrapper && viewport) {
        const handlePause = () => {
          if (!context.isClosePausedRef.current) {
            const pauseEvent = new CustomEvent(VIEWPORT_PAUSE);
            viewport.dispatchEvent(pauseEvent);
            context.isClosePausedRef.current = true;
          }
        };
        const handleResume = () => {
          if (context.isClosePausedRef.current) {
            const resumeEvent = new CustomEvent(VIEWPORT_RESUME);
            viewport.dispatchEvent(resumeEvent);
            context.isClosePausedRef.current = false;
          }
        };
        const handleFocusOutResume = (event) => {
          const isFocusMovingOutside = !wrapper.contains(event.relatedTarget);
          if (isFocusMovingOutside) handleResume();
        };
        const handlePointerLeaveResume = () => {
          const isFocusInside = wrapper.contains(document.activeElement);
          if (!isFocusInside) handleResume();
        };
        wrapper.addEventListener("focusin", handlePause);
        wrapper.addEventListener("focusout", handleFocusOutResume);
        wrapper.addEventListener("pointermove", handlePause);
        wrapper.addEventListener("pointerleave", handlePointerLeaveResume);
        window.addEventListener("blur", handlePause);
        window.addEventListener("focus", handleResume);
        return () => {
          wrapper.removeEventListener("focusin", handlePause);
          wrapper.removeEventListener("focusout", handleFocusOutResume);
          wrapper.removeEventListener("pointermove", handlePause);
          wrapper.removeEventListener("pointerleave", handlePointerLeaveResume);
          window.removeEventListener("blur", handlePause);
          window.removeEventListener("focus", handleResume);
        };
      }
    }, [hasToasts, context.isClosePausedRef]);
    const getSortedTabbableCandidates = React.useCallback(
      ({ tabbingDirection }) => {
        const toastItems = getItems();
        const tabbableCandidates = toastItems.map((toastItem) => {
          const toastNode = toastItem.ref.current;
          const toastTabbableCandidates = [toastNode, ...getTabbableCandidates(toastNode)];
          return tabbingDirection === "forwards" ? toastTabbableCandidates : toastTabbableCandidates.reverse();
        });
        return (tabbingDirection === "forwards" ? tabbableCandidates.reverse() : tabbableCandidates).flat();
      },
      [getItems]
    );
    React.useEffect(() => {
      const viewport = ref.current;
      if (viewport) {
        const handleKeyDown = (event) => {
          var _a, _b, _c;
          const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;
          const isTabKey = event.key === "Tab" && !isMetaKey;
          if (isTabKey) {
            const focusedElement = document.activeElement;
            const isTabbingBackwards = event.shiftKey;
            const targetIsViewport = event.target === viewport;
            if (targetIsViewport && isTabbingBackwards) {
              (_a = headFocusProxyRef.current) == null ? void 0 : _a.focus();
              return;
            }
            const tabbingDirection = isTabbingBackwards ? "backwards" : "forwards";
            const sortedCandidates = getSortedTabbableCandidates({ tabbingDirection });
            const index2 = sortedCandidates.findIndex((candidate) => candidate === focusedElement);
            if (focusFirst(sortedCandidates.slice(index2 + 1))) {
              event.preventDefault();
            } else {
              isTabbingBackwards ? (_b = headFocusProxyRef.current) == null ? void 0 : _b.focus() : (_c = tailFocusProxyRef.current) == null ? void 0 : _c.focus();
            }
          }
        };
        viewport.addEventListener("keydown", handleKeyDown);
        return () => viewport.removeEventListener("keydown", handleKeyDown);
      }
    }, [getItems, getSortedTabbableCandidates]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Branch,
      {
        ref: wrapperRef,
        role: "region",
        "aria-label": label2.replace("{hotkey}", hotkeyLabel),
        tabIndex: -1,
        style: { pointerEvents: hasToasts ? void 0 : "none" },
        children: [
          hasToasts && /* @__PURE__ */ jsxRuntimeExports.jsx(
            FocusProxy,
            {
              ref: headFocusProxyRef,
              onFocusFromOutsideViewport: () => {
                const tabbableCandidates = getSortedTabbableCandidates({
                  tabbingDirection: "forwards"
                });
                focusFirst(tabbableCandidates);
              }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.Slot, { scope: __scopeToast, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.ol, { tabIndex: -1, ...viewportProps, ref: composedRefs }) }),
          hasToasts && /* @__PURE__ */ jsxRuntimeExports.jsx(
            FocusProxy,
            {
              ref: tailFocusProxyRef,
              onFocusFromOutsideViewport: () => {
                const tabbableCandidates = getSortedTabbableCandidates({
                  tabbingDirection: "backwards"
                });
                focusFirst(tabbableCandidates);
              }
            }
          )
        ]
      }
    );
  }
);
ToastViewport$1.displayName = VIEWPORT_NAME;
var FOCUS_PROXY_NAME = "ToastFocusProxy";
var FocusProxy = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToast, onFocusFromOutsideViewport, ...proxyProps } = props;
    const context = useToastProviderContext(FOCUS_PROXY_NAME, __scopeToast);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      VisuallyHidden,
      {
        "aria-hidden": true,
        tabIndex: 0,
        ...proxyProps,
        ref: forwardedRef,
        style: { position: "fixed" },
        onFocus: (event) => {
          var _a;
          const prevFocusedElement = event.relatedTarget;
          const isFocusFromOutsideViewport = !((_a = context.viewport) == null ? void 0 : _a.contains(prevFocusedElement));
          if (isFocusFromOutsideViewport) onFocusFromOutsideViewport();
        }
      }
    );
  }
);
FocusProxy.displayName = FOCUS_PROXY_NAME;
var TOAST_NAME = "Toast";
var TOAST_SWIPE_START = "toast.swipeStart";
var TOAST_SWIPE_MOVE = "toast.swipeMove";
var TOAST_SWIPE_CANCEL = "toast.swipeCancel";
var TOAST_SWIPE_END = "toast.swipeEnd";
var Toast$1 = React.forwardRef(
  (props, forwardedRef) => {
    const { forceMount, open: openProp, defaultOpen, onOpenChange, ...toastProps } = props;
    const [open = true, setOpen] = useControllableState({
      prop: openProp,
      defaultProp: defaultOpen,
      onChange: onOpenChange
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      ToastImpl,
      {
        open,
        ...toastProps,
        ref: forwardedRef,
        onClose: () => setOpen(false),
        onPause: useCallbackRef$1(props.onPause),
        onResume: useCallbackRef$1(props.onResume),
        onSwipeStart: composeEventHandlers(props.onSwipeStart, (event) => {
          event.currentTarget.setAttribute("data-swipe", "start");
        }),
        onSwipeMove: composeEventHandlers(props.onSwipeMove, (event) => {
          const { x, y } = event.detail.delta;
          event.currentTarget.setAttribute("data-swipe", "move");
          event.currentTarget.style.setProperty("--radix-toast-swipe-move-x", `${x}px`);
          event.currentTarget.style.setProperty("--radix-toast-swipe-move-y", `${y}px`);
        }),
        onSwipeCancel: composeEventHandlers(props.onSwipeCancel, (event) => {
          event.currentTarget.setAttribute("data-swipe", "cancel");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-move-x");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-move-y");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-end-x");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-end-y");
        }),
        onSwipeEnd: composeEventHandlers(props.onSwipeEnd, (event) => {
          const { x, y } = event.detail.delta;
          event.currentTarget.setAttribute("data-swipe", "end");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-move-x");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-move-y");
          event.currentTarget.style.setProperty("--radix-toast-swipe-end-x", `${x}px`);
          event.currentTarget.style.setProperty("--radix-toast-swipe-end-y", `${y}px`);
          setOpen(false);
        })
      }
    ) });
  }
);
Toast$1.displayName = TOAST_NAME;
var [ToastInteractiveProvider, useToastInteractiveContext] = createToastContext(TOAST_NAME, {
  onClose() {
  }
});
var ToastImpl = React.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeToast,
      type: type2 = "foreground",
      duration: durationProp,
      open,
      onClose,
      onEscapeKeyDown,
      onPause,
      onResume,
      onSwipeStart,
      onSwipeMove,
      onSwipeCancel,
      onSwipeEnd,
      ...toastProps
    } = props;
    const context = useToastProviderContext(TOAST_NAME, __scopeToast);
    const [node, setNode] = React.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node2) => setNode(node2));
    const pointerStartRef = React.useRef(null);
    const swipeDeltaRef = React.useRef(null);
    const duration = durationProp || context.duration;
    const closeTimerStartTimeRef = React.useRef(0);
    const closeTimerRemainingTimeRef = React.useRef(duration);
    const closeTimerRef = React.useRef(0);
    const { onToastAdd, onToastRemove } = context;
    const handleClose = useCallbackRef$1(() => {
      var _a;
      const isFocusInToast = node == null ? void 0 : node.contains(document.activeElement);
      if (isFocusInToast) (_a = context.viewport) == null ? void 0 : _a.focus();
      onClose();
    });
    const startTimer = React.useCallback(
      (duration2) => {
        if (!duration2 || duration2 === Infinity) return;
        window.clearTimeout(closeTimerRef.current);
        closeTimerStartTimeRef.current = (/* @__PURE__ */ new Date()).getTime();
        closeTimerRef.current = window.setTimeout(handleClose, duration2);
      },
      [handleClose]
    );
    React.useEffect(() => {
      const viewport = context.viewport;
      if (viewport) {
        const handleResume = () => {
          startTimer(closeTimerRemainingTimeRef.current);
          onResume == null ? void 0 : onResume();
        };
        const handlePause = () => {
          const elapsedTime = (/* @__PURE__ */ new Date()).getTime() - closeTimerStartTimeRef.current;
          closeTimerRemainingTimeRef.current = closeTimerRemainingTimeRef.current - elapsedTime;
          window.clearTimeout(closeTimerRef.current);
          onPause == null ? void 0 : onPause();
        };
        viewport.addEventListener(VIEWPORT_PAUSE, handlePause);
        viewport.addEventListener(VIEWPORT_RESUME, handleResume);
        return () => {
          viewport.removeEventListener(VIEWPORT_PAUSE, handlePause);
          viewport.removeEventListener(VIEWPORT_RESUME, handleResume);
        };
      }
    }, [context.viewport, duration, onPause, onResume, startTimer]);
    React.useEffect(() => {
      if (open && !context.isClosePausedRef.current) startTimer(duration);
    }, [open, duration, context.isClosePausedRef, startTimer]);
    React.useEffect(() => {
      onToastAdd();
      return () => onToastRemove();
    }, [onToastAdd, onToastRemove]);
    const announceTextContent = React.useMemo(() => {
      return node ? getAnnounceTextContent(node) : null;
    }, [node]);
    if (!context.viewport) return null;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      announceTextContent && /* @__PURE__ */ jsxRuntimeExports.jsx(
        ToastAnnounce,
        {
          __scopeToast,
          role: "status",
          "aria-live": type2 === "foreground" ? "assertive" : "polite",
          "aria-atomic": true,
          children: announceTextContent
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ToastInteractiveProvider, { scope: __scopeToast, onClose: handleClose, children: ReactDOM.createPortal(
        /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.ItemSlot, { scope: __scopeToast, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Root$8,
          {
            asChild: true,
            onEscapeKeyDown: composeEventHandlers(onEscapeKeyDown, () => {
              if (!context.isFocusedToastEscapeKeyDownRef.current) handleClose();
              context.isFocusedToastEscapeKeyDownRef.current = false;
            }),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Primitive.li,
              {
                role: "status",
                "aria-live": "off",
                "aria-atomic": true,
                tabIndex: 0,
                "data-state": open ? "open" : "closed",
                "data-swipe-direction": context.swipeDirection,
                ...toastProps,
                ref: composedRefs,
                style: { userSelect: "none", touchAction: "none", ...props.style },
                onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
                  if (event.key !== "Escape") return;
                  onEscapeKeyDown == null ? void 0 : onEscapeKeyDown(event.nativeEvent);
                  if (!event.nativeEvent.defaultPrevented) {
                    context.isFocusedToastEscapeKeyDownRef.current = true;
                    handleClose();
                  }
                }),
                onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
                  if (event.button !== 0) return;
                  pointerStartRef.current = { x: event.clientX, y: event.clientY };
                }),
                onPointerMove: composeEventHandlers(props.onPointerMove, (event) => {
                  if (!pointerStartRef.current) return;
                  const x = event.clientX - pointerStartRef.current.x;
                  const y = event.clientY - pointerStartRef.current.y;
                  const hasSwipeMoveStarted = Boolean(swipeDeltaRef.current);
                  const isHorizontalSwipe = ["left", "right"].includes(context.swipeDirection);
                  const clamp2 = ["left", "up"].includes(context.swipeDirection) ? Math.min : Math.max;
                  const clampedX = isHorizontalSwipe ? clamp2(0, x) : 0;
                  const clampedY = !isHorizontalSwipe ? clamp2(0, y) : 0;
                  const moveStartBuffer = event.pointerType === "touch" ? 10 : 2;
                  const delta = { x: clampedX, y: clampedY };
                  const eventDetail = { originalEvent: event, delta };
                  if (hasSwipeMoveStarted) {
                    swipeDeltaRef.current = delta;
                    handleAndDispatchCustomEvent(TOAST_SWIPE_MOVE, onSwipeMove, eventDetail, {
                      discrete: false
                    });
                  } else if (isDeltaInDirection(delta, context.swipeDirection, moveStartBuffer)) {
                    swipeDeltaRef.current = delta;
                    handleAndDispatchCustomEvent(TOAST_SWIPE_START, onSwipeStart, eventDetail, {
                      discrete: false
                    });
                    event.target.setPointerCapture(event.pointerId);
                  } else if (Math.abs(x) > moveStartBuffer || Math.abs(y) > moveStartBuffer) {
                    pointerStartRef.current = null;
                  }
                }),
                onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {
                  const delta = swipeDeltaRef.current;
                  const target2 = event.target;
                  if (target2.hasPointerCapture(event.pointerId)) {
                    target2.releasePointerCapture(event.pointerId);
                  }
                  swipeDeltaRef.current = null;
                  pointerStartRef.current = null;
                  if (delta) {
                    const toast = event.currentTarget;
                    const eventDetail = { originalEvent: event, delta };
                    if (isDeltaInDirection(delta, context.swipeDirection, context.swipeThreshold)) {
                      handleAndDispatchCustomEvent(TOAST_SWIPE_END, onSwipeEnd, eventDetail, {
                        discrete: true
                      });
                    } else {
                      handleAndDispatchCustomEvent(
                        TOAST_SWIPE_CANCEL,
                        onSwipeCancel,
                        eventDetail,
                        {
                          discrete: true
                        }
                      );
                    }
                    toast.addEventListener("click", (event2) => event2.preventDefault(), {
                      once: true
                    });
                  }
                })
              }
            )
          }
        ) }),
        context.viewport
      ) })
    ] });
  }
);
var ToastAnnounce = (props) => {
  const { __scopeToast, children, ...announceProps } = props;
  const context = useToastProviderContext(TOAST_NAME, __scopeToast);
  const [renderAnnounceText, setRenderAnnounceText] = React.useState(false);
  const [isAnnounced, setIsAnnounced] = React.useState(false);
  useNextFrame(() => setRenderAnnounceText(true));
  React.useEffect(() => {
    const timer = window.setTimeout(() => setIsAnnounced(true), 1e3);
    return () => window.clearTimeout(timer);
  }, []);
  return isAnnounced ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$4, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(VisuallyHidden, { ...announceProps, children: renderAnnounceText && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    context.label,
    " ",
    children
  ] }) }) });
};
var TITLE_NAME = "ToastTitle";
var ToastTitle$1 = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToast, ...titleProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...titleProps, ref: forwardedRef });
  }
);
ToastTitle$1.displayName = TITLE_NAME;
var DESCRIPTION_NAME = "ToastDescription";
var ToastDescription$1 = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToast, ...descriptionProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...descriptionProps, ref: forwardedRef });
  }
);
ToastDescription$1.displayName = DESCRIPTION_NAME;
var ACTION_NAME = "ToastAction";
var ToastAction$1 = React.forwardRef(
  (props, forwardedRef) => {
    const { altText, ...actionProps } = props;
    if (!altText.trim()) {
      console.error(
        `Invalid prop \`altText\` supplied to \`${ACTION_NAME}\`. Expected non-empty \`string\`.`
      );
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ToastAnnounceExclude, { altText, asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ToastClose$1, { ...actionProps, ref: forwardedRef }) });
  }
);
ToastAction$1.displayName = ACTION_NAME;
var CLOSE_NAME = "ToastClose";
var ToastClose$1 = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToast, ...closeProps } = props;
    const interactiveContext = useToastInteractiveContext(CLOSE_NAME, __scopeToast);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ToastAnnounceExclude, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        ...closeProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, interactiveContext.onClose)
      }
    ) });
  }
);
ToastClose$1.displayName = CLOSE_NAME;
var ToastAnnounceExclude = React.forwardRef((props, forwardedRef) => {
  const { __scopeToast, altText, ...announceExcludeProps } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive.div,
    {
      "data-radix-toast-announce-exclude": "",
      "data-radix-toast-announce-alt": altText || void 0,
      ...announceExcludeProps,
      ref: forwardedRef
    }
  );
});
function getAnnounceTextContent(container) {
  const textContent = [];
  const childNodes = Array.from(container.childNodes);
  childNodes.forEach((node) => {
    if (node.nodeType === node.TEXT_NODE && node.textContent) textContent.push(node.textContent);
    if (isHTMLElement(node)) {
      const isHidden2 = node.ariaHidden || node.hidden || node.style.display === "none";
      const isExcluded = node.dataset.radixToastAnnounceExclude === "";
      if (!isHidden2) {
        if (isExcluded) {
          const altText = node.dataset.radixToastAnnounceAlt;
          if (altText) textContent.push(altText);
        } else {
          textContent.push(...getAnnounceTextContent(node));
        }
      }
    }
  });
  return textContent;
}
function handleAndDispatchCustomEvent(name2, handler, detail, { discrete }) {
  const currentTarget = detail.originalEvent.currentTarget;
  const event = new CustomEvent(name2, { bubbles: true, cancelable: true, detail });
  if (handler) currentTarget.addEventListener(name2, handler, { once: true });
  if (discrete) {
    dispatchDiscreteCustomEvent(currentTarget, event);
  } else {
    currentTarget.dispatchEvent(event);
  }
}
var isDeltaInDirection = (delta, direction, threshold2 = 0) => {
  const deltaX = Math.abs(delta.x);
  const deltaY = Math.abs(delta.y);
  const isDeltaX = deltaX > deltaY;
  if (direction === "left" || direction === "right") {
    return isDeltaX && deltaX > threshold2;
  } else {
    return !isDeltaX && deltaY > threshold2;
  }
};
function useNextFrame(callback = () => {
}) {
  const fn = useCallbackRef$1(callback);
  useLayoutEffect2(() => {
    let raf1 = 0;
    let raf2 = 0;
    raf1 = window.requestAnimationFrame(() => raf2 = window.requestAnimationFrame(fn));
    return () => {
      window.cancelAnimationFrame(raf1);
      window.cancelAnimationFrame(raf2);
    };
  }, [fn]);
}
function isHTMLElement(node) {
  return node.nodeType === node.ELEMENT_NODE;
}
function getTabbableCandidates(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode()) nodes.push(walker.currentNode);
  return nodes;
}
function focusFirst(candidates) {
  const previouslyFocusedElement = document.activeElement;
  return candidates.some((candidate) => {
    if (candidate === previouslyFocusedElement) return true;
    candidate.focus();
    return document.activeElement !== previouslyFocusedElement;
  });
}
var Provider$1 = ToastProvider$1;
var Viewport = ToastViewport$1;
var Root2 = Toast$1;
var Title = ToastTitle$1;
var Description = ToastDescription$1;
var Action = ToastAction$1;
var Close = ToastClose$1;
const ToastProvider = Provider$1;
const ToastViewport = forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Viewport,
  {
    ref,
    className: cn(
      "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:max-w-[420px] sm:flex-col",
      className
    ),
    ...props
  }
));
ToastViewport.displayName = Viewport.displayName;
const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center space-x-2 overflow-hidden rounded-lg border p-4 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive: "destructive group bg-system-fail text-grayscale-1000",
        success: "destructive group  bg-primary text-grayscale-1000"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
);
const Toast = forwardRef(({ className, variant, ...props }, ref) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Root2,
    {
      ref,
      className: cn(toastVariants({ variant }), className),
      ...props,
      children: [
        variant === "success" && /* @__PURE__ */ jsxRuntimeExports.jsx(SvgSuccess, {}),
        variant === "destructive" && /* @__PURE__ */ jsxRuntimeExports.jsx(SvgFail, {}),
        props.children
      ]
    }
  );
});
Toast.displayName = Root2.displayName;
const ToastAction = forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Action,
  {
    ref,
    className: cn(
      "hover:bg-secondary inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
      className
    ),
    ...props
  }
));
ToastAction.displayName = Action.displayName;
const ToastClose = forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Close,
  {
    ref,
    className: cn(
      "absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className
    ),
    "toast-close": "",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(SvgPopClose, { className: "h-4 w-4" })
  }
));
ToastClose.displayName = Close.displayName;
const ToastTitle = forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Title,
  {
    ref,
    className: cn("text-sm font-semibold", className),
    ...props
  }
));
ToastTitle.displayName = Title.displayName;
const ToastDescription = forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Description,
  {
    ref,
    className: cn("text-sm opacity-90", className),
    ...props
  }
));
ToastDescription.displayName = Description.displayName;
var [createTooltipContext, createTooltipScope] = createContextScope("Tooltip", [
  createPopperScope
]);
var usePopperScope = createPopperScope();
var PROVIDER_NAME = "TooltipProvider";
var DEFAULT_DELAY_DURATION = 700;
var TOOLTIP_OPEN = "tooltip.open";
var [TooltipProviderContextProvider, useTooltipProviderContext] = createTooltipContext(PROVIDER_NAME);
var TooltipProvider$1 = (props) => {
  const {
    __scopeTooltip,
    delayDuration = DEFAULT_DELAY_DURATION,
    skipDelayDuration = 300,
    disableHoverableContent = false,
    children
  } = props;
  const [isOpenDelayed, setIsOpenDelayed] = React.useState(true);
  const isPointerInTransitRef = React.useRef(false);
  const skipDelayTimerRef = React.useRef(0);
  React.useEffect(() => {
    const skipDelayTimer = skipDelayTimerRef.current;
    return () => window.clearTimeout(skipDelayTimer);
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TooltipProviderContextProvider,
    {
      scope: __scopeTooltip,
      isOpenDelayed,
      delayDuration,
      onOpen: React.useCallback(() => {
        window.clearTimeout(skipDelayTimerRef.current);
        setIsOpenDelayed(false);
      }, []),
      onClose: React.useCallback(() => {
        window.clearTimeout(skipDelayTimerRef.current);
        skipDelayTimerRef.current = window.setTimeout(
          () => setIsOpenDelayed(true),
          skipDelayDuration
        );
      }, [skipDelayDuration]),
      isPointerInTransitRef,
      onPointerInTransitChange: React.useCallback((inTransit) => {
        isPointerInTransitRef.current = inTransit;
      }, []),
      disableHoverableContent,
      children
    }
  );
};
TooltipProvider$1.displayName = PROVIDER_NAME;
var TOOLTIP_NAME = "Tooltip";
var [TooltipContextProvider, useTooltipContext] = createTooltipContext(TOOLTIP_NAME);
var Tooltip$1 = (props) => {
  const {
    __scopeTooltip,
    children,
    open: openProp,
    defaultOpen = false,
    onOpenChange,
    disableHoverableContent: disableHoverableContentProp,
    delayDuration: delayDurationProp
  } = props;
  const providerContext = useTooltipProviderContext(TOOLTIP_NAME, props.__scopeTooltip);
  const popperScope = usePopperScope(__scopeTooltip);
  const [trigger, setTrigger] = React.useState(null);
  const contentId = useId$1();
  const openTimerRef = React.useRef(0);
  const disableHoverableContent = disableHoverableContentProp ?? providerContext.disableHoverableContent;
  const delayDuration = delayDurationProp ?? providerContext.delayDuration;
  const wasOpenDelayedRef = React.useRef(false);
  const [open = false, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: (open2) => {
      if (open2) {
        providerContext.onOpen();
        document.dispatchEvent(new CustomEvent(TOOLTIP_OPEN));
      } else {
        providerContext.onClose();
      }
      onOpenChange == null ? void 0 : onOpenChange(open2);
    }
  });
  const stateAttribute = React.useMemo(() => {
    return open ? wasOpenDelayedRef.current ? "delayed-open" : "instant-open" : "closed";
  }, [open]);
  const handleOpen = React.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = 0;
    wasOpenDelayedRef.current = false;
    setOpen(true);
  }, [setOpen]);
  const handleClose = React.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = 0;
    setOpen(false);
  }, [setOpen]);
  const handleDelayedOpen = React.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = window.setTimeout(() => {
      wasOpenDelayedRef.current = true;
      setOpen(true);
      openTimerRef.current = 0;
    }, delayDuration);
  }, [delayDuration, setOpen]);
  React.useEffect(() => {
    return () => {
      if (openTimerRef.current) {
        window.clearTimeout(openTimerRef.current);
        openTimerRef.current = 0;
      }
    };
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root2$7, { ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    TooltipContextProvider,
    {
      scope: __scopeTooltip,
      contentId,
      open,
      stateAttribute,
      trigger,
      onTriggerChange: setTrigger,
      onTriggerEnter: React.useCallback(() => {
        if (providerContext.isOpenDelayed) handleDelayedOpen();
        else handleOpen();
      }, [providerContext.isOpenDelayed, handleDelayedOpen, handleOpen]),
      onTriggerLeave: React.useCallback(() => {
        if (disableHoverableContent) {
          handleClose();
        } else {
          window.clearTimeout(openTimerRef.current);
          openTimerRef.current = 0;
        }
      }, [handleClose, disableHoverableContent]),
      onOpen: handleOpen,
      onClose: handleClose,
      disableHoverableContent,
      children
    }
  ) });
};
Tooltip$1.displayName = TOOLTIP_NAME;
var TRIGGER_NAME = "TooltipTrigger";
var TooltipTrigger$1 = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTooltip, ...triggerProps } = props;
    const context = useTooltipContext(TRIGGER_NAME, __scopeTooltip);
    const providerContext = useTooltipProviderContext(TRIGGER_NAME, __scopeTooltip);
    const popperScope = usePopperScope(__scopeTooltip);
    const ref = React.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref, context.onTriggerChange);
    const isPointerDownRef = React.useRef(false);
    const hasPointerMoveOpenedRef = React.useRef(false);
    const handlePointerUp = React.useCallback(() => isPointerDownRef.current = false, []);
    React.useEffect(() => {
      return () => document.removeEventListener("pointerup", handlePointerUp);
    }, [handlePointerUp]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor, { asChild: true, ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        "aria-describedby": context.open ? context.contentId : void 0,
        "data-state": context.stateAttribute,
        ...triggerProps,
        ref: composedRefs,
        onPointerMove: composeEventHandlers(props.onPointerMove, (event) => {
          if (event.pointerType === "touch") return;
          if (!hasPointerMoveOpenedRef.current && !providerContext.isPointerInTransitRef.current) {
            context.onTriggerEnter();
            hasPointerMoveOpenedRef.current = true;
          }
        }),
        onPointerLeave: composeEventHandlers(props.onPointerLeave, () => {
          context.onTriggerLeave();
          hasPointerMoveOpenedRef.current = false;
        }),
        onPointerDown: composeEventHandlers(props.onPointerDown, () => {
          isPointerDownRef.current = true;
          document.addEventListener("pointerup", handlePointerUp, { once: true });
        }),
        onFocus: composeEventHandlers(props.onFocus, () => {
          if (!isPointerDownRef.current) context.onOpen();
        }),
        onBlur: composeEventHandlers(props.onBlur, context.onClose),
        onClick: composeEventHandlers(props.onClick, context.onClose)
      }
    ) });
  }
);
TooltipTrigger$1.displayName = TRIGGER_NAME;
var PORTAL_NAME = "TooltipPortal";
var [PortalProvider, usePortalContext] = createTooltipContext(PORTAL_NAME, {
  forceMount: void 0
});
var CONTENT_NAME = "TooltipContent";
var TooltipContent$1 = React.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext(CONTENT_NAME, props.__scopeTooltip);
    const { forceMount = portalContext.forceMount, side = "top", ...contentProps } = props;
    const context = useTooltipContext(CONTENT_NAME, props.__scopeTooltip);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: context.disableHoverableContent ? /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContentImpl, { side, ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContentHoverable, { side, ...contentProps, ref: forwardedRef }) });
  }
);
var TooltipContentHoverable = React.forwardRef((props, forwardedRef) => {
  const context = useTooltipContext(CONTENT_NAME, props.__scopeTooltip);
  const providerContext = useTooltipProviderContext(CONTENT_NAME, props.__scopeTooltip);
  const ref = React.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  const [pointerGraceArea, setPointerGraceArea] = React.useState(null);
  const { trigger, onClose } = context;
  const content = ref.current;
  const { onPointerInTransitChange } = providerContext;
  const handleRemoveGraceArea = React.useCallback(() => {
    setPointerGraceArea(null);
    onPointerInTransitChange(false);
  }, [onPointerInTransitChange]);
  const handleCreateGraceArea = React.useCallback(
    (event, hoverTarget) => {
      const currentTarget = event.currentTarget;
      const exitPoint = { x: event.clientX, y: event.clientY };
      const exitSide = getExitSideFromRect(exitPoint, currentTarget.getBoundingClientRect());
      const paddedExitPoints = getPaddedExitPoints(exitPoint, exitSide);
      const hoverTargetPoints = getPointsFromRect(hoverTarget.getBoundingClientRect());
      const graceArea = getHull([...paddedExitPoints, ...hoverTargetPoints]);
      setPointerGraceArea(graceArea);
      onPointerInTransitChange(true);
    },
    [onPointerInTransitChange]
  );
  React.useEffect(() => {
    return () => handleRemoveGraceArea();
  }, [handleRemoveGraceArea]);
  React.useEffect(() => {
    if (trigger && content) {
      const handleTriggerLeave = (event) => handleCreateGraceArea(event, content);
      const handleContentLeave = (event) => handleCreateGraceArea(event, trigger);
      trigger.addEventListener("pointerleave", handleTriggerLeave);
      content.addEventListener("pointerleave", handleContentLeave);
      return () => {
        trigger.removeEventListener("pointerleave", handleTriggerLeave);
        content.removeEventListener("pointerleave", handleContentLeave);
      };
    }
  }, [trigger, content, handleCreateGraceArea, handleRemoveGraceArea]);
  React.useEffect(() => {
    if (pointerGraceArea) {
      const handleTrackPointerGrace = (event) => {
        const target2 = event.target;
        const pointerPosition = { x: event.clientX, y: event.clientY };
        const hasEnteredTarget = (trigger == null ? void 0 : trigger.contains(target2)) || (content == null ? void 0 : content.contains(target2));
        const isPointerOutsideGraceArea = !isPointInPolygon(pointerPosition, pointerGraceArea);
        if (hasEnteredTarget) {
          handleRemoveGraceArea();
        } else if (isPointerOutsideGraceArea) {
          handleRemoveGraceArea();
          onClose();
        }
      };
      document.addEventListener("pointermove", handleTrackPointerGrace);
      return () => document.removeEventListener("pointermove", handleTrackPointerGrace);
    }
  }, [trigger, content, pointerGraceArea, onClose, handleRemoveGraceArea]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContentImpl, { ...props, ref: composedRefs });
});
var [VisuallyHiddenContentContextProvider, useVisuallyHiddenContentContext] = createTooltipContext(TOOLTIP_NAME, { isInside: false });
var TooltipContentImpl = React.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeTooltip,
      children,
      "aria-label": ariaLabel,
      onEscapeKeyDown,
      onPointerDownOutside,
      ...contentProps
    } = props;
    const context = useTooltipContext(CONTENT_NAME, __scopeTooltip);
    const popperScope = usePopperScope(__scopeTooltip);
    const { onClose } = context;
    React.useEffect(() => {
      document.addEventListener(TOOLTIP_OPEN, onClose);
      return () => document.removeEventListener(TOOLTIP_OPEN, onClose);
    }, [onClose]);
    React.useEffect(() => {
      if (context.trigger) {
        const handleScroll2 = (event) => {
          const target2 = event.target;
          if (target2 == null ? void 0 : target2.contains(context.trigger)) onClose();
        };
        window.addEventListener("scroll", handleScroll2, { capture: true });
        return () => window.removeEventListener("scroll", handleScroll2, { capture: true });
      }
    }, [context.trigger, onClose]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      DismissableLayer,
      {
        asChild: true,
        disableOutsidePointerEvents: false,
        onEscapeKeyDown,
        onPointerDownOutside,
        onFocusOutside: (event) => event.preventDefault(),
        onDismiss: onClose,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Content$2,
          {
            "data-state": context.stateAttribute,
            ...popperScope,
            ...contentProps,
            ref: forwardedRef,
            style: {
              ...contentProps.style,
              // re-namespace exposed content custom properties
              ...{
                "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
                "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
                "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
                "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
                "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
              }
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Slottable, { children }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(VisuallyHiddenContentContextProvider, { scope: __scopeTooltip, isInside: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Root$3, { id: context.contentId, role: "tooltip", children: ariaLabel || children }) })
            ]
          }
        )
      }
    );
  }
);
TooltipContent$1.displayName = CONTENT_NAME;
var ARROW_NAME = "TooltipArrow";
var TooltipArrow = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTooltip, ...arrowProps } = props;
    const popperScope = usePopperScope(__scopeTooltip);
    const visuallyHiddenContentContext = useVisuallyHiddenContentContext(
      ARROW_NAME,
      __scopeTooltip
    );
    return visuallyHiddenContentContext.isInside ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow, { ...popperScope, ...arrowProps, ref: forwardedRef });
  }
);
TooltipArrow.displayName = ARROW_NAME;
function getExitSideFromRect(point2, rect) {
  const top = Math.abs(rect.top - point2.y);
  const bottom = Math.abs(rect.bottom - point2.y);
  const right2 = Math.abs(rect.right - point2.x);
  const left2 = Math.abs(rect.left - point2.x);
  switch (Math.min(top, bottom, right2, left2)) {
    case left2:
      return "left";
    case right2:
      return "right";
    case top:
      return "top";
    case bottom:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function getPaddedExitPoints(exitPoint, exitSide, padding = 5) {
  const paddedExitPoints = [];
  switch (exitSide) {
    case "top":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y + padding },
        { x: exitPoint.x + padding, y: exitPoint.y + padding }
      );
      break;
    case "bottom":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y - padding },
        { x: exitPoint.x + padding, y: exitPoint.y - padding }
      );
      break;
    case "left":
      paddedExitPoints.push(
        { x: exitPoint.x + padding, y: exitPoint.y - padding },
        { x: exitPoint.x + padding, y: exitPoint.y + padding }
      );
      break;
    case "right":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y - padding },
        { x: exitPoint.x - padding, y: exitPoint.y + padding }
      );
      break;
  }
  return paddedExitPoints;
}
function getPointsFromRect(rect) {
  const { top, right: right2, bottom, left: left2 } = rect;
  return [
    { x: left2, y: top },
    { x: right2, y: top },
    { x: right2, y: bottom },
    { x: left2, y: bottom }
  ];
}
function isPointInPolygon(point2, polygon) {
  const { x, y } = point2;
  let inside = false;
  for (let i2 = 0, j = polygon.length - 1; i2 < polygon.length; j = i2++) {
    const xi = polygon[i2].x;
    const yi = polygon[i2].y;
    const xj = polygon[j].x;
    const yj = polygon[j].y;
    const intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
    if (intersect) inside = !inside;
  }
  return inside;
}
function getHull(points2) {
  const newPoints = points2.slice();
  newPoints.sort((a, b) => {
    if (a.x < b.x) return -1;
    else if (a.x > b.x) return 1;
    else if (a.y < b.y) return -1;
    else if (a.y > b.y) return 1;
    else return 0;
  });
  return getHullPresorted(newPoints);
}
function getHullPresorted(points2) {
  if (points2.length <= 1) return points2.slice();
  const upperHull = [];
  for (let i2 = 0; i2 < points2.length; i2++) {
    const p = points2[i2];
    while (upperHull.length >= 2) {
      const q = upperHull[upperHull.length - 1];
      const r2 = upperHull[upperHull.length - 2];
      if ((q.x - r2.x) * (p.y - r2.y) >= (q.y - r2.y) * (p.x - r2.x)) upperHull.pop();
      else break;
    }
    upperHull.push(p);
  }
  upperHull.pop();
  const lowerHull = [];
  for (let i2 = points2.length - 1; i2 >= 0; i2--) {
    const p = points2[i2];
    while (lowerHull.length >= 2) {
      const q = lowerHull[lowerHull.length - 1];
      const r2 = lowerHull[lowerHull.length - 2];
      if ((q.x - r2.x) * (p.y - r2.y) >= (q.y - r2.y) * (p.x - r2.x)) lowerHull.pop();
      else break;
    }
    lowerHull.push(p);
  }
  lowerHull.pop();
  if (upperHull.length === 1 && lowerHull.length === 1 && upperHull[0].x === lowerHull[0].x && upperHull[0].y === lowerHull[0].y) {
    return upperHull;
  } else {
    return upperHull.concat(lowerHull);
  }
}
var Provider = TooltipProvider$1;
var Root3 = Tooltip$1;
var Trigger = TooltipTrigger$1;
var Content2 = TooltipContent$1;
const TooltipProvider = Provider;
const Tooltip = Root3;
const TooltipTrigger = Trigger;
const TooltipContent = forwardRef(
  ({ className, sideOffset = 4, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    Content2,
    {
      ref,
      sideOffset,
      className: cn(
        "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      ),
      ...props
    }
  )
);
TooltipContent.displayName = Content2.displayName;
const AggregationPicker = ({ aggregationType: aggregationType2, updateAggrType }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center gap-x-2", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Select, { value: aggregationType2 || "none", onValueChange: updateAggrType, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(SelectTrigger, { className: "h-10 border-grayscale-600 font-bold text-grayscale-400 dark:border-dark-grayscale-600  dark:bg-dark-bg-333 dark:hover:bg-dark-grayscale-600", children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectValue, { placeholder: t2("none") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(SelectContent, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: "none", children: t2("none") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: "minute", children: t2("Minutely") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: "hour", children: t2("Hourly") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: "day", children: t2("Daily") })
    ] })
  ] }) });
};
const WidgetDatePicker = ({
  dispatch,
  dateRange,
  aggregationType: aggregationType2,
  onApplyFilter,
  showDatePicker = true,
  onClear = () => dispatch({ type: "REFETCHED" }),
  useRealtime,
  isRealtime,
  className,
  children,
  onBack,
  storeKey = "default",
  storeCache: storeCache2 = false
}) => {
  const { t: t2 } = useTranslation();
  const { updateIsRealtime, updateDateRange, updateAggrType } = useDatePickerStore(storeKey, storeCache2);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cn("flex w-full justify-end", className), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "max-w-1/2 flex w-full items-center justify-end gap-x-2 ", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex w-full items-center justify-end gap-x-1 sm:gap-x-2", children: [
      onBack && showDatePicker ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        SvgArrowLeft,
        {
          className: "h-5 w-5 cursor-pointer text-grayscale-400",
          onClick: onBack
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children }),
      !isRealtime && /* @__PURE__ */ jsxRuntimeExports.jsx(
        AggregationPicker,
        {
          aggregationType: aggregationType2,
          updateAggrType: (newAggrType) => {
            dispatch({
              type: "SET_AGGREGATION_TYPE",
              payload: newAggrType
            });
            updateAggrType(newAggrType);
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "", children: showDatePicker && /* @__PURE__ */ jsxRuntimeExports.jsx(
        DatePicker,
        {
          dateRange,
          onDateRange: (newDateRange) => {
            dispatch({
              type: "SET_DATE_RANGE",
              payload: newDateRange
            });
            updateDateRange(newDateRange);
          },
          onApplyFilter
        }
      ) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: `flex min-w-fit ${showDatePicker && "flex-col sm:flex-row"} items-center gap-x-2`,
        children: [
          useRealtime && /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: "flex cursor-pointer items-center gap-x-1.5",
              title: t2("Toggle realtime"),
              onClick: () => {
                dispatch({ type: "RESET_DATE_RANGE" });
                dispatch({
                  type: "TOGGLE_REALTIME",
                  payload: {
                    aggregationType: "none"
                  }
                });
                updateIsRealtime(!isRealtime);
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex h-5 w-5 items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "relative flex h-2 w-2", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "span",
                    {
                      className: `absolute inline-flex h-full w-full rounded-full ${isRealtime ? "animate-ping bg-warning " : "bg-grayscale-400"}`
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "span",
                    {
                      className: `relative inline-flex h-2 w-2 rounded-full ${isRealtime ? "bg-warning" : "bg-grayscale-400"}`
                    }
                  )
                ] }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "span",
                  {
                    className: `hidden font-normal sm:block ${isRealtime ? "text-warning" : "text-grayscale-400"}`,
                    children: t2("Realtime")
                  }
                )
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button$1,
            {
              variant: "ghost",
              type: "button",
              className: "flex w-10 items-center justify-center p-1 text-grayscale-400",
              onClick: onClear,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(SvgRefresh, { className: "h-5 w-5 cursor-pointer text-grayscale-300" })
            }
          )
        ]
      }
    )
  ] }) }) });
};
var reactGridLayout = { exports: {} };
var ReactGridLayout = {};
var fastEquals$1 = { exports: {} };
var fastEquals = fastEquals$1.exports;
var hasRequiredFastEquals;
function requireFastEquals() {
  if (hasRequiredFastEquals) return fastEquals$1.exports;
  hasRequiredFastEquals = 1;
  (function(module2, exports2) {
    (function(global2, factory) {
      factory(exports2);
    })(fastEquals, function(exports3) {
      function createDefaultIsNestedEqual(comparator) {
        return function isEqual2(a, b, _indexOrKeyA, _indexOrKeyB, _parentA, _parentB, meta) {
          return comparator(a, b, meta);
        };
      }
      function createIsCircular(areItemsEqual) {
        return function isCircular(a, b, isEqual2, cache) {
          if (!a || !b || typeof a !== "object" || typeof b !== "object") {
            return areItemsEqual(a, b, isEqual2, cache);
          }
          var cachedA = cache.get(a);
          var cachedB = cache.get(b);
          if (cachedA && cachedB) {
            return cachedA === b && cachedB === a;
          }
          cache.set(a, b);
          cache.set(b, a);
          var result = areItemsEqual(a, b, isEqual2, cache);
          cache.delete(a);
          cache.delete(b);
          return result;
        };
      }
      function merge(a, b) {
        var merged = {};
        for (var key in a) {
          merged[key] = a[key];
        }
        for (var key in b) {
          merged[key] = b[key];
        }
        return merged;
      }
      function isPlainObject(value2) {
        return value2.constructor === Object || value2.constructor == null;
      }
      function isPromiseLike(value2) {
        return typeof value2.then === "function";
      }
      function sameValueZeroEqual(a, b) {
        return a === b || a !== a && b !== b;
      }
      var ARGUMENTS_TAG = "[object Arguments]";
      var BOOLEAN_TAG = "[object Boolean]";
      var DATE_TAG = "[object Date]";
      var REG_EXP_TAG = "[object RegExp]";
      var MAP_TAG = "[object Map]";
      var NUMBER_TAG = "[object Number]";
      var OBJECT_TAG = "[object Object]";
      var SET_TAG = "[object Set]";
      var STRING_TAG = "[object String]";
      var toString2 = Object.prototype.toString;
      function createComparator(_a) {
        var areArraysEqual2 = _a.areArraysEqual, areDatesEqual2 = _a.areDatesEqual, areMapsEqual2 = _a.areMapsEqual, areObjectsEqual2 = _a.areObjectsEqual, areRegExpsEqual2 = _a.areRegExpsEqual, areSetsEqual2 = _a.areSetsEqual, createIsNestedEqual = _a.createIsNestedEqual;
        var isEqual2 = createIsNestedEqual(comparator);
        function comparator(a, b, meta) {
          if (a === b) {
            return true;
          }
          if (!a || !b || typeof a !== "object" || typeof b !== "object") {
            return a !== a && b !== b;
          }
          if (isPlainObject(a) && isPlainObject(b)) {
            return areObjectsEqual2(a, b, isEqual2, meta);
          }
          var aArray = Array.isArray(a);
          var bArray = Array.isArray(b);
          if (aArray || bArray) {
            return aArray === bArray && areArraysEqual2(a, b, isEqual2, meta);
          }
          var aTag = toString2.call(a);
          if (aTag !== toString2.call(b)) {
            return false;
          }
          if (aTag === DATE_TAG) {
            return areDatesEqual2(a, b, isEqual2, meta);
          }
          if (aTag === REG_EXP_TAG) {
            return areRegExpsEqual2(a, b, isEqual2, meta);
          }
          if (aTag === MAP_TAG) {
            return areMapsEqual2(a, b, isEqual2, meta);
          }
          if (aTag === SET_TAG) {
            return areSetsEqual2(a, b, isEqual2, meta);
          }
          if (aTag === OBJECT_TAG || aTag === ARGUMENTS_TAG) {
            return isPromiseLike(a) || isPromiseLike(b) ? false : areObjectsEqual2(a, b, isEqual2, meta);
          }
          if (aTag === BOOLEAN_TAG || aTag === NUMBER_TAG || aTag === STRING_TAG) {
            return sameValueZeroEqual(a.valueOf(), b.valueOf());
          }
          return false;
        }
        return comparator;
      }
      function areArraysEqual(a, b, isEqual2, meta) {
        var index2 = a.length;
        if (b.length !== index2) {
          return false;
        }
        while (index2-- > 0) {
          if (!isEqual2(a[index2], b[index2], index2, index2, a, b, meta)) {
            return false;
          }
        }
        return true;
      }
      var areArraysEqualCircular = createIsCircular(areArraysEqual);
      function areDatesEqual(a, b) {
        return sameValueZeroEqual(a.valueOf(), b.valueOf());
      }
      function areMapsEqual(a, b, isEqual2, meta) {
        var isValueEqual = a.size === b.size;
        if (!isValueEqual) {
          return false;
        }
        if (!a.size) {
          return true;
        }
        var matchedIndices = {};
        var indexA = 0;
        a.forEach(function(aValue, aKey) {
          if (!isValueEqual) {
            return;
          }
          var hasMatch = false;
          var matchIndexB = 0;
          b.forEach(function(bValue, bKey) {
            if (!hasMatch && !matchedIndices[matchIndexB] && (hasMatch = isEqual2(aKey, bKey, indexA, matchIndexB, a, b, meta) && isEqual2(aValue, bValue, aKey, bKey, a, b, meta))) {
              matchedIndices[matchIndexB] = true;
            }
            matchIndexB++;
          });
          indexA++;
          isValueEqual = hasMatch;
        });
        return isValueEqual;
      }
      var areMapsEqualCircular = createIsCircular(areMapsEqual);
      var OWNER = "_owner";
      var hasOwnProperty2 = Object.prototype.hasOwnProperty;
      function areObjectsEqual(a, b, isEqual2, meta) {
        var keysA = Object.keys(a);
        var index2 = keysA.length;
        if (Object.keys(b).length !== index2) {
          return false;
        }
        var key;
        while (index2-- > 0) {
          key = keysA[index2];
          if (key === OWNER) {
            var reactElementA = !!a.$$typeof;
            var reactElementB = !!b.$$typeof;
            if ((reactElementA || reactElementB) && reactElementA !== reactElementB) {
              return false;
            }
          }
          if (!hasOwnProperty2.call(b, key) || !isEqual2(a[key], b[key], key, key, a, b, meta)) {
            return false;
          }
        }
        return true;
      }
      var areObjectsEqualCircular = createIsCircular(areObjectsEqual);
      function areRegExpsEqual(a, b) {
        return a.source === b.source && a.flags === b.flags;
      }
      function areSetsEqual(a, b, isEqual2, meta) {
        var isValueEqual = a.size === b.size;
        if (!isValueEqual) {
          return false;
        }
        if (!a.size) {
          return true;
        }
        var matchedIndices = {};
        a.forEach(function(aValue, aKey) {
          if (!isValueEqual) {
            return;
          }
          var hasMatch = false;
          var matchIndex = 0;
          b.forEach(function(bValue, bKey) {
            if (!hasMatch && !matchedIndices[matchIndex] && (hasMatch = isEqual2(aValue, bValue, aKey, bKey, a, b, meta))) {
              matchedIndices[matchIndex] = true;
            }
            matchIndex++;
          });
          isValueEqual = hasMatch;
        });
        return isValueEqual;
      }
      var areSetsEqualCircular = createIsCircular(areSetsEqual);
      var DEFAULT_CONFIG = Object.freeze({
        areArraysEqual,
        areDatesEqual,
        areMapsEqual,
        areObjectsEqual,
        areRegExpsEqual,
        areSetsEqual,
        createIsNestedEqual: createDefaultIsNestedEqual
      });
      var DEFAULT_CIRCULAR_CONFIG = Object.freeze({
        areArraysEqual: areArraysEqualCircular,
        areDatesEqual,
        areMapsEqual: areMapsEqualCircular,
        areObjectsEqual: areObjectsEqualCircular,
        areRegExpsEqual,
        areSetsEqual: areSetsEqualCircular,
        createIsNestedEqual: createDefaultIsNestedEqual
      });
      var isDeepEqual = createComparator(DEFAULT_CONFIG);
      function deepEqual2(a, b) {
        return isDeepEqual(a, b, void 0);
      }
      var isShallowEqual = createComparator(merge(DEFAULT_CONFIG, { createIsNestedEqual: function() {
        return sameValueZeroEqual;
      } }));
      function shallowEqual(a, b) {
        return isShallowEqual(a, b, void 0);
      }
      var isCircularDeepEqual = createComparator(DEFAULT_CIRCULAR_CONFIG);
      function circularDeepEqual(a, b) {
        return isCircularDeepEqual(a, b, /* @__PURE__ */ new WeakMap());
      }
      var isCircularShallowEqual = createComparator(merge(DEFAULT_CIRCULAR_CONFIG, {
        createIsNestedEqual: function() {
          return sameValueZeroEqual;
        }
      }));
      function circularShallowEqual(a, b) {
        return isCircularShallowEqual(a, b, /* @__PURE__ */ new WeakMap());
      }
      function createCustomEqual(getComparatorOptions) {
        return createComparator(merge(DEFAULT_CONFIG, getComparatorOptions(DEFAULT_CONFIG)));
      }
      function createCustomCircularEqual(getComparatorOptions) {
        var comparator = createComparator(merge(DEFAULT_CIRCULAR_CONFIG, getComparatorOptions(DEFAULT_CIRCULAR_CONFIG)));
        return function(a, b, meta) {
          if (meta === void 0) {
            meta = /* @__PURE__ */ new WeakMap();
          }
          return comparator(a, b, meta);
        };
      }
      exports3.circularDeepEqual = circularDeepEqual;
      exports3.circularShallowEqual = circularShallowEqual;
      exports3.createCustomCircularEqual = createCustomCircularEqual;
      exports3.createCustomEqual = createCustomEqual;
      exports3.deepEqual = deepEqual2;
      exports3.sameValueZeroEqual = sameValueZeroEqual;
      exports3.shallowEqual = shallowEqual;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  })(fastEquals$1, fastEquals$1.exports);
  return fastEquals$1.exports;
}
var clsx$1 = { exports: {} };
var hasRequiredClsx;
function requireClsx() {
  if (hasRequiredClsx) return clsx$1.exports;
  hasRequiredClsx = 1;
  function r2(e2) {
    var o2, t2, f = "";
    if ("string" == typeof e2 || "number" == typeof e2) f += e2;
    else if ("object" == typeof e2) if (Array.isArray(e2)) {
      var n2 = e2.length;
      for (o2 = 0; o2 < n2; o2++) e2[o2] && (t2 = r2(e2[o2])) && (f && (f += " "), f += t2);
    } else for (t2 in e2) e2[t2] && (f && (f += " "), f += t2);
    return f;
  }
  function e() {
    for (var e2, o2, t2 = 0, f = "", n2 = arguments.length; t2 < n2; t2++) (e2 = arguments[t2]) && (o2 = r2(e2)) && (f && (f += " "), f += o2);
    return f;
  }
  clsx$1.exports = e, clsx$1.exports.clsx = e;
  return clsx$1.exports;
}
var utils$1 = {};
var fastRGLPropsEqual;
var hasRequiredFastRGLPropsEqual;
function requireFastRGLPropsEqual() {
  if (hasRequiredFastRGLPropsEqual) return fastRGLPropsEqual;
  hasRequiredFastRGLPropsEqual = 1;
  fastRGLPropsEqual = function fastRGLPropsEqual2(a, b, isEqualImpl) {
    if (a === b) return true;
    return a.className === b.className && isEqualImpl(a.style, b.style) && a.width === b.width && a.autoSize === b.autoSize && a.cols === b.cols && a.draggableCancel === b.draggableCancel && a.draggableHandle === b.draggableHandle && isEqualImpl(a.verticalCompact, b.verticalCompact) && isEqualImpl(a.compactType, b.compactType) && isEqualImpl(a.layout, b.layout) && isEqualImpl(a.margin, b.margin) && isEqualImpl(a.containerPadding, b.containerPadding) && a.rowHeight === b.rowHeight && a.maxRows === b.maxRows && a.isBounded === b.isBounded && a.isDraggable === b.isDraggable && a.isResizable === b.isResizable && a.allowOverlap === b.allowOverlap && a.preventCollision === b.preventCollision && a.useCSSTransforms === b.useCSSTransforms && a.transformScale === b.transformScale && a.isDroppable === b.isDroppable && isEqualImpl(a.resizeHandles, b.resizeHandles) && isEqualImpl(a.resizeHandle, b.resizeHandle) && a.onLayoutChange === b.onLayoutChange && a.onDragStart === b.onDragStart && a.onDrag === b.onDrag && a.onDragStop === b.onDragStop && a.onResizeStart === b.onResizeStart && a.onResize === b.onResize && a.onResizeStop === b.onResizeStop && a.onDrop === b.onDrop && isEqualImpl(a.droppingItem, b.droppingItem) && isEqualImpl(a.innerRef, b.innerRef);
  };
  return fastRGLPropsEqual;
}
var hasRequiredUtils$1;
function requireUtils$1() {
  if (hasRequiredUtils$1) return utils$1;
  hasRequiredUtils$1 = 1;
  Object.defineProperty(utils$1, "__esModule", {
    value: true
  });
  utils$1.bottom = bottom;
  utils$1.childrenEqual = childrenEqual;
  utils$1.cloneLayout = cloneLayout;
  utils$1.cloneLayoutItem = cloneLayoutItem;
  utils$1.collides = collides;
  utils$1.compact = compact;
  utils$1.compactItem = compactItem;
  utils$1.compactType = compactType;
  utils$1.correctBounds = correctBounds;
  utils$1.fastPositionEqual = fastPositionEqual;
  utils$1.fastRGLPropsEqual = void 0;
  utils$1.getAllCollisions = getAllCollisions;
  utils$1.getFirstCollision = getFirstCollision;
  utils$1.getLayoutItem = getLayoutItem;
  utils$1.getStatics = getStatics;
  utils$1.modifyLayout = modifyLayout;
  utils$1.moveElement = moveElement;
  utils$1.moveElementAwayFromCollision = moveElementAwayFromCollision;
  utils$1.noop = void 0;
  utils$1.perc = perc;
  utils$1.resizeItemInDirection = resizeItemInDirection;
  utils$1.setTopLeft = setTopLeft;
  utils$1.setTransform = setTransform;
  utils$1.sortLayoutItems = sortLayoutItems;
  utils$1.sortLayoutItemsByColRow = sortLayoutItemsByColRow;
  utils$1.sortLayoutItemsByRowCol = sortLayoutItemsByRowCol;
  utils$1.synchronizeLayoutWithChildren = synchronizeLayoutWithChildren;
  utils$1.validateLayout = validateLayout;
  utils$1.withLayoutItem = withLayoutItem;
  var _fastEquals = /* @__PURE__ */ requireFastEquals();
  var _react = _interopRequireDefault(React__default);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  const isProduction = process.env.NODE_ENV === "production";
  function bottom(layout2) {
    let max2 = 0, bottomY;
    for (let i2 = 0, len = layout2.length; i2 < len; i2++) {
      bottomY = layout2[i2].y + layout2[i2].h;
      if (bottomY > max2) max2 = bottomY;
    }
    return max2;
  }
  function cloneLayout(layout2) {
    const newLayout = Array(layout2.length);
    for (let i2 = 0, len = layout2.length; i2 < len; i2++) {
      newLayout[i2] = cloneLayoutItem(layout2[i2]);
    }
    return newLayout;
  }
  function modifyLayout(layout2, layoutItem) {
    const newLayout = Array(layout2.length);
    for (let i2 = 0, len = layout2.length; i2 < len; i2++) {
      if (layoutItem.i === layout2[i2].i) {
        newLayout[i2] = layoutItem;
      } else {
        newLayout[i2] = layout2[i2];
      }
    }
    return newLayout;
  }
  function withLayoutItem(layout2, itemKey, cb) {
    let item = getLayoutItem(layout2, itemKey);
    if (!item) return [layout2, null];
    item = cb(cloneLayoutItem(item));
    layout2 = modifyLayout(layout2, item);
    return [layout2, item];
  }
  function cloneLayoutItem(layoutItem) {
    return {
      w: layoutItem.w,
      h: layoutItem.h,
      x: layoutItem.x,
      y: layoutItem.y,
      i: layoutItem.i,
      minW: layoutItem.minW,
      maxW: layoutItem.maxW,
      minH: layoutItem.minH,
      maxH: layoutItem.maxH,
      moved: Boolean(layoutItem.moved),
      static: Boolean(layoutItem.static),
      // These can be null/undefined
      isDraggable: layoutItem.isDraggable,
      isResizable: layoutItem.isResizable,
      resizeHandles: layoutItem.resizeHandles,
      isBounded: layoutItem.isBounded
    };
  }
  function childrenEqual(a, b) {
    return (0, _fastEquals.deepEqual)(_react.default.Children.map(a, (c) => c == null ? void 0 : c.key), _react.default.Children.map(b, (c) => c == null ? void 0 : c.key)) && (0, _fastEquals.deepEqual)(_react.default.Children.map(a, (c) => c == null ? void 0 : c.props["data-grid"]), _react.default.Children.map(b, (c) => c == null ? void 0 : c.props["data-grid"]));
  }
  utils$1.fastRGLPropsEqual = requireFastRGLPropsEqual();
  function fastPositionEqual(a, b) {
    return a.left === b.left && a.top === b.top && a.width === b.width && a.height === b.height;
  }
  function collides(l1, l2) {
    if (l1.i === l2.i) return false;
    if (l1.x + l1.w <= l2.x) return false;
    if (l1.x >= l2.x + l2.w) return false;
    if (l1.y + l1.h <= l2.y) return false;
    if (l1.y >= l2.y + l2.h) return false;
    return true;
  }
  function compact(layout2, compactType2, cols, allowOverlap) {
    const compareWith = getStatics(layout2);
    const sorted = sortLayoutItems(layout2, compactType2);
    const out = Array(layout2.length);
    for (let i2 = 0, len = sorted.length; i2 < len; i2++) {
      let l = cloneLayoutItem(sorted[i2]);
      if (!l.static) {
        l = compactItem(compareWith, l, compactType2, cols, sorted, allowOverlap);
        compareWith.push(l);
      }
      out[layout2.indexOf(sorted[i2])] = l;
      l.moved = false;
    }
    return out;
  }
  const heightWidth = {
    x: "w",
    y: "h"
  };
  function resolveCompactionCollision(layout2, item, moveToCoord, axis) {
    const sizeProp = heightWidth[axis];
    item[axis] += 1;
    const itemIndex = layout2.map((layoutItem) => {
      return layoutItem.i;
    }).indexOf(item.i);
    for (let i2 = itemIndex + 1; i2 < layout2.length; i2++) {
      const otherItem = layout2[i2];
      if (otherItem.static) continue;
      if (otherItem.y > item.y + item.h) break;
      if (collides(item, otherItem)) {
        resolveCompactionCollision(layout2, otherItem, moveToCoord + item[sizeProp], axis);
      }
    }
    item[axis] = moveToCoord;
  }
  function compactItem(compareWith, l, compactType2, cols, fullLayout, allowOverlap) {
    const compactV = compactType2 === "vertical";
    const compactH = compactType2 === "horizontal";
    if (compactV) {
      l.y = Math.min(bottom(compareWith), l.y);
      while (l.y > 0 && !getFirstCollision(compareWith, l)) {
        l.y--;
      }
    } else if (compactH) {
      while (l.x > 0 && !getFirstCollision(compareWith, l)) {
        l.x--;
      }
    }
    let collides2;
    while ((collides2 = getFirstCollision(compareWith, l)) && !(compactType2 === null && allowOverlap)) {
      if (compactH) {
        resolveCompactionCollision(fullLayout, l, collides2.x + collides2.w, "x");
      } else {
        resolveCompactionCollision(fullLayout, l, collides2.y + collides2.h, "y");
      }
      if (compactH && l.x + l.w > cols) {
        l.x = cols - l.w;
        l.y++;
        while (l.x > 0 && !getFirstCollision(compareWith, l)) {
          l.x--;
        }
      }
    }
    l.y = Math.max(l.y, 0);
    l.x = Math.max(l.x, 0);
    return l;
  }
  function correctBounds(layout2, bounds) {
    const collidesWith = getStatics(layout2);
    for (let i2 = 0, len = layout2.length; i2 < len; i2++) {
      const l = layout2[i2];
      if (l.x + l.w > bounds.cols) l.x = bounds.cols - l.w;
      if (l.x < 0) {
        l.x = 0;
        l.w = bounds.cols;
      }
      if (!l.static) collidesWith.push(l);
      else {
        while (getFirstCollision(collidesWith, l)) {
          l.y++;
        }
      }
    }
    return layout2;
  }
  function getLayoutItem(layout2, id2) {
    for (let i2 = 0, len = layout2.length; i2 < len; i2++) {
      if (layout2[i2].i === id2) return layout2[i2];
    }
  }
  function getFirstCollision(layout2, layoutItem) {
    for (let i2 = 0, len = layout2.length; i2 < len; i2++) {
      if (collides(layout2[i2], layoutItem)) return layout2[i2];
    }
  }
  function getAllCollisions(layout2, layoutItem) {
    return layout2.filter((l) => collides(l, layoutItem));
  }
  function getStatics(layout2) {
    return layout2.filter((l) => l.static);
  }
  function moveElement(layout2, l, x, y, isUserAction, preventCollision, compactType2, cols, allowOverlap) {
    if (l.static && l.isDraggable !== true) return layout2;
    if (l.y === y && l.x === x) return layout2;
    log2(`Moving element ${l.i} to [${String(x)},${String(y)}] from [${l.x},${l.y}]`);
    const oldX = l.x;
    const oldY = l.y;
    if (typeof x === "number") l.x = x;
    if (typeof y === "number") l.y = y;
    l.moved = true;
    let sorted = sortLayoutItems(layout2, compactType2);
    const movingUp = compactType2 === "vertical" && typeof y === "number" ? oldY >= y : compactType2 === "horizontal" && typeof x === "number" ? oldX >= x : false;
    if (movingUp) sorted = sorted.reverse();
    const collisions = getAllCollisions(sorted, l);
    const hasCollisions = collisions.length > 0;
    if (hasCollisions && allowOverlap) {
      return cloneLayout(layout2);
    } else if (hasCollisions && preventCollision) {
      log2(`Collision prevented on ${l.i}, reverting.`);
      l.x = oldX;
      l.y = oldY;
      l.moved = false;
      return layout2;
    }
    for (let i2 = 0, len = collisions.length; i2 < len; i2++) {
      const collision = collisions[i2];
      log2(`Resolving collision between ${l.i} at [${l.x},${l.y}] and ${collision.i} at [${collision.x},${collision.y}]`);
      if (collision.moved) continue;
      if (collision.static) {
        layout2 = moveElementAwayFromCollision(layout2, collision, l, isUserAction, compactType2);
      } else {
        layout2 = moveElementAwayFromCollision(layout2, l, collision, isUserAction, compactType2);
      }
    }
    return layout2;
  }
  function moveElementAwayFromCollision(layout2, collidesWith, itemToMove, isUserAction, compactType2, cols) {
    const compactH = compactType2 === "horizontal";
    const compactV = compactType2 === "vertical";
    const preventCollision = collidesWith.static;
    if (isUserAction) {
      isUserAction = false;
      const fakeItem = {
        x: compactH ? Math.max(collidesWith.x - itemToMove.w, 0) : itemToMove.x,
        y: compactV ? Math.max(collidesWith.y - itemToMove.h, 0) : itemToMove.y,
        w: itemToMove.w,
        h: itemToMove.h,
        i: "-1"
      };
      const firstCollision = getFirstCollision(layout2, fakeItem);
      const collisionNorth = firstCollision && firstCollision.y + firstCollision.h > collidesWith.y;
      const collisionWest = firstCollision && collidesWith.x + collidesWith.w > firstCollision.x;
      if (!firstCollision) {
        log2(`Doing reverse collision on ${itemToMove.i} up to [${fakeItem.x},${fakeItem.y}].`);
        return moveElement(layout2, itemToMove, compactH ? fakeItem.x : void 0, compactV ? fakeItem.y : void 0, isUserAction, preventCollision, compactType2);
      } else if (collisionNorth && compactV) {
        return moveElement(layout2, itemToMove, void 0, collidesWith.y + 1, isUserAction, preventCollision, compactType2);
      } else if (collisionNorth && compactType2 == null) {
        collidesWith.y = itemToMove.y;
        itemToMove.y = itemToMove.y + itemToMove.h;
        return layout2;
      } else if (collisionWest && compactH) {
        return moveElement(layout2, collidesWith, itemToMove.x, void 0, isUserAction, preventCollision, compactType2);
      }
    }
    const newX = compactH ? itemToMove.x + 1 : void 0;
    const newY = compactV ? itemToMove.y + 1 : void 0;
    if (newX == null && newY == null) {
      return layout2;
    }
    return moveElement(layout2, itemToMove, compactH ? itemToMove.x + 1 : void 0, compactV ? itemToMove.y + 1 : void 0, isUserAction, preventCollision, compactType2);
  }
  function perc(num) {
    return num * 100 + "%";
  }
  const constrainWidth = (left2, currentWidth, newWidth, containerWidth) => {
    return left2 + newWidth > containerWidth ? currentWidth : newWidth;
  };
  const constrainHeight = (top, currentHeight, newHeight) => {
    return top < 0 ? currentHeight : newHeight;
  };
  const constrainLeft = (left2) => Math.max(0, left2);
  const constrainTop = (top) => Math.max(0, top);
  const resizeNorth = (currentSize, _ref, _containerWidth) => {
    let {
      left: left2,
      height,
      width
    } = _ref;
    const top = currentSize.top - (height - currentSize.height);
    return {
      left: left2,
      width,
      height: constrainHeight(top, currentSize.height, height),
      top: constrainTop(top)
    };
  };
  const resizeEast = (currentSize, _ref2, containerWidth) => {
    let {
      top,
      left: left2,
      height,
      width
    } = _ref2;
    return {
      top,
      height,
      width: constrainWidth(currentSize.left, currentSize.width, width, containerWidth),
      left: constrainLeft(left2)
    };
  };
  const resizeWest = (currentSize, _ref3, containerWidth) => {
    let {
      top,
      height,
      width
    } = _ref3;
    const left2 = currentSize.left - (width - currentSize.width);
    return {
      height,
      width: left2 < 0 ? currentSize.width : constrainWidth(currentSize.left, currentSize.width, width, containerWidth),
      top: constrainTop(top),
      left: constrainLeft(left2)
    };
  };
  const resizeSouth = (currentSize, _ref4, containerWidth) => {
    let {
      top,
      left: left2,
      height,
      width
    } = _ref4;
    return {
      width,
      left: left2,
      height: constrainHeight(top, currentSize.height, height),
      top: constrainTop(top)
    };
  };
  const resizeNorthEast = function() {
    return resizeNorth(arguments.length <= 0 ? void 0 : arguments[0], resizeEast(...arguments));
  };
  const resizeNorthWest = function() {
    return resizeNorth(arguments.length <= 0 ? void 0 : arguments[0], resizeWest(...arguments));
  };
  const resizeSouthEast = function() {
    return resizeSouth(arguments.length <= 0 ? void 0 : arguments[0], resizeEast(...arguments));
  };
  const resizeSouthWest = function() {
    return resizeSouth(arguments.length <= 0 ? void 0 : arguments[0], resizeWest(...arguments));
  };
  const ordinalResizeHandlerMap = {
    n: resizeNorth,
    ne: resizeNorthEast,
    e: resizeEast,
    se: resizeSouthEast,
    s: resizeSouth,
    sw: resizeSouthWest,
    w: resizeWest,
    nw: resizeNorthWest
  };
  function resizeItemInDirection(direction, currentSize, newSize, containerWidth) {
    const ordinalHandler = ordinalResizeHandlerMap[direction];
    if (!ordinalHandler) return newSize;
    return ordinalHandler(currentSize, {
      ...currentSize,
      ...newSize
    }, containerWidth);
  }
  function setTransform(_ref5) {
    let {
      top,
      left: left2,
      width,
      height
    } = _ref5;
    const translate2 = `translate(${left2}px,${top}px)`;
    return {
      transform: translate2,
      WebkitTransform: translate2,
      MozTransform: translate2,
      msTransform: translate2,
      OTransform: translate2,
      width: `${width}px`,
      height: `${height}px`,
      position: "absolute"
    };
  }
  function setTopLeft(_ref6) {
    let {
      top,
      left: left2,
      width,
      height
    } = _ref6;
    return {
      top: `${top}px`,
      left: `${left2}px`,
      width: `${width}px`,
      height: `${height}px`,
      position: "absolute"
    };
  }
  function sortLayoutItems(layout2, compactType2) {
    if (compactType2 === "horizontal") return sortLayoutItemsByColRow(layout2);
    if (compactType2 === "vertical") return sortLayoutItemsByRowCol(layout2);
    else return layout2;
  }
  function sortLayoutItemsByRowCol(layout2) {
    return layout2.slice(0).sort(function(a, b) {
      if (a.y > b.y || a.y === b.y && a.x > b.x) {
        return 1;
      } else if (a.y === b.y && a.x === b.x) {
        return 0;
      }
      return -1;
    });
  }
  function sortLayoutItemsByColRow(layout2) {
    return layout2.slice(0).sort(function(a, b) {
      if (a.x > b.x || a.x === b.x && a.y > b.y) {
        return 1;
      }
      return -1;
    });
  }
  function synchronizeLayoutWithChildren(initialLayout, children, cols, compactType2, allowOverlap) {
    initialLayout = initialLayout || [];
    const layout2 = [];
    _react.default.Children.forEach(children, (child) => {
      if ((child == null ? void 0 : child.key) == null) return;
      const exists = getLayoutItem(initialLayout, String(child.key));
      const g = child.props["data-grid"];
      if (exists && g == null) {
        layout2.push(cloneLayoutItem(exists));
      } else {
        if (g) {
          if (!isProduction) {
            validateLayout([g], "ReactGridLayout.children");
          }
          layout2.push(cloneLayoutItem({
            ...g,
            i: child.key
          }));
        } else {
          layout2.push(cloneLayoutItem({
            w: 1,
            h: 1,
            x: 0,
            y: bottom(layout2),
            i: String(child.key)
          }));
        }
      }
    });
    const correctedLayout = correctBounds(layout2, {
      cols
    });
    return allowOverlap ? correctedLayout : compact(correctedLayout, compactType2, cols);
  }
  function validateLayout(layout2) {
    let contextName = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "Layout";
    const subProps = ["x", "y", "w", "h"];
    if (!Array.isArray(layout2)) throw new Error(contextName + " must be an array!");
    for (let i2 = 0, len = layout2.length; i2 < len; i2++) {
      const item = layout2[i2];
      for (let j = 0; j < subProps.length; j++) {
        const key = subProps[j];
        const value2 = item[key];
        if (typeof value2 !== "number" || Number.isNaN(value2)) {
          throw new Error(`ReactGridLayout: ${contextName}[${i2}].${key} must be a number! Received: ${value2} (${typeof value2})`);
        }
      }
      if (typeof item.i !== "undefined" && typeof item.i !== "string") {
        throw new Error(`ReactGridLayout: ${contextName}[${i2}].i must be a string! Received: ${item.i} (${typeof item.i})`);
      }
    }
  }
  function compactType(props) {
    const {
      verticalCompact,
      compactType: compactType2
    } = props || {};
    return verticalCompact === false ? null : compactType2;
  }
  function log2() {
    return;
  }
  const noop2 = () => {
  };
  utils$1.noop = noop2;
  return utils$1;
}
var calculateUtils = {};
var hasRequiredCalculateUtils;
function requireCalculateUtils() {
  if (hasRequiredCalculateUtils) return calculateUtils;
  hasRequiredCalculateUtils = 1;
  Object.defineProperty(calculateUtils, "__esModule", {
    value: true
  });
  calculateUtils.calcGridColWidth = calcGridColWidth;
  calculateUtils.calcGridItemPosition = calcGridItemPosition;
  calculateUtils.calcGridItemWHPx = calcGridItemWHPx;
  calculateUtils.calcWH = calcWH;
  calculateUtils.calcXY = calcXY;
  calculateUtils.clamp = clamp2;
  function calcGridColWidth(positionParams) {
    const {
      margin,
      containerPadding,
      containerWidth,
      cols
    } = positionParams;
    return (containerWidth - margin[0] * (cols - 1) - containerPadding[0] * 2) / cols;
  }
  function calcGridItemWHPx(gridUnits, colOrRowSize, marginPx) {
    if (!Number.isFinite(gridUnits)) return gridUnits;
    return Math.round(colOrRowSize * gridUnits + Math.max(0, gridUnits - 1) * marginPx);
  }
  function calcGridItemPosition(positionParams, x, y, w, h, state) {
    const {
      margin,
      containerPadding,
      rowHeight
    } = positionParams;
    const colWidth = calcGridColWidth(positionParams);
    const out = {};
    if (state && state.resizing) {
      out.width = Math.round(state.resizing.width);
      out.height = Math.round(state.resizing.height);
    } else {
      out.width = calcGridItemWHPx(w, colWidth, margin[0]);
      out.height = calcGridItemWHPx(h, rowHeight, margin[1]);
    }
    if (state && state.dragging) {
      out.top = Math.round(state.dragging.top);
      out.left = Math.round(state.dragging.left);
    } else if (state && state.resizing && typeof state.resizing.top === "number" && typeof state.resizing.left === "number") {
      out.top = Math.round(state.resizing.top);
      out.left = Math.round(state.resizing.left);
    } else {
      out.top = Math.round((rowHeight + margin[1]) * y + containerPadding[1]);
      out.left = Math.round((colWidth + margin[0]) * x + containerPadding[0]);
    }
    return out;
  }
  function calcXY(positionParams, top, left2, w, h) {
    const {
      margin,
      containerPadding,
      cols,
      rowHeight,
      maxRows
    } = positionParams;
    const colWidth = calcGridColWidth(positionParams);
    let x = Math.round((left2 - containerPadding[0]) / (colWidth + margin[0]));
    let y = Math.round((top - containerPadding[1]) / (rowHeight + margin[1]));
    x = clamp2(x, 0, cols - w);
    y = clamp2(y, 0, maxRows - h);
    return {
      x,
      y
    };
  }
  function calcWH(positionParams, width, height, x, y, handle) {
    const {
      margin,
      maxRows,
      cols,
      rowHeight
    } = positionParams;
    const colWidth = calcGridColWidth(positionParams);
    let w = Math.round((width + margin[0]) / (colWidth + margin[0]));
    let h = Math.round((height + margin[1]) / (rowHeight + margin[1]));
    let _w = clamp2(w, 0, cols - x);
    let _h = clamp2(h, 0, maxRows - y);
    if (["sw", "w", "nw"].indexOf(handle) !== -1) {
      _w = clamp2(w, 0, cols);
    }
    if (["nw", "n", "ne"].indexOf(handle) !== -1) {
      _h = clamp2(h, 0, maxRows);
    }
    return {
      w: _w,
      h: _h
    };
  }
  function clamp2(num, lowerBound, upperBound) {
    return Math.max(Math.min(num, upperBound), lowerBound);
  }
  return calculateUtils;
}
var GridItem = {};
var propTypes$1 = { exports: {} };
var reactIs = { exports: {} };
var reactIs_production_min = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_production_min;
function requireReactIs_production_min() {
  if (hasRequiredReactIs_production_min) return reactIs_production_min;
  hasRequiredReactIs_production_min = 1;
  var b = "function" === typeof Symbol && Symbol.for, c = b ? Symbol.for("react.element") : 60103, d = b ? Symbol.for("react.portal") : 60106, e = b ? Symbol.for("react.fragment") : 60107, f = b ? Symbol.for("react.strict_mode") : 60108, g = b ? Symbol.for("react.profiler") : 60114, h = b ? Symbol.for("react.provider") : 60109, k = b ? Symbol.for("react.context") : 60110, l = b ? Symbol.for("react.async_mode") : 60111, m = b ? Symbol.for("react.concurrent_mode") : 60111, n2 = b ? Symbol.for("react.forward_ref") : 60112, p = b ? Symbol.for("react.suspense") : 60113, q = b ? Symbol.for("react.suspense_list") : 60120, r2 = b ? Symbol.for("react.memo") : 60115, t2 = b ? Symbol.for("react.lazy") : 60116, v = b ? Symbol.for("react.block") : 60121, w = b ? Symbol.for("react.fundamental") : 60117, x = b ? Symbol.for("react.responder") : 60118, y = b ? Symbol.for("react.scope") : 60119;
  function z2(a) {
    if ("object" === typeof a && null !== a) {
      var u = a.$$typeof;
      switch (u) {
        case c:
          switch (a = a.type, a) {
            case l:
            case m:
            case e:
            case g:
            case f:
            case p:
              return a;
            default:
              switch (a = a && a.$$typeof, a) {
                case k:
                case n2:
                case t2:
                case r2:
                case h:
                  return a;
                default:
                  return u;
              }
          }
        case d:
          return u;
      }
    }
  }
  function A(a) {
    return z2(a) === m;
  }
  reactIs_production_min.AsyncMode = l;
  reactIs_production_min.ConcurrentMode = m;
  reactIs_production_min.ContextConsumer = k;
  reactIs_production_min.ContextProvider = h;
  reactIs_production_min.Element = c;
  reactIs_production_min.ForwardRef = n2;
  reactIs_production_min.Fragment = e;
  reactIs_production_min.Lazy = t2;
  reactIs_production_min.Memo = r2;
  reactIs_production_min.Portal = d;
  reactIs_production_min.Profiler = g;
  reactIs_production_min.StrictMode = f;
  reactIs_production_min.Suspense = p;
  reactIs_production_min.isAsyncMode = function(a) {
    return A(a) || z2(a) === l;
  };
  reactIs_production_min.isConcurrentMode = A;
  reactIs_production_min.isContextConsumer = function(a) {
    return z2(a) === k;
  };
  reactIs_production_min.isContextProvider = function(a) {
    return z2(a) === h;
  };
  reactIs_production_min.isElement = function(a) {
    return "object" === typeof a && null !== a && a.$$typeof === c;
  };
  reactIs_production_min.isForwardRef = function(a) {
    return z2(a) === n2;
  };
  reactIs_production_min.isFragment = function(a) {
    return z2(a) === e;
  };
  reactIs_production_min.isLazy = function(a) {
    return z2(a) === t2;
  };
  reactIs_production_min.isMemo = function(a) {
    return z2(a) === r2;
  };
  reactIs_production_min.isPortal = function(a) {
    return z2(a) === d;
  };
  reactIs_production_min.isProfiler = function(a) {
    return z2(a) === g;
  };
  reactIs_production_min.isStrictMode = function(a) {
    return z2(a) === f;
  };
  reactIs_production_min.isSuspense = function(a) {
    return z2(a) === p;
  };
  reactIs_production_min.isValidElementType = function(a) {
    return "string" === typeof a || "function" === typeof a || a === e || a === m || a === g || a === f || a === p || a === q || "object" === typeof a && null !== a && (a.$$typeof === t2 || a.$$typeof === r2 || a.$$typeof === h || a.$$typeof === k || a.$$typeof === n2 || a.$$typeof === w || a.$$typeof === x || a.$$typeof === y || a.$$typeof === v);
  };
  reactIs_production_min.typeOf = z2;
  return reactIs_production_min;
}
var reactIs_development = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_development;
function requireReactIs_development() {
  if (hasRequiredReactIs_development) return reactIs_development;
  hasRequiredReactIs_development = 1;
  if (process.env.NODE_ENV !== "production") {
    (function() {
      var hasSymbol = typeof Symbol === "function" && Symbol.for;
      var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
      var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
      var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
      var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
      var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
      var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
      var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
      var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
      var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
      var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
      var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
      var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
      var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
      var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
      var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
      var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
      var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
      var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
      function isValidElementType(type2) {
        return typeof type2 === "string" || typeof type2 === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
        type2 === REACT_FRAGMENT_TYPE || type2 === REACT_CONCURRENT_MODE_TYPE || type2 === REACT_PROFILER_TYPE || type2 === REACT_STRICT_MODE_TYPE || type2 === REACT_SUSPENSE_TYPE || type2 === REACT_SUSPENSE_LIST_TYPE || typeof type2 === "object" && type2 !== null && (type2.$$typeof === REACT_LAZY_TYPE || type2.$$typeof === REACT_MEMO_TYPE || type2.$$typeof === REACT_PROVIDER_TYPE || type2.$$typeof === REACT_CONTEXT_TYPE || type2.$$typeof === REACT_FORWARD_REF_TYPE || type2.$$typeof === REACT_FUNDAMENTAL_TYPE || type2.$$typeof === REACT_RESPONDER_TYPE || type2.$$typeof === REACT_SCOPE_TYPE || type2.$$typeof === REACT_BLOCK_TYPE);
      }
      function typeOf(object) {
        if (typeof object === "object" && object !== null) {
          var $$typeof = object.$$typeof;
          switch ($$typeof) {
            case REACT_ELEMENT_TYPE:
              var type2 = object.type;
              switch (type2) {
                case REACT_ASYNC_MODE_TYPE:
                case REACT_CONCURRENT_MODE_TYPE:
                case REACT_FRAGMENT_TYPE:
                case REACT_PROFILER_TYPE:
                case REACT_STRICT_MODE_TYPE:
                case REACT_SUSPENSE_TYPE:
                  return type2;
                default:
                  var $$typeofType = type2 && type2.$$typeof;
                  switch ($$typeofType) {
                    case REACT_CONTEXT_TYPE:
                    case REACT_FORWARD_REF_TYPE:
                    case REACT_LAZY_TYPE:
                    case REACT_MEMO_TYPE:
                    case REACT_PROVIDER_TYPE:
                      return $$typeofType;
                    default:
                      return $$typeof;
                  }
              }
            case REACT_PORTAL_TYPE:
              return $$typeof;
          }
        }
        return void 0;
      }
      var AsyncMode = REACT_ASYNC_MODE_TYPE;
      var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
      var ContextConsumer = REACT_CONTEXT_TYPE;
      var ContextProvider = REACT_PROVIDER_TYPE;
      var Element2 = REACT_ELEMENT_TYPE;
      var ForwardRef = REACT_FORWARD_REF_TYPE;
      var Fragment = REACT_FRAGMENT_TYPE;
      var Lazy = REACT_LAZY_TYPE;
      var Memo = REACT_MEMO_TYPE;
      var Portal3 = REACT_PORTAL_TYPE;
      var Profiler = REACT_PROFILER_TYPE;
      var StrictMode = REACT_STRICT_MODE_TYPE;
      var Suspense2 = REACT_SUSPENSE_TYPE;
      var hasWarnedAboutDeprecatedIsAsyncMode = false;
      function isAsyncMode(object) {
        {
          if (!hasWarnedAboutDeprecatedIsAsyncMode) {
            hasWarnedAboutDeprecatedIsAsyncMode = true;
            console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
          }
        }
        return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
      }
      function isConcurrentMode(object) {
        return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
      }
      function isContextConsumer(object) {
        return typeOf(object) === REACT_CONTEXT_TYPE;
      }
      function isContextProvider(object) {
        return typeOf(object) === REACT_PROVIDER_TYPE;
      }
      function isElement2(object) {
        return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
      }
      function isForwardRef(object) {
        return typeOf(object) === REACT_FORWARD_REF_TYPE;
      }
      function isFragment(object) {
        return typeOf(object) === REACT_FRAGMENT_TYPE;
      }
      function isLazy(object) {
        return typeOf(object) === REACT_LAZY_TYPE;
      }
      function isMemo(object) {
        return typeOf(object) === REACT_MEMO_TYPE;
      }
      function isPortal(object) {
        return typeOf(object) === REACT_PORTAL_TYPE;
      }
      function isProfiler(object) {
        return typeOf(object) === REACT_PROFILER_TYPE;
      }
      function isStrictMode(object) {
        return typeOf(object) === REACT_STRICT_MODE_TYPE;
      }
      function isSuspense(object) {
        return typeOf(object) === REACT_SUSPENSE_TYPE;
      }
      reactIs_development.AsyncMode = AsyncMode;
      reactIs_development.ConcurrentMode = ConcurrentMode;
      reactIs_development.ContextConsumer = ContextConsumer;
      reactIs_development.ContextProvider = ContextProvider;
      reactIs_development.Element = Element2;
      reactIs_development.ForwardRef = ForwardRef;
      reactIs_development.Fragment = Fragment;
      reactIs_development.Lazy = Lazy;
      reactIs_development.Memo = Memo;
      reactIs_development.Portal = Portal3;
      reactIs_development.Profiler = Profiler;
      reactIs_development.StrictMode = StrictMode;
      reactIs_development.Suspense = Suspense2;
      reactIs_development.isAsyncMode = isAsyncMode;
      reactIs_development.isConcurrentMode = isConcurrentMode;
      reactIs_development.isContextConsumer = isContextConsumer;
      reactIs_development.isContextProvider = isContextProvider;
      reactIs_development.isElement = isElement2;
      reactIs_development.isForwardRef = isForwardRef;
      reactIs_development.isFragment = isFragment;
      reactIs_development.isLazy = isLazy;
      reactIs_development.isMemo = isMemo;
      reactIs_development.isPortal = isPortal;
      reactIs_development.isProfiler = isProfiler;
      reactIs_development.isStrictMode = isStrictMode;
      reactIs_development.isSuspense = isSuspense;
      reactIs_development.isValidElementType = isValidElementType;
      reactIs_development.typeOf = typeOf;
    })();
  }
  return reactIs_development;
}
var hasRequiredReactIs;
function requireReactIs() {
  if (hasRequiredReactIs) return reactIs.exports;
  hasRequiredReactIs = 1;
  if (process.env.NODE_ENV === "production") {
    reactIs.exports = requireReactIs_production_min();
  } else {
    reactIs.exports = requireReactIs_development();
  }
  return reactIs.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var objectAssign;
var hasRequiredObjectAssign;
function requireObjectAssign() {
  if (hasRequiredObjectAssign) return objectAssign;
  hasRequiredObjectAssign = 1;
  var getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var hasOwnProperty2 = Object.prototype.hasOwnProperty;
  var propIsEnumerable = Object.prototype.propertyIsEnumerable;
  function toObject(val) {
    if (val === null || val === void 0) {
      throw new TypeError("Object.assign cannot be called with null or undefined");
    }
    return Object(val);
  }
  function shouldUseNative() {
    try {
      if (!Object.assign) {
        return false;
      }
      var test1 = new String("abc");
      test1[5] = "de";
      if (Object.getOwnPropertyNames(test1)[0] === "5") {
        return false;
      }
      var test2 = {};
      for (var i2 = 0; i2 < 10; i2++) {
        test2["_" + String.fromCharCode(i2)] = i2;
      }
      var order2 = Object.getOwnPropertyNames(test2).map(function(n2) {
        return test2[n2];
      });
      if (order2.join("") !== "0123456789") {
        return false;
      }
      var test3 = {};
      "abcdefghijklmnopqrst".split("").forEach(function(letter) {
        test3[letter] = letter;
      });
      if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
        return false;
      }
      return true;
    } catch (err) {
      return false;
    }
  }
  objectAssign = shouldUseNative() ? Object.assign : function(target2, source2) {
    var from;
    var to = toObject(target2);
    var symbols;
    for (var s2 = 1; s2 < arguments.length; s2++) {
      from = Object(arguments[s2]);
      for (var key in from) {
        if (hasOwnProperty2.call(from, key)) {
          to[key] = from[key];
        }
      }
      if (getOwnPropertySymbols) {
        symbols = getOwnPropertySymbols(from);
        for (var i2 = 0; i2 < symbols.length; i2++) {
          if (propIsEnumerable.call(from, symbols[i2])) {
            to[symbols[i2]] = from[symbols[i2]];
          }
        }
      }
    }
    return to;
  };
  return objectAssign;
}
var ReactPropTypesSecret_1;
var hasRequiredReactPropTypesSecret;
function requireReactPropTypesSecret() {
  if (hasRequiredReactPropTypesSecret) return ReactPropTypesSecret_1;
  hasRequiredReactPropTypesSecret = 1;
  var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  ReactPropTypesSecret_1 = ReactPropTypesSecret;
  return ReactPropTypesSecret_1;
}
var has;
var hasRequiredHas;
function requireHas() {
  if (hasRequiredHas) return has;
  hasRequiredHas = 1;
  has = Function.call.bind(Object.prototype.hasOwnProperty);
  return has;
}
var checkPropTypes_1;
var hasRequiredCheckPropTypes;
function requireCheckPropTypes() {
  if (hasRequiredCheckPropTypes) return checkPropTypes_1;
  hasRequiredCheckPropTypes = 1;
  var printWarning = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var ReactPropTypesSecret = /* @__PURE__ */ requireReactPropTypesSecret();
    var loggedTypeFailures = {};
    var has2 = /* @__PURE__ */ requireHas();
    printWarning = function(text2) {
      var message2 = "Warning: " + text2;
      if (typeof console !== "undefined") {
        console.error(message2);
      }
      try {
        throw new Error(message2);
      } catch (x) {
      }
    };
  }
  function checkPropTypes(typeSpecs, values, location2, componentName, getStack) {
    if (process.env.NODE_ENV !== "production") {
      for (var typeSpecName in typeSpecs) {
        if (has2(typeSpecs, typeSpecName)) {
          var error2;
          try {
            if (typeof typeSpecs[typeSpecName] !== "function") {
              var err = Error(
                (componentName || "React class") + ": " + location2 + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              err.name = "Invariant Violation";
              throw err;
            }
            error2 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location2, null, ReactPropTypesSecret);
          } catch (ex) {
            error2 = ex;
          }
          if (error2 && !(error2 instanceof Error)) {
            printWarning(
              (componentName || "React class") + ": type specification of " + location2 + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error2 + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
            );
          }
          if (error2 instanceof Error && !(error2.message in loggedTypeFailures)) {
            loggedTypeFailures[error2.message] = true;
            var stack = getStack ? getStack() : "";
            printWarning(
              "Failed " + location2 + " type: " + error2.message + (stack != null ? stack : "")
            );
          }
        }
      }
    }
  }
  checkPropTypes.resetWarningCache = function() {
    if (process.env.NODE_ENV !== "production") {
      loggedTypeFailures = {};
    }
  };
  checkPropTypes_1 = checkPropTypes;
  return checkPropTypes_1;
}
var factoryWithTypeCheckers;
var hasRequiredFactoryWithTypeCheckers;
function requireFactoryWithTypeCheckers() {
  if (hasRequiredFactoryWithTypeCheckers) return factoryWithTypeCheckers;
  hasRequiredFactoryWithTypeCheckers = 1;
  var ReactIs = requireReactIs();
  var assign = requireObjectAssign();
  var ReactPropTypesSecret = /* @__PURE__ */ requireReactPropTypesSecret();
  var has2 = /* @__PURE__ */ requireHas();
  var checkPropTypes = /* @__PURE__ */ requireCheckPropTypes();
  var printWarning = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    printWarning = function(text2) {
      var message2 = "Warning: " + text2;
      if (typeof console !== "undefined") {
        console.error(message2);
      }
      try {
        throw new Error(message2);
      } catch (x) {
      }
    };
  }
  function emptyFunctionThatReturnsNull() {
    return null;
  }
  factoryWithTypeCheckers = function(isValidElement, throwOnDirectAccess) {
    var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = "@@iterator";
    function getIteratorFn(maybeIterable) {
      var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
      if (typeof iteratorFn === "function") {
        return iteratorFn;
      }
    }
    var ANONYMOUS = "<<anonymous>>";
    var ReactPropTypes = {
      array: createPrimitiveTypeChecker("array"),
      bigint: createPrimitiveTypeChecker("bigint"),
      bool: createPrimitiveTypeChecker("boolean"),
      func: createPrimitiveTypeChecker("function"),
      number: createPrimitiveTypeChecker("number"),
      object: createPrimitiveTypeChecker("object"),
      string: createPrimitiveTypeChecker("string"),
      symbol: createPrimitiveTypeChecker("symbol"),
      any: createAnyTypeChecker(),
      arrayOf: createArrayOfTypeChecker,
      element: createElementTypeChecker(),
      elementType: createElementTypeTypeChecker(),
      instanceOf: createInstanceTypeChecker,
      node: createNodeChecker(),
      objectOf: createObjectOfTypeChecker,
      oneOf: createEnumTypeChecker,
      oneOfType: createUnionTypeChecker,
      shape: createShapeTypeChecker,
      exact: createStrictShapeTypeChecker
    };
    function is(x, y) {
      if (x === y) {
        return x !== 0 || 1 / x === 1 / y;
      } else {
        return x !== x && y !== y;
      }
    }
    function PropTypeError(message2, data) {
      this.message = message2;
      this.data = data && typeof data === "object" ? data : {};
      this.stack = "";
    }
    PropTypeError.prototype = Error.prototype;
    function createChainableTypeChecker(validate) {
      if (process.env.NODE_ENV !== "production") {
        var manualPropTypeCallCache = {};
        var manualPropTypeWarningCount = 0;
      }
      function checkType(isRequired, props, propName, componentName, location2, propFullName, secret) {
        componentName = componentName || ANONYMOUS;
        propFullName = propFullName || propName;
        if (secret !== ReactPropTypesSecret) {
          if (throwOnDirectAccess) {
            var err = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            err.name = "Invariant Violation";
            throw err;
          } else if (process.env.NODE_ENV !== "production" && typeof console !== "undefined") {
            var cacheKey = componentName + ":" + propName;
            if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3) {
              printWarning(
                "You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
              );
              manualPropTypeCallCache[cacheKey] = true;
              manualPropTypeWarningCount++;
            }
          }
        }
        if (props[propName] == null) {
          if (isRequired) {
            if (props[propName] === null) {
              return new PropTypeError("The " + location2 + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
            }
            return new PropTypeError("The " + location2 + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
          }
          return null;
        } else {
          return validate(props, propName, componentName, location2, propFullName);
        }
      }
      var chainedCheckType = checkType.bind(null, false);
      chainedCheckType.isRequired = checkType.bind(null, true);
      return chainedCheckType;
    }
    function createPrimitiveTypeChecker(expectedType) {
      function validate(props, propName, componentName, location2, propFullName, secret) {
        var propValue = props[propName];
        var propType = getPropType(propValue);
        if (propType !== expectedType) {
          var preciseType = getPreciseType(propValue);
          return new PropTypeError(
            "Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."),
            { expectedType }
          );
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function createAnyTypeChecker() {
      return createChainableTypeChecker(emptyFunctionThatReturnsNull);
    }
    function createArrayOfTypeChecker(typeChecker) {
      function validate(props, propName, componentName, location2, propFullName) {
        if (typeof typeChecker !== "function") {
          return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
        }
        var propValue = props[propName];
        if (!Array.isArray(propValue)) {
          var propType = getPropType(propValue);
          return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
        }
        for (var i2 = 0; i2 < propValue.length; i2++) {
          var error2 = typeChecker(propValue, i2, componentName, location2, propFullName + "[" + i2 + "]", ReactPropTypesSecret);
          if (error2 instanceof Error) {
            return error2;
          }
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function createElementTypeChecker() {
      function validate(props, propName, componentName, location2, propFullName) {
        var propValue = props[propName];
        if (!isValidElement(propValue)) {
          var propType = getPropType(propValue);
          return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function createElementTypeTypeChecker() {
      function validate(props, propName, componentName, location2, propFullName) {
        var propValue = props[propName];
        if (!ReactIs.isValidElementType(propValue)) {
          var propType = getPropType(propValue);
          return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function createInstanceTypeChecker(expectedClass) {
      function validate(props, propName, componentName, location2, propFullName) {
        if (!(props[propName] instanceof expectedClass)) {
          var expectedClassName = expectedClass.name || ANONYMOUS;
          var actualClassName = getClassName(props[propName]);
          return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function createEnumTypeChecker(expectedValues) {
      if (!Array.isArray(expectedValues)) {
        if (process.env.NODE_ENV !== "production") {
          if (arguments.length > 1) {
            printWarning(
              "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
            );
          } else {
            printWarning("Invalid argument supplied to oneOf, expected an array.");
          }
        }
        return emptyFunctionThatReturnsNull;
      }
      function validate(props, propName, componentName, location2, propFullName) {
        var propValue = props[propName];
        for (var i2 = 0; i2 < expectedValues.length; i2++) {
          if (is(propValue, expectedValues[i2])) {
            return null;
          }
        }
        var valuesString = JSON.stringify(expectedValues, function replacer(key, value2) {
          var type2 = getPreciseType(value2);
          if (type2 === "symbol") {
            return String(value2);
          }
          return value2;
        });
        return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
      }
      return createChainableTypeChecker(validate);
    }
    function createObjectOfTypeChecker(typeChecker) {
      function validate(props, propName, componentName, location2, propFullName) {
        if (typeof typeChecker !== "function") {
          return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
        }
        var propValue = props[propName];
        var propType = getPropType(propValue);
        if (propType !== "object") {
          return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
        }
        for (var key in propValue) {
          if (has2(propValue, key)) {
            var error2 = typeChecker(propValue, key, componentName, location2, propFullName + "." + key, ReactPropTypesSecret);
            if (error2 instanceof Error) {
              return error2;
            }
          }
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function createUnionTypeChecker(arrayOfTypeCheckers) {
      if (!Array.isArray(arrayOfTypeCheckers)) {
        process.env.NODE_ENV !== "production" ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
        return emptyFunctionThatReturnsNull;
      }
      for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {
        var checker = arrayOfTypeCheckers[i2];
        if (typeof checker !== "function") {
          printWarning(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i2 + "."
          );
          return emptyFunctionThatReturnsNull;
        }
      }
      function validate(props, propName, componentName, location2, propFullName) {
        var expectedTypes = [];
        for (var i3 = 0; i3 < arrayOfTypeCheckers.length; i3++) {
          var checker2 = arrayOfTypeCheckers[i3];
          var checkerResult = checker2(props, propName, componentName, location2, propFullName, ReactPropTypesSecret);
          if (checkerResult == null) {
            return null;
          }
          if (checkerResult.data && has2(checkerResult.data, "expectedType")) {
            expectedTypes.push(checkerResult.data.expectedType);
          }
        }
        var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
        return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
      }
      return createChainableTypeChecker(validate);
    }
    function createNodeChecker() {
      function validate(props, propName, componentName, location2, propFullName) {
        if (!isNode2(props[propName])) {
          return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function invalidValidatorError(componentName, location2, propFullName, key, type2) {
      return new PropTypeError(
        (componentName || "React class") + ": " + location2 + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type2 + "`."
      );
    }
    function createShapeTypeChecker(shapeTypes) {
      function validate(props, propName, componentName, location2, propFullName) {
        var propValue = props[propName];
        var propType = getPropType(propValue);
        if (propType !== "object") {
          return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
        }
        for (var key in shapeTypes) {
          var checker = shapeTypes[key];
          if (typeof checker !== "function") {
            return invalidValidatorError(componentName, location2, propFullName, key, getPreciseType(checker));
          }
          var error2 = checker(propValue, key, componentName, location2, propFullName + "." + key, ReactPropTypesSecret);
          if (error2) {
            return error2;
          }
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function createStrictShapeTypeChecker(shapeTypes) {
      function validate(props, propName, componentName, location2, propFullName) {
        var propValue = props[propName];
        var propType = getPropType(propValue);
        if (propType !== "object") {
          return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
        }
        var allKeys = assign({}, props[propName], shapeTypes);
        for (var key in allKeys) {
          var checker = shapeTypes[key];
          if (has2(shapeTypes, key) && typeof checker !== "function") {
            return invalidValidatorError(componentName, location2, propFullName, key, getPreciseType(checker));
          }
          if (!checker) {
            return new PropTypeError(
              "Invalid " + location2 + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
            );
          }
          var error2 = checker(propValue, key, componentName, location2, propFullName + "." + key, ReactPropTypesSecret);
          if (error2) {
            return error2;
          }
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function isNode2(propValue) {
      switch (typeof propValue) {
        case "number":
        case "string":
        case "undefined":
          return true;
        case "boolean":
          return !propValue;
        case "object":
          if (Array.isArray(propValue)) {
            return propValue.every(isNode2);
          }
          if (propValue === null || isValidElement(propValue)) {
            return true;
          }
          var iteratorFn = getIteratorFn(propValue);
          if (iteratorFn) {
            var iterator = iteratorFn.call(propValue);
            var step;
            if (iteratorFn !== propValue.entries) {
              while (!(step = iterator.next()).done) {
                if (!isNode2(step.value)) {
                  return false;
                }
              }
            } else {
              while (!(step = iterator.next()).done) {
                var entry = step.value;
                if (entry) {
                  if (!isNode2(entry[1])) {
                    return false;
                  }
                }
              }
            }
          } else {
            return false;
          }
          return true;
        default:
          return false;
      }
    }
    function isSymbol2(propType, propValue) {
      if (propType === "symbol") {
        return true;
      }
      if (!propValue) {
        return false;
      }
      if (propValue["@@toStringTag"] === "Symbol") {
        return true;
      }
      if (typeof Symbol === "function" && propValue instanceof Symbol) {
        return true;
      }
      return false;
    }
    function getPropType(propValue) {
      var propType = typeof propValue;
      if (Array.isArray(propValue)) {
        return "array";
      }
      if (propValue instanceof RegExp) {
        return "object";
      }
      if (isSymbol2(propType, propValue)) {
        return "symbol";
      }
      return propType;
    }
    function getPreciseType(propValue) {
      if (typeof propValue === "undefined" || propValue === null) {
        return "" + propValue;
      }
      var propType = getPropType(propValue);
      if (propType === "object") {
        if (propValue instanceof Date) {
          return "date";
        } else if (propValue instanceof RegExp) {
          return "regexp";
        }
      }
      return propType;
    }
    function getPostfixForTypeWarning(value2) {
      var type2 = getPreciseType(value2);
      switch (type2) {
        case "array":
        case "object":
          return "an " + type2;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + type2;
        default:
          return type2;
      }
    }
    function getClassName(propValue) {
      if (!propValue.constructor || !propValue.constructor.name) {
        return ANONYMOUS;
      }
      return propValue.constructor.name;
    }
    ReactPropTypes.checkPropTypes = checkPropTypes;
    ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
    ReactPropTypes.PropTypes = ReactPropTypes;
    return ReactPropTypes;
  };
  return factoryWithTypeCheckers;
}
var factoryWithThrowingShims;
var hasRequiredFactoryWithThrowingShims;
function requireFactoryWithThrowingShims() {
  if (hasRequiredFactoryWithThrowingShims) return factoryWithThrowingShims;
  hasRequiredFactoryWithThrowingShims = 1;
  var ReactPropTypesSecret = /* @__PURE__ */ requireReactPropTypesSecret();
  function emptyFunction() {
  }
  function emptyFunctionWithReset() {
  }
  emptyFunctionWithReset.resetWarningCache = emptyFunction;
  factoryWithThrowingShims = function() {
    function shim(props, propName, componentName, location2, propFullName, secret) {
      if (secret === ReactPropTypesSecret) {
        return;
      }
      var err = new Error(
        "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
      );
      err.name = "Invariant Violation";
      throw err;
    }
    shim.isRequired = shim;
    function getShim() {
      return shim;
    }
    var ReactPropTypes = {
      array: shim,
      bigint: shim,
      bool: shim,
      func: shim,
      number: shim,
      object: shim,
      string: shim,
      symbol: shim,
      any: shim,
      arrayOf: getShim,
      element: shim,
      elementType: shim,
      instanceOf: getShim,
      node: shim,
      objectOf: getShim,
      oneOf: getShim,
      oneOfType: getShim,
      shape: getShim,
      exact: getShim,
      checkPropTypes: emptyFunctionWithReset,
      resetWarningCache: emptyFunction
    };
    ReactPropTypes.PropTypes = ReactPropTypes;
    return ReactPropTypes;
  };
  return factoryWithThrowingShims;
}
var hasRequiredPropTypes$1;
function requirePropTypes$1() {
  if (hasRequiredPropTypes$1) return propTypes$1.exports;
  hasRequiredPropTypes$1 = 1;
  if (process.env.NODE_ENV !== "production") {
    var ReactIs = requireReactIs();
    var throwOnDirectAccess = true;
    propTypes$1.exports = /* @__PURE__ */ requireFactoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
  } else {
    propTypes$1.exports = /* @__PURE__ */ requireFactoryWithThrowingShims()();
  }
  return propTypes$1.exports;
}
var cjs = { exports: {} };
var Draggable = {};
function r$1(e) {
  var t2, f, n2 = "";
  if ("string" == typeof e || "number" == typeof e) n2 += e;
  else if ("object" == typeof e) if (Array.isArray(e)) for (t2 = 0; t2 < e.length; t2++) e[t2] && (f = r$1(e[t2])) && (n2 && (n2 += " "), n2 += f);
  else for (t2 in e) e[t2] && (n2 && (n2 += " "), n2 += t2);
  return n2;
}
function clsx() {
  for (var e, t2, f = 0, n2 = ""; f < arguments.length; ) (e = arguments[f++]) && (t2 = r$1(e)) && (n2 && (n2 += " "), n2 += t2);
  return n2;
}
const clsx_m = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  clsx,
  default: clsx
}, Symbol.toStringTag, { value: "Module" }));
const require$$3 = /* @__PURE__ */ getAugmentedNamespace(clsx_m);
var domFns = {};
var shims = {};
var hasRequiredShims;
function requireShims() {
  if (hasRequiredShims) return shims;
  hasRequiredShims = 1;
  Object.defineProperty(shims, "__esModule", {
    value: true
  });
  shims.dontSetMe = dontSetMe;
  shims.findInArray = findInArray;
  shims.int = int;
  shims.isFunction = isFunction2;
  shims.isNum = isNum;
  function findInArray(array, callback) {
    for (let i2 = 0, length = array.length; i2 < length; i2++) {
      if (callback.apply(callback, [array[i2], i2, array])) return array[i2];
    }
  }
  function isFunction2(func) {
    return typeof func === "function" || Object.prototype.toString.call(func) === "[object Function]";
  }
  function isNum(num) {
    return typeof num === "number" && !isNaN(num);
  }
  function int(a) {
    return parseInt(a, 10);
  }
  function dontSetMe(props, propName, componentName) {
    if (props[propName]) {
      return new Error("Invalid prop ".concat(propName, " passed to ").concat(componentName, " - do not set this, set it on the child."));
    }
  }
  return shims;
}
var getPrefix = {};
var hasRequiredGetPrefix;
function requireGetPrefix() {
  if (hasRequiredGetPrefix) return getPrefix;
  hasRequiredGetPrefix = 1;
  Object.defineProperty(getPrefix, "__esModule", {
    value: true
  });
  getPrefix.browserPrefixToKey = browserPrefixToKey;
  getPrefix.browserPrefixToStyle = browserPrefixToStyle;
  getPrefix.default = void 0;
  getPrefix.getPrefix = getPrefix$1;
  const prefixes = ["Moz", "Webkit", "O", "ms"];
  function getPrefix$1() {
    var _window$document;
    let prop = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "transform";
    if (typeof window === "undefined") return "";
    const style = (_window$document = window.document) === null || _window$document === void 0 || (_window$document = _window$document.documentElement) === null || _window$document === void 0 ? void 0 : _window$document.style;
    if (!style) return "";
    if (prop in style) return "";
    for (let i2 = 0; i2 < prefixes.length; i2++) {
      if (browserPrefixToKey(prop, prefixes[i2]) in style) return prefixes[i2];
    }
    return "";
  }
  function browserPrefixToKey(prop, prefix) {
    return prefix ? "".concat(prefix).concat(kebabToTitleCase(prop)) : prop;
  }
  function browserPrefixToStyle(prop, prefix) {
    return prefix ? "-".concat(prefix.toLowerCase(), "-").concat(prop) : prop;
  }
  function kebabToTitleCase(str) {
    let out = "";
    let shouldCapitalize = true;
    for (let i2 = 0; i2 < str.length; i2++) {
      if (shouldCapitalize) {
        out += str[i2].toUpperCase();
        shouldCapitalize = false;
      } else if (str[i2] === "-") {
        shouldCapitalize = true;
      } else {
        out += str[i2];
      }
    }
    return out;
  }
  getPrefix.default = getPrefix$1();
  return getPrefix;
}
var hasRequiredDomFns;
function requireDomFns() {
  if (hasRequiredDomFns) return domFns;
  hasRequiredDomFns = 1;
  Object.defineProperty(domFns, "__esModule", {
    value: true
  });
  domFns.addClassName = addClassName;
  domFns.addEvent = addEvent;
  domFns.addUserSelectStyles = addUserSelectStyles;
  domFns.createCSSTransform = createCSSTransform;
  domFns.createSVGTransform = createSVGTransform;
  domFns.getTouch = getTouch;
  domFns.getTouchIdentifier = getTouchIdentifier;
  domFns.getTranslation = getTranslation;
  domFns.innerHeight = innerHeight;
  domFns.innerWidth = innerWidth;
  domFns.matchesSelector = matchesSelector;
  domFns.matchesSelectorAndParentsTo = matchesSelectorAndParentsTo;
  domFns.offsetXYFromParent = offsetXYFromParent;
  domFns.outerHeight = outerHeight;
  domFns.outerWidth = outerWidth;
  domFns.removeClassName = removeClassName;
  domFns.removeEvent = removeEvent;
  domFns.removeUserSelectStyles = removeUserSelectStyles;
  var _shims = requireShims();
  var _getPrefix = _interopRequireWildcard(requireGetPrefix());
  function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
    var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop2) {
      return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
  }
  function _interopRequireWildcard(obj, nodeInterop) {
    if (obj && obj.__esModule) {
      return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
      return { default: obj };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) {
      if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
    newObj.default = obj;
    if (cache) {
      cache.set(obj, newObj);
    }
    return newObj;
  }
  let matchesSelectorFunc = "";
  function matchesSelector(el, selector) {
    if (!matchesSelectorFunc) {
      matchesSelectorFunc = (0, _shims.findInArray)(["matches", "webkitMatchesSelector", "mozMatchesSelector", "msMatchesSelector", "oMatchesSelector"], function(method) {
        return (0, _shims.isFunction)(el[method]);
      });
    }
    if (!(0, _shims.isFunction)(el[matchesSelectorFunc])) return false;
    return el[matchesSelectorFunc](selector);
  }
  function matchesSelectorAndParentsTo(el, selector, baseNode) {
    let node = el;
    do {
      if (matchesSelector(node, selector)) return true;
      if (node === baseNode) return false;
      node = node.parentNode;
    } while (node);
    return false;
  }
  function addEvent(el, event, handler, inputOptions) {
    if (!el) return;
    const options = {
      capture: true,
      ...inputOptions
    };
    if (el.addEventListener) {
      el.addEventListener(event, handler, options);
    } else if (el.attachEvent) {
      el.attachEvent("on" + event, handler);
    } else {
      el["on" + event] = handler;
    }
  }
  function removeEvent(el, event, handler, inputOptions) {
    if (!el) return;
    const options = {
      capture: true,
      ...inputOptions
    };
    if (el.removeEventListener) {
      el.removeEventListener(event, handler, options);
    } else if (el.detachEvent) {
      el.detachEvent("on" + event, handler);
    } else {
      el["on" + event] = null;
    }
  }
  function outerHeight(node) {
    let height = node.clientHeight;
    const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
    height += (0, _shims.int)(computedStyle.borderTopWidth);
    height += (0, _shims.int)(computedStyle.borderBottomWidth);
    return height;
  }
  function outerWidth(node) {
    let width = node.clientWidth;
    const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
    width += (0, _shims.int)(computedStyle.borderLeftWidth);
    width += (0, _shims.int)(computedStyle.borderRightWidth);
    return width;
  }
  function innerHeight(node) {
    let height = node.clientHeight;
    const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
    height -= (0, _shims.int)(computedStyle.paddingTop);
    height -= (0, _shims.int)(computedStyle.paddingBottom);
    return height;
  }
  function innerWidth(node) {
    let width = node.clientWidth;
    const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
    width -= (0, _shims.int)(computedStyle.paddingLeft);
    width -= (0, _shims.int)(computedStyle.paddingRight);
    return width;
  }
  function offsetXYFromParent(evt, offsetParent, scale) {
    const isBody = offsetParent === offsetParent.ownerDocument.body;
    const offsetParentRect = isBody ? {
      left: 0,
      top: 0
    } : offsetParent.getBoundingClientRect();
    const x = (evt.clientX + offsetParent.scrollLeft - offsetParentRect.left) / scale;
    const y = (evt.clientY + offsetParent.scrollTop - offsetParentRect.top) / scale;
    return {
      x,
      y
    };
  }
  function createCSSTransform(controlPos, positionOffset) {
    const translation = getTranslation(controlPos, positionOffset, "px");
    return {
      [(0, _getPrefix.browserPrefixToKey)("transform", _getPrefix.default)]: translation
    };
  }
  function createSVGTransform(controlPos, positionOffset) {
    const translation = getTranslation(controlPos, positionOffset, "");
    return translation;
  }
  function getTranslation(_ref, positionOffset, unitSuffix) {
    let {
      x,
      y
    } = _ref;
    let translation = "translate(".concat(x).concat(unitSuffix, ",").concat(y).concat(unitSuffix, ")");
    if (positionOffset) {
      const defaultX = "".concat(typeof positionOffset.x === "string" ? positionOffset.x : positionOffset.x + unitSuffix);
      const defaultY = "".concat(typeof positionOffset.y === "string" ? positionOffset.y : positionOffset.y + unitSuffix);
      translation = "translate(".concat(defaultX, ", ").concat(defaultY, ")") + translation;
    }
    return translation;
  }
  function getTouch(e, identifier) {
    return e.targetTouches && (0, _shims.findInArray)(e.targetTouches, (t2) => identifier === t2.identifier) || e.changedTouches && (0, _shims.findInArray)(e.changedTouches, (t2) => identifier === t2.identifier);
  }
  function getTouchIdentifier(e) {
    if (e.targetTouches && e.targetTouches[0]) return e.targetTouches[0].identifier;
    if (e.changedTouches && e.changedTouches[0]) return e.changedTouches[0].identifier;
  }
  function addUserSelectStyles(doc) {
    if (!doc) return;
    let styleEl = doc.getElementById("react-draggable-style-el");
    if (!styleEl) {
      styleEl = doc.createElement("style");
      styleEl.type = "text/css";
      styleEl.id = "react-draggable-style-el";
      styleEl.innerHTML = ".react-draggable-transparent-selection *::-moz-selection {all: inherit;}\n";
      styleEl.innerHTML += ".react-draggable-transparent-selection *::selection {all: inherit;}\n";
      doc.getElementsByTagName("head")[0].appendChild(styleEl);
    }
    if (doc.body) addClassName(doc.body, "react-draggable-transparent-selection");
  }
  function removeUserSelectStyles(doc) {
    if (!doc) return;
    try {
      if (doc.body) removeClassName(doc.body, "react-draggable-transparent-selection");
      if (doc.selection) {
        doc.selection.empty();
      } else {
        const selection = (doc.defaultView || window).getSelection();
        if (selection && selection.type !== "Caret") {
          selection.removeAllRanges();
        }
      }
    } catch (e) {
    }
  }
  function addClassName(el, className) {
    if (el.classList) {
      el.classList.add(className);
    } else {
      if (!el.className.match(new RegExp("(?:^|\\s)".concat(className, "(?!\\S)")))) {
        el.className += " ".concat(className);
      }
    }
  }
  function removeClassName(el, className) {
    if (el.classList) {
      el.classList.remove(className);
    } else {
      el.className = el.className.replace(new RegExp("(?:^|\\s)".concat(className, "(?!\\S)"), "g"), "");
    }
  }
  return domFns;
}
var positionFns = {};
var hasRequiredPositionFns;
function requirePositionFns() {
  if (hasRequiredPositionFns) return positionFns;
  hasRequiredPositionFns = 1;
  Object.defineProperty(positionFns, "__esModule", {
    value: true
  });
  positionFns.canDragX = canDragX;
  positionFns.canDragY = canDragY;
  positionFns.createCoreData = createCoreData;
  positionFns.createDraggableData = createDraggableData;
  positionFns.getBoundPosition = getBoundPosition;
  positionFns.getControlPosition = getControlPosition;
  positionFns.snapToGrid = snapToGrid;
  var _shims = requireShims();
  var _domFns = requireDomFns();
  function getBoundPosition(draggable, x, y) {
    if (!draggable.props.bounds) return [x, y];
    let {
      bounds
    } = draggable.props;
    bounds = typeof bounds === "string" ? bounds : cloneBounds(bounds);
    const node = findDOMNode(draggable);
    if (typeof bounds === "string") {
      const {
        ownerDocument
      } = node;
      const ownerWindow = ownerDocument.defaultView;
      let boundNode;
      if (bounds === "parent") {
        boundNode = node.parentNode;
      } else {
        boundNode = ownerDocument.querySelector(bounds);
      }
      if (!(boundNode instanceof ownerWindow.HTMLElement)) {
        throw new Error('Bounds selector "' + bounds + '" could not find an element.');
      }
      const boundNodeEl = boundNode;
      const nodeStyle = ownerWindow.getComputedStyle(node);
      const boundNodeStyle = ownerWindow.getComputedStyle(boundNodeEl);
      bounds = {
        left: -node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingLeft) + (0, _shims.int)(nodeStyle.marginLeft),
        top: -node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingTop) + (0, _shims.int)(nodeStyle.marginTop),
        right: (0, _domFns.innerWidth)(boundNodeEl) - (0, _domFns.outerWidth)(node) - node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingRight) - (0, _shims.int)(nodeStyle.marginRight),
        bottom: (0, _domFns.innerHeight)(boundNodeEl) - (0, _domFns.outerHeight)(node) - node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingBottom) - (0, _shims.int)(nodeStyle.marginBottom)
      };
    }
    if ((0, _shims.isNum)(bounds.right)) x = Math.min(x, bounds.right);
    if ((0, _shims.isNum)(bounds.bottom)) y = Math.min(y, bounds.bottom);
    if ((0, _shims.isNum)(bounds.left)) x = Math.max(x, bounds.left);
    if ((0, _shims.isNum)(bounds.top)) y = Math.max(y, bounds.top);
    return [x, y];
  }
  function snapToGrid(grid, pendingX, pendingY) {
    const x = Math.round(pendingX / grid[0]) * grid[0];
    const y = Math.round(pendingY / grid[1]) * grid[1];
    return [x, y];
  }
  function canDragX(draggable) {
    return draggable.props.axis === "both" || draggable.props.axis === "x";
  }
  function canDragY(draggable) {
    return draggable.props.axis === "both" || draggable.props.axis === "y";
  }
  function getControlPosition(e, touchIdentifier, draggableCore) {
    const touchObj = typeof touchIdentifier === "number" ? (0, _domFns.getTouch)(e, touchIdentifier) : null;
    if (typeof touchIdentifier === "number" && !touchObj) return null;
    const node = findDOMNode(draggableCore);
    const offsetParent = draggableCore.props.offsetParent || node.offsetParent || node.ownerDocument.body;
    return (0, _domFns.offsetXYFromParent)(touchObj || e, offsetParent, draggableCore.props.scale);
  }
  function createCoreData(draggable, x, y) {
    const isStart = !(0, _shims.isNum)(draggable.lastX);
    const node = findDOMNode(draggable);
    if (isStart) {
      return {
        node,
        deltaX: 0,
        deltaY: 0,
        lastX: x,
        lastY: y,
        x,
        y
      };
    } else {
      return {
        node,
        deltaX: x - draggable.lastX,
        deltaY: y - draggable.lastY,
        lastX: draggable.lastX,
        lastY: draggable.lastY,
        x,
        y
      };
    }
  }
  function createDraggableData(draggable, coreData) {
    const scale = draggable.props.scale;
    return {
      node: coreData.node,
      x: draggable.state.x + coreData.deltaX / scale,
      y: draggable.state.y + coreData.deltaY / scale,
      deltaX: coreData.deltaX / scale,
      deltaY: coreData.deltaY / scale,
      lastX: draggable.state.x,
      lastY: draggable.state.y
    };
  }
  function cloneBounds(bounds) {
    return {
      left: bounds.left,
      top: bounds.top,
      right: bounds.right,
      bottom: bounds.bottom
    };
  }
  function findDOMNode(draggable) {
    const node = draggable.findDOMNode();
    if (!node) {
      throw new Error("<DraggableCore>: Unmounted during event!");
    }
    return node;
  }
  return positionFns;
}
var DraggableCore = {};
var log = {};
var hasRequiredLog;
function requireLog() {
  if (hasRequiredLog) return log;
  hasRequiredLog = 1;
  Object.defineProperty(log, "__esModule", {
    value: true
  });
  log.default = log$1;
  function log$1() {
  }
  return log;
}
var hasRequiredDraggableCore;
function requireDraggableCore() {
  if (hasRequiredDraggableCore) return DraggableCore;
  hasRequiredDraggableCore = 1;
  Object.defineProperty(DraggableCore, "__esModule", {
    value: true
  });
  DraggableCore.default = void 0;
  var React2 = _interopRequireWildcard(React__default);
  var _propTypes = _interopRequireDefault(/* @__PURE__ */ requirePropTypes$1());
  var _reactDom = _interopRequireDefault(ReactDOM__default);
  var _domFns = requireDomFns();
  var _positionFns = requirePositionFns();
  var _shims = requireShims();
  var _log = _interopRequireDefault(requireLog());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
    var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop2) {
      return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
  }
  function _interopRequireWildcard(obj, nodeInterop) {
    if (obj && obj.__esModule) {
      return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
      return { default: obj };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) {
      if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
    newObj.default = obj;
    if (cache) {
      cache.set(obj, newObj);
    }
    return newObj;
  }
  function _defineProperty2(obj, key, value2) {
    key = _toPropertyKey2(key);
    if (key in obj) {
      Object.defineProperty(obj, key, { value: value2, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value2;
    }
    return obj;
  }
  function _toPropertyKey2(arg) {
    var key = _toPrimitive2(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _toPrimitive2(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  const eventsFor = {
    touch: {
      start: "touchstart",
      move: "touchmove",
      stop: "touchend"
    },
    mouse: {
      start: "mousedown",
      move: "mousemove",
      stop: "mouseup"
    }
  };
  let dragEventFor = eventsFor.mouse;
  let DraggableCore$1 = class DraggableCore extends React2.Component {
    constructor() {
      super(...arguments);
      _defineProperty2(this, "dragging", false);
      _defineProperty2(this, "lastX", NaN);
      _defineProperty2(this, "lastY", NaN);
      _defineProperty2(this, "touchIdentifier", null);
      _defineProperty2(this, "mounted", false);
      _defineProperty2(this, "handleDragStart", (e) => {
        this.props.onMouseDown(e);
        if (!this.props.allowAnyClick && typeof e.button === "number" && e.button !== 0) return false;
        const thisNode = this.findDOMNode();
        if (!thisNode || !thisNode.ownerDocument || !thisNode.ownerDocument.body) {
          throw new Error("<DraggableCore> not mounted on DragStart!");
        }
        const {
          ownerDocument
        } = thisNode;
        if (this.props.disabled || !(e.target instanceof ownerDocument.defaultView.Node) || this.props.handle && !(0, _domFns.matchesSelectorAndParentsTo)(e.target, this.props.handle, thisNode) || this.props.cancel && (0, _domFns.matchesSelectorAndParentsTo)(e.target, this.props.cancel, thisNode)) {
          return;
        }
        if (e.type === "touchstart") e.preventDefault();
        const touchIdentifier = (0, _domFns.getTouchIdentifier)(e);
        this.touchIdentifier = touchIdentifier;
        const position2 = (0, _positionFns.getControlPosition)(e, touchIdentifier, this);
        if (position2 == null) return;
        const {
          x,
          y
        } = position2;
        const coreEvent = (0, _positionFns.createCoreData)(this, x, y);
        (0, _log.default)("DraggableCore: handleDragStart: %j", coreEvent);
        (0, _log.default)("calling", this.props.onStart);
        const shouldUpdate = this.props.onStart(e, coreEvent);
        if (shouldUpdate === false || this.mounted === false) return;
        if (this.props.enableUserSelectHack) (0, _domFns.addUserSelectStyles)(ownerDocument);
        this.dragging = true;
        this.lastX = x;
        this.lastY = y;
        (0, _domFns.addEvent)(ownerDocument, dragEventFor.move, this.handleDrag);
        (0, _domFns.addEvent)(ownerDocument, dragEventFor.stop, this.handleDragStop);
      });
      _defineProperty2(this, "handleDrag", (e) => {
        const position2 = (0, _positionFns.getControlPosition)(e, this.touchIdentifier, this);
        if (position2 == null) return;
        let {
          x,
          y
        } = position2;
        if (Array.isArray(this.props.grid)) {
          let deltaX = x - this.lastX, deltaY = y - this.lastY;
          [deltaX, deltaY] = (0, _positionFns.snapToGrid)(this.props.grid, deltaX, deltaY);
          if (!deltaX && !deltaY) return;
          x = this.lastX + deltaX, y = this.lastY + deltaY;
        }
        const coreEvent = (0, _positionFns.createCoreData)(this, x, y);
        (0, _log.default)("DraggableCore: handleDrag: %j", coreEvent);
        const shouldUpdate = this.props.onDrag(e, coreEvent);
        if (shouldUpdate === false || this.mounted === false) {
          try {
            this.handleDragStop(new MouseEvent("mouseup"));
          } catch (err) {
            const event = document.createEvent("MouseEvents");
            event.initMouseEvent("mouseup", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
            this.handleDragStop(event);
          }
          return;
        }
        this.lastX = x;
        this.lastY = y;
      });
      _defineProperty2(this, "handleDragStop", (e) => {
        if (!this.dragging) return;
        const position2 = (0, _positionFns.getControlPosition)(e, this.touchIdentifier, this);
        if (position2 == null) return;
        let {
          x,
          y
        } = position2;
        if (Array.isArray(this.props.grid)) {
          let deltaX = x - this.lastX || 0;
          let deltaY = y - this.lastY || 0;
          [deltaX, deltaY] = (0, _positionFns.snapToGrid)(this.props.grid, deltaX, deltaY);
          x = this.lastX + deltaX, y = this.lastY + deltaY;
        }
        const coreEvent = (0, _positionFns.createCoreData)(this, x, y);
        const shouldContinue = this.props.onStop(e, coreEvent);
        if (shouldContinue === false || this.mounted === false) return false;
        const thisNode = this.findDOMNode();
        if (thisNode) {
          if (this.props.enableUserSelectHack) (0, _domFns.removeUserSelectStyles)(thisNode.ownerDocument);
        }
        (0, _log.default)("DraggableCore: handleDragStop: %j", coreEvent);
        this.dragging = false;
        this.lastX = NaN;
        this.lastY = NaN;
        if (thisNode) {
          (0, _log.default)("DraggableCore: Removing handlers");
          (0, _domFns.removeEvent)(thisNode.ownerDocument, dragEventFor.move, this.handleDrag);
          (0, _domFns.removeEvent)(thisNode.ownerDocument, dragEventFor.stop, this.handleDragStop);
        }
      });
      _defineProperty2(this, "onMouseDown", (e) => {
        dragEventFor = eventsFor.mouse;
        return this.handleDragStart(e);
      });
      _defineProperty2(this, "onMouseUp", (e) => {
        dragEventFor = eventsFor.mouse;
        return this.handleDragStop(e);
      });
      _defineProperty2(this, "onTouchStart", (e) => {
        dragEventFor = eventsFor.touch;
        return this.handleDragStart(e);
      });
      _defineProperty2(this, "onTouchEnd", (e) => {
        dragEventFor = eventsFor.touch;
        return this.handleDragStop(e);
      });
    }
    componentDidMount() {
      this.mounted = true;
      const thisNode = this.findDOMNode();
      if (thisNode) {
        (0, _domFns.addEvent)(thisNode, eventsFor.touch.start, this.onTouchStart, {
          passive: false
        });
      }
    }
    componentWillUnmount() {
      this.mounted = false;
      const thisNode = this.findDOMNode();
      if (thisNode) {
        const {
          ownerDocument
        } = thisNode;
        (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.move, this.handleDrag);
        (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.move, this.handleDrag);
        (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.stop, this.handleDragStop);
        (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.stop, this.handleDragStop);
        (0, _domFns.removeEvent)(thisNode, eventsFor.touch.start, this.onTouchStart, {
          passive: false
        });
        if (this.props.enableUserSelectHack) (0, _domFns.removeUserSelectStyles)(ownerDocument);
      }
    }
    // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find
    // the underlying DOM node ourselves. See the README for more information.
    findDOMNode() {
      var _this$props, _this$props2;
      return (_this$props = this.props) !== null && _this$props !== void 0 && _this$props.nodeRef ? (_this$props2 = this.props) === null || _this$props2 === void 0 || (_this$props2 = _this$props2.nodeRef) === null || _this$props2 === void 0 ? void 0 : _this$props2.current : _reactDom.default.findDOMNode(this);
    }
    render() {
      return /* @__PURE__ */ React2.cloneElement(React2.Children.only(this.props.children), {
        // Note: mouseMove handler is attached to document so it will still function
        // when the user drags quickly and leaves the bounds of the element.
        onMouseDown: this.onMouseDown,
        onMouseUp: this.onMouseUp,
        // onTouchStart is added on `componentDidMount` so they can be added with
        // {passive: false}, which allows it to cancel. See
        // https://developers.google.com/web/updates/2017/01/scrolling-intervention
        onTouchEnd: this.onTouchEnd
      });
    }
  };
  DraggableCore.default = DraggableCore$1;
  _defineProperty2(DraggableCore$1, "displayName", "DraggableCore");
  _defineProperty2(DraggableCore$1, "propTypes", {
    /**
     * `allowAnyClick` allows dragging using any mouse button.
     * By default, we only accept the left button.
     *
     * Defaults to `false`.
     */
    allowAnyClick: _propTypes.default.bool,
    children: _propTypes.default.node.isRequired,
    /**
     * `disabled`, if true, stops the <Draggable> from dragging. All handlers,
     * with the exception of `onMouseDown`, will not fire.
     */
    disabled: _propTypes.default.bool,
    /**
     * By default, we add 'user-select:none' attributes to the document body
     * to prevent ugly text selection during drag. If this is causing problems
     * for your app, set this to `false`.
     */
    enableUserSelectHack: _propTypes.default.bool,
    /**
     * `offsetParent`, if set, uses the passed DOM node to compute drag offsets
     * instead of using the parent node.
     */
    offsetParent: function(props, propName) {
      if (props[propName] && props[propName].nodeType !== 1) {
        throw new Error("Draggable's offsetParent must be a DOM Node.");
      }
    },
    /**
     * `grid` specifies the x and y that dragging should snap to.
     */
    grid: _propTypes.default.arrayOf(_propTypes.default.number),
    /**
     * `handle` specifies a selector to be used as the handle that initiates drag.
     *
     * Example:
     *
     * ```jsx
     *   let App = React.createClass({
     *       render: function () {
     *         return (
     *            <Draggable handle=".handle">
     *              <div>
     *                  <div className="handle">Click me to drag</div>
     *                  <div>This is some other content</div>
     *              </div>
     *           </Draggable>
     *         );
     *       }
     *   });
     * ```
     */
    handle: _propTypes.default.string,
    /**
     * `cancel` specifies a selector to be used to prevent drag initialization.
     *
     * Example:
     *
     * ```jsx
     *   let App = React.createClass({
     *       render: function () {
     *           return(
     *               <Draggable cancel=".cancel">
     *                   <div>
     *                     <div className="cancel">You can't drag from here</div>
     *                     <div>Dragging here works fine</div>
     *                   </div>
     *               </Draggable>
     *           );
     *       }
     *   });
     * ```
     */
    cancel: _propTypes.default.string,
    /* If running in React Strict mode, ReactDOM.findDOMNode() is deprecated.
     * Unfortunately, in order for <Draggable> to work properly, we need raw access
     * to the underlying DOM node. If you want to avoid the warning, pass a `nodeRef`
     * as in this example:
     *
     * function MyComponent() {
     *   const nodeRef = React.useRef(null);
     *   return (
     *     <Draggable nodeRef={nodeRef}>
     *       <div ref={nodeRef}>Example Target</div>
     *     </Draggable>
     *   );
     * }
     *
     * This can be used for arbitrarily nested components, so long as the ref ends up
     * pointing to the actual child DOM node and not a custom component.
     */
    nodeRef: _propTypes.default.object,
    /**
     * Called when dragging starts.
     * If this function returns the boolean false, dragging will be canceled.
     */
    onStart: _propTypes.default.func,
    /**
     * Called while dragging.
     * If this function returns the boolean false, dragging will be canceled.
     */
    onDrag: _propTypes.default.func,
    /**
     * Called when dragging stops.
     * If this function returns the boolean false, the drag will remain active.
     */
    onStop: _propTypes.default.func,
    /**
     * A workaround option which can be passed if onMouseDown needs to be accessed,
     * since it'll always be blocked (as there is internal use of onMouseDown)
     */
    onMouseDown: _propTypes.default.func,
    /**
     * `scale`, if set, applies scaling while dragging an element
     */
    scale: _propTypes.default.number,
    /**
     * These properties should be defined on the child, not here.
     */
    className: _shims.dontSetMe,
    style: _shims.dontSetMe,
    transform: _shims.dontSetMe
  });
  _defineProperty2(DraggableCore$1, "defaultProps", {
    allowAnyClick: false,
    // by default only accept left click
    disabled: false,
    enableUserSelectHack: true,
    onStart: function() {
    },
    onDrag: function() {
    },
    onStop: function() {
    },
    onMouseDown: function() {
    },
    scale: 1
  });
  return DraggableCore;
}
var hasRequiredDraggable;
function requireDraggable() {
  if (hasRequiredDraggable) return Draggable;
  hasRequiredDraggable = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "DraggableCore", {
      enumerable: true,
      get: function() {
        return _DraggableCore.default;
      }
    });
    exports2.default = void 0;
    var React2 = _interopRequireWildcard(React__default);
    var _propTypes = _interopRequireDefault(/* @__PURE__ */ requirePropTypes$1());
    var _reactDom = _interopRequireDefault(ReactDOM__default);
    var _clsx = _interopRequireDefault(require$$3);
    var _domFns = requireDomFns();
    var _positionFns = requirePositionFns();
    var _shims = requireShims();
    var _DraggableCore = _interopRequireDefault(requireDraggableCore());
    var _log = _interopRequireDefault(requireLog());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function") return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _extends() {
      _extends = Object.assign ? Object.assign.bind() : function(target2) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source2 = arguments[i2];
          for (var key in source2) {
            if (Object.prototype.hasOwnProperty.call(source2, key)) {
              target2[key] = source2[key];
            }
          }
        }
        return target2;
      };
      return _extends.apply(this, arguments);
    }
    function _defineProperty2(obj, key, value2) {
      key = _toPropertyKey2(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value: value2, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value2;
      }
      return obj;
    }
    function _toPropertyKey2(arg) {
      var key = _toPrimitive2(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive2(input, hint) {
      if (typeof input !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    class Draggable2 extends React2.Component {
      // React 16.3+
      // Arity (props, state)
      static getDerivedStateFromProps(_ref, _ref2) {
        let {
          position: position2
        } = _ref;
        let {
          prevPropsPosition
        } = _ref2;
        if (position2 && (!prevPropsPosition || position2.x !== prevPropsPosition.x || position2.y !== prevPropsPosition.y)) {
          (0, _log.default)("Draggable: getDerivedStateFromProps %j", {
            position: position2,
            prevPropsPosition
          });
          return {
            x: position2.x,
            y: position2.y,
            prevPropsPosition: {
              ...position2
            }
          };
        }
        return null;
      }
      constructor(props) {
        super(props);
        _defineProperty2(this, "onDragStart", (e, coreData) => {
          (0, _log.default)("Draggable: onDragStart: %j", coreData);
          const shouldStart = this.props.onStart(e, (0, _positionFns.createDraggableData)(this, coreData));
          if (shouldStart === false) return false;
          this.setState({
            dragging: true,
            dragged: true
          });
        });
        _defineProperty2(this, "onDrag", (e, coreData) => {
          if (!this.state.dragging) return false;
          (0, _log.default)("Draggable: onDrag: %j", coreData);
          const uiData = (0, _positionFns.createDraggableData)(this, coreData);
          const newState = {
            x: uiData.x,
            y: uiData.y,
            slackX: 0,
            slackY: 0
          };
          if (this.props.bounds) {
            const {
              x,
              y
            } = newState;
            newState.x += this.state.slackX;
            newState.y += this.state.slackY;
            const [newStateX, newStateY] = (0, _positionFns.getBoundPosition)(this, newState.x, newState.y);
            newState.x = newStateX;
            newState.y = newStateY;
            newState.slackX = this.state.slackX + (x - newState.x);
            newState.slackY = this.state.slackY + (y - newState.y);
            uiData.x = newState.x;
            uiData.y = newState.y;
            uiData.deltaX = newState.x - this.state.x;
            uiData.deltaY = newState.y - this.state.y;
          }
          const shouldUpdate = this.props.onDrag(e, uiData);
          if (shouldUpdate === false) return false;
          this.setState(newState);
        });
        _defineProperty2(this, "onDragStop", (e, coreData) => {
          if (!this.state.dragging) return false;
          const shouldContinue = this.props.onStop(e, (0, _positionFns.createDraggableData)(this, coreData));
          if (shouldContinue === false) return false;
          (0, _log.default)("Draggable: onDragStop: %j", coreData);
          const newState = {
            dragging: false,
            slackX: 0,
            slackY: 0
          };
          const controlled = Boolean(this.props.position);
          if (controlled) {
            const {
              x,
              y
            } = this.props.position;
            newState.x = x;
            newState.y = y;
          }
          this.setState(newState);
        });
        this.state = {
          // Whether or not we are currently dragging.
          dragging: false,
          // Whether or not we have been dragged before.
          dragged: false,
          // Current transform x and y.
          x: props.position ? props.position.x : props.defaultPosition.x,
          y: props.position ? props.position.y : props.defaultPosition.y,
          prevPropsPosition: {
            ...props.position
          },
          // Used for compensating for out-of-bounds drags
          slackX: 0,
          slackY: 0,
          // Can only determine if SVG after mounting
          isElementSVG: false
        };
        if (props.position && !(props.onDrag || props.onStop)) {
          console.warn("A `position` was applied to this <Draggable>, without drag handlers. This will make this component effectively undraggable. Please attach `onDrag` or `onStop` handlers so you can adjust the `position` of this element.");
        }
      }
      componentDidMount() {
        if (typeof window.SVGElement !== "undefined" && this.findDOMNode() instanceof window.SVGElement) {
          this.setState({
            isElementSVG: true
          });
        }
      }
      componentWillUnmount() {
        this.setState({
          dragging: false
        });
      }
      // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find
      // the underlying DOM node ourselves. See the README for more information.
      findDOMNode() {
        var _this$props$nodeRef$c, _this$props;
        return (_this$props$nodeRef$c = (_this$props = this.props) === null || _this$props === void 0 || (_this$props = _this$props.nodeRef) === null || _this$props === void 0 ? void 0 : _this$props.current) !== null && _this$props$nodeRef$c !== void 0 ? _this$props$nodeRef$c : _reactDom.default.findDOMNode(this);
      }
      render() {
        const {
          axis,
          bounds,
          children,
          defaultPosition,
          defaultClassName,
          defaultClassNameDragging,
          defaultClassNameDragged,
          position: position2,
          positionOffset,
          scale,
          ...draggableCoreProps
        } = this.props;
        let style = {};
        let svgTransform = null;
        const controlled = Boolean(position2);
        const draggable = !controlled || this.state.dragging;
        const validPosition = position2 || defaultPosition;
        const transformOpts = {
          // Set left if horizontal drag is enabled
          x: (0, _positionFns.canDragX)(this) && draggable ? this.state.x : validPosition.x,
          // Set top if vertical drag is enabled
          y: (0, _positionFns.canDragY)(this) && draggable ? this.state.y : validPosition.y
        };
        if (this.state.isElementSVG) {
          svgTransform = (0, _domFns.createSVGTransform)(transformOpts, positionOffset);
        } else {
          style = (0, _domFns.createCSSTransform)(transformOpts, positionOffset);
        }
        const className = (0, _clsx.default)(children.props.className || "", defaultClassName, {
          [defaultClassNameDragging]: this.state.dragging,
          [defaultClassNameDragged]: this.state.dragged
        });
        return /* @__PURE__ */ React2.createElement(_DraggableCore.default, _extends({}, draggableCoreProps, {
          onStart: this.onDragStart,
          onDrag: this.onDrag,
          onStop: this.onDragStop
        }), /* @__PURE__ */ React2.cloneElement(React2.Children.only(children), {
          className,
          style: {
            ...children.props.style,
            ...style
          },
          transform: svgTransform
        }));
      }
    }
    exports2.default = Draggable2;
    _defineProperty2(Draggable2, "displayName", "Draggable");
    _defineProperty2(Draggable2, "propTypes", {
      // Accepts all props <DraggableCore> accepts.
      ..._DraggableCore.default.propTypes,
      /**
       * `axis` determines which axis the draggable can move.
       *
       *  Note that all callbacks will still return data as normal. This only
       *  controls flushing to the DOM.
       *
       * 'both' allows movement horizontally and vertically.
       * 'x' limits movement to horizontal axis.
       * 'y' limits movement to vertical axis.
       * 'none' limits all movement.
       *
       * Defaults to 'both'.
       */
      axis: _propTypes.default.oneOf(["both", "x", "y", "none"]),
      /**
       * `bounds` determines the range of movement available to the element.
       * Available values are:
       *
       * 'parent' restricts movement within the Draggable's parent node.
       *
       * Alternatively, pass an object with the following properties, all of which are optional:
       *
       * {left: LEFT_BOUND, right: RIGHT_BOUND, bottom: BOTTOM_BOUND, top: TOP_BOUND}
       *
       * All values are in px.
       *
       * Example:
       *
       * ```jsx
       *   let App = React.createClass({
       *       render: function () {
       *         return (
       *            <Draggable bounds={{right: 300, bottom: 300}}>
       *              <div>Content</div>
       *           </Draggable>
       *         );
       *       }
       *   });
       * ```
       */
      bounds: _propTypes.default.oneOfType([_propTypes.default.shape({
        left: _propTypes.default.number,
        right: _propTypes.default.number,
        top: _propTypes.default.number,
        bottom: _propTypes.default.number
      }), _propTypes.default.string, _propTypes.default.oneOf([false])]),
      defaultClassName: _propTypes.default.string,
      defaultClassNameDragging: _propTypes.default.string,
      defaultClassNameDragged: _propTypes.default.string,
      /**
       * `defaultPosition` specifies the x and y that the dragged item should start at
       *
       * Example:
       *
       * ```jsx
       *      let App = React.createClass({
       *          render: function () {
       *              return (
       *                  <Draggable defaultPosition={{x: 25, y: 25}}>
       *                      <div>I start with transformX: 25px and transformY: 25px;</div>
       *                  </Draggable>
       *              );
       *          }
       *      });
       * ```
       */
      defaultPosition: _propTypes.default.shape({
        x: _propTypes.default.number,
        y: _propTypes.default.number
      }),
      positionOffset: _propTypes.default.shape({
        x: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string]),
        y: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string])
      }),
      /**
       * `position`, if present, defines the current position of the element.
       *
       *  This is similar to how form elements in React work - if no `position` is supplied, the component
       *  is uncontrolled.
       *
       * Example:
       *
       * ```jsx
       *      let App = React.createClass({
       *          render: function () {
       *              return (
       *                  <Draggable position={{x: 25, y: 25}}>
       *                      <div>I start with transformX: 25px and transformY: 25px;</div>
       *                  </Draggable>
       *              );
       *          }
       *      });
       * ```
       */
      position: _propTypes.default.shape({
        x: _propTypes.default.number,
        y: _propTypes.default.number
      }),
      /**
       * These properties should be defined on the child, not here.
       */
      className: _shims.dontSetMe,
      style: _shims.dontSetMe,
      transform: _shims.dontSetMe
    });
    _defineProperty2(Draggable2, "defaultProps", {
      ..._DraggableCore.default.defaultProps,
      axis: "both",
      bounds: false,
      defaultClassName: "react-draggable",
      defaultClassNameDragging: "react-draggable-dragging",
      defaultClassNameDragged: "react-draggable-dragged",
      defaultPosition: {
        x: 0,
        y: 0
      },
      scale: 1
    });
  })(Draggable);
  return Draggable;
}
var hasRequiredCjs;
function requireCjs() {
  if (hasRequiredCjs) return cjs.exports;
  hasRequiredCjs = 1;
  const {
    default: Draggable2,
    DraggableCore: DraggableCore2
  } = requireDraggable();
  cjs.exports = Draggable2;
  cjs.exports.default = Draggable2;
  cjs.exports.DraggableCore = DraggableCore2;
  return cjs.exports;
}
var reactResizable = { exports: {} };
var Resizable = {};
var utils = {};
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils;
  hasRequiredUtils = 1;
  utils.__esModule = true;
  utils.cloneElement = cloneElement;
  var _react = _interopRequireDefault(React__default);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function ownKeys2(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread2(target2) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source2 = null != arguments[i2] ? arguments[i2] : {};
      i2 % 2 ? ownKeys2(Object(source2), true).forEach(function(key) {
        _defineProperty2(target2, key, source2[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source2)) : ownKeys2(Object(source2)).forEach(function(key) {
        Object.defineProperty(target2, key, Object.getOwnPropertyDescriptor(source2, key));
      });
    }
    return target2;
  }
  function _defineProperty2(obj, key, value2) {
    key = _toPropertyKey2(key);
    if (key in obj) {
      Object.defineProperty(obj, key, { value: value2, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value2;
    }
    return obj;
  }
  function _toPropertyKey2(arg) {
    var key = _toPrimitive2(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _toPrimitive2(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  function cloneElement(element, props) {
    if (props.style && element.props.style) {
      props.style = _objectSpread2(_objectSpread2({}, element.props.style), props.style);
    }
    if (props.className && element.props.className) {
      props.className = element.props.className + " " + props.className;
    }
    return /* @__PURE__ */ _react.default.cloneElement(element, props);
  }
  return utils;
}
var propTypes = {};
var hasRequiredPropTypes;
function requirePropTypes() {
  if (hasRequiredPropTypes) return propTypes;
  hasRequiredPropTypes = 1;
  propTypes.__esModule = true;
  propTypes.resizableProps = void 0;
  var _propTypes = _interopRequireDefault(/* @__PURE__ */ requirePropTypes$1());
  requireCjs();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var resizableProps = {
    /*
    * Restricts resizing to a particular axis (default: 'both')
    * 'both' - allows resizing by width or height
    * 'x' - only allows the width to be changed
    * 'y' - only allows the height to be changed
    * 'none' - disables resizing altogether
    * */
    axis: _propTypes.default.oneOf(["both", "x", "y", "none"]),
    className: _propTypes.default.string,
    /*
    * Require that one and only one child be present.
    * */
    children: _propTypes.default.element.isRequired,
    /*
    * These will be passed wholesale to react-draggable's DraggableCore
    * */
    draggableOpts: _propTypes.default.shape({
      allowAnyClick: _propTypes.default.bool,
      cancel: _propTypes.default.string,
      children: _propTypes.default.node,
      disabled: _propTypes.default.bool,
      enableUserSelectHack: _propTypes.default.bool,
      offsetParent: _propTypes.default.node,
      grid: _propTypes.default.arrayOf(_propTypes.default.number),
      handle: _propTypes.default.string,
      nodeRef: _propTypes.default.object,
      onStart: _propTypes.default.func,
      onDrag: _propTypes.default.func,
      onStop: _propTypes.default.func,
      onMouseDown: _propTypes.default.func,
      scale: _propTypes.default.number
    }),
    /*
    * Initial height
    * */
    height: function height() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var props = args[0];
      if (props.axis === "both" || props.axis === "y") {
        var _PropTypes$number;
        return (_PropTypes$number = _propTypes.default.number).isRequired.apply(_PropTypes$number, args);
      }
      return _propTypes.default.number.apply(_propTypes.default, args);
    },
    /*
    * Customize cursor resize handle
    * */
    handle: _propTypes.default.oneOfType([_propTypes.default.node, _propTypes.default.func]),
    /*
    * If you change this, be sure to update your css
    * */
    handleSize: _propTypes.default.arrayOf(_propTypes.default.number),
    lockAspectRatio: _propTypes.default.bool,
    /*
    * Max X & Y measure
    * */
    maxConstraints: _propTypes.default.arrayOf(_propTypes.default.number),
    /*
    * Min X & Y measure
    * */
    minConstraints: _propTypes.default.arrayOf(_propTypes.default.number),
    /*
    * Called on stop resize event
    * */
    onResizeStop: _propTypes.default.func,
    /*
    * Called on start resize event
    * */
    onResizeStart: _propTypes.default.func,
    /*
    * Called on resize event
    * */
    onResize: _propTypes.default.func,
    /*
    * Defines which resize handles should be rendered (default: 'se')
    * 's' - South handle (bottom-center)
    * 'w' - West handle (left-center)
    * 'e' - East handle (right-center)
    * 'n' - North handle (top-center)
    * 'sw' - Southwest handle (bottom-left)
    * 'nw' - Northwest handle (top-left)
    * 'se' - Southeast handle (bottom-right)
    * 'ne' - Northeast handle (top-center)
    * */
    resizeHandles: _propTypes.default.arrayOf(_propTypes.default.oneOf(["s", "w", "e", "n", "sw", "nw", "se", "ne"])),
    /*
    * If `transform: scale(n)` is set on the parent, this should be set to `n`.
    * */
    transformScale: _propTypes.default.number,
    /*
     * Initial width
     */
    width: function width() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      var props = args[0];
      if (props.axis === "both" || props.axis === "x") {
        var _PropTypes$number2;
        return (_PropTypes$number2 = _propTypes.default.number).isRequired.apply(_PropTypes$number2, args);
      }
      return _propTypes.default.number.apply(_propTypes.default, args);
    }
  };
  propTypes.resizableProps = resizableProps;
  return propTypes;
}
var hasRequiredResizable;
function requireResizable() {
  if (hasRequiredResizable) return Resizable;
  hasRequiredResizable = 1;
  Resizable.__esModule = true;
  Resizable.default = void 0;
  var React2 = _interopRequireWildcard(React__default);
  var _reactDraggable = requireCjs();
  var _utils = requireUtils();
  var _propTypes = requirePropTypes();
  var _excluded = ["children", "className", "draggableOpts", "width", "height", "handle", "handleSize", "lockAspectRatio", "axis", "minConstraints", "maxConstraints", "onResize", "onResizeStop", "onResizeStart", "resizeHandles", "transformScale"];
  function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
    var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
    return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
      return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
  }
  function _interopRequireWildcard(obj, nodeInterop) {
    if (obj && obj.__esModule) {
      return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
      return { default: obj };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) {
      if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
    newObj.default = obj;
    if (cache) {
      cache.set(obj, newObj);
    }
    return newObj;
  }
  function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target2) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source2 = arguments[i2];
        for (var key in source2) {
          if (Object.prototype.hasOwnProperty.call(source2, key)) {
            target2[key] = source2[key];
          }
        }
      }
      return target2;
    };
    return _extends.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose(source2, excluded) {
    if (source2 == null) return {};
    var target2 = {};
    var sourceKeys = Object.keys(source2);
    var key, i2;
    for (i2 = 0; i2 < sourceKeys.length; i2++) {
      key = sourceKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      target2[key] = source2[key];
    }
    return target2;
  }
  function ownKeys2(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread2(target2) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source2 = null != arguments[i2] ? arguments[i2] : {};
      i2 % 2 ? ownKeys2(Object(source2), true).forEach(function(key) {
        _defineProperty2(target2, key, source2[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source2)) : ownKeys2(Object(source2)).forEach(function(key) {
        Object.defineProperty(target2, key, Object.getOwnPropertyDescriptor(source2, key));
      });
    }
    return target2;
  }
  function _defineProperty2(obj, key, value2) {
    key = _toPropertyKey2(key);
    if (key in obj) {
      Object.defineProperty(obj, key, { value: value2, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value2;
    }
    return obj;
  }
  function _toPropertyKey2(arg) {
    var key = _toPrimitive2(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _toPrimitive2(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
  }
  function _setPrototypeOf(o2, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p2) {
      o3.__proto__ = p2;
      return o3;
    };
    return _setPrototypeOf(o2, p);
  }
  var Resizable$1 = /* @__PURE__ */ function(_React$Component) {
    _inheritsLoose(Resizable2, _React$Component);
    function Resizable2() {
      var _this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
      _this.handleRefs = {};
      _this.lastHandleRect = null;
      _this.slack = null;
      return _this;
    }
    var _proto = Resizable2.prototype;
    _proto.componentWillUnmount = function componentWillUnmount() {
      this.resetData();
    };
    _proto.resetData = function resetData() {
      this.lastHandleRect = this.slack = null;
    };
    _proto.runConstraints = function runConstraints(width, height) {
      var _this$props = this.props, minConstraints = _this$props.minConstraints, maxConstraints = _this$props.maxConstraints, lockAspectRatio = _this$props.lockAspectRatio;
      if (!minConstraints && !maxConstraints && !lockAspectRatio) return [width, height];
      if (lockAspectRatio) {
        var ratio = this.props.width / this.props.height;
        var deltaW = width - this.props.width;
        var deltaH = height - this.props.height;
        if (Math.abs(deltaW) > Math.abs(deltaH * ratio)) {
          height = width / ratio;
        } else {
          width = height * ratio;
        }
      }
      var oldW = width, oldH = height;
      var _ref = this.slack || [0, 0], slackW = _ref[0], slackH = _ref[1];
      width += slackW;
      height += slackH;
      if (minConstraints) {
        width = Math.max(minConstraints[0], width);
        height = Math.max(minConstraints[1], height);
      }
      if (maxConstraints) {
        width = Math.min(maxConstraints[0], width);
        height = Math.min(maxConstraints[1], height);
      }
      this.slack = [slackW + (oldW - width), slackH + (oldH - height)];
      return [width, height];
    };
    _proto.resizeHandler = function resizeHandler(handlerName, axis) {
      var _this2 = this;
      return function(e, _ref2) {
        var node = _ref2.node, deltaX = _ref2.deltaX, deltaY = _ref2.deltaY;
        if (handlerName === "onResizeStart") _this2.resetData();
        var canDragX = (_this2.props.axis === "both" || _this2.props.axis === "x") && axis !== "n" && axis !== "s";
        var canDragY = (_this2.props.axis === "both" || _this2.props.axis === "y") && axis !== "e" && axis !== "w";
        if (!canDragX && !canDragY) return;
        var axisV = axis[0];
        var axisH = axis[axis.length - 1];
        var handleRect = node.getBoundingClientRect();
        if (_this2.lastHandleRect != null) {
          if (axisH === "w") {
            var deltaLeftSinceLast = handleRect.left - _this2.lastHandleRect.left;
            deltaX += deltaLeftSinceLast;
          }
          if (axisV === "n") {
            var deltaTopSinceLast = handleRect.top - _this2.lastHandleRect.top;
            deltaY += deltaTopSinceLast;
          }
        }
        _this2.lastHandleRect = handleRect;
        if (axisH === "w") deltaX = -deltaX;
        if (axisV === "n") deltaY = -deltaY;
        var width = _this2.props.width + (canDragX ? deltaX / _this2.props.transformScale : 0);
        var height = _this2.props.height + (canDragY ? deltaY / _this2.props.transformScale : 0);
        var _this2$runConstraints = _this2.runConstraints(width, height);
        width = _this2$runConstraints[0];
        height = _this2$runConstraints[1];
        var dimensionsChanged = width !== _this2.props.width || height !== _this2.props.height;
        var cb = typeof _this2.props[handlerName] === "function" ? _this2.props[handlerName] : null;
        var shouldSkipCb = handlerName === "onResize" && !dimensionsChanged;
        if (cb && !shouldSkipCb) {
          e.persist == null ? void 0 : e.persist();
          cb(e, {
            node,
            size: {
              width,
              height
            },
            handle: axis
          });
        }
        if (handlerName === "onResizeStop") _this2.resetData();
      };
    };
    _proto.renderResizeHandle = function renderResizeHandle(handleAxis, ref) {
      var handle = this.props.handle;
      if (!handle) {
        return /* @__PURE__ */ React2.createElement("span", {
          className: "react-resizable-handle react-resizable-handle-" + handleAxis,
          ref
        });
      }
      if (typeof handle === "function") {
        return handle(handleAxis, ref);
      }
      var isDOMElement = typeof handle.type === "string";
      var props = _objectSpread2({
        ref
      }, isDOMElement ? {} : {
        handleAxis
      });
      return /* @__PURE__ */ React2.cloneElement(handle, props);
    };
    _proto.render = function render() {
      var _this3 = this;
      var _this$props2 = this.props, children = _this$props2.children, className = _this$props2.className, draggableOpts = _this$props2.draggableOpts;
      _this$props2.width;
      _this$props2.height;
      _this$props2.handle;
      _this$props2.handleSize;
      _this$props2.lockAspectRatio;
      _this$props2.axis;
      _this$props2.minConstraints;
      _this$props2.maxConstraints;
      _this$props2.onResize;
      _this$props2.onResizeStop;
      _this$props2.onResizeStart;
      var resizeHandles = _this$props2.resizeHandles;
      _this$props2.transformScale;
      var p = _objectWithoutPropertiesLoose(_this$props2, _excluded);
      return (0, _utils.cloneElement)(children, _objectSpread2(_objectSpread2({}, p), {}, {
        className: (className ? className + " " : "") + "react-resizable",
        children: [].concat(children.props.children, resizeHandles.map(function(handleAxis) {
          var _this3$handleRefs$han;
          var ref = (_this3$handleRefs$han = _this3.handleRefs[handleAxis]) != null ? _this3$handleRefs$han : _this3.handleRefs[handleAxis] = /* @__PURE__ */ React2.createRef();
          return /* @__PURE__ */ React2.createElement(_reactDraggable.DraggableCore, _extends({}, draggableOpts, {
            nodeRef: ref,
            key: "resizableHandle-" + handleAxis,
            onStop: _this3.resizeHandler("onResizeStop", handleAxis),
            onStart: _this3.resizeHandler("onResizeStart", handleAxis),
            onDrag: _this3.resizeHandler("onResize", handleAxis)
          }), _this3.renderResizeHandle(handleAxis, ref));
        }))
      }));
    };
    return Resizable2;
  }(React2.Component);
  Resizable.default = Resizable$1;
  Resizable$1.propTypes = _propTypes.resizableProps;
  Resizable$1.defaultProps = {
    axis: "both",
    handleSize: [20, 20],
    lockAspectRatio: false,
    minConstraints: [20, 20],
    maxConstraints: [Infinity, Infinity],
    resizeHandles: ["se"],
    transformScale: 1
  };
  return Resizable;
}
var ResizableBox = {};
var hasRequiredResizableBox;
function requireResizableBox() {
  if (hasRequiredResizableBox) return ResizableBox;
  hasRequiredResizableBox = 1;
  ResizableBox.__esModule = true;
  ResizableBox.default = void 0;
  var React2 = _interopRequireWildcard(React__default);
  var _propTypes = _interopRequireDefault(/* @__PURE__ */ requirePropTypes$1());
  var _Resizable = _interopRequireDefault(requireResizable());
  var _propTypes2 = requirePropTypes();
  var _excluded = ["handle", "handleSize", "onResize", "onResizeStart", "onResizeStop", "draggableOpts", "minConstraints", "maxConstraints", "lockAspectRatio", "axis", "width", "height", "resizeHandles", "style", "transformScale"];
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
    var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
    return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
      return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
  }
  function _interopRequireWildcard(obj, nodeInterop) {
    if (obj && obj.__esModule) {
      return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
      return { default: obj };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) {
      if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
    newObj.default = obj;
    if (cache) {
      cache.set(obj, newObj);
    }
    return newObj;
  }
  function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target2) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source2 = arguments[i2];
        for (var key in source2) {
          if (Object.prototype.hasOwnProperty.call(source2, key)) {
            target2[key] = source2[key];
          }
        }
      }
      return target2;
    };
    return _extends.apply(this, arguments);
  }
  function ownKeys2(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread2(target2) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source2 = null != arguments[i2] ? arguments[i2] : {};
      i2 % 2 ? ownKeys2(Object(source2), true).forEach(function(key) {
        _defineProperty2(target2, key, source2[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source2)) : ownKeys2(Object(source2)).forEach(function(key) {
        Object.defineProperty(target2, key, Object.getOwnPropertyDescriptor(source2, key));
      });
    }
    return target2;
  }
  function _defineProperty2(obj, key, value2) {
    key = _toPropertyKey2(key);
    if (key in obj) {
      Object.defineProperty(obj, key, { value: value2, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value2;
    }
    return obj;
  }
  function _toPropertyKey2(arg) {
    var key = _toPrimitive2(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _toPrimitive2(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  function _objectWithoutPropertiesLoose(source2, excluded) {
    if (source2 == null) return {};
    var target2 = {};
    var sourceKeys = Object.keys(source2);
    var key, i2;
    for (i2 = 0; i2 < sourceKeys.length; i2++) {
      key = sourceKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      target2[key] = source2[key];
    }
    return target2;
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
  }
  function _setPrototypeOf(o2, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p2) {
      o3.__proto__ = p2;
      return o3;
    };
    return _setPrototypeOf(o2, p);
  }
  var ResizableBox$1 = /* @__PURE__ */ function(_React$Component) {
    _inheritsLoose(ResizableBox2, _React$Component);
    function ResizableBox2() {
      var _this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
      _this.state = {
        width: _this.props.width,
        height: _this.props.height,
        propsWidth: _this.props.width,
        propsHeight: _this.props.height
      };
      _this.onResize = function(e, data) {
        var size2 = data.size;
        if (_this.props.onResize) {
          e.persist == null ? void 0 : e.persist();
          _this.setState(size2, function() {
            return _this.props.onResize && _this.props.onResize(e, data);
          });
        } else {
          _this.setState(size2);
        }
      };
      return _this;
    }
    ResizableBox2.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {
      if (state.propsWidth !== props.width || state.propsHeight !== props.height) {
        return {
          width: props.width,
          height: props.height,
          propsWidth: props.width,
          propsHeight: props.height
        };
      }
      return null;
    };
    var _proto = ResizableBox2.prototype;
    _proto.render = function render() {
      var _this$props = this.props, handle = _this$props.handle, handleSize = _this$props.handleSize;
      _this$props.onResize;
      var onResizeStart = _this$props.onResizeStart, onResizeStop = _this$props.onResizeStop, draggableOpts = _this$props.draggableOpts, minConstraints = _this$props.minConstraints, maxConstraints = _this$props.maxConstraints, lockAspectRatio = _this$props.lockAspectRatio, axis = _this$props.axis;
      _this$props.width;
      _this$props.height;
      var resizeHandles = _this$props.resizeHandles, style = _this$props.style, transformScale = _this$props.transformScale, props = _objectWithoutPropertiesLoose(_this$props, _excluded);
      return /* @__PURE__ */ React2.createElement(_Resizable.default, {
        axis,
        draggableOpts,
        handle,
        handleSize,
        height: this.state.height,
        lockAspectRatio,
        maxConstraints,
        minConstraints,
        onResizeStart,
        onResize: this.onResize,
        onResizeStop,
        resizeHandles,
        transformScale,
        width: this.state.width
      }, /* @__PURE__ */ React2.createElement("div", _extends({}, props, {
        style: _objectSpread2(_objectSpread2({}, style), {}, {
          width: this.state.width + "px",
          height: this.state.height + "px"
        })
      })));
    };
    return ResizableBox2;
  }(React2.Component);
  ResizableBox.default = ResizableBox$1;
  ResizableBox$1.propTypes = _objectSpread2(_objectSpread2({}, _propTypes2.resizableProps), {}, {
    children: _propTypes.default.element
  });
  return ResizableBox;
}
var hasRequiredReactResizable;
function requireReactResizable() {
  if (hasRequiredReactResizable) return reactResizable.exports;
  hasRequiredReactResizable = 1;
  reactResizable.exports = function() {
    throw new Error("Don't instantiate Resizable directly! Use require('react-resizable').Resizable");
  };
  reactResizable.exports.Resizable = requireResizable().default;
  reactResizable.exports.ResizableBox = requireResizableBox().default;
  return reactResizable.exports;
}
var ReactGridLayoutPropTypes = {};
var hasRequiredReactGridLayoutPropTypes;
function requireReactGridLayoutPropTypes() {
  if (hasRequiredReactGridLayoutPropTypes) return ReactGridLayoutPropTypes;
  hasRequiredReactGridLayoutPropTypes = 1;
  Object.defineProperty(ReactGridLayoutPropTypes, "__esModule", {
    value: true
  });
  ReactGridLayoutPropTypes.resizeHandleType = ReactGridLayoutPropTypes.resizeHandleAxesType = ReactGridLayoutPropTypes.default = void 0;
  var _propTypes = _interopRequireDefault(/* @__PURE__ */ requirePropTypes$1());
  var _react = _interopRequireDefault(React__default);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  const resizeHandleAxesType = ReactGridLayoutPropTypes.resizeHandleAxesType = _propTypes.default.arrayOf(_propTypes.default.oneOf(["s", "w", "e", "n", "sw", "nw", "se", "ne"]));
  const resizeHandleType = ReactGridLayoutPropTypes.resizeHandleType = _propTypes.default.oneOfType([_propTypes.default.node, _propTypes.default.func]);
  ReactGridLayoutPropTypes.default = {
    //
    // Basic props
    //
    className: _propTypes.default.string,
    style: _propTypes.default.object,
    // This can be set explicitly. If it is not set, it will automatically
    // be set to the container width. Note that resizes will *not* cause this to adjust.
    // If you need that behavior, use WidthProvider.
    width: _propTypes.default.number,
    // If true, the container height swells and contracts to fit contents
    autoSize: _propTypes.default.bool,
    // # of cols.
    cols: _propTypes.default.number,
    // A selector that will not be draggable.
    draggableCancel: _propTypes.default.string,
    // A selector for the draggable handler
    draggableHandle: _propTypes.default.string,
    // Deprecated
    verticalCompact: function(props) {
      if (props.verticalCompact === false && process.env.NODE_ENV !== "production") {
        console.warn(
          // eslint-disable-line no-console
          '`verticalCompact` on <ReactGridLayout> is deprecated and will be removed soon. Use `compactType`: "horizontal" | "vertical" | null.'
        );
      }
    },
    // Choose vertical or hotizontal compaction
    compactType: _propTypes.default.oneOf(["vertical", "horizontal"]),
    // layout is an array of object with the format:
    // {x: Number, y: Number, w: Number, h: Number, i: String}
    layout: function(props) {
      var layout2 = props.layout;
      if (layout2 === void 0) return;
      requireUtils$1().validateLayout(layout2, "layout");
    },
    //
    // Grid Dimensions
    //
    // Margin between items [x, y] in px
    margin: _propTypes.default.arrayOf(_propTypes.default.number),
    // Padding inside the container [x, y] in px
    containerPadding: _propTypes.default.arrayOf(_propTypes.default.number),
    // Rows have a static height, but you can change this based on breakpoints if you like
    rowHeight: _propTypes.default.number,
    // Default Infinity, but you can specify a max here if you like.
    // Note that this isn't fully fleshed out and won't error if you specify a layout that
    // extends beyond the row capacity. It will, however, not allow users to drag/resize
    // an item past the barrier. They can push items beyond the barrier, though.
    // Intentionally not documented for this reason.
    maxRows: _propTypes.default.number,
    //
    // Flags
    //
    isBounded: _propTypes.default.bool,
    isDraggable: _propTypes.default.bool,
    isResizable: _propTypes.default.bool,
    // If true, grid can be placed one over the other.
    allowOverlap: _propTypes.default.bool,
    // If true, grid items won't change position when being dragged over.
    preventCollision: _propTypes.default.bool,
    // Use CSS transforms instead of top/left
    useCSSTransforms: _propTypes.default.bool,
    // parent layout transform scale
    transformScale: _propTypes.default.number,
    // If true, an external element can trigger onDrop callback with a specific grid position as a parameter
    isDroppable: _propTypes.default.bool,
    // Resize handle options
    resizeHandles: resizeHandleAxesType,
    resizeHandle: resizeHandleType,
    //
    // Callbacks
    //
    // Callback so you can save the layout. Calls after each drag & resize stops.
    onLayoutChange: _propTypes.default.func,
    // Calls when drag starts. Callback is of the signature (layout, oldItem, newItem, placeholder, e, ?node).
    // All callbacks below have the same signature. 'start' and 'stop' callbacks omit the 'placeholder'.
    onDragStart: _propTypes.default.func,
    // Calls on each drag movement.
    onDrag: _propTypes.default.func,
    // Calls when drag is complete.
    onDragStop: _propTypes.default.func,
    //Calls when resize starts.
    onResizeStart: _propTypes.default.func,
    // Calls when resize movement happens.
    onResize: _propTypes.default.func,
    // Calls when resize is complete.
    onResizeStop: _propTypes.default.func,
    // Calls when some element is dropped.
    onDrop: _propTypes.default.func,
    //
    // Other validations
    //
    droppingItem: _propTypes.default.shape({
      i: _propTypes.default.string.isRequired,
      w: _propTypes.default.number.isRequired,
      h: _propTypes.default.number.isRequired
    }),
    // Children must not have duplicate keys.
    children: function(props, propName) {
      const children = props[propName];
      const keys2 = {};
      _react.default.Children.forEach(children, function(child) {
        if ((child == null ? void 0 : child.key) == null) return;
        if (keys2[child.key]) {
          throw new Error('Duplicate child key "' + child.key + '" found! This will cause problems in ReactGridLayout.');
        }
        keys2[child.key] = true;
      });
    },
    // Optional ref for getting a reference for the wrapping div.
    innerRef: _propTypes.default.any
  };
  return ReactGridLayoutPropTypes;
}
var hasRequiredGridItem;
function requireGridItem() {
  if (hasRequiredGridItem) return GridItem;
  hasRequiredGridItem = 1;
  Object.defineProperty(GridItem, "__esModule", {
    value: true
  });
  GridItem.default = void 0;
  var _react = _interopRequireDefault(React__default);
  var _propTypes = _interopRequireDefault(/* @__PURE__ */ requirePropTypes$1());
  var _reactDraggable = requireCjs();
  var _reactResizable = requireReactResizable();
  var _utils = requireUtils$1();
  var _calculateUtils = requireCalculateUtils();
  var _ReactGridLayoutPropTypes = requireReactGridLayoutPropTypes();
  var _clsx = _interopRequireDefault(requireClsx());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _defineProperty2(obj, key, value2) {
    key = _toPropertyKey2(key);
    if (key in obj) {
      Object.defineProperty(obj, key, { value: value2, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value2;
    }
    return obj;
  }
  function _toPropertyKey2(arg) {
    var key = _toPrimitive2(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _toPrimitive2(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  let GridItem$1 = class GridItem extends _react.default.Component {
    constructor() {
      super(...arguments);
      _defineProperty2(this, "state", {
        resizing: null,
        dragging: null,
        className: ""
      });
      _defineProperty2(this, "elementRef", /* @__PURE__ */ _react.default.createRef());
      _defineProperty2(this, "onDragStart", (e, _ref) => {
        let {
          node
        } = _ref;
        const {
          onDragStart,
          transformScale
        } = this.props;
        if (!onDragStart) return;
        const newPosition = {
          top: 0,
          left: 0
        };
        const {
          offsetParent
        } = node;
        if (!offsetParent) return;
        const parentRect = offsetParent.getBoundingClientRect();
        const clientRect = node.getBoundingClientRect();
        const cLeft = clientRect.left / transformScale;
        const pLeft = parentRect.left / transformScale;
        const cTop = clientRect.top / transformScale;
        const pTop = parentRect.top / transformScale;
        newPosition.left = cLeft - pLeft + offsetParent.scrollLeft;
        newPosition.top = cTop - pTop + offsetParent.scrollTop;
        this.setState({
          dragging: newPosition
        });
        const {
          x,
          y
        } = (0, _calculateUtils.calcXY)(this.getPositionParams(), newPosition.top, newPosition.left, this.props.w, this.props.h);
        return onDragStart.call(this, this.props.i, x, y, {
          e,
          node,
          newPosition
        });
      });
      _defineProperty2(this, "onDrag", (e, _ref2) => {
        let {
          node,
          deltaX,
          deltaY
        } = _ref2;
        const {
          onDrag
        } = this.props;
        if (!onDrag) return;
        if (!this.state.dragging) {
          throw new Error("onDrag called before onDragStart.");
        }
        let top = this.state.dragging.top + deltaY;
        let left2 = this.state.dragging.left + deltaX;
        const {
          isBounded,
          i: i2,
          w,
          h,
          containerWidth
        } = this.props;
        const positionParams = this.getPositionParams();
        if (isBounded) {
          const {
            offsetParent
          } = node;
          if (offsetParent) {
            const {
              margin,
              rowHeight,
              containerPadding
            } = this.props;
            const bottomBoundary = offsetParent.clientHeight - (0, _calculateUtils.calcGridItemWHPx)(h, rowHeight, margin[1]);
            top = (0, _calculateUtils.clamp)(top - containerPadding[1], 0, bottomBoundary);
            const colWidth = (0, _calculateUtils.calcGridColWidth)(positionParams);
            const rightBoundary = containerWidth - (0, _calculateUtils.calcGridItemWHPx)(w, colWidth, margin[0]);
            left2 = (0, _calculateUtils.clamp)(left2 - containerPadding[0], 0, rightBoundary);
          }
        }
        const newPosition = {
          top,
          left: left2
        };
        this.setState({
          dragging: newPosition
        });
        const {
          x,
          y
        } = (0, _calculateUtils.calcXY)(positionParams, top, left2, w, h);
        return onDrag.call(this, i2, x, y, {
          e,
          node,
          newPosition
        });
      });
      _defineProperty2(this, "onDragStop", (e, _ref3) => {
        let {
          node
        } = _ref3;
        const {
          onDragStop
        } = this.props;
        if (!onDragStop) return;
        if (!this.state.dragging) {
          throw new Error("onDragEnd called before onDragStart.");
        }
        const {
          w,
          h,
          i: i2
        } = this.props;
        const {
          left: left2,
          top
        } = this.state.dragging;
        const newPosition = {
          top,
          left: left2
        };
        this.setState({
          dragging: null
        });
        const {
          x,
          y
        } = (0, _calculateUtils.calcXY)(this.getPositionParams(), top, left2, w, h);
        return onDragStop.call(this, i2, x, y, {
          e,
          node,
          newPosition
        });
      });
      _defineProperty2(this, "onResizeStop", (e, callbackData, position2) => this.onResizeHandler(e, callbackData, position2, "onResizeStop"));
      _defineProperty2(this, "onResizeStart", (e, callbackData, position2) => this.onResizeHandler(e, callbackData, position2, "onResizeStart"));
      _defineProperty2(this, "onResize", (e, callbackData, position2) => this.onResizeHandler(e, callbackData, position2, "onResize"));
    }
    shouldComponentUpdate(nextProps, nextState) {
      if (this.props.children !== nextProps.children) return true;
      if (this.props.droppingPosition !== nextProps.droppingPosition) return true;
      const oldPosition = (0, _calculateUtils.calcGridItemPosition)(this.getPositionParams(this.props), this.props.x, this.props.y, this.props.w, this.props.h, this.state);
      const newPosition = (0, _calculateUtils.calcGridItemPosition)(this.getPositionParams(nextProps), nextProps.x, nextProps.y, nextProps.w, nextProps.h, nextState);
      return !(0, _utils.fastPositionEqual)(oldPosition, newPosition) || this.props.useCSSTransforms !== nextProps.useCSSTransforms;
    }
    componentDidMount() {
      this.moveDroppingItem({});
    }
    componentDidUpdate(prevProps) {
      this.moveDroppingItem(prevProps);
    }
    // When a droppingPosition is present, this means we should fire a move event, as if we had moved
    // this element by `x, y` pixels.
    moveDroppingItem(prevProps) {
      const {
        droppingPosition
      } = this.props;
      if (!droppingPosition) return;
      const node = this.elementRef.current;
      if (!node) return;
      const prevDroppingPosition = prevProps.droppingPosition || {
        left: 0,
        top: 0
      };
      const {
        dragging
      } = this.state;
      const shouldDrag = dragging && droppingPosition.left !== prevDroppingPosition.left || droppingPosition.top !== prevDroppingPosition.top;
      if (!dragging) {
        this.onDragStart(droppingPosition.e, {
          node,
          deltaX: droppingPosition.left,
          deltaY: droppingPosition.top
        });
      } else if (shouldDrag) {
        const deltaX = droppingPosition.left - dragging.left;
        const deltaY = droppingPosition.top - dragging.top;
        this.onDrag(droppingPosition.e, {
          node,
          deltaX,
          deltaY
        });
      }
    }
    getPositionParams() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.props;
      return {
        cols: props.cols,
        containerPadding: props.containerPadding,
        containerWidth: props.containerWidth,
        margin: props.margin,
        maxRows: props.maxRows,
        rowHeight: props.rowHeight
      };
    }
    /**
     * This is where we set the grid item's absolute placement. It gets a little tricky because we want to do it
     * well when server rendering, and the only way to do that properly is to use percentage width/left because
     * we don't know exactly what the browser viewport is.
     * Unfortunately, CSS Transforms, which are great for performance, break in this instance because a percentage
     * left is relative to the item itself, not its container! So we cannot use them on the server rendering pass.
     *
     * @param  {Object} pos Position object with width, height, left, top.
     * @return {Object}     Style object.
     */
    createStyle(pos) {
      const {
        usePercentages,
        containerWidth,
        useCSSTransforms
      } = this.props;
      let style;
      if (useCSSTransforms) {
        style = (0, _utils.setTransform)(pos);
      } else {
        style = (0, _utils.setTopLeft)(pos);
        if (usePercentages) {
          style.left = (0, _utils.perc)(pos.left / containerWidth);
          style.width = (0, _utils.perc)(pos.width / containerWidth);
        }
      }
      return style;
    }
    /**
     * Mix a Draggable instance into a child.
     * @param  {Element} child    Child element.
     * @return {Element}          Child wrapped in Draggable.
     */
    mixinDraggable(child, isDraggable) {
      return /* @__PURE__ */ _react.default.createElement(_reactDraggable.DraggableCore, {
        disabled: !isDraggable,
        onStart: this.onDragStart,
        onDrag: this.onDrag,
        onStop: this.onDragStop,
        handle: this.props.handle,
        cancel: ".react-resizable-handle" + (this.props.cancel ? "," + this.props.cancel : ""),
        scale: this.props.transformScale,
        nodeRef: this.elementRef
      }, child);
    }
    /**
     * Utility function to setup callback handler definitions for
     * similarily structured resize events.
     */
    curryResizeHandler(position2, handler) {
      return (e, data) => (
        /*: Function*/
        handler(e, data, position2)
      );
    }
    /**
     * Mix a Resizable instance into a child.
     * @param  {Element} child    Child element.
     * @param  {Object} position  Position object (pixel values)
     * @return {Element}          Child wrapped in Resizable.
     */
    mixinResizable(child, position2, isResizable) {
      const {
        cols,
        minW,
        minH,
        maxW,
        maxH,
        transformScale,
        resizeHandles,
        resizeHandle
      } = this.props;
      const positionParams = this.getPositionParams();
      const maxWidth = (0, _calculateUtils.calcGridItemPosition)(positionParams, 0, 0, cols, 0).width;
      const mins = (0, _calculateUtils.calcGridItemPosition)(positionParams, 0, 0, minW, minH);
      const maxes = (0, _calculateUtils.calcGridItemPosition)(positionParams, 0, 0, maxW, maxH);
      const minConstraints = [mins.width, mins.height];
      const maxConstraints = [Math.min(maxes.width, maxWidth), Math.min(maxes.height, Infinity)];
      return /* @__PURE__ */ _react.default.createElement(
        _reactResizable.Resizable,
        {
          draggableOpts: {
            disabled: !isResizable
          },
          className: isResizable ? void 0 : "react-resizable-hide",
          width: position2.width,
          height: position2.height,
          minConstraints,
          maxConstraints,
          onResizeStop: this.curryResizeHandler(position2, this.onResizeStop),
          onResizeStart: this.curryResizeHandler(position2, this.onResizeStart),
          onResize: this.curryResizeHandler(position2, this.onResize),
          transformScale,
          resizeHandles,
          handle: resizeHandle
        },
        child
      );
    }
    /**
     * Wrapper around resize events to provide more useful data.
     */
    onResizeHandler(e, _ref4, position2, handlerName) {
      let {
        node,
        size: size2,
        handle
      } = _ref4;
      const handler = this.props[handlerName];
      if (!handler) return;
      const {
        x,
        y,
        i: i2,
        maxH,
        minH,
        containerWidth
      } = this.props;
      const {
        minW,
        maxW
      } = this.props;
      let updatedSize = size2;
      if (node) {
        updatedSize = (0, _utils.resizeItemInDirection)(handle, position2, size2, containerWidth);
        this.setState({
          resizing: handlerName === "onResizeStop" ? null : updatedSize
        });
      }
      let {
        w,
        h
      } = (0, _calculateUtils.calcWH)(this.getPositionParams(), updatedSize.width, updatedSize.height, x, y, handle);
      w = (0, _calculateUtils.clamp)(w, Math.max(minW, 1), maxW);
      h = (0, _calculateUtils.clamp)(h, minH, maxH);
      handler.call(this, i2, w, h, {
        e,
        node,
        size: updatedSize,
        handle
      });
    }
    render() {
      const {
        x,
        y,
        w,
        h,
        isDraggable,
        isResizable,
        droppingPosition,
        useCSSTransforms
      } = this.props;
      const pos = (0, _calculateUtils.calcGridItemPosition)(this.getPositionParams(), x, y, w, h, this.state);
      const child = _react.default.Children.only(this.props.children);
      let newChild = /* @__PURE__ */ _react.default.cloneElement(child, {
        ref: this.elementRef,
        className: (0, _clsx.default)("react-grid-item", child.props.className, this.props.className, {
          static: this.props.static,
          resizing: Boolean(this.state.resizing),
          "react-draggable": isDraggable,
          "react-draggable-dragging": Boolean(this.state.dragging),
          dropping: Boolean(droppingPosition),
          cssTransforms: useCSSTransforms
        }),
        // We can set the width and height on the child, but unfortunately we can't set the position.
        style: {
          ...this.props.style,
          ...child.props.style,
          ...this.createStyle(pos)
        }
      });
      newChild = this.mixinResizable(newChild, pos, isResizable);
      newChild = this.mixinDraggable(newChild, isDraggable);
      return newChild;
    }
  };
  GridItem.default = GridItem$1;
  _defineProperty2(GridItem$1, "propTypes", {
    // Children must be only a single element
    children: _propTypes.default.element,
    // General grid attributes
    cols: _propTypes.default.number.isRequired,
    containerWidth: _propTypes.default.number.isRequired,
    rowHeight: _propTypes.default.number.isRequired,
    margin: _propTypes.default.array.isRequired,
    maxRows: _propTypes.default.number.isRequired,
    containerPadding: _propTypes.default.array.isRequired,
    // These are all in grid units
    x: _propTypes.default.number.isRequired,
    y: _propTypes.default.number.isRequired,
    w: _propTypes.default.number.isRequired,
    h: _propTypes.default.number.isRequired,
    // All optional
    minW: function(props, propName) {
      const value2 = props[propName];
      if (typeof value2 !== "number") return new Error("minWidth not Number");
      if (value2 > props.w || value2 > props.maxW) return new Error("minWidth larger than item width/maxWidth");
    },
    maxW: function(props, propName) {
      const value2 = props[propName];
      if (typeof value2 !== "number") return new Error("maxWidth not Number");
      if (value2 < props.w || value2 < props.minW) return new Error("maxWidth smaller than item width/minWidth");
    },
    minH: function(props, propName) {
      const value2 = props[propName];
      if (typeof value2 !== "number") return new Error("minHeight not Number");
      if (value2 > props.h || value2 > props.maxH) return new Error("minHeight larger than item height/maxHeight");
    },
    maxH: function(props, propName) {
      const value2 = props[propName];
      if (typeof value2 !== "number") return new Error("maxHeight not Number");
      if (value2 < props.h || value2 < props.minH) return new Error("maxHeight smaller than item height/minHeight");
    },
    // ID is nice to have for callbacks
    i: _propTypes.default.string.isRequired,
    // Resize handle options
    resizeHandles: _ReactGridLayoutPropTypes.resizeHandleAxesType,
    resizeHandle: _ReactGridLayoutPropTypes.resizeHandleType,
    // Functions
    onDragStop: _propTypes.default.func,
    onDragStart: _propTypes.default.func,
    onDrag: _propTypes.default.func,
    onResizeStop: _propTypes.default.func,
    onResizeStart: _propTypes.default.func,
    onResize: _propTypes.default.func,
    // Flags
    isDraggable: _propTypes.default.bool.isRequired,
    isResizable: _propTypes.default.bool.isRequired,
    isBounded: _propTypes.default.bool.isRequired,
    static: _propTypes.default.bool,
    // Use CSS transforms instead of top/left
    useCSSTransforms: _propTypes.default.bool.isRequired,
    transformScale: _propTypes.default.number,
    // Others
    className: _propTypes.default.string,
    // Selector for draggable handle
    handle: _propTypes.default.string,
    // Selector for draggable cancel (see react-draggable)
    cancel: _propTypes.default.string,
    // Current position of a dropping element
    droppingPosition: _propTypes.default.shape({
      e: _propTypes.default.object.isRequired,
      left: _propTypes.default.number.isRequired,
      top: _propTypes.default.number.isRequired
    })
  });
  _defineProperty2(GridItem$1, "defaultProps", {
    className: "",
    cancel: "",
    handle: "",
    minH: 1,
    minW: 1,
    maxH: Infinity,
    maxW: Infinity,
    transformScale: 1
  });
  return GridItem;
}
var hasRequiredReactGridLayout$1;
function requireReactGridLayout$1() {
  if (hasRequiredReactGridLayout$1) return ReactGridLayout;
  hasRequiredReactGridLayout$1 = 1;
  Object.defineProperty(ReactGridLayout, "__esModule", {
    value: true
  });
  ReactGridLayout.default = void 0;
  var React2 = _interopRequireWildcard(React__default);
  var _fastEquals = /* @__PURE__ */ requireFastEquals();
  var _clsx = _interopRequireDefault(requireClsx());
  var _utils = requireUtils$1();
  var _calculateUtils = requireCalculateUtils();
  var _GridItem = _interopRequireDefault(requireGridItem());
  var _ReactGridLayoutPropTypes = _interopRequireDefault(requireReactGridLayoutPropTypes());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r2 = /* @__PURE__ */ new WeakMap(), t2 = /* @__PURE__ */ new WeakMap();
    return (_getRequireWildcardCache = function(e2) {
      return e2 ? t2 : r2;
    })(e);
  }
  function _interopRequireWildcard(e, r2) {
    if (e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return { default: e };
    var t2 = _getRequireWildcardCache(r2);
    if (t2 && t2.has(e)) return t2.get(e);
    var n2 = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
      var i2 = a ? Object.getOwnPropertyDescriptor(e, u) : null;
      i2 && (i2.get || i2.set) ? Object.defineProperty(n2, u, i2) : n2[u] = e[u];
    }
    return n2.default = e, t2 && t2.set(e, n2), n2;
  }
  function _defineProperty2(obj, key, value2) {
    key = _toPropertyKey2(key);
    if (key in obj) {
      Object.defineProperty(obj, key, { value: value2, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value2;
    }
    return obj;
  }
  function _toPropertyKey2(arg) {
    var key = _toPrimitive2(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _toPrimitive2(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  const layoutClassName = "react-grid-layout";
  let isFirefox = false;
  try {
    isFirefox = /firefox/i.test(navigator.userAgent);
  } catch (e) {
  }
  let ReactGridLayout$1 = class ReactGridLayout extends React2.Component {
    constructor() {
      super(...arguments);
      _defineProperty2(this, "state", {
        activeDrag: null,
        layout: (0, _utils.synchronizeLayoutWithChildren)(
          this.props.layout,
          this.props.children,
          this.props.cols,
          // Legacy support for verticalCompact: false
          (0, _utils.compactType)(this.props),
          this.props.allowOverlap
        ),
        mounted: false,
        oldDragItem: null,
        oldLayout: null,
        oldResizeItem: null,
        resizing: false,
        droppingDOMNode: null,
        children: []
      });
      _defineProperty2(this, "dragEnterCounter", 0);
      _defineProperty2(this, "onDragStart", (i2, x, y, _ref) => {
        let {
          e,
          node
        } = _ref;
        const {
          layout: layout2
        } = this.state;
        const l = (0, _utils.getLayoutItem)(layout2, i2);
        if (!l) return;
        const placeholder2 = {
          w: l.w,
          h: l.h,
          x: l.x,
          y: l.y,
          placeholder: true,
          i: i2
        };
        this.setState({
          oldDragItem: (0, _utils.cloneLayoutItem)(l),
          oldLayout: layout2,
          activeDrag: placeholder2
        });
        return this.props.onDragStart(layout2, l, l, null, e, node);
      });
      _defineProperty2(this, "onDrag", (i2, x, y, _ref2) => {
        let {
          e,
          node
        } = _ref2;
        const {
          oldDragItem
        } = this.state;
        let {
          layout: layout2
        } = this.state;
        const {
          cols,
          allowOverlap,
          preventCollision
        } = this.props;
        const l = (0, _utils.getLayoutItem)(layout2, i2);
        if (!l) return;
        const placeholder2 = {
          w: l.w,
          h: l.h,
          x: l.x,
          y: l.y,
          placeholder: true,
          i: i2
        };
        const isUserAction = true;
        layout2 = (0, _utils.moveElement)(layout2, l, x, y, isUserAction, preventCollision, (0, _utils.compactType)(this.props), cols, allowOverlap);
        this.props.onDrag(layout2, oldDragItem, l, placeholder2, e, node);
        this.setState({
          layout: allowOverlap ? layout2 : (0, _utils.compact)(layout2, (0, _utils.compactType)(this.props), cols),
          activeDrag: placeholder2
        });
      });
      _defineProperty2(this, "onDragStop", (i2, x, y, _ref3) => {
        let {
          e,
          node
        } = _ref3;
        if (!this.state.activeDrag) return;
        const {
          oldDragItem
        } = this.state;
        let {
          layout: layout2
        } = this.state;
        const {
          cols,
          preventCollision,
          allowOverlap
        } = this.props;
        const l = (0, _utils.getLayoutItem)(layout2, i2);
        if (!l) return;
        const isUserAction = true;
        layout2 = (0, _utils.moveElement)(layout2, l, x, y, isUserAction, preventCollision, (0, _utils.compactType)(this.props), cols, allowOverlap);
        const newLayout = allowOverlap ? layout2 : (0, _utils.compact)(layout2, (0, _utils.compactType)(this.props), cols);
        this.props.onDragStop(newLayout, oldDragItem, l, null, e, node);
        const {
          oldLayout
        } = this.state;
        this.setState({
          activeDrag: null,
          layout: newLayout,
          oldDragItem: null,
          oldLayout: null
        });
        this.onLayoutMaybeChanged(newLayout, oldLayout);
      });
      _defineProperty2(this, "onResizeStart", (i2, w, h, _ref4) => {
        let {
          e,
          node
        } = _ref4;
        const {
          layout: layout2
        } = this.state;
        const l = (0, _utils.getLayoutItem)(layout2, i2);
        if (!l) return;
        this.setState({
          oldResizeItem: (0, _utils.cloneLayoutItem)(l),
          oldLayout: this.state.layout,
          resizing: true
        });
        this.props.onResizeStart(layout2, l, l, null, e, node);
      });
      _defineProperty2(this, "onResize", (i2, w, h, _ref5) => {
        let {
          e,
          node,
          size: size2,
          handle
        } = _ref5;
        const {
          oldResizeItem
        } = this.state;
        const {
          layout: layout2
        } = this.state;
        const {
          cols,
          preventCollision,
          allowOverlap
        } = this.props;
        let shouldMoveItem = false;
        let finalLayout;
        let x;
        let y;
        const [newLayout, l] = (0, _utils.withLayoutItem)(layout2, i2, (l2) => {
          let hasCollisions;
          x = l2.x;
          y = l2.y;
          if (["sw", "w", "nw", "n", "ne"].indexOf(handle) !== -1) {
            if (["sw", "nw", "w"].indexOf(handle) !== -1) {
              x = l2.x + (l2.w - w);
              w = l2.x !== x && x < 0 ? l2.w : w;
              x = x < 0 ? 0 : x;
            }
            if (["ne", "n", "nw"].indexOf(handle) !== -1) {
              y = l2.y + (l2.h - h);
              h = l2.y !== y && y < 0 ? l2.h : h;
              y = y < 0 ? 0 : y;
            }
            shouldMoveItem = true;
          }
          if (preventCollision && !allowOverlap) {
            const collisions = (0, _utils.getAllCollisions)(layout2, {
              ...l2,
              w,
              h,
              x,
              y
            }).filter((layoutItem) => layoutItem.i !== l2.i);
            hasCollisions = collisions.length > 0;
            if (hasCollisions) {
              y = l2.y;
              h = l2.h;
              x = l2.x;
              w = l2.w;
              shouldMoveItem = false;
            }
          }
          l2.w = w;
          l2.h = h;
          return l2;
        });
        if (!l) return;
        finalLayout = newLayout;
        if (shouldMoveItem) {
          const isUserAction = true;
          finalLayout = (0, _utils.moveElement)(newLayout, l, x, y, isUserAction, this.props.preventCollision, (0, _utils.compactType)(this.props), cols, allowOverlap);
        }
        const placeholder2 = {
          w: l.w,
          h: l.h,
          x: l.x,
          y: l.y,
          static: true,
          i: i2
        };
        this.props.onResize(finalLayout, oldResizeItem, l, placeholder2, e, node);
        this.setState({
          layout: allowOverlap ? finalLayout : (0, _utils.compact)(finalLayout, (0, _utils.compactType)(this.props), cols),
          activeDrag: placeholder2
        });
      });
      _defineProperty2(this, "onResizeStop", (i2, w, h, _ref6) => {
        let {
          e,
          node
        } = _ref6;
        const {
          layout: layout2,
          oldResizeItem
        } = this.state;
        const {
          cols,
          allowOverlap
        } = this.props;
        const l = (0, _utils.getLayoutItem)(layout2, i2);
        const newLayout = allowOverlap ? layout2 : (0, _utils.compact)(layout2, (0, _utils.compactType)(this.props), cols);
        this.props.onResizeStop(newLayout, oldResizeItem, l, null, e, node);
        const {
          oldLayout
        } = this.state;
        this.setState({
          activeDrag: null,
          layout: newLayout,
          oldResizeItem: null,
          oldLayout: null,
          resizing: false
        });
        this.onLayoutMaybeChanged(newLayout, oldLayout);
      });
      _defineProperty2(this, "onDragOver", (e) => {
        var _a;
        e.preventDefault();
        e.stopPropagation();
        if (isFirefox && // $FlowIgnore can't figure this out
        !((_a = e.nativeEvent.target) == null ? void 0 : _a.classList.contains(layoutClassName))) {
          return false;
        }
        const {
          droppingItem,
          onDropDragOver,
          margin,
          cols,
          rowHeight,
          maxRows,
          width,
          containerPadding,
          transformScale
        } = this.props;
        const onDragOverResult = onDropDragOver == null ? void 0 : onDropDragOver(e);
        if (onDragOverResult === false) {
          if (this.state.droppingDOMNode) {
            this.removeDroppingPlaceholder();
          }
          return false;
        }
        const finalDroppingItem = {
          ...droppingItem,
          ...onDragOverResult
        };
        const {
          layout: layout2
        } = this.state;
        const gridRect = e.currentTarget.getBoundingClientRect();
        const layerX = e.clientX - gridRect.left;
        const layerY = e.clientY - gridRect.top;
        const droppingPosition = {
          left: layerX / transformScale,
          top: layerY / transformScale,
          e
        };
        if (!this.state.droppingDOMNode) {
          const positionParams = {
            cols,
            margin,
            maxRows,
            rowHeight,
            containerWidth: width,
            containerPadding: containerPadding || margin
          };
          const calculatedPosition = (0, _calculateUtils.calcXY)(positionParams, layerY, layerX, finalDroppingItem.w, finalDroppingItem.h);
          this.setState({
            droppingDOMNode: /* @__PURE__ */ React2.createElement("div", {
              key: finalDroppingItem.i
            }),
            droppingPosition,
            layout: [...layout2, {
              ...finalDroppingItem,
              x: calculatedPosition.x,
              y: calculatedPosition.y,
              static: false,
              isDraggable: true
            }]
          });
        } else if (this.state.droppingPosition) {
          const {
            left: left2,
            top
          } = this.state.droppingPosition;
          const shouldUpdatePosition = left2 != layerX || top != layerY;
          if (shouldUpdatePosition) {
            this.setState({
              droppingPosition
            });
          }
        }
      });
      _defineProperty2(this, "removeDroppingPlaceholder", () => {
        const {
          droppingItem,
          cols
        } = this.props;
        const {
          layout: layout2
        } = this.state;
        const newLayout = (0, _utils.compact)(layout2.filter((l) => l.i !== droppingItem.i), (0, _utils.compactType)(this.props), cols, this.props.allowOverlap);
        this.setState({
          layout: newLayout,
          droppingDOMNode: null,
          activeDrag: null,
          droppingPosition: void 0
        });
      });
      _defineProperty2(this, "onDragLeave", (e) => {
        e.preventDefault();
        e.stopPropagation();
        this.dragEnterCounter--;
        if (this.dragEnterCounter === 0) {
          this.removeDroppingPlaceholder();
        }
      });
      _defineProperty2(this, "onDragEnter", (e) => {
        e.preventDefault();
        e.stopPropagation();
        this.dragEnterCounter++;
      });
      _defineProperty2(this, "onDrop", (e) => {
        e.preventDefault();
        e.stopPropagation();
        const {
          droppingItem
        } = this.props;
        const {
          layout: layout2
        } = this.state;
        const item = layout2.find((l) => l.i === droppingItem.i);
        this.dragEnterCounter = 0;
        this.removeDroppingPlaceholder();
        this.props.onDrop(layout2, item, e);
      });
    }
    componentDidMount() {
      this.setState({
        mounted: true
      });
      this.onLayoutMaybeChanged(this.state.layout, this.props.layout);
    }
    static getDerivedStateFromProps(nextProps, prevState) {
      let newLayoutBase;
      if (prevState.activeDrag) {
        return null;
      }
      if (!(0, _fastEquals.deepEqual)(nextProps.layout, prevState.propsLayout) || nextProps.compactType !== prevState.compactType) {
        newLayoutBase = nextProps.layout;
      } else if (!(0, _utils.childrenEqual)(nextProps.children, prevState.children)) {
        newLayoutBase = prevState.layout;
      }
      if (newLayoutBase) {
        const newLayout = (0, _utils.synchronizeLayoutWithChildren)(newLayoutBase, nextProps.children, nextProps.cols, (0, _utils.compactType)(nextProps), nextProps.allowOverlap);
        return {
          layout: newLayout,
          // We need to save these props to state for using
          // getDerivedStateFromProps instead of componentDidMount (in which we would get extra rerender)
          compactType: nextProps.compactType,
          children: nextProps.children,
          propsLayout: nextProps.layout
        };
      }
      return null;
    }
    shouldComponentUpdate(nextProps, nextState) {
      return (
        // NOTE: this is almost always unequal. Therefore the only way to get better performance
        // from SCU is if the user intentionally memoizes children. If they do, and they can
        // handle changes properly, performance will increase.
        this.props.children !== nextProps.children || !(0, _utils.fastRGLPropsEqual)(this.props, nextProps, _fastEquals.deepEqual) || this.state.activeDrag !== nextState.activeDrag || this.state.mounted !== nextState.mounted || this.state.droppingPosition !== nextState.droppingPosition
      );
    }
    componentDidUpdate(prevProps, prevState) {
      if (!this.state.activeDrag) {
        const newLayout = this.state.layout;
        const oldLayout = prevState.layout;
        this.onLayoutMaybeChanged(newLayout, oldLayout);
      }
    }
    /**
     * Calculates a pixel value for the container.
     * @return {String} Container height in pixels.
     */
    containerHeight() {
      if (!this.props.autoSize) return;
      const nbRow = (0, _utils.bottom)(this.state.layout);
      const containerPaddingY = this.props.containerPadding ? this.props.containerPadding[1] : this.props.margin[1];
      return nbRow * this.props.rowHeight + (nbRow - 1) * this.props.margin[1] + containerPaddingY * 2 + "px";
    }
    onLayoutMaybeChanged(newLayout, oldLayout) {
      if (!oldLayout) oldLayout = this.state.layout;
      if (!(0, _fastEquals.deepEqual)(oldLayout, newLayout)) {
        this.props.onLayoutChange(newLayout);
      }
    }
    /**
     * Create a placeholder object.
     * @return {Element} Placeholder div.
     */
    placeholder() {
      const {
        activeDrag
      } = this.state;
      if (!activeDrag) return null;
      const {
        width,
        cols,
        margin,
        containerPadding,
        rowHeight,
        maxRows,
        useCSSTransforms,
        transformScale
      } = this.props;
      return /* @__PURE__ */ React2.createElement(_GridItem.default, {
        w: activeDrag.w,
        h: activeDrag.h,
        x: activeDrag.x,
        y: activeDrag.y,
        i: activeDrag.i,
        className: `react-grid-placeholder ${this.state.resizing ? "placeholder-resizing" : ""}`,
        containerWidth: width,
        cols,
        margin,
        containerPadding: containerPadding || margin,
        maxRows,
        rowHeight,
        isDraggable: false,
        isResizable: false,
        isBounded: false,
        useCSSTransforms,
        transformScale
      }, /* @__PURE__ */ React2.createElement("div", null));
    }
    /**
     * Given a grid item, set its style attributes & surround in a <Draggable>.
     * @param  {Element} child React element.
     * @return {Element}       Element wrapped in draggable and properly placed.
     */
    processGridItem(child, isDroppingItem) {
      if (!child || !child.key) return;
      const l = (0, _utils.getLayoutItem)(this.state.layout, String(child.key));
      if (!l) return null;
      const {
        width,
        cols,
        margin,
        containerPadding,
        rowHeight,
        maxRows,
        isDraggable,
        isResizable,
        isBounded,
        useCSSTransforms,
        transformScale,
        draggableCancel,
        draggableHandle,
        resizeHandles,
        resizeHandle
      } = this.props;
      const {
        mounted,
        droppingPosition
      } = this.state;
      const draggable = typeof l.isDraggable === "boolean" ? l.isDraggable : !l.static && isDraggable;
      const resizable = typeof l.isResizable === "boolean" ? l.isResizable : !l.static && isResizable;
      const resizeHandlesOptions = l.resizeHandles || resizeHandles;
      const bounded = draggable && isBounded && l.isBounded !== false;
      return /* @__PURE__ */ React2.createElement(_GridItem.default, {
        containerWidth: width,
        cols,
        margin,
        containerPadding: containerPadding || margin,
        maxRows,
        rowHeight,
        cancel: draggableCancel,
        handle: draggableHandle,
        onDragStop: this.onDragStop,
        onDragStart: this.onDragStart,
        onDrag: this.onDrag,
        onResizeStart: this.onResizeStart,
        onResize: this.onResize,
        onResizeStop: this.onResizeStop,
        isDraggable: draggable,
        isResizable: resizable,
        isBounded: bounded,
        useCSSTransforms: useCSSTransforms && mounted,
        usePercentages: !mounted,
        transformScale,
        w: l.w,
        h: l.h,
        x: l.x,
        y: l.y,
        i: l.i,
        minH: l.minH,
        minW: l.minW,
        maxH: l.maxH,
        maxW: l.maxW,
        static: l.static,
        droppingPosition: isDroppingItem ? droppingPosition : void 0,
        resizeHandles: resizeHandlesOptions,
        resizeHandle
      }, child);
    }
    render() {
      const {
        className,
        style,
        isDroppable,
        innerRef
      } = this.props;
      const mergedClassName = (0, _clsx.default)(layoutClassName, className);
      const mergedStyle = {
        height: this.containerHeight(),
        ...style
      };
      return /* @__PURE__ */ React2.createElement("div", {
        ref: innerRef,
        className: mergedClassName,
        style: mergedStyle,
        onDrop: isDroppable ? this.onDrop : _utils.noop,
        onDragLeave: isDroppable ? this.onDragLeave : _utils.noop,
        onDragEnter: isDroppable ? this.onDragEnter : _utils.noop,
        onDragOver: isDroppable ? this.onDragOver : _utils.noop
      }, React2.Children.map(this.props.children, (child) => this.processGridItem(child)), isDroppable && this.state.droppingDOMNode && this.processGridItem(this.state.droppingDOMNode, true), this.placeholder());
    }
  };
  ReactGridLayout.default = ReactGridLayout$1;
  _defineProperty2(ReactGridLayout$1, "displayName", "ReactGridLayout");
  _defineProperty2(ReactGridLayout$1, "propTypes", _ReactGridLayoutPropTypes.default);
  _defineProperty2(ReactGridLayout$1, "defaultProps", {
    autoSize: true,
    cols: 12,
    className: "",
    style: {},
    draggableHandle: "",
    draggableCancel: "",
    containerPadding: null,
    rowHeight: 150,
    maxRows: Infinity,
    // infinite vertical growth
    layout: [],
    margin: [10, 10],
    isBounded: false,
    isDraggable: true,
    isResizable: true,
    allowOverlap: false,
    isDroppable: false,
    useCSSTransforms: true,
    transformScale: 1,
    verticalCompact: true,
    compactType: "vertical",
    preventCollision: false,
    droppingItem: {
      i: "__dropping-elem__",
      h: 1,
      w: 1
    },
    resizeHandles: ["se"],
    onLayoutChange: _utils.noop,
    onDragStart: _utils.noop,
    onDrag: _utils.noop,
    onDragStop: _utils.noop,
    onResizeStart: _utils.noop,
    onResize: _utils.noop,
    onResizeStop: _utils.noop,
    onDrop: _utils.noop,
    onDropDragOver: _utils.noop
  });
  return ReactGridLayout;
}
var ResponsiveReactGridLayout = {};
var responsiveUtils = {};
var hasRequiredResponsiveUtils;
function requireResponsiveUtils() {
  if (hasRequiredResponsiveUtils) return responsiveUtils;
  hasRequiredResponsiveUtils = 1;
  Object.defineProperty(responsiveUtils, "__esModule", {
    value: true
  });
  responsiveUtils.findOrGenerateResponsiveLayout = findOrGenerateResponsiveLayout;
  responsiveUtils.getBreakpointFromWidth = getBreakpointFromWidth;
  responsiveUtils.getColsFromBreakpoint = getColsFromBreakpoint;
  responsiveUtils.sortBreakpoints = sortBreakpoints;
  var _utils = requireUtils$1();
  function getBreakpointFromWidth(breakpoints, width) {
    const sorted = sortBreakpoints(breakpoints);
    let matching = sorted[0];
    for (let i2 = 1, len = sorted.length; i2 < len; i2++) {
      const breakpointName = sorted[i2];
      if (width > breakpoints[breakpointName]) matching = breakpointName;
    }
    return matching;
  }
  function getColsFromBreakpoint(breakpoint, cols) {
    if (!cols[breakpoint]) {
      throw new Error("ResponsiveReactGridLayout: `cols` entry for breakpoint " + breakpoint + " is missing!");
    }
    return cols[breakpoint];
  }
  function findOrGenerateResponsiveLayout(layouts, breakpoints, breakpoint, lastBreakpoint, cols, compactType) {
    if (layouts[breakpoint]) return (0, _utils.cloneLayout)(layouts[breakpoint]);
    let layout2 = layouts[lastBreakpoint];
    const breakpointsSorted = sortBreakpoints(breakpoints);
    const breakpointsAbove = breakpointsSorted.slice(breakpointsSorted.indexOf(breakpoint));
    for (let i2 = 0, len = breakpointsAbove.length; i2 < len; i2++) {
      const b = breakpointsAbove[i2];
      if (layouts[b]) {
        layout2 = layouts[b];
        break;
      }
    }
    layout2 = (0, _utils.cloneLayout)(layout2 || []);
    return (0, _utils.compact)((0, _utils.correctBounds)(layout2, {
      cols
    }), compactType, cols);
  }
  function sortBreakpoints(breakpoints) {
    const keys2 = Object.keys(breakpoints);
    return keys2.sort(function(a, b) {
      return breakpoints[a] - breakpoints[b];
    });
  }
  return responsiveUtils;
}
var hasRequiredResponsiveReactGridLayout;
function requireResponsiveReactGridLayout() {
  if (hasRequiredResponsiveReactGridLayout) return ResponsiveReactGridLayout;
  hasRequiredResponsiveReactGridLayout = 1;
  Object.defineProperty(ResponsiveReactGridLayout, "__esModule", {
    value: true
  });
  ResponsiveReactGridLayout.default = void 0;
  var React2 = _interopRequireWildcard(React__default);
  var _propTypes = _interopRequireDefault(/* @__PURE__ */ requirePropTypes$1());
  var _fastEquals = /* @__PURE__ */ requireFastEquals();
  var _utils = requireUtils$1();
  var _responsiveUtils = requireResponsiveUtils();
  var _ReactGridLayout = _interopRequireDefault(requireReactGridLayout$1());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r2 = /* @__PURE__ */ new WeakMap(), t2 = /* @__PURE__ */ new WeakMap();
    return (_getRequireWildcardCache = function(e2) {
      return e2 ? t2 : r2;
    })(e);
  }
  function _interopRequireWildcard(e, r2) {
    if (e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return { default: e };
    var t2 = _getRequireWildcardCache(r2);
    if (t2 && t2.has(e)) return t2.get(e);
    var n2 = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
      var i2 = a ? Object.getOwnPropertyDescriptor(e, u) : null;
      i2 && (i2.get || i2.set) ? Object.defineProperty(n2, u, i2) : n2[u] = e[u];
    }
    return n2.default = e, t2 && t2.set(e, n2), n2;
  }
  function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target2) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source2 = arguments[i2];
        for (var key in source2) {
          if (Object.prototype.hasOwnProperty.call(source2, key)) {
            target2[key] = source2[key];
          }
        }
      }
      return target2;
    };
    return _extends.apply(this, arguments);
  }
  function _defineProperty2(obj, key, value2) {
    key = _toPropertyKey2(key);
    if (key in obj) {
      Object.defineProperty(obj, key, { value: value2, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value2;
    }
    return obj;
  }
  function _toPropertyKey2(arg) {
    var key = _toPrimitive2(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _toPrimitive2(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  const type2 = (obj) => Object.prototype.toString.call(obj);
  function getIndentationValue(param, breakpoint) {
    if (param == null) return null;
    return Array.isArray(param) ? param : param[breakpoint];
  }
  let ResponsiveReactGridLayout$1 = class ResponsiveReactGridLayout extends React2.Component {
    constructor() {
      super(...arguments);
      _defineProperty2(this, "state", this.generateInitialState());
      _defineProperty2(this, "onLayoutChange", (layout2) => {
        this.props.onLayoutChange(layout2, {
          ...this.props.layouts,
          [this.state.breakpoint]: layout2
        });
      });
    }
    generateInitialState() {
      const {
        width,
        breakpoints,
        layouts,
        cols
      } = this.props;
      const breakpoint = (0, _responsiveUtils.getBreakpointFromWidth)(breakpoints, width);
      const colNo = (0, _responsiveUtils.getColsFromBreakpoint)(breakpoint, cols);
      const compactType = this.props.verticalCompact === false ? null : this.props.compactType;
      const initialLayout = (0, _responsiveUtils.findOrGenerateResponsiveLayout)(layouts, breakpoints, breakpoint, breakpoint, colNo, compactType);
      return {
        layout: initialLayout,
        breakpoint,
        cols: colNo
      };
    }
    static getDerivedStateFromProps(nextProps, prevState) {
      if (!(0, _fastEquals.deepEqual)(nextProps.layouts, prevState.layouts)) {
        const {
          breakpoint,
          cols
        } = prevState;
        const newLayout = (0, _responsiveUtils.findOrGenerateResponsiveLayout)(nextProps.layouts, nextProps.breakpoints, breakpoint, breakpoint, cols, nextProps.compactType);
        return {
          layout: newLayout,
          layouts: nextProps.layouts
        };
      }
      return null;
    }
    componentDidUpdate(prevProps) {
      if (this.props.width != prevProps.width || this.props.breakpoint !== prevProps.breakpoint || !(0, _fastEquals.deepEqual)(this.props.breakpoints, prevProps.breakpoints) || !(0, _fastEquals.deepEqual)(this.props.cols, prevProps.cols)) {
        this.onWidthChange(prevProps);
      }
    }
    /**
     * When the width changes work through breakpoints and reset state with the new width & breakpoint.
     * Width changes are necessary to figure out the widget widths.
     */
    onWidthChange(prevProps) {
      const {
        breakpoints,
        cols,
        layouts,
        compactType
      } = this.props;
      const newBreakpoint = this.props.breakpoint || (0, _responsiveUtils.getBreakpointFromWidth)(this.props.breakpoints, this.props.width);
      const lastBreakpoint = this.state.breakpoint;
      const newCols = (0, _responsiveUtils.getColsFromBreakpoint)(newBreakpoint, cols);
      const newLayouts = {
        ...layouts
      };
      if (lastBreakpoint !== newBreakpoint || prevProps.breakpoints !== breakpoints || prevProps.cols !== cols) {
        if (!(lastBreakpoint in newLayouts)) newLayouts[lastBreakpoint] = (0, _utils.cloneLayout)(this.state.layout);
        let layout2 = (0, _responsiveUtils.findOrGenerateResponsiveLayout)(newLayouts, breakpoints, newBreakpoint, lastBreakpoint, newCols, compactType);
        layout2 = (0, _utils.synchronizeLayoutWithChildren)(layout2, this.props.children, newCols, compactType, this.props.allowOverlap);
        newLayouts[newBreakpoint] = layout2;
        this.props.onBreakpointChange(newBreakpoint, newCols);
        this.props.onLayoutChange(layout2, newLayouts);
        this.setState({
          breakpoint: newBreakpoint,
          layout: layout2,
          cols: newCols
        });
      }
      const margin = getIndentationValue(this.props.margin, newBreakpoint);
      const containerPadding = getIndentationValue(this.props.containerPadding, newBreakpoint);
      this.props.onWidthChange(this.props.width, margin, newCols, containerPadding);
    }
    render() {
      const {
        breakpoint,
        breakpoints,
        cols,
        layouts,
        margin,
        containerPadding,
        onBreakpointChange,
        onLayoutChange,
        onWidthChange,
        ...other
      } = this.props;
      return /* @__PURE__ */ React2.createElement(_ReactGridLayout.default, _extends({}, other, {
        // $FlowIgnore should allow nullable here due to DefaultProps
        margin: getIndentationValue(margin, this.state.breakpoint),
        containerPadding: getIndentationValue(containerPadding, this.state.breakpoint),
        onLayoutChange: this.onLayoutChange,
        layout: this.state.layout,
        cols: this.state.cols
      }));
    }
  };
  ResponsiveReactGridLayout.default = ResponsiveReactGridLayout$1;
  _defineProperty2(ResponsiveReactGridLayout$1, "propTypes", {
    //
    // Basic props
    //
    // Optional, but if you are managing width yourself you may want to set the breakpoint
    // yourself as well.
    breakpoint: _propTypes.default.string,
    // {name: pxVal}, e.g. {lg: 1200, md: 996, sm: 768, xs: 480}
    breakpoints: _propTypes.default.object,
    allowOverlap: _propTypes.default.bool,
    // # of cols. This is a breakpoint -> cols map
    cols: _propTypes.default.object,
    // # of margin. This is a breakpoint -> margin map
    // e.g. { lg: [5, 5], md: [10, 10], sm: [15, 15] }
    // Margin between items [x, y] in px
    // e.g. [10, 10]
    margin: _propTypes.default.oneOfType([_propTypes.default.array, _propTypes.default.object]),
    // # of containerPadding. This is a breakpoint -> containerPadding map
    // e.g. { lg: [5, 5], md: [10, 10], sm: [15, 15] }
    // Padding inside the container [x, y] in px
    // e.g. [10, 10]
    containerPadding: _propTypes.default.oneOfType([_propTypes.default.array, _propTypes.default.object]),
    // layouts is an object mapping breakpoints to layouts.
    // e.g. {lg: Layout, md: Layout, ...}
    layouts(props, propName) {
      if (type2(props[propName]) !== "[object Object]") {
        throw new Error("Layout property must be an object. Received: " + type2(props[propName]));
      }
      Object.keys(props[propName]).forEach((key) => {
        if (!(key in props.breakpoints)) {
          throw new Error("Each key in layouts must align with a key in breakpoints.");
        }
        (0, _utils.validateLayout)(props.layouts[key], "layouts." + key);
      });
    },
    // The width of this component.
    // Required in this propTypes stanza because generateInitialState() will fail without it.
    width: _propTypes.default.number.isRequired,
    //
    // Callbacks
    //
    // Calls back with breakpoint and new # cols
    onBreakpointChange: _propTypes.default.func,
    // Callback so you can save the layout.
    // Calls back with (currentLayout, allLayouts). allLayouts are keyed by breakpoint.
    onLayoutChange: _propTypes.default.func,
    // Calls back with (containerWidth, margin, cols, containerPadding)
    onWidthChange: _propTypes.default.func
  });
  _defineProperty2(ResponsiveReactGridLayout$1, "defaultProps", {
    breakpoints: {
      lg: 1200,
      md: 996,
      sm: 768,
      xs: 480,
      xxs: 0
    },
    cols: {
      lg: 12,
      md: 10,
      sm: 6,
      xs: 4,
      xxs: 2
    },
    containerPadding: {
      lg: null,
      md: null,
      sm: null,
      xs: null,
      xxs: null
    },
    layouts: {},
    margin: [10, 10],
    allowOverlap: false,
    onBreakpointChange: _utils.noop,
    onLayoutChange: _utils.noop,
    onWidthChange: _utils.noop
  });
  return ResponsiveReactGridLayout;
}
var WidthProvider = {};
var MapShim = function() {
  if (typeof Map !== "undefined") {
    return Map;
  }
  function getIndex(arr, key) {
    var result = -1;
    arr.some(function(entry, index2) {
      if (entry[0] === key) {
        result = index2;
        return true;
      }
      return false;
    });
    return result;
  }
  return (
    /** @class */
    function() {
      function class_1() {
        this.__entries__ = [];
      }
      Object.defineProperty(class_1.prototype, "size", {
        /**
         * @returns {boolean}
         */
        get: function() {
          return this.__entries__.length;
        },
        enumerable: true,
        configurable: true
      });
      class_1.prototype.get = function(key) {
        var index2 = getIndex(this.__entries__, key);
        var entry = this.__entries__[index2];
        return entry && entry[1];
      };
      class_1.prototype.set = function(key, value2) {
        var index2 = getIndex(this.__entries__, key);
        if (~index2) {
          this.__entries__[index2][1] = value2;
        } else {
          this.__entries__.push([key, value2]);
        }
      };
      class_1.prototype.delete = function(key) {
        var entries = this.__entries__;
        var index2 = getIndex(entries, key);
        if (~index2) {
          entries.splice(index2, 1);
        }
      };
      class_1.prototype.has = function(key) {
        return !!~getIndex(this.__entries__, key);
      };
      class_1.prototype.clear = function() {
        this.__entries__.splice(0);
      };
      class_1.prototype.forEach = function(callback, ctx) {
        if (ctx === void 0) {
          ctx = null;
        }
        for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
          var entry = _a[_i];
          callback.call(ctx, entry[1], entry[0]);
        }
      };
      return class_1;
    }()
  );
}();
var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && window.document === document;
var global$1 = function() {
  if (typeof global !== "undefined" && global.Math === Math) {
    return global;
  }
  if (typeof self !== "undefined" && self.Math === Math) {
    return self;
  }
  if (typeof window !== "undefined" && window.Math === Math) {
    return window;
  }
  return Function("return this")();
}();
var requestAnimationFrame$1 = function() {
  if (typeof requestAnimationFrame === "function") {
    return requestAnimationFrame.bind(global$1);
  }
  return function(callback) {
    return setTimeout(function() {
      return callback(Date.now());
    }, 1e3 / 60);
  };
}();
var trailingTimeout = 2;
function throttle(callback, delay) {
  var leadingCall = false, trailingCall = false, lastCallTime = 0;
  function resolvePending() {
    if (leadingCall) {
      leadingCall = false;
      callback();
    }
    if (trailingCall) {
      proxy();
    }
  }
  function timeoutCallback() {
    requestAnimationFrame$1(resolvePending);
  }
  function proxy() {
    var timeStamp = Date.now();
    if (leadingCall) {
      if (timeStamp - lastCallTime < trailingTimeout) {
        return;
      }
      trailingCall = true;
    } else {
      leadingCall = true;
      trailingCall = false;
      setTimeout(timeoutCallback, delay);
    }
    lastCallTime = timeStamp;
  }
  return proxy;
}
var REFRESH_DELAY = 20;
var transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"];
var mutationObserverSupported = typeof MutationObserver !== "undefined";
var ResizeObserverController = (
  /** @class */
  function() {
    function ResizeObserverController2() {
      this.connected_ = false;
      this.mutationEventsAdded_ = false;
      this.mutationsObserver_ = null;
      this.observers_ = [];
      this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
      this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
    }
    ResizeObserverController2.prototype.addObserver = function(observer) {
      if (!~this.observers_.indexOf(observer)) {
        this.observers_.push(observer);
      }
      if (!this.connected_) {
        this.connect_();
      }
    };
    ResizeObserverController2.prototype.removeObserver = function(observer) {
      var observers2 = this.observers_;
      var index2 = observers2.indexOf(observer);
      if (~index2) {
        observers2.splice(index2, 1);
      }
      if (!observers2.length && this.connected_) {
        this.disconnect_();
      }
    };
    ResizeObserverController2.prototype.refresh = function() {
      var changesDetected = this.updateObservers_();
      if (changesDetected) {
        this.refresh();
      }
    };
    ResizeObserverController2.prototype.updateObservers_ = function() {
      var activeObservers = this.observers_.filter(function(observer) {
        return observer.gatherActive(), observer.hasActive();
      });
      activeObservers.forEach(function(observer) {
        return observer.broadcastActive();
      });
      return activeObservers.length > 0;
    };
    ResizeObserverController2.prototype.connect_ = function() {
      if (!isBrowser || this.connected_) {
        return;
      }
      document.addEventListener("transitionend", this.onTransitionEnd_);
      window.addEventListener("resize", this.refresh);
      if (mutationObserverSupported) {
        this.mutationsObserver_ = new MutationObserver(this.refresh);
        this.mutationsObserver_.observe(document, {
          attributes: true,
          childList: true,
          characterData: true,
          subtree: true
        });
      } else {
        document.addEventListener("DOMSubtreeModified", this.refresh);
        this.mutationEventsAdded_ = true;
      }
      this.connected_ = true;
    };
    ResizeObserverController2.prototype.disconnect_ = function() {
      if (!isBrowser || !this.connected_) {
        return;
      }
      document.removeEventListener("transitionend", this.onTransitionEnd_);
      window.removeEventListener("resize", this.refresh);
      if (this.mutationsObserver_) {
        this.mutationsObserver_.disconnect();
      }
      if (this.mutationEventsAdded_) {
        document.removeEventListener("DOMSubtreeModified", this.refresh);
      }
      this.mutationsObserver_ = null;
      this.mutationEventsAdded_ = false;
      this.connected_ = false;
    };
    ResizeObserverController2.prototype.onTransitionEnd_ = function(_a) {
      var _b = _a.propertyName, propertyName = _b === void 0 ? "" : _b;
      var isReflowProperty = transitionKeys.some(function(key) {
        return !!~propertyName.indexOf(key);
      });
      if (isReflowProperty) {
        this.refresh();
      }
    };
    ResizeObserverController2.getInstance = function() {
      if (!this.instance_) {
        this.instance_ = new ResizeObserverController2();
      }
      return this.instance_;
    };
    ResizeObserverController2.instance_ = null;
    return ResizeObserverController2;
  }()
);
var defineConfigurable = function(target2, props) {
  for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
    var key = _a[_i];
    Object.defineProperty(target2, key, {
      value: props[key],
      enumerable: false,
      writable: false,
      configurable: true
    });
  }
  return target2;
};
var getWindowOf = function(target2) {
  var ownerGlobal = target2 && target2.ownerDocument && target2.ownerDocument.defaultView;
  return ownerGlobal || global$1;
};
var emptyRect = createRectInit(0, 0, 0, 0);
function toFloat(value2) {
  return parseFloat(value2) || 0;
}
function getBordersSize(styles) {
  var positions = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    positions[_i - 1] = arguments[_i];
  }
  return positions.reduce(function(size2, position2) {
    var value2 = styles["border-" + position2 + "-width"];
    return size2 + toFloat(value2);
  }, 0);
}
function getPaddings(styles) {
  var positions = ["top", "right", "bottom", "left"];
  var paddings = {};
  for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
    var position2 = positions_1[_i];
    var value2 = styles["padding-" + position2];
    paddings[position2] = toFloat(value2);
  }
  return paddings;
}
function getSVGContentRect(target2) {
  var bbox = target2.getBBox();
  return createRectInit(0, 0, bbox.width, bbox.height);
}
function getHTMLElementContentRect(target2) {
  var clientWidth = target2.clientWidth, clientHeight = target2.clientHeight;
  if (!clientWidth && !clientHeight) {
    return emptyRect;
  }
  var styles = getWindowOf(target2).getComputedStyle(target2);
  var paddings = getPaddings(styles);
  var horizPad = paddings.left + paddings.right;
  var vertPad = paddings.top + paddings.bottom;
  var width = toFloat(styles.width), height = toFloat(styles.height);
  if (styles.boxSizing === "border-box") {
    if (Math.round(width + horizPad) !== clientWidth) {
      width -= getBordersSize(styles, "left", "right") + horizPad;
    }
    if (Math.round(height + vertPad) !== clientHeight) {
      height -= getBordersSize(styles, "top", "bottom") + vertPad;
    }
  }
  if (!isDocumentElement(target2)) {
    var vertScrollbar = Math.round(width + horizPad) - clientWidth;
    var horizScrollbar = Math.round(height + vertPad) - clientHeight;
    if (Math.abs(vertScrollbar) !== 1) {
      width -= vertScrollbar;
    }
    if (Math.abs(horizScrollbar) !== 1) {
      height -= horizScrollbar;
    }
  }
  return createRectInit(paddings.left, paddings.top, width, height);
}
var isSVGGraphicsElement = function() {
  if (typeof SVGGraphicsElement !== "undefined") {
    return function(target2) {
      return target2 instanceof getWindowOf(target2).SVGGraphicsElement;
    };
  }
  return function(target2) {
    return target2 instanceof getWindowOf(target2).SVGElement && typeof target2.getBBox === "function";
  };
}();
function isDocumentElement(target2) {
  return target2 === getWindowOf(target2).document.documentElement;
}
function getContentRect(target2) {
  if (!isBrowser) {
    return emptyRect;
  }
  if (isSVGGraphicsElement(target2)) {
    return getSVGContentRect(target2);
  }
  return getHTMLElementContentRect(target2);
}
function createReadOnlyRect(_a) {
  var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
  var Constr = typeof DOMRectReadOnly !== "undefined" ? DOMRectReadOnly : Object;
  var rect = Object.create(Constr.prototype);
  defineConfigurable(rect, {
    x,
    y,
    width,
    height,
    top: y,
    right: x + width,
    bottom: height + y,
    left: x
  });
  return rect;
}
function createRectInit(x, y, width, height) {
  return { x, y, width, height };
}
var ResizeObservation = (
  /** @class */
  function() {
    function ResizeObservation2(target2) {
      this.broadcastWidth = 0;
      this.broadcastHeight = 0;
      this.contentRect_ = createRectInit(0, 0, 0, 0);
      this.target = target2;
    }
    ResizeObservation2.prototype.isActive = function() {
      var rect = getContentRect(this.target);
      this.contentRect_ = rect;
      return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
    };
    ResizeObservation2.prototype.broadcastRect = function() {
      var rect = this.contentRect_;
      this.broadcastWidth = rect.width;
      this.broadcastHeight = rect.height;
      return rect;
    };
    return ResizeObservation2;
  }()
);
var ResizeObserverEntry = (
  /** @class */
  /* @__PURE__ */ function() {
    function ResizeObserverEntry2(target2, rectInit) {
      var contentRect = createReadOnlyRect(rectInit);
      defineConfigurable(this, { target: target2, contentRect });
    }
    return ResizeObserverEntry2;
  }()
);
var ResizeObserverSPI = (
  /** @class */
  function() {
    function ResizeObserverSPI2(callback, controller, callbackCtx) {
      this.activeObservations_ = [];
      this.observations_ = new MapShim();
      if (typeof callback !== "function") {
        throw new TypeError("The callback provided as parameter 1 is not a function.");
      }
      this.callback_ = callback;
      this.controller_ = controller;
      this.callbackCtx_ = callbackCtx;
    }
    ResizeObserverSPI2.prototype.observe = function(target2) {
      if (!arguments.length) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      if (typeof Element === "undefined" || !(Element instanceof Object)) {
        return;
      }
      if (!(target2 instanceof getWindowOf(target2).Element)) {
        throw new TypeError('parameter 1 is not of type "Element".');
      }
      var observations = this.observations_;
      if (observations.has(target2)) {
        return;
      }
      observations.set(target2, new ResizeObservation(target2));
      this.controller_.addObserver(this);
      this.controller_.refresh();
    };
    ResizeObserverSPI2.prototype.unobserve = function(target2) {
      if (!arguments.length) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      if (typeof Element === "undefined" || !(Element instanceof Object)) {
        return;
      }
      if (!(target2 instanceof getWindowOf(target2).Element)) {
        throw new TypeError('parameter 1 is not of type "Element".');
      }
      var observations = this.observations_;
      if (!observations.has(target2)) {
        return;
      }
      observations.delete(target2);
      if (!observations.size) {
        this.controller_.removeObserver(this);
      }
    };
    ResizeObserverSPI2.prototype.disconnect = function() {
      this.clearActive();
      this.observations_.clear();
      this.controller_.removeObserver(this);
    };
    ResizeObserverSPI2.prototype.gatherActive = function() {
      var _this = this;
      this.clearActive();
      this.observations_.forEach(function(observation) {
        if (observation.isActive()) {
          _this.activeObservations_.push(observation);
        }
      });
    };
    ResizeObserverSPI2.prototype.broadcastActive = function() {
      if (!this.hasActive()) {
        return;
      }
      var ctx = this.callbackCtx_;
      var entries = this.activeObservations_.map(function(observation) {
        return new ResizeObserverEntry(observation.target, observation.broadcastRect());
      });
      this.callback_.call(ctx, entries, ctx);
      this.clearActive();
    };
    ResizeObserverSPI2.prototype.clearActive = function() {
      this.activeObservations_.splice(0);
    };
    ResizeObserverSPI2.prototype.hasActive = function() {
      return this.activeObservations_.length > 0;
    };
    return ResizeObserverSPI2;
  }()
);
var observers = typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : new MapShim();
var ResizeObserver$1 = (
  /** @class */
  /* @__PURE__ */ function() {
    function ResizeObserver2(callback) {
      if (!(this instanceof ResizeObserver2)) {
        throw new TypeError("Cannot call a class as a function.");
      }
      if (!arguments.length) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      var controller = ResizeObserverController.getInstance();
      var observer = new ResizeObserverSPI(callback, controller, this);
      observers.set(this, observer);
    }
    return ResizeObserver2;
  }()
);
[
  "observe",
  "unobserve",
  "disconnect"
].forEach(function(method) {
  ResizeObserver$1.prototype[method] = function() {
    var _a;
    return (_a = observers.get(this))[method].apply(_a, arguments);
  };
});
var index = function() {
  if (typeof global$1.ResizeObserver !== "undefined") {
    return global$1.ResizeObserver;
  }
  return ResizeObserver$1;
}();
const ResizeObserver_es = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: index
}, Symbol.toStringTag, { value: "Module" }));
const require$$2 = /* @__PURE__ */ getAugmentedNamespace(ResizeObserver_es);
var hasRequiredWidthProvider;
function requireWidthProvider() {
  if (hasRequiredWidthProvider) return WidthProvider;
  hasRequiredWidthProvider = 1;
  Object.defineProperty(WidthProvider, "__esModule", {
    value: true
  });
  WidthProvider.default = WidthProvideRGL;
  var React2 = _interopRequireWildcard(React__default);
  var _propTypes = _interopRequireDefault(/* @__PURE__ */ requirePropTypes$1());
  var _resizeObserverPolyfill = _interopRequireDefault(require$$2);
  var _clsx = _interopRequireDefault(requireClsx());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r2 = /* @__PURE__ */ new WeakMap(), t2 = /* @__PURE__ */ new WeakMap();
    return (_getRequireWildcardCache = function(e2) {
      return e2 ? t2 : r2;
    })(e);
  }
  function _interopRequireWildcard(e, r2) {
    if (e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return { default: e };
    var t2 = _getRequireWildcardCache(r2);
    if (t2 && t2.has(e)) return t2.get(e);
    var n2 = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
      var i2 = a ? Object.getOwnPropertyDescriptor(e, u) : null;
      i2 && (i2.get || i2.set) ? Object.defineProperty(n2, u, i2) : n2[u] = e[u];
    }
    return n2.default = e, t2 && t2.set(e, n2), n2;
  }
  function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target2) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source2 = arguments[i2];
        for (var key in source2) {
          if (Object.prototype.hasOwnProperty.call(source2, key)) {
            target2[key] = source2[key];
          }
        }
      }
      return target2;
    };
    return _extends.apply(this, arguments);
  }
  function _defineProperty2(obj, key, value2) {
    key = _toPropertyKey2(key);
    if (key in obj) {
      Object.defineProperty(obj, key, { value: value2, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value2;
    }
    return obj;
  }
  function _toPropertyKey2(arg) {
    var key = _toPrimitive2(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _toPrimitive2(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  const layoutClassName = "react-grid-layout";
  function WidthProvideRGL(ComposedComponent) {
    var _class;
    return _class = class WidthProvider extends React2.Component {
      constructor() {
        super(...arguments);
        _defineProperty2(this, "state", {
          width: 1280
        });
        _defineProperty2(this, "elementRef", /* @__PURE__ */ React2.createRef());
        _defineProperty2(this, "mounted", false);
        _defineProperty2(this, "resizeObserver", void 0);
      }
      componentDidMount() {
        this.mounted = true;
        this.resizeObserver = new _resizeObserverPolyfill.default((entries) => {
          const node2 = this.elementRef.current;
          if (node2 instanceof HTMLElement) {
            const width = entries[0].contentRect.width;
            this.setState({
              width
            });
          }
        });
        const node = this.elementRef.current;
        if (node instanceof HTMLElement) {
          this.resizeObserver.observe(node);
        }
      }
      componentWillUnmount() {
        this.mounted = false;
        const node = this.elementRef.current;
        if (node instanceof HTMLElement) {
          this.resizeObserver.unobserve(node);
        }
        this.resizeObserver.disconnect();
      }
      render() {
        const {
          measureBeforeMount,
          ...rest
        } = this.props;
        if (measureBeforeMount && !this.mounted) {
          return /* @__PURE__ */ React2.createElement("div", {
            className: (0, _clsx.default)(this.props.className, layoutClassName),
            style: this.props.style,
            ref: this.elementRef
          });
        }
        return /* @__PURE__ */ React2.createElement(ComposedComponent, _extends({
          innerRef: this.elementRef
        }, rest, this.state));
      }
    }, _defineProperty2(_class, "defaultProps", {
      measureBeforeMount: false
    }), _defineProperty2(_class, "propTypes", {
      // If true, will not render children until mounted. Useful for getting the exact width before
      // rendering, to prevent any unsightly resizing.
      measureBeforeMount: _propTypes.default.bool
    }), _class;
  }
  return WidthProvider;
}
var hasRequiredReactGridLayout;
function requireReactGridLayout() {
  if (hasRequiredReactGridLayout) return reactGridLayout.exports;
  hasRequiredReactGridLayout = 1;
  (function(module2) {
    module2.exports = requireReactGridLayout$1().default;
    module2.exports.utils = requireUtils$1();
    module2.exports.calculateUtils = requireCalculateUtils();
    module2.exports.Responsive = requireResponsiveReactGridLayout().default;
    module2.exports.Responsive.utils = requireResponsiveUtils();
    module2.exports.WidthProvider = requireWidthProvider().default;
  })(reactGridLayout);
  return reactGridLayout.exports;
}
var reactGridLayoutExports = requireReactGridLayout();
const StaticWidgetWrapper = forwardRef(({ style, className, widget: widget2 }, ref) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      style: { ...style },
      className: cn(
        `flex flex-col rounded-2xl bg-grayscale-1000 font-bold text-grayscale-100 shadow-sm dark:bg-dark-bg-333 dark:text-dark-grayscale-100`,
        className
      ),
      ref,
      children: [
        widget2.title && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "dashboard-item-header flex items-center justify-between px-6 py-6", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "line-clamp-1 text-lg", children: widget2.title }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: `dashboard-item-content relative flex h-full flex-col overflow-auto`,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollArea, { className: "h-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx(FallbackUi, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(LazyLoader, { children: widget2.content }) }) })
          }
        )
      ]
    }
  ) });
});
StaticWidgetWrapper.displayName = "StaticWidgetWrapper";
const ResGridLayout = reactGridLayoutExports.WidthProvider(reactGridLayoutExports.Responsive);
const StaticDashboard = ({ widgets = [], widgetMargin = 24 }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    ResGridLayout,
    {
      breakpoints: { md: 820, sm: 768 },
      cols: { md: 20, sm: 1 },
      rowHeight: 24,
      isBounded: true,
      margin: [widgetMargin, widgetMargin],
      draggableCancel: ".dashboard-item-content",
      draggableHandle: ".dashboard-item-header",
      containerPadding: [0, 0],
      resizeHandle: null,
      useCSSTransforms: false,
      children: widgets.map((widget2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        StaticWidgetWrapper,
        {
          widget: widget2,
          "data-grid": { ...widget2 }
        },
        widget2.i
      ))
    }
  );
};
const useRoleStore = create((set2, get2) => {
  return {
    roles: [],
    access: false,
    accessedDashboardIds: /* @__PURE__ */ new Set(),
    initRoles: (userRoles) => {
      const roles = userRoles.effectiveRoles.map((role) => role.name);
      set2({ roles });
    },
    checkRole: (role) => get2().roles.includes(role),
    setAccess: (access) => set2({ access }),
    addAccessedDashboardId: (id2) => {
      const { accessedDashboardIds } = get2();
      accessedDashboardIds.add(id2);
      set2({ accessedDashboardIds });
    },
    hasAccessedDashboardId: (id2) => get2().accessedDashboardIds.has(id2)
  };
});
const useUserAgentStore = create((set2) => {
  return {
    isDevice: null,
    setIsDevice: (type2) => {
      set2(() => ({ isDevice: type2 === "mobile" || type2 === "wearable" }));
    }
  };
});
const useDashboard = () => {
  const { appName } = useRoutingContext();
  const { postChildInventory, postInventory, putInventory } = useApi();
  const getWindowSize = () => {
    const width = window.innerWidth;
    if (width >= 1200) return 12;
    if (width >= 996) return 10;
    if (width >= 768) return 6;
    if (width >= 480) return 4;
    return 2;
  };
  const methods = {
    /**
     * Creates a new dashboard and returns its information.
     *
     * @param {Object} params - Parameters for creating the dashboard.
     * @param {number} params.widgetMargin - The margin value for widgets.
     * @param {string} params.headerStyle - The header style of the dashboard.
     * @param {number} params.priority - The priority of the dashboard.
     * @param {string} params.name - The name of the dashboard.
     * @param {string} params.icon - The icon used for the dashboard.
     * @param {string} params.type - The type of the dashboard.
     * @param {boolean} params.global - Indicates if the dashboard is global.
     * @param {string} params.category - The category of the dashboard.
     * @param {string} [params.sourceId] - The ID of the parent source, if applicable.
     * @returns {Promise<Object>} A promise resolving to the response data of the created dashboard.
     */
    postDashboard: async ({
      widgetMargin,
      headerStyle,
      priority,
      name: name2,
      icon: icon2,
      type: type2,
      global: global2,
      category,
      sourceId
    }) => {
      const obj = {
        u5s_Dashboard: {
          name: name2,
          priority,
          icon: icon2,
          widgetClasses: {
            [headerStyle]: true
          },
          widgetMargin
        }
      };
      obj["name"] = name2;
      if (category === "device") {
        obj["u5s_Dashboard"]["deviceTypeValue"] = type2;
      }
      if (global2) {
        obj["c8y_Global"] = {};
        obj["u5s_Dashboard"]["deviceType"] = true;
        obj[`u5s_Dashboard!type!${type2}`] = {};
        return await postInventory(obj);
      }
      if (!global2 && sourceId) {
        obj[`u5s_Dashboard!${category}!${sourceId}`] = {};
        return await postChildInventory(obj, sourceId);
      }
      obj["c8y_Global"] = {};
      obj[`u5s_Dashboard!name!home-${appName}`] = {};
      return await postInventory(obj);
    },
    //  
    /**
     * Updates an existing dashboard with new details.
     *
     * @param {Object} params - Parameters for updating the dashboard.
     * @param {number} params.widgetMargin - The updated margin value for widgets.
     * @param {string} params.headerStyle - The updated header style.
     * @param {number} params.priority - The updated priority.
     * @param {string} params.name - The updated name.
     * @param {string} params.icon - The updated icon.
     * @param {Object} params.dashboard - The existing dashboard managedobject to be updated.
     * @returns {Promise<Object>} A promise resolving to the response data of the updated dashboard.
     */
    putDashboard: async ({
      widgetMargin,
      headerStyle,
      priority,
      name: name2,
      icon: icon2,
      dashboard: dashboard2
    }) => {
      const obj = cloneDeep(dashboard2);
      obj["name"] = name2;
      obj["u5s_Dashboard"]["priority"] = priority;
      obj["u5s_Dashboard"]["icon"] = icon2;
      obj["u5s_Dashboard"]["widgetMargin"] = widgetMargin;
      obj["u5s_Dashboard"]["name"] = name2;
      delete obj["u5s_Dashboard"]["widgetClasses"];
      obj["u5s_Dashboard"]["widgetClasses"] = { [headerStyle]: true };
      return await putInventory(dashboard2.id, obj);
    },
    //  
    /**
     * Adds a new widget to a dashboard.
     *
     * @param {Object} params - Parameters for adding the widget.
     * @param {Object} params.dashboard - The dashboard managedobject to add the widget to.
     * @param {Object} params.obj - The widget object to add.
     * @returns {Promise<Object>} A promise resolving to the response data of the updated dashboard.
     */
    postWidget: async ({ dashboard: dashboard2, obj }) => {
      const cloneDashboard = cloneDeep(dashboard2);
      const widgetsLength = Object.keys(
        dashboard2["u5s_Dashboard"]["children"] ?? {}
      ).length;
      const id2 = String(Math.random()).substring(2);
      const widget2 = {
        ...obj,
        i: id2,
        x: widgetsLength * 4 % getWindowSize(),
        y: 0,
        w: 4,
        h: 4
      };
      cloneDashboard["u5s_Dashboard"]["children"] = {
        ...cloneDashboard["u5s_Dashboard"]["children"],
        [id2]: widget2
      };
      return putInventory(dashboard2.id, cloneDashboard);
    },
    /**   , action = 'edit' | 'remove' */
    /**
     * Edits or removes a widget in a dashboard.
     *
     * @param {Object} params - Parameters for managing the widget.
     * @param {Object} params.dashboard - The dashboard managedobject containing the widget.
     * @param {Object} params.widget - The updated widget object (for editing).
     * @param {string} params.widgetId - The ID of the widget to edit or remove.
     * @param {string} params.action - The action to perform, either 'edit' or 'remove'.
     * @returns {Promise<Object>} A promise resolving to the response data of the updated dashboard.
     */
    putWidget: async ({ dashboard: dashboard2, widget: widget2, widgetId, action }) => {
      const cloneDashboard = cloneDeep(dashboard2);
      if (action === "edit") {
        cloneDashboard["u5s_Dashboard"]["children"] = {
          ...cloneDashboard["u5s_Dashboard"]["children"],
          [widgetId]: widget2
        };
      }
      if (action === "remove") {
        delete cloneDashboard["u5s_Dashboard"]["children"][widgetId];
      }
      return putInventory(dashboard2.id, cloneDashboard);
    },
    /**
     * Updates the layout of widgets in a dashboard.
     *
     * @param {Object} dashboard - The dashboard managedobject containing the current widgets.
     * @param {Array<Object>} newLayout - An array of layout objects, each representing a widget's new position and size.
     * @param {string} newLayout[].i - The ID of the widget to update.
     * @param {number} newLayout[].x - The new x-coordinate of the widget.
     * @param {number} newLayout[].y - The new y-coordinate of the widget.
     * @param {number} newLayout[].w - The new width of the widget.
     * @param {number} newLayout[].h - The new height of the widget.
     *
     * @returns {Promise<void>} A promise that resolves when the dashboard layout has been successfully updated.
     */
    putLayout: async (dashboard2, newLayout) => {
      const updatedDashboard = cloneDeep(dashboard2);
      newLayout.forEach(({ i: i2, x, y, w, h }) => {
        const widget2 = updatedDashboard["u5s_Dashboard"]["children"][i2];
        if (widget2) {
          updatedDashboard["u5s_Dashboard"]["children"][i2] = {
            ...widget2,
            x,
            y,
            w,
            h
          };
        }
      });
      await putInventory(dashboard2.id, updatedDashboard);
    }
  };
  return methods;
};
const useQueryStore = create((set2) => ({
  isQueryInvalidated: 0,
  setQueryInvalidated: () => set2((state) => ({ isQueryInvalidated: state.isQueryInvalidated + 1 })),
  resetQueryInvalidated: () => set2({ isQueryInvalidated: false })
}));
const useQueryDashboardStore = create((set2) => ({
  isQueryAddInvalidated: false,
  isQueryDeleteInvalidated: false,
  newDashboardId: null,
  // Add    
  setQueryAddInvalidated: () => set2({ isQueryAddInvalidated: true }),
  resetQueryAddInvalidated: () => set2({ isQueryAddInvalidated: false }),
  setNewDashboardId: (state) => set2({ newDashboardId: state }),
  // Delete    
  setQueryDeleteInvalidated: () => set2({ isQueryDeleteInvalidated: true }),
  resetQueryDeleteInvalidated: () => set2({ isQueryDeleteInvalidated: false })
}));
const initializeState = (dashboard2, key, defaultValue) => {
  if (!dashboard2 || !dashboard2["u5s_Dashboard"]) return defaultValue;
  if (key === "widgetClasses") {
    return Object.keys(dashboard2["u5s_Dashboard"][key])[0] ?? defaultValue;
  }
  return dashboard2["u5s_Dashboard"][key] ?? defaultValue;
};
const GeneralSection = ({ type: type2, category, mode: mode2 }) => {
  const { t: t2 } = useTranslation();
  const { register, control } = useFormContext();
  useWatch({ name: "icon" });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-y-6", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center gap-x-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { className: "min-w-fit text-lg font-bold", children: t2("GENERAL") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full space-y-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-x-1", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { children: t2("Menu label") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          QuestionTooltip,
          {
            description: t2(
              "Menu label to display in submenu when dashboard is attached"
            )
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Input, { type: "text", name: "name", ...register("name") })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-x-1", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { children: t2("Position in navigation") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          QuestionTooltip,
          {
            description: t2("Position in navigation menu (0 ~ 10000)")
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Input,
        {
          min: 0,
          max: 1e4,
          type: "number",
          name: "priority",
          ...register("priority")
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center gap-x-2 pb-6", children: category !== "group" && mode2 !== "edit" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Controller,
        {
          name: "global",
          control,
          defaultValue: false,
          render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox, { onCheckedChange: (value2) => field.onChange(value2) })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { children: t2("Apply dashboard to all devices of type", { type: type2 }) })
    ] }) })
  ] });
};
const LayoutSection = ({ mode: mode2, className, headerStyle }) => {
  const { t: t2 } = useTranslation();
  const { control } = useFormContext();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: cn("flex flex-col gap-y-6", className), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center gap-x-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { className: "min-w-fit text-lg font-bold", children: t2("LAYOUT") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      FormField,
      {
        className: "flex gap-x-6",
        name: "headerStyle",
        control,
        render: ({ field: { onChange } }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { className: "space-y-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { children: t2("Widget header style") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            RadioGroup,
            {
              className: "gap-0 rounded-lg border border-grayscale-600 dark:border-dark-grayscale-600",
              onValueChange: onChange,
              defaultValue: headerStyle,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { className: "flex items-center gap-x-2 border-b-[1px] border-grayscale-600 px-4 py-3 dark:border-dark-grayscale-600", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    RadioGroupItem,
                    {
                      value: "panel-title-regular",
                      id: "panel-title-regular"
                    }
                  ) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex w-full items-center justify-between", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { htmlFor: "panel-title-regular", children: t2("Regular") }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      QuestionTooltip,
                      {
                        description: t2(
                          "The widget has no border between header and content."
                        )
                      }
                    )
                  ] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { className: "flex items-center gap-x-2 border-b-[1px] border-grayscale-600 px-4 py-3 dark:border-dark-grayscale-600", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    RadioGroupItem,
                    {
                      value: "panel-title-border",
                      id: "panel-title-border"
                    }
                  ) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex w-full items-center justify-between", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { htmlFor: "panel-title-border", children: t2("Border") }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      QuestionTooltip,
                      {
                        description: t2(
                          "The widget has a small separation border between header and content."
                        )
                      }
                    )
                  ] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { className: "flex items-center gap-x-2 px-4 py-3", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    RadioGroupItem,
                    {
                      value: "panel-title-hidden",
                      id: "panel-title-hidden"
                    }
                  ) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex w-full items-center justify-between", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { htmlFor: "panel-title-hidden", children: t2("Hidden") }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      QuestionTooltip,
                      {
                        description: t2("The widget header is not shown.")
                      }
                    )
                  ] })
                ] })
              ]
            }
          ) })
        ] })
      }
    ),
    mode2 !== "widget" && /* @__PURE__ */ jsxRuntimeExports.jsx(
      FormField,
      {
        className: "flex gap-x-6",
        control,
        name: "widgetMargin",
        rules: { min: 0, max: 50 },
        render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { className: "space-y-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { children: t2("Widget margin") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex w-full items-center rounded-lg border border-grayscale-600 bg-grayscale-1000 dark:border-dark-grayscale-600 dark:bg-dark-bg-444", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input,
              {
                className: "right w-full rounded-md border-r-0 border-none px-2 leading-6",
                type: "number",
                ...field
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mr-4 h-6 w-6 bg-grayscale-1000 dark:bg-dark-bg-444", children: "px" })
          ] }) })
        ] })
      }
    )
  ] });
};
const headerVariants = cva("px-6 py-6", {
  variants: {
    headerStyle: {
      "panel-title-regular": "",
      "panel-title-border": "border-b",
      "panel-title-hidden": "hidden"
    }
  },
  defaultVariants: {
    headerStyle: "regular"
  }
});
const PreviewWidget = () => {
  const { t: t2 } = useTranslation();
  const headerStyle = useWatch({ name: "headerStyle" });
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-[500px] rounded-lg border-2 border-grayscale-700 p-10 dark:border-dark-grayscale-400", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative flex h-full flex-col rounded-lg border border-grayscale-800 text-grayscale-300 shadow-md dark:border-dark-grayscale-600", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: cn(headerVariants({ headerStyle })), children: [
      t2("WIDGET TITLE"),
      /* @__PURE__ */ jsxRuntimeExports.jsx(SvgSetting, { className: "absolute right-6 top-6 cursor-pointer" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "span",
      {
        className: cn(
          { "py-6": headerStyle === "panel-title-hidden" },
          "px-6"
        ),
        children: t2("Widget example content")
      }
    )
  ] }) });
};
const PreviewSection = () => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex w-full flex-col gap-y-6 lg:w-1/2", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center gap-x-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { className: "min-w-fit text-lg font-bold", children: t2("PREVIEW") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { children: t2("Tab and layout") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(PreviewWidget, {})
    ] })
  ] });
};
const DashboardModal = ({
  category,
  sourceId,
  dashboardId,
  open,
  onOpenChange,
  mode: mode2
}) => {
  const { putDashboard, postDashboard } = useDashboard();
  const { setNewDashboardId, setQueryAddInvalidated } = useQueryDashboardStore(
    ({ setNewDashboardId: setNewDashboardId2, setQueryAddInvalidated: setQueryAddInvalidated2 }) => ({
      setNewDashboardId: setNewDashboardId2,
      setQueryAddInvalidated: setQueryAddInvalidated2
    })
  );
  const { getInventory } = useApi();
  const { t: t2 } = useTranslation();
  const [{ data: dashboard2 }, { data: device2 }] = useSuspenseQueries({
    queries: [
      {
        queryKey: ["dashboard", dashboardId],
        staleTime: Infinity,
        queryFn: async () => {
          const res = await getInventory(dashboardId);
          return res.data;
        }
      },
      {
        queryKey: ["device", sourceId],
        staleTime: Infinity,
        queryFn: () => getInventory(sourceId)
      }
    ]
  });
  const headerStyle = initializeState(
    dashboard2,
    "widgetClasses",
    "panel-title-regular"
  );
  const methods = useForm({
    mode: "onBlur",
    defaultValues: {
      widgetMargin: 24,
      headerStyle: "panel-title-regular",
      priority: 1e4,
      name: "",
      icon: "dlt-c8y-icon-th",
      global: false
    }
  });
  useEffect(() => {
    const widgetMargin = initializeState(dashboard2, "widgetMargin", 24);
    const initialHeaderStyle = headerStyle;
    const priority = initializeState(dashboard2, "priority", 1e4);
    const name2 = initializeState(dashboard2, "name", "Dashboard");
    const icon2 = initializeState(dashboard2, "icon", "dlt-c8y-icon-th");
    methods.reset({
      ...methods.getValues(),
      widgetMargin,
      headerStyle: initialHeaderStyle,
      priority,
      name: name2,
      icon: icon2
    });
  }, []);
  const addDashboard = useCustomMutation({
    mutationFn: (data) => postDashboard({
      ...data,
      type: device2.data.type,
      category,
      sourceId
    }),
    queryKey: [],
    successMessage: "Dashboard created successfully.",
    errorMessage: "Failed to created dashboard.",
    onSuccess: (data) => {
      setNewDashboardId(data.data.id);
      setQueryAddInvalidated();
      onOpenChange();
    }
  });
  const editDashboard = useCustomMutation({
    mutationFn: (data) => putDashboard({
      ...data,
      dashboard: dashboard2
    }),
    queryKey: [],
    successMessage: "Dashboard edited successfully.",
    errorMessage: "Failed to edit dashboard.",
    onSuccess: (data) => {
      setNewDashboardId(data.data.id);
      setQueryAddInvalidated();
      onOpenChange();
    }
  });
  const handleSubmit = (data) => {
    if (mode2 === "edit") editDashboard(data);
    else addDashboard(data);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog, { open, onOpenChange, children: /* @__PURE__ */ jsxRuntimeExports.jsx(FormProvider, { ...methods, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    DialogContent,
    {
      overlay: true,
      className: "w-full max-w-full bg-grayscale-1000 lg:max-w-screen-lg",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(DialogHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, { className: "text-2xl", children: mode2 === "edit" ? t2("Edit dashboard") : t2("Add dashboard") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollArea, { className: "flex h-dialog items-center justify-center sm:h-[60vh]", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-3 py-2 lg:flex lg:gap-x-6 lg:space-y-0", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lg:w-1/2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              GeneralSection,
              {
                type: device2.data.type,
                category,
                mode: t2(mode2)
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(LayoutSection, { mode: t2(mode2), headerStyle })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(PreviewSection, {})
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogFooter, { className: "w-full items-center justify-center px-6 pb-8 pt-6 sm:justify-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button$1,
            {
              variant: "destructive",
              onClick: onOpenChange,
              className: "h-13.5 w-full max-w-[200px] text-lg",
              children: t2("Cancel")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button$1,
            {
              onClick: methods.handleSubmit(handleSubmit),
              className: "h-13.5 w-full max-w-[200px] text-lg",
              children: t2("Save")
            }
          )
        ] })
      ]
    }
  ) }) });
};
const RemoveModal = ({ open, onOpenChange, title: title2, onDelete, children }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog, { open, onOpenChange, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    DialogContent,
    {
      overlay: true,
      closeButton: false,
      className: "w-full max-w-[335px] gap-0 rounded-2xl p-6 sm:max-w-[400px] sm:p-7",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(DialogHeader, { className: "mb-3 text-start", children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, { className: "pb-3 pt-0 text-xl font-bold", children: title2 }) }),
        children,
        /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogFooter, { className: "flex flex-row justify-end space-x-3 pb-0 sm:space-x-3", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button$1,
            {
              variant: "destructive",
              onClick: onOpenChange,
              className: "rounded-lg",
              children: t2("Cancel")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { onClick: onDelete, className: "rounded-lg", children: t2("Delete") })
        ] })
      ]
    }
  ) });
};
const s = (e, s2, o2) => {
  if (e && "reportValidity" in e) {
    const r2 = get$2(o2, s2);
    e.setCustomValidity(r2 && r2.message || ""), e.reportValidity();
  }
}, o = (t2, e) => {
  for (const o2 in e.fields) {
    const r2 = e.fields[o2];
    r2 && r2.ref && "reportValidity" in r2.ref ? s(r2.ref, o2, t2) : r2.refs && r2.refs.forEach((e2) => s(e2, o2, t2));
  }
}, r = (s2, r2) => {
  r2.shouldUseNativeValidation && o(s2, r2);
  const f = {};
  for (const o2 in s2) {
    const n2 = get$2(r2.fields, o2), a = Object.assign(s2[o2] || {}, { ref: n2 && n2.ref });
    if (i(r2.names || Object.keys(s2), o2)) {
      const s3 = Object.assign({}, get$2(f, o2));
      set$1(s3, "root", a), set$1(f, o2, s3);
    } else set$1(f, o2, a);
  }
  return f;
}, i = (t2, e) => t2.some((t3) => t3.startsWith(e + "."));
var n = function(r2, e) {
  for (var n2 = {}; r2.length; ) {
    var t2 = r2[0], s2 = t2.code, i2 = t2.message, a = t2.path.join(".");
    if (!n2[a]) if ("unionErrors" in t2) {
      var u = t2.unionErrors[0].errors[0];
      n2[a] = { message: u.message, type: u.code };
    } else n2[a] = { message: i2, type: s2 };
    if ("unionErrors" in t2 && t2.unionErrors.forEach(function(e2) {
      return e2.errors.forEach(function(e3) {
        return r2.push(e3);
      });
    }), e) {
      var c = n2[a].types, f = c && c[t2.code];
      n2[a] = appendErrors(a, e, n2, s2, f ? [].concat(f, t2.message) : t2.message);
    }
    r2.shift();
  }
  return n2;
}, t = function(o$1, t2, s2) {
  return void 0 === s2 && (s2 = {}), function(i2, a, u) {
    try {
      return Promise.resolve(function(e, n2) {
        try {
          var a2 = Promise.resolve(o$1["sync" === s2.mode ? "parse" : "parseAsync"](i2, t2)).then(function(e2) {
            return u.shouldUseNativeValidation && o({}, u), { errors: {}, values: s2.raw ? i2 : e2 };
          });
        } catch (r2) {
          return n2(r2);
        }
        return a2 && a2.then ? a2.then(void 0, n2) : a2;
      }(0, function(r$12) {
        if (function(r2) {
          return Array.isArray(null == r2 ? void 0 : r2.errors);
        }(r$12)) return { values: {}, errors: r(n(r$12.errors, !u.shouldUseNativeValidation && "all" === u.criteriaMode), u) };
        throw r$12;
      }));
    } catch (r2) {
      return Promise.reject(r2);
    }
  };
};
const DynamicWidget = ({ widgetId, searchQuery, type: type2, onSelect, ...props }) => {
  const { t: t2 } = useTranslation();
  const [error2, setError] = useState("");
  const widgetComponent = widgetManager.load(widgetId);
  if (error2) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      t2("Error loading widget:"),
      " ",
      error2
    ] });
  }
  if (type2 === "previewImage") {
    const path2 = widgetComponent && widgetComponent["previewImage"];
    const label2 = widgetComponent && widgetComponent["label"];
    const highlightedLabel = (label22) => {
      if (!searchQuery) return t2(label22);
      const regex = new RegExp(`(${searchQuery})`, "gi");
      const searchQueries = t2(label22).split(regex);
      return searchQueries.map(
        (query, index2) => regex.test(query) ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          "span",
          {
            className: "font-bold text-primary dark:text-dark-primary",
            children: query
          },
          index2
        ) : /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: query }, index2)
      );
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: "rounded-lg bg-grayscale-900 p-1 duration-150 hover:ring-4 hover:ring-blue-500 dark:bg-dark-grayscale-900",
        ...props,
        onClick: () => onSelect(widgetComponent),
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rounded-lg bg-grayscale-1000 p-2 dark:bg-dark-bg-333", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-gray-200 mb-2 w-full p-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: path2, alt: t2(label2), className: "aspect-square" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center text-sm uppercase", children: highlightedLabel(label2) })
        ] })
      }
    );
  }
  const Widget = widgetComponent && widgetComponent[type2];
  return Widget ? /* @__PURE__ */ jsxRuntimeExports.jsx(Widget, { ...props }) : null;
};
const DynamicWidget$1 = memo$1(DynamicWidget);
const SelectWidget = ({ widgetList, handleSelectWidget }) => {
  const { t: t2 } = useTranslation();
  const { control } = useFormContext();
  const [searchQuery, setSearchQuery] = useState("");
  const [filteredWidgets, setFilteredWidgets] = useState(widgetList);
  const widgetInfo = widgetList.map((widgetId) => {
    const widget2 = widgetManager.load(widgetId);
    return { ...widget2, translation: t2(widget2.label, { lng: "ko" }) };
  });
  const handleSearchChange = (e) => {
    const query = e.target.value.toLowerCase();
    setSearchQuery(query);
    const filtered = widgetInfo.filter(
      (widget2) => widget2.label.toLowerCase().includes(query) || widget2.id.toLowerCase().includes(query) || widget2.translation.includes(query)
    ).map((w) => w.id);
    setFilteredWidgets(filtered);
  };
  const handleKeyPress = async (e) => {
    if (e.key === "Enter") {
      e.preventDefault();
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative mb-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Input,
      {
        id: "widget-search",
        type: "text",
        className: "w-full rounded-md border border-grayscale-600 focus:ring-primary dark:border-dark-grayscale-600",
        placeholder: t2("Search..."),
        value: searchQuery,
        onChange: handleSearchChange,
        onKeyDown: handleKeyPress,
        clearable: true
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-2 justify-between gap-2 pb-1 text-sm lg:grid-cols-3 xl:grid-cols-4", children: filteredWidgets.length > 0 && filteredWidgets.map((widgetId, i2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      Controller,
      {
        name: "selectedWidget",
        control,
        defaultValue: null,
        render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          DynamicWidget$1,
          {
            widgetId,
            searchQuery,
            type: "previewImage",
            onSelect: (widget2) => {
              handleSelectWidget(widget2);
              field.onChange(widget2);
            },
            ...field,
            ref: null
          }
        )
      },
      widgetId
    )) })
  ] });
};
const Configuration = ({ selectedWidget, sourceId }) => {
  const { t: t2 } = useTranslation();
  const { control, setValue, getValues } = useFormContext();
  const { data: device2 } = useDeviceInventory(sourceId, {
    enabled: !selectedWidget.data.options.noDeviceTarget || !!sourceId,
    refetchOnMount: "always",
    select: (data) => (data == null ? void 0 : data.data) ? data.data : data
  });
  const link2 = useWatch({ name: "link" });
  useEffect(() => {
    if (!device2) return;
    const selectedDevice = getValues("config.device");
    if (!selectedDevice) return;
    const updateDeviceId = selectedDevice.id === "" || !selectedDevice.id ? device2.id : selectedDevice.id;
    const updateDeviceName = selectedDevice.name === "" || !selectedDevice.name ? device2.name : selectedDevice.name;
    if (sourceId)
      setValue("config.device", {
        id: updateDeviceId,
        name: updateDeviceName
      });
  }, [device2, sourceId]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(FocusScope, { children: selectedWidget && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex w-full flex-col justify-center pb-3", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "py-8", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-lg font-bold text-grayscale-200 dark:text-dark-grayscale-200", children: t2(selectedWidget.label) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm font-medium text-grayscale-300 dark:text-dark-grayscale-300", children: t2(selectedWidget.description) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        FormField,
        {
          control,
          name: "title",
          render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { className: "mb-6 space-y-1.5", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { children: t2("Title") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input,
              {
                className: "text-base font-bold",
                placeholder: selectedWidget.label,
                ...field,
                value: field.value,
                clearable: true
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, {})
          ] })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(DataManager, { dataType: "link", name: "link", data: link2 })
    ] }),
    !selectedWidget.data.options.noDeviceTarget && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        FormField,
        {
          name: "config.device",
          control,
          render: ({ field: { onChange } }) => {
            var _a, _b;
            return /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { className: "space-y-1.5", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { children: t2("Target assets or devices") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                SearchDeviceTree,
                {
                  groupSelectable: selectedWidget.data.options.groupsSelectable,
                  context: device2,
                  selected: (props) => {
                    if (!props) {
                      return;
                    }
                    const id2 = props.id ?? "";
                    const name2 = props.name ?? "";
                    onChange({ id: id2, name: name2 });
                  },
                  getSelectedDevice: ((_b = (_a = selectedWidget == null ? void 0 : selectedWidget.config) == null ? void 0 : _a.device) == null ? void 0 : _b.id) || null
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, {})
            ] });
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Separator, { className: "my-6" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      DynamicWidget$1,
      {
        widgetId: selectedWidget["id"],
        type: "configComponent"
      }
    ) })
  ] }) }) });
};
const WidgetModal = ({
  open,
  onOpenChange,
  dashboardId,
  onAddWidget,
  onEditWidget,
  mode: mode2,
  sourceId,
  widget: widget2 = null
}) => {
  const { getInventory } = useApi();
  const { t: t$1 } = useTranslation();
  const { data: dashboard2 } = useSuspenseQuery({
    queryKey: ["dashboard", dashboardId],
    staleTime: Infinity,
    refetchOnMount: "always",
    queryFn: async () => {
      const res = await getInventory(dashboardId);
      return res.data;
    }
  });
  const [selectedWidget, setSelectedWidget] = useState(widget2);
  const headerStyle = selectedWidget && selectedWidget.classes ? Object.keys(selectedWidget.classes)[0] : initializeState(dashboard2, "widgetClasses", "panel-title-regular");
  const resolver = useMemo(() => {
    if (!selectedWidget) return z.object({});
    if (selectedWidget.schema) return selectedWidget.schema.merge(baseSchema);
    return widgetManager.getSchema(selectedWidget.id).merge(baseSchema);
  }, [selectedWidget]);
  const methods = useForm({
    mode: "onBlur",
    defaultValues: {
      headerStyle,
      title: selectedWidget ? selectedWidget.title ?? selectedWidget.label : "",
      link: selectedWidget ? selectedWidget.link : null,
      config: selectedWidget ? selectedWidget.defaultValues ?? selectedWidget.config : {}
    },
    resolver: t(resolver)
  });
  useEffect(() => {
    const initialHeaderStyle = headerStyle;
    methods.reset({ ...methods.getValues(), headerStyle: initialHeaderStyle });
  }, [dashboard2, selectedWidget]);
  useEffect(() => {
    if (!selectedWidget) return;
    methods.reset({
      ...methods.getValues(),
      title: selectedWidget.title ?? selectedWidget.label,
      config: selectedWidget.defaultValues ?? selectedWidget.config,
      link: selectedWidget ? selectedWidget.link : null
    });
  }, [selectedWidget]);
  const [currentTab, setCurrentTab] = useState(mode2);
  const handleSelectWidget = (widget22) => {
    setSelectedWidget((pre) => ({ ...pre, ...widget22 }));
    setCurrentTab("configuration");
  };
  const handleSubmit = (widget22) => {
    const obj = cloneDeep(widget22);
    const { id: id2, data, label: label2, description: description2 } = selectedWidget;
    obj["id"] = id2;
    obj["data"] = data;
    obj["label"] = label2;
    obj["description"] = description2;
    delete obj["headerStyle"];
    obj["classes"] = { [widget22["headerStyle"]]: true };
    if (onEditWidget) {
      const { x, y, w, h, i: i2 } = selectedWidget;
      obj["x"] = x;
      obj["y"] = y;
      obj["w"] = w;
      obj["h"] = h;
      obj["i"] = i2;
    }
    onEditWidget ? onEditWidget({ dashboard: dashboard2, obj }) : onAddWidget({
      dashboard: dashboard2,
      obj
    });
  };
  const widgetList = widgetManager.list();
  const scrollAreaRef = useRef(null);
  useEffect(() => {
    if (scrollAreaRef.current) {
      const scrollContent = scrollAreaRef.current.querySelector(
        "[data-radix-scroll-area-viewport]"
      );
      if (scrollContent) {
        scrollContent.scrollTop = 0;
      }
    }
  }, [currentTab]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog, { open, onOpenChange, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    DialogContent,
    {
      overlay: true,
      className: "bg-grayscale-1000 px-0 lg:max-w-screen-md xl:max-w-screen-lg",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Form, { ...methods, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: methods.handleSubmit(handleSubmit), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(DialogHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, { className: "mb-4 px-6 text-xl font-extrabold", children: t$1("Add widget") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Tabs$1,
          {
            value: currentTab,
            onValueChange: (value2) => setCurrentTab(value2),
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsList, { className: "flex w-full justify-around rounded-none border-b border-grayscale-700 bg-grayscale-1000 py-3 text-grayscale-300 dark:border-dark-grayscale-400 dark:bg-dark-bg-444 dark:text-grayscale-600", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  TabsTrigger,
                  {
                    value: "select-widget",
                    className: "flex w-full gap-x-1 text-[18px]",
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(SvgDashboard, { className: "h-5 w-5" }),
                      t$1("Select widget")
                    ]
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  TabsTrigger,
                  {
                    value: "configuration",
                    className: "flex w-full gap-x-1 text-[18px] disabled:!cursor-not-allowed",
                    disabled: !selectedWidget,
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(SvgComposition, { className: "h-5 w-5 " }),
                      t$1("Configuration")
                    ]
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  TabsTrigger,
                  {
                    value: "appearance",
                    className: "flex w-full gap-x-1 text-[18px] disabled:!cursor-not-allowed",
                    disabled: !selectedWidget,
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(SvgStyle, { className: "h-5 w-5" }),
                      t$1("Appearance")
                    ]
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                ScrollArea,
                {
                  ref: scrollAreaRef,
                  className: "flex h-dialog items-center justify-center sm:h-[60vh]",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(FallbackUi, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(LazyLoader, { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      TabsContent,
                      {
                        value: "select-widget",
                        className: "bg-gray-200 p-5 sm:p-6",
                        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                          SelectWidget,
                          {
                            widgetList,
                            handleSelectWidget
                          }
                        )
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "configuration", className: "p-5 sm:p-6", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Configuration,
                      {
                        selectedWidget,
                        sourceId
                      }
                    ) }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      TabsContent,
                      {
                        value: "appearance",
                        className: "justify-between space-y-6 p-5 sm:p-6 lg:flex lg:gap-x-6 lg:space-y-0",
                        children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx(
                            LayoutSection,
                            {
                              headerStyle,
                              className: "lg:w-1/2",
                              mode: "widget"
                            }
                          ),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(PreviewSection, { headerStyle })
                        ]
                      }
                    )
                  ] }) })
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogFooter, { className: "w-full items-center justify-center px-6 pt-6 sm:justify-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button$1,
            {
              variant: "destructive",
              onClick: onOpenChange,
              className: "h-13.5 w-full max-w-[200px] text-lg",
              children: t$1("Cancel")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button$1,
            {
              type: "submit",
              disabled: !methods.formState.isValid,
              className: "h-13.5 w-full max-w-[200px] text-lg",
              children: t$1("Save")
            }
          )
        ] })
      ] }) })
    }
  ) });
};
const useWidgetActions = ({
  action,
  widgetId,
  dashboardId,
  closeModal,
  successMessage,
  errorMessage,
  callback
}) => {
  const { toast } = useToast();
  const { putWidget } = useDashboard();
  const queryClient = useQueryClient();
  const setQueryInvalidated = useQueryStore(
    (state) => state.setQueryInvalidated
  );
  let mutationFn;
  if (action === "edit") {
    mutationFn = ({ dashboard: dashboard2, obj }) => putWidget({
      dashboard: dashboard2,
      widget: obj,
      widgetId,
      action: "edit"
    });
  }
  if (action === "remove") {
    mutationFn = (dashboard2) => putWidget({
      dashboard: dashboard2,
      action: "remove",
      widgetId
    });
  }
  const { mutate } = useMutation({
    mutationFn,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["dashboard", dashboardId] }).then(() => {
        setQueryInvalidated();
        if (callback) callback();
      });
      toast({
        title: successMessage,
        duration: 3e3,
        variant: "success"
      });
    },
    onError: () => {
      toast({
        title: errorMessage,
        duration: 3e3,
        variant: "destructive"
      });
    },
    onSettled: () => {
      closeModal(false);
    }
  });
  return mutate;
};
const ContextWidgetActionItems = ({
  dashboard: dashboard2,
  widget: widget2,
  sourceId,
  isHovered,
  setIsEdit
}) => {
  var _a;
  const { goTo } = useTransitionNavigate();
  const { t: t2 } = useTranslation();
  const [editModalIsOpen, setEditModalIsOpen] = useState(false);
  const [removeModalIsOpen, setRemoveModalIsOpen] = useState(false);
  const [isConfigurationClick, setIsConfigurationClick] = useState(false);
  const headerStyle = Object.keys(widget2.classes)[0];
  const widgetMsgSuccess = "Widget edited successfully.";
  const widgetMsgFail = "Widget editing failed.";
  const getURL = () => {
    if ((widget2 == null ? void 0 : widget2.link.length) < 1) return;
    const { isGroup, __original, id: id2 } = widget2.link[0];
    return `/${isGroup ? "group" : "device"}/${__original.id}/dashboard/${id2}`;
  };
  const editWidget = useWidgetActions({
    action: "edit",
    widgetId: widget2.i,
    dashboardId: dashboard2.id,
    closeModal: setEditModalIsOpen,
    callback: () => setIsEdit((pre) => pre + 1),
    successMessage: t2(widgetMsgSuccess),
    errorMessage: t2(widgetMsgFail)
  });
  const removeWidget = useWidgetActions({
    action: "remove",
    widgetId: widget2.i,
    dashboardId: dashboard2.id,
    closeModal: setEditModalIsOpen,
    successMessage: t2("Widget removed."),
    errorMessage: t2("Widget removal failed.")
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    editModalIsOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(
      WidgetModal,
      {
        open: editModalIsOpen,
        onOpenChange: () => setEditModalIsOpen((pre) => !pre),
        dashboardId: dashboard2.id,
        onEditWidget: editWidget,
        mode: "configuration",
        sourceId,
        widget: widget2
      }
    ),
    removeModalIsOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(
      RemoveModal,
      {
        onOpenChange: () => setRemoveModalIsOpen((pre) => !pre),
        open: removeModalIsOpen,
        onDelete: () => removeWidget(dashboard2),
        title: t2("Remove widget"),
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-grayscale-300", children: [
          t2("you are about to remove widget from your dashboard."),
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          t2("do you want to proceed?")
        ] })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: `flex items-center justify-center ${headerStyle === "panel-title-hidden" ? "absolute  right-6 top-6 z-1 h-6" : "relative"} `,
        children: [
          ((_a = widget2 == null ? void 0 : widget2.link) == null ? void 0 : _a.length) > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
            SvgArrowRight,
            {
              className: `h-6 w-6 cursor-pointer text-grayscale-300`,
              onClick: () => goTo(getURL())
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(DropdownMenu, { onOpenChange: (open) => setIsConfigurationClick(open), children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(DropdownMenuTrigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              SvgSetting,
              {
                className: cn(
                  {
                    hidden: !isHovered && !isConfigurationClick,
                    visible: isHovered || isConfigurationClick
                  },
                  "ml-1 text-grayscale-300 outline-none transition-opacity"
                )
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              DropdownMenuContent,
              {
                align: "end",
                className: cn(
                  headerStyle === "panel-title-hidden" ? "" : "",
                  " shadow-md dark:border-dark-grayscale-400 dark:bg-dark-bg-444"
                ),
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    DropdownMenuItem,
                    {
                      onSelect: () => setEditModalIsOpen(true),
                      className: "gap-x-2",
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(SvgEdit, {}),
                        t2("Edit")
                      ]
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    DropdownMenuItem,
                    {
                      className: "gap-x-2",
                      onSelect: () => setRemoveModalIsOpen(true),
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(SvgTrash, { className: "h-4 w-4" }),
                        t2("Remove")
                      ]
                    }
                  )
                ]
              }
            )
          ] })
        ]
      }
    )
  ] });
};
const ContextWidgetWrapper = forwardRef(
  ({
    style,
    className,
    onMouseDown,
    onMouseUp,
    onTouchEnd,
    widget: widget2,
    dashboard: dashboard2,
    sourceId,
    isFrozen,
    props,
    children
  }, ref) => {
    const [isEdit, setIsEdit] = useState(0);
    const [isHovered, setIsHovered] = useState(false);
    const headerStyle = Object.keys(widget2.classes)[0];
    const getHeaderClass = () => {
      switch (headerStyle) {
        case "panel-title-border":
          return "border-b border-grayscale-800 px-6 py-6";
        case "panel-title-hidden":
          return "h-6 pr-6";
        default:
          return "px-6 px-6 py-6";
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: { ...style },
        className: cn(
          `flex flex-col rounded-2xl bg-grayscale-1000 font-bold text-grayscale-100 shadow-sm dark:bg-dark-bg-333 dark:text-dark-grayscale-100`,
          className
        ),
        ref,
        onMouseDown,
        onMouseUp,
        onTouchEnd,
        onMouseEnter: () => setIsHovered(true),
        onMouseLeave: () => setIsHovered(false),
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: cn(
                getHeaderClass(),
                `dashboard-item-header flex ${isFrozen ? "" : "cursor-move "} items-center justify-between`
              ),
              children: [
                headerStyle === "panel-title-hidden" ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", {}) : /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "line-clamp-1 text-lg", children: widget2.title }),
                !isFrozen && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  ContextWidgetActionItems,
                  {
                    dashboard: dashboard2,
                    widget: widget2,
                    sourceId,
                    isHovered,
                    setIsEdit
                  }
                )
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: `dashboard-item-content relative flex h-full flex-col overflow-auto`,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollArea, { className: "mb-3 mr-3 h-full pb-3 pl-6 pr-3", children: /* @__PURE__ */ jsxRuntimeExports.jsx(FallbackUi, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(LazyLoader, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DynamicWidget$1,
                  {
                    widgetId: widget2.id,
                    config: widget2.config,
                    type: "component",
                    widgetKey: widget2.i,
                    sourceId,
                    w: widget2.w,
                    h: widget2.h,
                    headerStyle
                  },
                  `${widget2.id}_${isEdit}`
                ) }) }) }),
                children
              ]
            }
          )
        ]
      }
    ) });
  }
);
ContextWidgetWrapper.displayName = "ContextWidgetWrapper";
const ContextGrid = ({ dashboard: dashboard2, sourceId }) => {
  const minSize = { minH: 4, minW: 2 };
  const { putLayout } = useDashboard();
  const ResGridLayout2 = useMemo(() => reactGridLayoutExports.WidthProvider(reactGridLayoutExports.Responsive), []);
  const containerRef = useRef(null);
  const access = useRoleStore((state) => state.access);
  const widgets = useMemo(() => {
    const widgets2 = Object.values(dashboard2["u5s_Dashboard"]["children"]);
    return orderBy(widgets2, ["y", "x"], ["asc", "asc"]);
  }, [dashboard2["u5s_Dashboard"]["children"], dashboard2.id]);
  const [updatedWidgets, setUpdatedWidgets] = useState([]);
  const [windowWidth, setWindowWidth] = useState(window.innerWidth);
  const widgetMargin = Number(dashboard2.u5s_Dashboard.widgetMargin);
  const isFrozen = !access || dashboard2["u5s_Dashboard"]["isFrozen"] || windowWidth <= 1024;
  const queryClient = useQueryClient();
  const [isDragging, setIsDragging] = useState(false);
  const [preLayout, setPreLayout] = useState([]);
  const { mutate: handleDrag } = useMutation({
    mutationFn: ({ newLayout }) => putLayout(dashboard2, newLayout),
    onSettled: async () => {
      await queryClient.invalidateQueries({
        queryKey: ["dashboard", dashboard2.id]
      });
    }
  });
  const onDragStart = (layout2) => {
    setPreLayout(layout2);
    setIsDragging(true);
  };
  const onDragStop = (newLayout) => {
    if (isEqual(preLayout, newLayout)) return;
    setIsDragging(false);
    handleDrag({ newLayout });
  };
  const onBreakpointChange = (newBreakpoint, newCols) => {
    calculateGrid(newBreakpoint, newCols);
  };
  useEffect(() => {
    const updateWindowWidth = () => {
      setWindowWidth(window.innerWidth);
    };
    window.addEventListener("resize", updateWindowWidth);
    return () => {
      window.removeEventListener("resize", updateWindowWidth);
    };
  }, []);
  const calculateGrid = (breakpoint, maxColumns) => {
    if (breakpoint === "xl") return setUpdatedWidgets(widgets);
    const totalWidgets = widgets.length;
    const updatedWidgets2 = [];
    let currentRowY = 0;
    for (let i2 = 0; i2 < totalWidgets; i2++) {
      const currentWidget = widgets[i2];
      const { w: widgetWidth, h: widgetHeight } = currentWidget;
      let maxRowHeight = widgetHeight;
      if (widgetWidth >= maxColumns) {
        updatedWidgets2.push({
          ...currentWidget,
          y: currentRowY,
          w: widgetWidth > maxColumns ? maxColumns : widgetWidth
        });
        currentRowY += widgetHeight;
        continue;
      }
      let currentRowWidth = 0;
      let startWidgetIndex = i2;
      let nextWidgetIndex = i2;
      while (nextWidgetIndex < totalWidgets && currentRowWidth + widgets[nextWidgetIndex].w <= maxColumns) {
        const nextWidget = widgets[nextWidgetIndex];
        currentRowWidth += nextWidget.w;
        maxRowHeight = Math.max(maxRowHeight, nextWidget.h);
        nextWidgetIndex++;
      }
      if (currentRowWidth > maxColumns) {
        nextWidgetIndex--;
      }
      if (nextWidgetIndex - startWidgetIndex === 1) {
        const singleWidget = widgets[startWidgetIndex];
        updatedWidgets2.push({
          ...singleWidget,
          h: maxRowHeight,
          w: maxColumns,
          //     
          y: currentRowY,
          x: 0
          //  
        });
        currentRowY += maxRowHeight;
        continue;
      }
      let convertW = Math.floor(
        maxColumns / (nextWidgetIndex - startWidgetIndex)
      );
      let remainingColumns = maxColumns - convertW * (nextWidgetIndex - startWidgetIndex);
      let currentX = 0;
      while (startWidgetIndex < nextWidgetIndex) {
        const widget2 = widgets[startWidgetIndex];
        let widgetW = convertW;
        if (remainingColumns > 0) {
          widgetW++;
          remainingColumns--;
        }
        updatedWidgets2.push({
          ...widget2,
          h: maxRowHeight,
          w: widgetW,
          y: currentRowY,
          x: currentX
        });
        currentX += widgetW;
        startWidgetIndex++;
      }
      currentRowY += maxRowHeight;
      i2 = nextWidgetIndex - 1;
    }
    setUpdatedWidgets(updatedWidgets2);
  };
  useEffect(() => {
    const calculateBreakpoint = (width) => {
      if (width >= 1440) return { breakpoint: "xl", cols: 12 };
      if (width >= 1024) return { breakpoint: "lg", cols: 6 };
      if (width >= 768) return { breakpoint: "md", cols: 6 };
      if (width >= 576) return { breakpoint: "sm", cols: 4 };
      if (width >= 480) return { breakpoint: "xs", cols: 4 };
      return { breakpoint: "xss", cols: 1 };
    };
    if (containerRef.current) {
      const width = containerRef.current.state.width;
      const { breakpoint, cols } = calculateBreakpoint(width);
      onBreakpointChange(breakpoint, cols);
    }
  }, [dashboard2.iId]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    ResGridLayout2,
    {
      breakpoints: {
        xl: 1440,
        lg: 1024,
        md: 768,
        sm: 576,
        xs: 480,
        xss: 0
      },
      cols: {
        xl: 12,
        lg: 6,
        md: 6,
        sm: 4,
        xs: 4,
        xss: 1
      },
      ref: containerRef,
      rowHeight: 24,
      isResizable: !isFrozen,
      isDraggable: !isFrozen,
      isBounded: true,
      margin: [widgetMargin, widgetMargin],
      onDragStart,
      onDragStop,
      onResizeStart: onDragStart,
      onResizeStop: onDragStop,
      draggableCancel: ".dashboard-item-content",
      draggableHandle: ".dashboard-item-header",
      containerPadding: [0, 0],
      resizeHandle: null,
      onBreakpointChange,
      useCSSTransforms: false,
      children: widgets.map((widget2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        ContextWidgetWrapper,
        {
          widget: widget2,
          "data-grid": { ...widget2, ...minSize },
          dashboard: dashboard2,
          sourceId,
          isFrozen
        },
        widget2.i
      ))
    }
  );
};
const ContextGrid$1 = memo$1(ContextGrid);
const RenderEmptyStateMessage = ({
  title: title2,
  description: description2,
  buttonText,
  access,
  onClick
}) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full bg-grayscale-900 pt-6 text-center dark:bg-dark-grayscale-900", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "icon-5x c8y-icon c8y-icon-device c8y-icon-duocolor text-primary" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "pb-1 pt-4 text-xl", children: t2(title2) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "pb-4 text-xs", children: t2(description2) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button$1,
        {
          variant: "outline",
          onClick,
          className: `${access ? "cursor-pointer" : "cursor-not-allowed"}`,
          children: t2(buttonText)
        }
      )
    ] })
  ] });
};
const useDashboardStore = create((set2) => ({
  isDashboard: false,
  isFullScreen: document.fullscreenElement,
  dashboardModalIsOpen: false,
  editModalIsOpen: false,
  widgetModalIsOpen: false,
  deleteModalIsOpen: false,
  setIsDashboard: (isDashboard) => set2(() => ({ isDashboard })),
  setDashboardModalIsOpen: () => set2((state) => ({ dashboardModalIsOpen: !state.dashboardModalIsOpen })),
  setEditModalIsOpen: () => set2((state) => ({ editModalIsOpen: !state.editModalIsOpen })),
  setWidgetModalIsOpen: () => set2((state) => ({ widgetModalIsOpen: !state.widgetModalIsOpen })),
  setDeleteModalIsOpen: () => set2((state) => ({ deleteModalIsOpen: !state.deleteModalIsOpen })),
  setIsFullScreen: () => set2(() => ({ isFullScreen: document.fullscreenElement }))
}));
const useDashboardActions = (dashboard2) => {
  const access = useRoleStore((state) => state.access);
  const { dashboardId, sourceId } = useRoutingContext();
  const { postWidget } = useDashboard();
  const { putInventory, removeInventory } = useApi();
  const {
    setDashboardModalIsOpen,
    setEditModalIsOpen,
    setWidgetModalIsOpen,
    setDeleteModalIsOpen,
    setIsFullScreen
  } = useDashboardStore((state) => ({
    setDashboardModalIsOpen: state.setDashboardModalIsOpen,
    setEditModalIsOpen: state.setEditModalIsOpen,
    setWidgetModalIsOpen: state.setWidgetModalIsOpen,
    setDeleteModalIsOpen: state.setDeleteModalIsOpen,
    setIsFullScreen: state.setIsFullScreen
  }));
  const setQueryDeleteInvalidated = useQueryDashboardStore(
    (state) => state.setQueryDeleteInvalidated
  );
  const handleLock = useCustomMutation({
    mutationFn: async (checked) => {
      dashboard2["u5s_Dashboard"]["isFrozen"] = checked;
      const res = await putInventory(dashboardId, dashboard2);
      return res.data;
    },
    queryKey: ["dashboard", dashboardId],
    successMessage: (checked) => `Dashboard is ${checked ? "locked" : "unlocked"}.`,
    errorMessage: (checked) => `Failed to ${checked ? "lock" : "unlock"} the dashboard.`
  });
  const deleteDashboard = useCustomMutation({
    mutationFn: () => removeInventory(dashboardId),
    queryKey: ["dashboards", sourceId],
    onSuccess: () => {
      setTimeout(() => {
        setQueryDeleteInvalidated();
        setDeleteModalIsOpen(false);
      }, 300);
    },
    successMessage: "Dashboard deleted.",
    errorMessage: "Failed to delete dashboard."
  });
  const addWidget = useCustomMutation({
    mutationFn: async ({ dashboard: dashboard22, obj }) => postWidget({ dashboard: dashboard22, obj }),
    queryKey: ["dashboard", dashboardId],
    onSuccess: () => setWidgetModalIsOpen(false),
    successMessage: "Widgets added successfully.",
    errorMessage: "Widgets addition failed."
  });
  const handleDashboard = (type2) => {
    if (!access) return;
    if (type2 === "dashboard") {
      setDashboardModalIsOpen(true);
    }
    if (type2 === "edit") {
      setEditModalIsOpen(true);
    }
    if (type2 === "add") {
      setWidgetModalIsOpen(true);
    }
  };
  const handleFullScreen = () => {
    const element = document.querySelector(".fullscreen");
    if (!document.fullscreenElement) {
      if (element.requestFullscreen) {
        element.requestFullscreen();
      } else if (element.mozRequestFullScreen) {
        element.mozRequestFullScreen();
      } else if (element.webkitRequestFullscreen) {
        element.webkitRequestFullscreen();
      } else if (element.msRequestFullscreen) {
        element.msRequestFullscreen();
      }
    } else {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      } else if (document.mozCancelFullScreen) {
        document.mozCancelFullScreen();
      } else if (document.webkitExitFullscreen) {
        document.webkitExitFullscreen();
      } else if (document.msExitFullscreen) {
        document.msExitFullscreen();
      }
    }
  };
  useEffect(() => {
    const handleFullscreenChange = () => {
      setIsFullScreen();
    };
    document.addEventListener("fullscreenchange", handleFullscreenChange);
    document.addEventListener("webkitfullscreenchange", handleFullscreenChange);
    document.addEventListener("mozfullscreenchange", handleFullscreenChange);
    document.addEventListener("MSFullscreenChange", handleFullscreenChange);
    return () => {
      document.removeEventListener("fullscreenchange", handleFullscreenChange);
      document.removeEventListener(
        "webkitfullscreenchange",
        handleFullscreenChange
      );
      document.removeEventListener(
        "mozfullscreenchange",
        handleFullscreenChange
      );
      document.removeEventListener(
        "MSFullscreenChange",
        handleFullscreenChange
      );
    };
  }, []);
  return {
    handleFullScreen,
    handleDashboard,
    mutations: {
      handleLock,
      deleteDashboard,
      addWidget
    },
    access
  };
};
const ContextDashboard = () => {
  var _a;
  const { dashboardId, sourceId, category } = useRoutingContext();
  const { getInventory } = useApi();
  const { data: dashboard2 } = useSuspenseQuery({
    queryKey: ["dashboard", dashboardId],
    staleTime: Infinity,
    enabled: !!dashboardId,
    queryFn: async () => {
      const res = await getInventory(dashboardId);
      return res.data;
    }
  });
  const { t: t2 } = useTranslation();
  const {
    dashboardModalIsOpen,
    editModalIsOpen,
    widgetModalIsOpen,
    deleteModalIsOpen,
    setDashboardModalIsOpen,
    setEditModalIsOpen,
    setWidgetModalIsOpen,
    setDeleteModalIsOpen,
    setIsDashboard
  } = useDashboardStore((state) => state);
  const { mutations } = useDashboardActions();
  useEffect(() => {
    setIsDashboard(true);
    return () => setIsDashboard(false);
  }, []);
  const renderContent = () => {
    var _a2, _b;
    if (!dashboard2["u5s_Dashboard"]) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        RenderEmptyStateMessage,
        {
          title: "no dashboard to display.",
          description: "add a dashboard.",
          buttonText: "add dashboard",
          access: true,
          onClick: () => setDashboardModalIsOpen(true)
        }
      );
    }
    if (!((_a2 = dashboard2["u5s_Dashboard"]) == null ? void 0 : _a2["children"]) || Object.values((_b = dashboard2["u5s_Dashboard"]) == null ? void 0 : _b["children"]).length === 0) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        RenderEmptyStateMessage,
        {
          title: "no widgets to display.",
          description: "add widgets to this dashboard.",
          buttonText: "add widget",
          access: true,
          onClick: () => setWidgetModalIsOpen(true)
        }
      );
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ContextGrid$1, { dashboard: dashboard2, sourceId });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    (dashboardModalIsOpen || editModalIsOpen) && /* @__PURE__ */ jsxRuntimeExports.jsx(
      DashboardModal,
      {
        category,
        sourceId,
        dashboardId,
        open: dashboardModalIsOpen || editModalIsOpen,
        onOpenChange: () => {
          if (dashboardModalIsOpen) {
            setDashboardModalIsOpen((pre) => !pre);
          } else if (editModalIsOpen) {
            setEditModalIsOpen((pre) => !pre);
          }
        },
        mode: dashboardModalIsOpen ? "dashboard" : "edit"
      }
    ),
    widgetModalIsOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(
      WidgetModal,
      {
        open: widgetModalIsOpen,
        onOpenChange: () => setWidgetModalIsOpen((pre) => !pre),
        dashboardId,
        onAddWidget: mutations.addWidget,
        mode: "select-widget",
        sourceId
      }
    ),
    deleteModalIsOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(
      RemoveModal,
      {
        onOpenChange: () => setDeleteModalIsOpen((pre) => !pre),
        open: deleteModalIsOpen,
        onDelete: mutations.deleteDashboard,
        title: t2("Delete dashboard"),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-grayscale-300", children: t2("You are about to delete the dashboard", {
          dashboardName: (_a = dashboard2["u5s_Dashboard"]) == null ? void 0 : _a["name"]
        }) })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollArea, { scrollBar: false, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-grayscale-900 dark:bg-dark-grayscale-900", children: /* @__PURE__ */ jsxRuntimeExports.jsx(FallbackUi, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(LazyLoader, { children: renderContent() }) }) }) })
  ] });
};
var uaParser$1 = { exports: {} };
var uaParser = uaParser$1.exports;
var hasRequiredUaParser;
function requireUaParser() {
  if (hasRequiredUaParser) return uaParser$1.exports;
  hasRequiredUaParser = 1;
  (function(module2, exports2) {
    (function(window2, undefined$1) {
      var LIBVERSION = "1.0.40", EMPTY = "", UNKNOWN = "?", FUNC_TYPE = "function", UNDEF_TYPE = "undefined", OBJ_TYPE = "object", STR_TYPE = "string", MAJOR = "major", MODEL = "model", NAME2 = "name", TYPE = "type", VENDOR = "vendor", VERSION = "version", ARCHITECTURE = "architecture", CONSOLE = "console", MOBILE = "mobile", TABLET = "tablet", SMARTTV = "smarttv", WEARABLE = "wearable", EMBEDDED = "embedded", UA_MAX_LENGTH = 500;
      var AMAZON = "Amazon", APPLE = "Apple", ASUS = "ASUS", BLACKBERRY = "BlackBerry", BROWSER = "Browser", CHROME = "Chrome", EDGE = "Edge", FIREFOX = "Firefox", GOOGLE = "Google", HUAWEI = "Huawei", LG = "LG", MICROSOFT = "Microsoft", MOTOROLA = "Motorola", OPERA = "Opera", SAMSUNG = "Samsung", SHARP = "Sharp", SONY = "Sony", XIAOMI = "Xiaomi", ZEBRA = "Zebra", FACEBOOK = "Facebook", CHROMIUM_OS = "Chromium OS", MAC_OS = "Mac OS", SUFFIX_BROWSER = " Browser";
      var extend = function(regexes2, extensions) {
        var mergedRegexes = {};
        for (var i2 in regexes2) {
          if (extensions[i2] && extensions[i2].length % 2 === 0) {
            mergedRegexes[i2] = extensions[i2].concat(regexes2[i2]);
          } else {
            mergedRegexes[i2] = regexes2[i2];
          }
        }
        return mergedRegexes;
      }, enumerize = function(arr) {
        var enums = {};
        for (var i2 = 0; i2 < arr.length; i2++) {
          enums[arr[i2].toUpperCase()] = arr[i2];
        }
        return enums;
      }, has2 = function(str1, str2) {
        return typeof str1 === STR_TYPE ? lowerize(str2).indexOf(lowerize(str1)) !== -1 : false;
      }, lowerize = function(str) {
        return str.toLowerCase();
      }, majorize = function(version2) {
        return typeof version2 === STR_TYPE ? version2.replace(/[^\d\.]/g, EMPTY).split(".")[0] : undefined$1;
      }, trim = function(str, len) {
        if (typeof str === STR_TYPE) {
          str = str.replace(/^\s\s*/, EMPTY);
          return typeof len === UNDEF_TYPE ? str : str.substring(0, UA_MAX_LENGTH);
        }
      };
      var rgxMapper = function(ua, arrays) {
        var i2 = 0, j, k, p, q, matches, match2;
        while (i2 < arrays.length && !matches) {
          var regex = arrays[i2], props = arrays[i2 + 1];
          j = k = 0;
          while (j < regex.length && !matches) {
            if (!regex[j]) {
              break;
            }
            matches = regex[j++].exec(ua);
            if (!!matches) {
              for (p = 0; p < props.length; p++) {
                match2 = matches[++k];
                q = props[p];
                if (typeof q === OBJ_TYPE && q.length > 0) {
                  if (q.length === 2) {
                    if (typeof q[1] == FUNC_TYPE) {
                      this[q[0]] = q[1].call(this, match2);
                    } else {
                      this[q[0]] = q[1];
                    }
                  } else if (q.length === 3) {
                    if (typeof q[1] === FUNC_TYPE && !(q[1].exec && q[1].test)) {
                      this[q[0]] = match2 ? q[1].call(this, match2, q[2]) : undefined$1;
                    } else {
                      this[q[0]] = match2 ? match2.replace(q[1], q[2]) : undefined$1;
                    }
                  } else if (q.length === 4) {
                    this[q[0]] = match2 ? q[3].call(this, match2.replace(q[1], q[2])) : undefined$1;
                  }
                } else {
                  this[q] = match2 ? match2 : undefined$1;
                }
              }
            }
          }
          i2 += 2;
        }
      }, strMapper = function(str, map2) {
        for (var i2 in map2) {
          if (typeof map2[i2] === OBJ_TYPE && map2[i2].length > 0) {
            for (var j = 0; j < map2[i2].length; j++) {
              if (has2(map2[i2][j], str)) {
                return i2 === UNKNOWN ? undefined$1 : i2;
              }
            }
          } else if (has2(map2[i2], str)) {
            return i2 === UNKNOWN ? undefined$1 : i2;
          }
        }
        return map2.hasOwnProperty("*") ? map2["*"] : str;
      };
      var oldSafariMap = {
        "1.0": "/8",
        "1.2": "/1",
        "1.3": "/3",
        "2.0": "/412",
        "2.0.2": "/416",
        "2.0.3": "/417",
        "2.0.4": "/419",
        "?": "/"
      }, windowsVersionMap = {
        "ME": "4.90",
        "NT 3.11": "NT3.51",
        "NT 4.0": "NT4.0",
        "2000": "NT 5.0",
        "XP": ["NT 5.1", "NT 5.2"],
        "Vista": "NT 6.0",
        "7": "NT 6.1",
        "8": "NT 6.2",
        "8.1": "NT 6.3",
        "10": ["NT 6.4", "NT 10.0"],
        "RT": "ARM"
      };
      var regexes = {
        browser: [
          [
            /\b(?:crmo|crios)\/([\w\.]+)/i
            // Chrome for Android/iOS
          ],
          [VERSION, [NAME2, "Chrome"]],
          [
            /edg(?:e|ios|a)?\/([\w\.]+)/i
            // Microsoft Edge
          ],
          [VERSION, [NAME2, "Edge"]],
          [
            // Presto based
            /(opera mini)\/([-\w\.]+)/i,
            // Opera Mini
            /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i,
            // Opera Mobi/Tablet
            /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i
            // Opera
          ],
          [NAME2, VERSION],
          [
            /opios[\/ ]+([\w\.]+)/i
            // Opera mini on iphone >= 8.0
          ],
          [VERSION, [NAME2, OPERA + " Mini"]],
          [
            /\bop(?:rg)?x\/([\w\.]+)/i
            // Opera GX
          ],
          [VERSION, [NAME2, OPERA + " GX"]],
          [
            /\bopr\/([\w\.]+)/i
            // Opera Webkit
          ],
          [VERSION, [NAME2, OPERA]],
          [
            // Mixed
            /\bb[ai]*d(?:uhd|[ub]*[aekoprswx]{5,6})[\/ ]?([\w\.]+)/i
            // Baidu
          ],
          [VERSION, [NAME2, "Baidu"]],
          [
            /\b(?:mxbrowser|mxios|myie2)\/?([-\w\.]*)\b/i
            // Maxthon
          ],
          [VERSION, [NAME2, "Maxthon"]],
          [
            /(kindle)\/([\w\.]+)/i,
            // Kindle
            /(lunascape|maxthon|netfront|jasmine|blazer|sleipnir)[\/ ]?([\w\.]*)/i,
            // Lunascape/Maxthon/Netfront/Jasmine/Blazer/Sleipnir
            // Trident based
            /(avant|iemobile|slim(?:browser|boat|jet))[\/ ]?([\d\.]*)/i,
            // Avant/IEMobile/SlimBrowser/SlimBoat/Slimjet
            /(?:ms|\()(ie) ([\w\.]+)/i,
            // Internet Explorer
            // Blink/Webkit/KHTML based                                         // Flock/RockMelt/Midori/Epiphany/Silk/Skyfire/Bolt/Iron/Iridium/PhantomJS/Bowser/QupZilla/Falkon
            /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|duckduckgo|klar|helio|(?=comodo_)?dragon)\/([-\w\.]+)/i,
            // Rekonq/Puffin/Brave/Whale/QQBrowserLite/QQ//Vivaldi/DuckDuckGo/Klar/Helio/Dragon
            /(heytap|ovi|115)browser\/([\d\.]+)/i,
            // HeyTap/Ovi/115
            /(weibo)__([\d\.]+)/i
            // Weibo
          ],
          [NAME2, VERSION],
          [
            /quark(?:pc)?\/([-\w\.]+)/i
            // Quark
          ],
          [VERSION, [NAME2, "Quark"]],
          [
            /\bddg\/([\w\.]+)/i
            // DuckDuckGo
          ],
          [VERSION, [NAME2, "DuckDuckGo"]],
          [
            /(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i
            // UCBrowser
          ],
          [VERSION, [NAME2, "UC" + BROWSER]],
          [
            /microm.+\bqbcore\/([\w\.]+)/i,
            // WeChat Desktop for Windows Built-in Browser
            /\bqbcore\/([\w\.]+).+microm/i,
            /micromessenger\/([\w\.]+)/i
            // WeChat
          ],
          [VERSION, [NAME2, "WeChat"]],
          [
            /konqueror\/([\w\.]+)/i
            // Konqueror
          ],
          [VERSION, [NAME2, "Konqueror"]],
          [
            /trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i
            // IE11
          ],
          [VERSION, [NAME2, "IE"]],
          [
            /ya(?:search)?browser\/([\w\.]+)/i
            // Yandex
          ],
          [VERSION, [NAME2, "Yandex"]],
          [
            /slbrowser\/([\w\.]+)/i
            // Smart Lenovo Browser
          ],
          [VERSION, [NAME2, "Smart Lenovo " + BROWSER]],
          [
            /(avast|avg)\/([\w\.]+)/i
            // Avast/AVG Secure Browser
          ],
          [[NAME2, /(.+)/, "$1 Secure " + BROWSER], VERSION],
          [
            /\bfocus\/([\w\.]+)/i
            // Firefox Focus
          ],
          [VERSION, [NAME2, FIREFOX + " Focus"]],
          [
            /\bopt\/([\w\.]+)/i
            // Opera Touch
          ],
          [VERSION, [NAME2, OPERA + " Touch"]],
          [
            /coc_coc\w+\/([\w\.]+)/i
            // Coc Coc Browser
          ],
          [VERSION, [NAME2, "Coc Coc"]],
          [
            /dolfin\/([\w\.]+)/i
            // Dolphin
          ],
          [VERSION, [NAME2, "Dolphin"]],
          [
            /coast\/([\w\.]+)/i
            // Opera Coast
          ],
          [VERSION, [NAME2, OPERA + " Coast"]],
          [
            /miuibrowser\/([\w\.]+)/i
            // MIUI Browser
          ],
          [VERSION, [NAME2, "MIUI" + SUFFIX_BROWSER]],
          [
            /fxios\/([\w\.-]+)/i
            // Firefox for iOS
          ],
          [VERSION, [NAME2, FIREFOX]],
          [
            /\bqihoobrowser\/?([\w\.]*)/i
            // 360
          ],
          [VERSION, [NAME2, "360"]],
          [
            /\b(qq)\/([\w\.]+)/i
            // QQ
          ],
          [[NAME2, /(.+)/, "$1Browser"], VERSION],
          [
            /(oculus|sailfish|huawei|vivo|pico)browser\/([\w\.]+)/i
          ],
          [[NAME2, /(.+)/, "$1" + SUFFIX_BROWSER], VERSION],
          [
            // Oculus/Sailfish/HuaweiBrowser/VivoBrowser/PicoBrowser
            /samsungbrowser\/([\w\.]+)/i
            // Samsung Internet
          ],
          [VERSION, [NAME2, SAMSUNG + " Internet"]],
          [
            /metasr[\/ ]?([\d\.]+)/i
            // Sogou Explorer
          ],
          [VERSION, [NAME2, "Sogou Explorer"]],
          [
            /(sogou)mo\w+\/([\d\.]+)/i
            // Sogou Mobile
          ],
          [[NAME2, "Sogou Mobile"], VERSION],
          [
            /(electron)\/([\w\.]+) safari/i,
            // Electron-based App
            /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i,
            // Tesla
            /m?(qqbrowser|2345(?=browser|chrome|explorer))\w*[\/ ]?v?([\w\.]+)/i
            // QQ/2345
          ],
          [NAME2, VERSION],
          [
            /(lbbrowser|rekonq)/i,
            // LieBao Browser/Rekonq
            /\[(linkedin)app\]/i
            // LinkedIn App for iOS & Android
          ],
          [NAME2],
          [
            /ome\/([\w\.]+) \w* ?(iron) saf/i,
            // Iron
            /ome\/([\w\.]+).+qihu (360)[es]e/i
            // 360
          ],
          [VERSION, NAME2],
          [
            // WebView
            /((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i
            // Facebook App for iOS & Android
          ],
          [[NAME2, FACEBOOK], VERSION],
          [
            /(Klarna)\/([\w\.]+)/i,
            // Klarna Shopping Browser for iOS & Android
            /(kakao(?:talk|story))[\/ ]([\w\.]+)/i,
            // Kakao App
            /(naver)\(.*?(\d+\.[\w\.]+).*\)/i,
            // Naver InApp
            /safari (line)\/([\w\.]+)/i,
            // Line App for iOS
            /\b(line)\/([\w\.]+)\/iab/i,
            // Line App for Android
            /(alipay)client\/([\w\.]+)/i,
            // Alipay
            /(twitter)(?:and| f.+e\/([\w\.]+))/i,
            // Twitter
            /(chromium|instagram|snapchat)[\/ ]([-\w\.]+)/i
            // Chromium/Instagram/Snapchat
          ],
          [NAME2, VERSION],
          [
            /\bgsa\/([\w\.]+) .*safari\//i
            // Google Search Appliance on iOS
          ],
          [VERSION, [NAME2, "GSA"]],
          [
            /musical_ly(?:.+app_?version\/|_)([\w\.]+)/i
            // TikTok
          ],
          [VERSION, [NAME2, "TikTok"]],
          [
            /headlesschrome(?:\/([\w\.]+)| )/i
            // Chrome Headless
          ],
          [VERSION, [NAME2, CHROME + " Headless"]],
          [
            / wv\).+(chrome)\/([\w\.]+)/i
            // Chrome WebView
          ],
          [[NAME2, CHROME + " WebView"], VERSION],
          [
            /droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i
            // Android Browser
          ],
          [VERSION, [NAME2, "Android " + BROWSER]],
          [
            /(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i
            // Chrome/OmniWeb/Arora/Tizen/Nokia
          ],
          [NAME2, VERSION],
          [
            /version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i
            // Mobile Safari
          ],
          [VERSION, [NAME2, "Mobile Safari"]],
          [
            /version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i
            // Safari & Safari Mobile
          ],
          [VERSION, NAME2],
          [
            /webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i
            // Safari < 3.0
          ],
          [NAME2, [VERSION, strMapper, oldSafariMap]],
          [
            /(webkit|khtml)\/([\w\.]+)/i
          ],
          [NAME2, VERSION],
          [
            // Gecko based
            /(navigator|netscape\d?)\/([-\w\.]+)/i
            // Netscape
          ],
          [[NAME2, "Netscape"], VERSION],
          [
            /(wolvic|librewolf)\/([\w\.]+)/i
            // Wolvic/LibreWolf
          ],
          [NAME2, VERSION],
          [
            /mobile vr; rv:([\w\.]+)\).+firefox/i
            // Firefox Reality
          ],
          [VERSION, [NAME2, FIREFOX + " Reality"]],
          [
            /ekiohf.+(flow)\/([\w\.]+)/i,
            // Flow
            /(swiftfox)/i,
            // Swiftfox
            /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror)[\/ ]?([\w\.\+]+)/i,
            // IceDragon/Iceweasel/Camino/Chimera/Fennec/Maemo/Minimo/Conkeror
            /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i,
            // Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix
            /(firefox)\/([\w\.]+)/i,
            // Other Firefox-based
            /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i,
            // Mozilla
            // Other
            /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i,
            // Polaris/Lynx/Dillo/iCab/Doris/Amaya/w3m/NetSurf/Obigo/Mosaic/Go/ICE/UP.Browser
            /(links) \(([\w\.]+)/i
            // Links
          ],
          [NAME2, [VERSION, /_/g, "."]],
          [
            /(cobalt)\/([\w\.]+)/i
            // Cobalt
          ],
          [NAME2, [VERSION, /master.|lts./, ""]]
        ],
        cpu: [
          [
            /(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i
            // AMD64 (x64)
          ],
          [[ARCHITECTURE, "amd64"]],
          [
            /(ia32(?=;))/i
            // IA32 (quicktime)
          ],
          [[ARCHITECTURE, lowerize]],
          [
            /((?:i[346]|x)86)[;\)]/i
            // IA32 (x86)
          ],
          [[ARCHITECTURE, "ia32"]],
          [
            /\b(aarch64|arm(v?8e?l?|_?64))\b/i
            // ARM64
          ],
          [[ARCHITECTURE, "arm64"]],
          [
            /\b(arm(?:v[67])?ht?n?[fl]p?)\b/i
            // ARMHF
          ],
          [[ARCHITECTURE, "armhf"]],
          [
            // PocketPC mistakenly identified as PowerPC
            /windows (ce|mobile); ppc;/i
          ],
          [[ARCHITECTURE, "arm"]],
          [
            /((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i
            // PowerPC
          ],
          [[ARCHITECTURE, /ower/, EMPTY, lowerize]],
          [
            /(sun4\w)[;\)]/i
            // SPARC
          ],
          [[ARCHITECTURE, "sparc"]],
          [
            /((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i
            // IA64, 68K, ARM/64, AVR/32, IRIX/64, MIPS/64, SPARC/64, PA-RISC
          ],
          [[ARCHITECTURE, lowerize]]
        ],
        device: [
          [
            //////////////////////////
            // MOBILES & TABLETS
            /////////////////////////
            // Samsung
            /\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i
          ],
          [MODEL, [VENDOR, SAMSUNG], [TYPE, TABLET]],
          [
            /\b((?:s[cgp]h|gt|sm)-(?![lr])\w+|sc[g-]?[\d]+a?|galaxy nexus)/i,
            /samsung[- ]((?!sm-[lr])[-\w]+)/i,
            /sec-(sgh\w+)/i
          ],
          [MODEL, [VENDOR, SAMSUNG], [TYPE, MOBILE]],
          [
            // Apple
            /(?:\/|\()(ip(?:hone|od)[\w, ]*)(?:\/|;)/i
            // iPod/iPhone
          ],
          [MODEL, [VENDOR, APPLE], [TYPE, MOBILE]],
          [
            /\((ipad);[-\w\),; ]+apple/i,
            // iPad
            /applecoremedia\/[\w\.]+ \((ipad)/i,
            /\b(ipad)\d\d?,\d\d?[;\]].+ios/i
          ],
          [MODEL, [VENDOR, APPLE], [TYPE, TABLET]],
          [
            /(macintosh);/i
          ],
          [MODEL, [VENDOR, APPLE]],
          [
            // Sharp
            /\b(sh-?[altvz]?\d\d[a-ekm]?)/i
          ],
          [MODEL, [VENDOR, SHARP], [TYPE, MOBILE]],
          [
            // Honor
            /(?:honor)([-\w ]+)[;\)]/i
          ],
          [MODEL, [VENDOR, "Honor"], [TYPE, MOBILE]],
          [
            // Huawei
            /\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i
          ],
          [MODEL, [VENDOR, HUAWEI], [TYPE, TABLET]],
          [
            /(?:huawei)([-\w ]+)[;\)]/i,
            /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i
          ],
          [MODEL, [VENDOR, HUAWEI], [TYPE, MOBILE]],
          [
            // Xiaomi
            /\b(poco[\w ]+|m2\d{3}j\d\d[a-z]{2})(?: bui|\))/i,
            // Xiaomi POCO
            /\b; (\w+) build\/hm\1/i,
            // Xiaomi Hongmi 'numeric' models
            /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i,
            // Xiaomi Hongmi
            /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i,
            // Xiaomi Redmi
            /oid[^\)]+; (m?[12][0-389][01]\w{3,6}[c-y])( bui|; wv|\))/i,
            // Xiaomi Redmi 'numeric' models
            /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite|pro)?)(?: bui|\))/i
            // Xiaomi Mi
          ],
          [[MODEL, /_/g, " "], [VENDOR, XIAOMI], [TYPE, MOBILE]],
          [
            /oid[^\)]+; (2\d{4}(283|rpbf)[cgl])( bui|\))/i,
            // Redmi Pad
            /\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i
            // Mi Pad tablets
          ],
          [[MODEL, /_/g, " "], [VENDOR, XIAOMI], [TYPE, TABLET]],
          [
            // OPPO
            /; (\w+) bui.+ oppo/i,
            /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i
          ],
          [MODEL, [VENDOR, "OPPO"], [TYPE, MOBILE]],
          [
            /\b(opd2\d{3}a?) bui/i
          ],
          [MODEL, [VENDOR, "OPPO"], [TYPE, TABLET]],
          [
            // Vivo
            /vivo (\w+)(?: bui|\))/i,
            /\b(v[12]\d{3}\w?[at])(?: bui|;)/i
          ],
          [MODEL, [VENDOR, "Vivo"], [TYPE, MOBILE]],
          [
            // Realme
            /\b(rmx[1-3]\d{3})(?: bui|;|\))/i
          ],
          [MODEL, [VENDOR, "Realme"], [TYPE, MOBILE]],
          [
            // Motorola
            /\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i,
            /\bmot(?:orola)?[- ](\w*)/i,
            /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i
          ],
          [MODEL, [VENDOR, MOTOROLA], [TYPE, MOBILE]],
          [
            /\b(mz60\d|xoom[2 ]{0,2}) build\//i
          ],
          [MODEL, [VENDOR, MOTOROLA], [TYPE, TABLET]],
          [
            // LG
            /((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i
          ],
          [MODEL, [VENDOR, LG], [TYPE, TABLET]],
          [
            /(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i,
            /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i,
            /\blg-?([\d\w]+) bui/i
          ],
          [MODEL, [VENDOR, LG], [TYPE, MOBILE]],
          [
            // Lenovo
            /(ideatab[-\w ]+)/i,
            /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i
          ],
          [MODEL, [VENDOR, "Lenovo"], [TYPE, TABLET]],
          [
            // Nokia
            /(?:maemo|nokia).*(n900|lumia \d+)/i,
            /nokia[-_ ]?([-\w\.]*)/i
          ],
          [[MODEL, /_/g, " "], [VENDOR, "Nokia"], [TYPE, MOBILE]],
          [
            // Google
            /(pixel c)\b/i
            // Google Pixel C
          ],
          [MODEL, [VENDOR, GOOGLE], [TYPE, TABLET]],
          [
            /droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i
            // Google Pixel
          ],
          [MODEL, [VENDOR, GOOGLE], [TYPE, MOBILE]],
          [
            // Sony
            /droid.+; (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i
          ],
          [MODEL, [VENDOR, SONY], [TYPE, MOBILE]],
          [
            /sony tablet [ps]/i,
            /\b(?:sony)?sgp\w+(?: bui|\))/i
          ],
          [[MODEL, "Xperia Tablet"], [VENDOR, SONY], [TYPE, TABLET]],
          [
            // OnePlus
            / (kb2005|in20[12]5|be20[12][59])\b/i,
            /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i
          ],
          [MODEL, [VENDOR, "OnePlus"], [TYPE, MOBILE]],
          [
            // Amazon
            /(alexa)webm/i,
            /(kf[a-z]{2}wi|aeo(?!bc)\w\w)( bui|\))/i,
            // Kindle Fire without Silk / Echo Show
            /(kf[a-z]+)( bui|\)).+silk\//i
            // Kindle Fire HD
          ],
          [MODEL, [VENDOR, AMAZON], [TYPE, TABLET]],
          [
            /((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i
            // Fire Phone
          ],
          [[MODEL, /(.+)/g, "Fire Phone $1"], [VENDOR, AMAZON], [TYPE, MOBILE]],
          [
            // BlackBerry
            /(playbook);[-\w\),; ]+(rim)/i
            // BlackBerry PlayBook
          ],
          [MODEL, VENDOR, [TYPE, TABLET]],
          [
            /\b((?:bb[a-f]|st[hv])100-\d)/i,
            /\(bb10; (\w+)/i
            // BlackBerry 10
          ],
          [MODEL, [VENDOR, BLACKBERRY], [TYPE, MOBILE]],
          [
            // Asus
            /(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i
          ],
          [MODEL, [VENDOR, ASUS], [TYPE, TABLET]],
          [
            / (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i
          ],
          [MODEL, [VENDOR, ASUS], [TYPE, MOBILE]],
          [
            // HTC
            /(nexus 9)/i
            // HTC Nexus 9
          ],
          [MODEL, [VENDOR, "HTC"], [TYPE, TABLET]],
          [
            /(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i,
            // HTC
            // ZTE
            /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i,
            /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i
            // Alcatel/GeeksPhone/Nexian/Panasonic/Sony
          ],
          [VENDOR, [MODEL, /_/g, " "], [TYPE, MOBILE]],
          [
            // TCL
            /droid [\w\.]+; ((?:8[14]9[16]|9(?:0(?:48|60|8[01])|1(?:3[27]|66)|2(?:6[69]|9[56])|466))[gqswx])\w*(\)| bui)/i
          ],
          [MODEL, [VENDOR, "TCL"], [TYPE, TABLET]],
          [
            // itel
            /(itel) ((\w+))/i
          ],
          [[VENDOR, lowerize], MODEL, [TYPE, strMapper, { "tablet": ["p10001l", "w7001"], "*": "mobile" }]],
          [
            // Acer
            /droid.+; ([ab][1-7]-?[0178a]\d\d?)/i
          ],
          [MODEL, [VENDOR, "Acer"], [TYPE, TABLET]],
          [
            // Meizu
            /droid.+; (m[1-5] note) bui/i,
            /\bmz-([-\w]{2,})/i
          ],
          [MODEL, [VENDOR, "Meizu"], [TYPE, MOBILE]],
          [
            // Ulefone
            /; ((?:power )?armor(?:[\w ]{0,8}))(?: bui|\))/i
          ],
          [MODEL, [VENDOR, "Ulefone"], [TYPE, MOBILE]],
          [
            // Energizer
            /; (energy ?\w+)(?: bui|\))/i,
            /; energizer ([\w ]+)(?: bui|\))/i
          ],
          [MODEL, [VENDOR, "Energizer"], [TYPE, MOBILE]],
          [
            // Cat
            /; cat (b35);/i,
            /; (b15q?|s22 flip|s48c|s62 pro)(?: bui|\))/i
          ],
          [MODEL, [VENDOR, "Cat"], [TYPE, MOBILE]],
          [
            // Smartfren
            /((?:new )?andromax[\w- ]+)(?: bui|\))/i
          ],
          [MODEL, [VENDOR, "Smartfren"], [TYPE, MOBILE]],
          [
            // Nothing
            /droid.+; (a(?:015|06[35]|142p?))/i
          ],
          [MODEL, [VENDOR, "Nothing"], [TYPE, MOBILE]],
          [
            // MIXED
            /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron|infinix|tecno|micromax|advan)[-_ ]?([-\w]*)/i,
            // BlackBerry/BenQ/Palm/Sony-Ericsson/Acer/Asus/Dell/Meizu/Motorola/Polytron/Infinix/Tecno/Micromax/Advan
            /; (imo) ((?!tab)[\w ]+?)(?: bui|\))/i,
            // IMO
            /(hp) ([\w ]+\w)/i,
            // HP iPAQ
            /(asus)-?(\w+)/i,
            // Asus
            /(microsoft); (lumia[\w ]+)/i,
            // Microsoft Lumia
            /(lenovo)[-_ ]?([-\w]+)/i,
            // Lenovo
            /(jolla)/i,
            // Jolla
            /(oppo) ?([\w ]+) bui/i
            // OPPO
          ],
          [VENDOR, MODEL, [TYPE, MOBILE]],
          [
            /(imo) (tab \w+)/i,
            // IMO
            /(kobo)\s(ereader|touch)/i,
            // Kobo
            /(archos) (gamepad2?)/i,
            // Archos
            /(hp).+(touchpad(?!.+tablet)|tablet)/i,
            // HP TouchPad
            /(kindle)\/([\w\.]+)/i,
            // Kindle
            /(nook)[\w ]+build\/(\w+)/i,
            // Nook
            /(dell) (strea[kpr\d ]*[\dko])/i,
            // Dell Streak
            /(le[- ]+pan)[- ]+(\w{1,9}) bui/i,
            // Le Pan Tablets
            /(trinity)[- ]*(t\d{3}) bui/i,
            // Trinity Tablets
            /(gigaset)[- ]+(q\w{1,9}) bui/i,
            // Gigaset Tablets
            /(vodafone) ([\w ]+)(?:\)| bui)/i
            // Vodafone
          ],
          [VENDOR, MODEL, [TYPE, TABLET]],
          [
            /(surface duo)/i
            // Surface Duo
          ],
          [MODEL, [VENDOR, MICROSOFT], [TYPE, TABLET]],
          [
            /droid [\d\.]+; (fp\du?)(?: b|\))/i
            // Fairphone
          ],
          [MODEL, [VENDOR, "Fairphone"], [TYPE, MOBILE]],
          [
            /(u304aa)/i
            // AT&T
          ],
          [MODEL, [VENDOR, "AT&T"], [TYPE, MOBILE]],
          [
            /\bsie-(\w*)/i
            // Siemens
          ],
          [MODEL, [VENDOR, "Siemens"], [TYPE, MOBILE]],
          [
            /\b(rct\w+) b/i
            // RCA Tablets
          ],
          [MODEL, [VENDOR, "RCA"], [TYPE, TABLET]],
          [
            /\b(venue[\d ]{2,7}) b/i
            // Dell Venue Tablets
          ],
          [MODEL, [VENDOR, "Dell"], [TYPE, TABLET]],
          [
            /\b(q(?:mv|ta)\w+) b/i
            // Verizon Tablet
          ],
          [MODEL, [VENDOR, "Verizon"], [TYPE, TABLET]],
          [
            /\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i
            // Barnes & Noble Tablet
          ],
          [MODEL, [VENDOR, "Barnes & Noble"], [TYPE, TABLET]],
          [
            /\b(tm\d{3}\w+) b/i
          ],
          [MODEL, [VENDOR, "NuVision"], [TYPE, TABLET]],
          [
            /\b(k88) b/i
            // ZTE K Series Tablet
          ],
          [MODEL, [VENDOR, "ZTE"], [TYPE, TABLET]],
          [
            /\b(nx\d{3}j) b/i
            // ZTE Nubia
          ],
          [MODEL, [VENDOR, "ZTE"], [TYPE, MOBILE]],
          [
            /\b(gen\d{3}) b.+49h/i
            // Swiss GEN Mobile
          ],
          [MODEL, [VENDOR, "Swiss"], [TYPE, MOBILE]],
          [
            /\b(zur\d{3}) b/i
            // Swiss ZUR Tablet
          ],
          [MODEL, [VENDOR, "Swiss"], [TYPE, TABLET]],
          [
            /\b((zeki)?tb.*\b) b/i
            // Zeki Tablets
          ],
          [MODEL, [VENDOR, "Zeki"], [TYPE, TABLET]],
          [
            /\b([yr]\d{2}) b/i,
            /\b(dragon[- ]+touch |dt)(\w{5}) b/i
            // Dragon Touch Tablet
          ],
          [[VENDOR, "Dragon Touch"], MODEL, [TYPE, TABLET]],
          [
            /\b(ns-?\w{0,9}) b/i
            // Insignia Tablets
          ],
          [MODEL, [VENDOR, "Insignia"], [TYPE, TABLET]],
          [
            /\b((nxa|next)-?\w{0,9}) b/i
            // NextBook Tablets
          ],
          [MODEL, [VENDOR, "NextBook"], [TYPE, TABLET]],
          [
            /\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i
            // Voice Xtreme Phones
          ],
          [[VENDOR, "Voice"], MODEL, [TYPE, MOBILE]],
          [
            /\b(lvtel\-)?(v1[12]) b/i
            // LvTel Phones
          ],
          [[VENDOR, "LvTel"], MODEL, [TYPE, MOBILE]],
          [
            /\b(ph-1) /i
            // Essential PH-1
          ],
          [MODEL, [VENDOR, "Essential"], [TYPE, MOBILE]],
          [
            /\b(v(100md|700na|7011|917g).*\b) b/i
            // Envizen Tablets
          ],
          [MODEL, [VENDOR, "Envizen"], [TYPE, TABLET]],
          [
            /\b(trio[-\w\. ]+) b/i
            // MachSpeed Tablets
          ],
          [MODEL, [VENDOR, "MachSpeed"], [TYPE, TABLET]],
          [
            /\btu_(1491) b/i
            // Rotor Tablets
          ],
          [MODEL, [VENDOR, "Rotor"], [TYPE, TABLET]],
          [
            /(shield[\w ]+) b/i
            // Nvidia Shield Tablets
          ],
          [MODEL, [VENDOR, "Nvidia"], [TYPE, TABLET]],
          [
            /(sprint) (\w+)/i
            // Sprint Phones
          ],
          [VENDOR, MODEL, [TYPE, MOBILE]],
          [
            /(kin\.[onetw]{3})/i
            // Microsoft Kin
          ],
          [[MODEL, /\./g, " "], [VENDOR, MICROSOFT], [TYPE, MOBILE]],
          [
            /droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i
            // Zebra
          ],
          [MODEL, [VENDOR, ZEBRA], [TYPE, TABLET]],
          [
            /droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i
          ],
          [MODEL, [VENDOR, ZEBRA], [TYPE, MOBILE]],
          [
            ///////////////////
            // SMARTTVS
            ///////////////////
            /smart-tv.+(samsung)/i
            // Samsung
          ],
          [VENDOR, [TYPE, SMARTTV]],
          [
            /hbbtv.+maple;(\d+)/i
          ],
          [[MODEL, /^/, "SmartTV"], [VENDOR, SAMSUNG], [TYPE, SMARTTV]],
          [
            /(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i
            // LG SmartTV
          ],
          [[VENDOR, LG], [TYPE, SMARTTV]],
          [
            /(apple) ?tv/i
            // Apple TV
          ],
          [VENDOR, [MODEL, APPLE + " TV"], [TYPE, SMARTTV]],
          [
            /crkey/i
            // Google Chromecast
          ],
          [[MODEL, CHROME + "cast"], [VENDOR, GOOGLE], [TYPE, SMARTTV]],
          [
            /droid.+aft(\w+)( bui|\))/i
            // Fire TV
          ],
          [MODEL, [VENDOR, AMAZON], [TYPE, SMARTTV]],
          [
            /\(dtv[\);].+(aquos)/i,
            /(aquos-tv[\w ]+)\)/i
            // Sharp
          ],
          [MODEL, [VENDOR, SHARP], [TYPE, SMARTTV]],
          [
            /(bravia[\w ]+)( bui|\))/i
            // Sony
          ],
          [MODEL, [VENDOR, SONY], [TYPE, SMARTTV]],
          [
            /(mitv-\w{5}) bui/i
            // Xiaomi
          ],
          [MODEL, [VENDOR, XIAOMI], [TYPE, SMARTTV]],
          [
            /Hbbtv.*(technisat) (.*);/i
            // TechniSAT
          ],
          [VENDOR, MODEL, [TYPE, SMARTTV]],
          [
            /\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i,
            // Roku
            /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i
            // HbbTV devices
          ],
          [[VENDOR, trim], [MODEL, trim], [TYPE, SMARTTV]],
          [
            /\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i
            // SmartTV from Unidentified Vendors
          ],
          [[TYPE, SMARTTV]],
          [
            ///////////////////
            // CONSOLES
            ///////////////////
            /(ouya)/i,
            // Ouya
            /(nintendo) ([wids3utch]+)/i
            // Nintendo
          ],
          [VENDOR, MODEL, [TYPE, CONSOLE]],
          [
            /droid.+; (shield) bui/i
            // Nvidia
          ],
          [MODEL, [VENDOR, "Nvidia"], [TYPE, CONSOLE]],
          [
            /(playstation [345portablevi]+)/i
            // Playstation
          ],
          [MODEL, [VENDOR, SONY], [TYPE, CONSOLE]],
          [
            /\b(xbox(?: one)?(?!; xbox))[\); ]/i
            // Microsoft Xbox
          ],
          [MODEL, [VENDOR, MICROSOFT], [TYPE, CONSOLE]],
          [
            ///////////////////
            // WEARABLES
            ///////////////////
            /\b(sm-[lr]\d\d[05][fnuw]?s?)\b/i
            // Samsung Galaxy Watch
          ],
          [MODEL, [VENDOR, SAMSUNG], [TYPE, WEARABLE]],
          [
            /((pebble))app/i
            // Pebble
          ],
          [VENDOR, MODEL, [TYPE, WEARABLE]],
          [
            /(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i
            // Apple Watch
          ],
          [MODEL, [VENDOR, APPLE], [TYPE, WEARABLE]],
          [
            /droid.+; (glass) \d/i
            // Google Glass
          ],
          [MODEL, [VENDOR, GOOGLE], [TYPE, WEARABLE]],
          [
            /droid.+; (wt63?0{2,3})\)/i
          ],
          [MODEL, [VENDOR, ZEBRA], [TYPE, WEARABLE]],
          [
            ///////////////////
            // XR
            ///////////////////
            /droid.+; (glass) \d/i
            // Google Glass
          ],
          [MODEL, [VENDOR, GOOGLE], [TYPE, WEARABLE]],
          [
            /(pico) (4|neo3(?: link|pro)?)/i
            // Pico
          ],
          [VENDOR, MODEL, [TYPE, WEARABLE]],
          [
            /; (quest( \d| pro)?)/i
            // Oculus Quest
          ],
          [MODEL, [VENDOR, FACEBOOK], [TYPE, WEARABLE]],
          [
            ///////////////////
            // EMBEDDED
            ///////////////////
            /(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i
            // Tesla
          ],
          [VENDOR, [TYPE, EMBEDDED]],
          [
            /(aeobc)\b/i
            // Echo Dot
          ],
          [MODEL, [VENDOR, AMAZON], [TYPE, EMBEDDED]],
          [
            ////////////////////
            // MIXED (GENERIC)
            ///////////////////
            /droid .+?; ([^;]+?)(?: bui|; wv\)|\) applew).+? mobile safari/i
            // Android Phones from Unidentified Vendors
          ],
          [MODEL, [TYPE, MOBILE]],
          [
            /droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i
            // Android Tablets from Unidentified Vendors
          ],
          [MODEL, [TYPE, TABLET]],
          [
            /\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i
            // Unidentifiable Tablet
          ],
          [[TYPE, TABLET]],
          [
            /(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i
            // Unidentifiable Mobile
          ],
          [[TYPE, MOBILE]],
          [
            /(android[-\w\. ]{0,9});.+buil/i
            // Generic Android Device
          ],
          [MODEL, [VENDOR, "Generic"]]
        ],
        engine: [
          [
            /windows.+ edge\/([\w\.]+)/i
            // EdgeHTML
          ],
          [VERSION, [NAME2, EDGE + "HTML"]],
          [
            /(arkweb)\/([\w\.]+)/i
            // ArkWeb
          ],
          [NAME2, VERSION],
          [
            /webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i
            // Blink
          ],
          [VERSION, [NAME2, "Blink"]],
          [
            /(presto)\/([\w\.]+)/i,
            // Presto
            /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna|servo)\/([\w\.]+)/i,
            // WebKit/Trident/NetFront/NetSurf/Amaya/Lynx/w3m/Goanna/Servo
            /ekioh(flow)\/([\w\.]+)/i,
            // Flow
            /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i,
            // KHTML/Tasman/Links
            /(icab)[\/ ]([23]\.[\d\.]+)/i,
            // iCab
            /\b(libweb)/i
          ],
          [NAME2, VERSION],
          [
            /rv\:([\w\.]{1,9})\b.+(gecko)/i
            // Gecko
          ],
          [VERSION, NAME2]
        ],
        os: [
          [
            // Windows
            /microsoft (windows) (vista|xp)/i
            // Windows (iTunes)
          ],
          [NAME2, VERSION],
          [
            /(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i
            // Windows Phone
          ],
          [NAME2, [VERSION, strMapper, windowsVersionMap]],
          [
            /windows nt 6\.2; (arm)/i,
            // Windows RT
            /windows[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i,
            /(?:win(?=3|9|n)|win 9x )([nt\d\.]+)/i
          ],
          [[VERSION, strMapper, windowsVersionMap], [NAME2, "Windows"]],
          [
            // iOS/macOS
            /ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i,
            // iOS
            /(?:ios;fbsv\/|iphone.+ios[\/ ])([\d\.]+)/i,
            /cfnetwork\/.+darwin/i
          ],
          [[VERSION, /_/g, "."], [NAME2, "iOS"]],
          [
            /(mac os x) ?([\w\. ]*)/i,
            /(macintosh|mac_powerpc\b)(?!.+haiku)/i
            // Mac OS
          ],
          [[NAME2, MAC_OS], [VERSION, /_/g, "."]],
          [
            // Mobile OSes
            /droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i
            // Android-x86/HarmonyOS
          ],
          [VERSION, NAME2],
          [
            // Android/WebOS/QNX/Bada/RIM/Maemo/MeeGo/Sailfish OS/OpenHarmony
            /(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish|openharmony)[-\/ ]?([\w\.]*)/i,
            /(blackberry)\w*\/([\w\.]*)/i,
            // Blackberry
            /(tizen|kaios)[\/ ]([\w\.]+)/i,
            // Tizen/KaiOS
            /\((series40);/i
            // Series 40
          ],
          [NAME2, VERSION],
          [
            /\(bb(10);/i
            // BlackBerry 10
          ],
          [VERSION, [NAME2, BLACKBERRY]],
          [
            /(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i
            // Symbian
          ],
          [VERSION, [NAME2, "Symbian"]],
          [
            /mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i
            // Firefox OS
          ],
          [VERSION, [NAME2, FIREFOX + " OS"]],
          [
            /web0s;.+rt(tv)/i,
            /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i
            // WebOS
          ],
          [VERSION, [NAME2, "webOS"]],
          [
            /watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i
            // watchOS
          ],
          [VERSION, [NAME2, "watchOS"]],
          [
            // Google Chromecast
            /crkey\/([\d\.]+)/i
            // Google Chromecast
          ],
          [VERSION, [NAME2, CHROME + "cast"]],
          [
            /(cros) [\w]+(?:\)| ([\w\.]+)\b)/i
            // Chromium OS
          ],
          [[NAME2, CHROMIUM_OS], VERSION],
          [
            // Smart TVs
            /panasonic;(viera)/i,
            // Panasonic Viera
            /(netrange)mmh/i,
            // Netrange
            /(nettv)\/(\d+\.[\w\.]+)/i,
            // NetTV
            // Console
            /(nintendo|playstation) ([wids345portablevuch]+)/i,
            // Nintendo/Playstation
            /(xbox); +xbox ([^\);]+)/i,
            // Microsoft Xbox (360, One, X, S, Series X, Series S)
            // Other
            /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i,
            // Joli/Palm
            /(mint)[\/\(\) ]?(\w*)/i,
            // Mint
            /(mageia|vectorlinux)[; ]/i,
            // Mageia/VectorLinux
            /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i,
            // Ubuntu/Debian/SUSE/Gentoo/Arch/Slackware/Fedora/Mandriva/CentOS/PCLinuxOS/RedHat/Zenwalk/Linpus/Raspbian/Plan9/Minix/RISCOS/Contiki/Deepin/Manjaro/elementary/Sabayon/Linspire
            /(hurd|linux) ?([\w\.]*)/i,
            // Hurd/Linux
            /(gnu) ?([\w\.]*)/i,
            // GNU
            /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i,
            // FreeBSD/NetBSD/OpenBSD/PC-BSD/GhostBSD/DragonFly
            /(haiku) (\w+)/i
            // Haiku
          ],
          [NAME2, VERSION],
          [
            /(sunos) ?([\w\.\d]*)/i
            // Solaris
          ],
          [[NAME2, "Solaris"], VERSION],
          [
            /((?:open)?solaris)[-\/ ]?([\w\.]*)/i,
            // Solaris
            /(aix) ((\d)(?=\.|\)| )[\w\.])*/i,
            // AIX
            /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux|serenityos)/i,
            // BeOS/OS2/AmigaOS/MorphOS/OpenVMS/Fuchsia/HP-UX/SerenityOS
            /(unix) ?([\w\.]*)/i
            // UNIX
          ],
          [NAME2, VERSION]
        ]
      };
      var UAParser2 = function(ua, extensions) {
        if (typeof ua === OBJ_TYPE) {
          extensions = ua;
          ua = undefined$1;
        }
        if (!(this instanceof UAParser2)) {
          return new UAParser2(ua, extensions).getResult();
        }
        var _navigator = typeof window2 !== UNDEF_TYPE && window2.navigator ? window2.navigator : undefined$1;
        var _ua = ua || (_navigator && _navigator.userAgent ? _navigator.userAgent : EMPTY);
        var _uach = _navigator && _navigator.userAgentData ? _navigator.userAgentData : undefined$1;
        var _rgxmap = extensions ? extend(regexes, extensions) : regexes;
        var _isSelfNav = _navigator && _navigator.userAgent == _ua;
        this.getBrowser = function() {
          var _browser = {};
          _browser[NAME2] = undefined$1;
          _browser[VERSION] = undefined$1;
          rgxMapper.call(_browser, _ua, _rgxmap.browser);
          _browser[MAJOR] = majorize(_browser[VERSION]);
          if (_isSelfNav && _navigator && _navigator.brave && typeof _navigator.brave.isBrave == FUNC_TYPE) {
            _browser[NAME2] = "Brave";
          }
          return _browser;
        };
        this.getCPU = function() {
          var _cpu = {};
          _cpu[ARCHITECTURE] = undefined$1;
          rgxMapper.call(_cpu, _ua, _rgxmap.cpu);
          return _cpu;
        };
        this.getDevice = function() {
          var _device = {};
          _device[VENDOR] = undefined$1;
          _device[MODEL] = undefined$1;
          _device[TYPE] = undefined$1;
          rgxMapper.call(_device, _ua, _rgxmap.device);
          if (_isSelfNav && !_device[TYPE] && _uach && _uach.mobile) {
            _device[TYPE] = MOBILE;
          }
          if (_isSelfNav && _device[MODEL] == "Macintosh" && _navigator && typeof _navigator.standalone !== UNDEF_TYPE && _navigator.maxTouchPoints && _navigator.maxTouchPoints > 2) {
            _device[MODEL] = "iPad";
            _device[TYPE] = TABLET;
          }
          return _device;
        };
        this.getEngine = function() {
          var _engine = {};
          _engine[NAME2] = undefined$1;
          _engine[VERSION] = undefined$1;
          rgxMapper.call(_engine, _ua, _rgxmap.engine);
          return _engine;
        };
        this.getOS = function() {
          var _os = {};
          _os[NAME2] = undefined$1;
          _os[VERSION] = undefined$1;
          rgxMapper.call(_os, _ua, _rgxmap.os);
          if (_isSelfNav && !_os[NAME2] && _uach && _uach.platform && _uach.platform != "Unknown") {
            _os[NAME2] = _uach.platform.replace(/chrome os/i, CHROMIUM_OS).replace(/macos/i, MAC_OS);
          }
          return _os;
        };
        this.getResult = function() {
          return {
            ua: this.getUA(),
            browser: this.getBrowser(),
            engine: this.getEngine(),
            os: this.getOS(),
            device: this.getDevice(),
            cpu: this.getCPU()
          };
        };
        this.getUA = function() {
          return _ua;
        };
        this.setUA = function(ua2) {
          _ua = typeof ua2 === STR_TYPE && ua2.length > UA_MAX_LENGTH ? trim(ua2, UA_MAX_LENGTH) : ua2;
          return this;
        };
        this.setUA(_ua);
        return this;
      };
      UAParser2.VERSION = LIBVERSION;
      UAParser2.BROWSER = enumerize([NAME2, VERSION, MAJOR]);
      UAParser2.CPU = enumerize([ARCHITECTURE]);
      UAParser2.DEVICE = enumerize([MODEL, VENDOR, TYPE, CONSOLE, MOBILE, SMARTTV, TABLET, WEARABLE, EMBEDDED]);
      UAParser2.ENGINE = UAParser2.OS = enumerize([NAME2, VERSION]);
      {
        if (module2.exports) {
          exports2 = module2.exports = UAParser2;
        }
        exports2.UAParser = UAParser2;
      }
      var $ = typeof window2 !== UNDEF_TYPE && (window2.jQuery || window2.Zepto);
      if ($ && !$.ua) {
        var parser = new UAParser2();
        $.ua = parser.getResult();
        $.ua.get = function() {
          return parser.getUA();
        };
        $.ua.set = function(ua) {
          parser.setUA(ua);
          var result = parser.getResult();
          for (var prop in result) {
            $.ua[prop] = result[prop];
          }
        };
      }
    })(typeof window === "object" ? window : uaParser);
  })(uaParser$1, uaParser$1.exports);
  return uaParser$1.exports;
}
var uaParserExports = requireUaParser();
const UAParser = /* @__PURE__ */ getDefaultExportFromCjs(uaParserExports);
const useSidebarStore = create((set2, get2) => {
  const xxl = 1375;
  return {
    sidebarIsOpen: window.innerWidth >= xxl,
    headerIsOpen: false,
    toggleSidebar: () => {
      const headerIsOpen = get2().headerIsOpen;
      const sidebarIsOpen = get2().sidebarIsOpen;
      if (headerIsOpen && !sidebarIsOpen) {
        set2(() => ({ headerIsOpen: false }));
      }
      set2((state) => ({ sidebarIsOpen: !state.sidebarIsOpen }));
    },
    responsiveSidebar: () => {
      if (window.innerWidth <= xxl) {
        set2({ sidebarIsOpen: false });
      } else {
        set2({ sidebarIsOpen: true });
      }
    },
    toggleHeader: () => {
      set2((state) => ({ headerIsOpen: !state.headerIsOpen }));
    }
  };
});
const Header = ({ pageTitle, headerItems }) => {
  const { toggleSidebar, sidebarIsOpen, headerIsOpen, toggleHeader } = useSidebarStore((state) => state);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "header",
    {
      className: `fixed top-0  flex w-full flex-col border-b bg-grayscale-1000 shadow-2 dark:bg-dark-bg-444 dark:drop-shadow-none sm:flex-row ${headerIsOpen ? "z-50 max-h-32 shadow-none" : "z-50"}`,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: `${headerIsOpen ? "max-h-32" : "max-h-16 overflow-hidden"} ease flex w-full flex-col justify-start px-4 transition-[max-height] duration-150 sm:flex-row sm:items-center sm:justify-between sm:overflow-visible sm:border-none lg:px-12`,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "my-auto flex min-h-16 items-center gap-3 sm:gap-4", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    "aria-controls": "sidebar",
                    onClick: toggleSidebar,
                    className: "stroke-grayscale-300 dark:stroke-dark-grayscale-300",
                    children: sidebarIsOpen ? /* @__PURE__ */ jsxRuntimeExports.jsx(SvgArrowLeft, { className: "aspect-square w-6 shrink-0" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(SvgMenuDrawer, { className: "aspect-square w-6 shrink-0" })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  NavLink,
                  {
                    to: "/",
                    className: `${sidebarIsOpen ? "block" : "hidden 2xl:block"}`,
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(SvgLogo02, { className: "h-6 w-fit" })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    className: `${sidebarIsOpen ? "hidden" : "block tablet:hidden"} line-clamp-1 w-fit whitespace-nowrap text-2xl font-bold text-grayscale-100 dark:text-dark-grayscale-200`,
                    children: pageTitle
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "ul",
                {
                  className: `relative z-50 my-auto flex min-h-16 w-full justify-center gap-2 sm:border-none`,
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-1 items-center  gap-3 whitespace-nowrap text-base text-grayscale-100 dark:text-dark-grayscale-300 max-sm:flex-wrap", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    NavigationMenu,
                    {
                      className: "w-full max-w-full  justify-evenly sm:justify-end",
                      viewportClassNames: "right-auto sm:-right-4 lg:-right-12",
                      children: headerItems
                    }
                  ) })
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `absolute -bottom-3 !z-[50] w-full sm:hidden`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "mx-auto flex h-6 w-10 justify-center rounded-full bg-white  shadow-2 dark:bg-dark-bg-444",
            onClick: () => toggleHeader(),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              SvgArrowDown,
              {
                className: `${headerIsOpen ? "rotate-180" : "rotate-0"} transition-all duration-150`
              }
            )
          }
        ) })
      ]
    }
  ) });
};
const HeaderDivider = () => /* @__PURE__ */ jsxRuntimeExports.jsx(NavigationMenuItem, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mx-2 my-auto h-3 w-px shrink-0 bg-grayscale-600 " }) });
const getIconComponent = (iconName) => {
  const icons = {
    administration: SvgAdministration,
    simulators: SvgAdvancedSimulators,
    cockpit: SvgCockpit,
    devicemanagement: SvgDeviceManagement,
    "migration-tool": SvgMigrationTool,
    "machine-learning-workbench": SvgMachineLearningWorkbench
  };
  return icons[iconName] || null;
};
const getInitials = (name2) => {
  const firstLetter = name2.slice(0, 1).toUpperCase();
  const secondLetter = name2.slice(1, 2).toLowerCase();
  return firstLetter + secondLetter;
};
const AppSwitcherItem = ({ app }) => {
  var _a;
  const { t: t2 } = useTranslation();
  const href = app.contextPath ? `/apps/${app.contextPath}/` : app.externalUrl;
  const IconComponent = getIconComponent(app.contextPath);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "group rounded-2xl border-2 border-grayscale-700 bg-white hover:bg-primary/10 hover:text-primary dark:border-dark-bg-333 dark:border-dark-grayscale-700 dark:bg-dark-bg-444 dark:text-dark-grayscale-200 dark:hover:bg-dark-primary/10 dark:hover:text-dark-primary", children: /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "h-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx(NavigationMenuLink, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "my-auto flex h-full w-full transform flex-col items-center space-y-1.5 px-2 pb-2 pt-3 group-hover:text-primary dark:group-hover:text-dark-primary", children: [
    IconComponent ? /* @__PURE__ */ jsxRuntimeExports.jsx(IconComponent, { className: "h-9 min-h-[36px] w-9 min-w-[36px] group-hover:text-primary dark:group-hover:text-dark-primary" }) : (
      /*   , app.manifest.icon.class    */
      ((_a = app == null ? void 0 : app.manifest) == null ? void 0 : _a.icon) && app.manifest.icon.class ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: `c8y-icon ${app.manifest.icon.class} text-[36px] group-hover:text-primary`
        }
      ) : (
        /*     getInitials  */
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex h-9 w-9 items-center justify-center rounded-lg border-[3px] border-grayscale-100 text-lg font-bold text-grayscale-100 group-hover:border-primary group-hover:text-primary dark:border-dark-grayscale-100 dark:text-dark-grayscale-100  dark:group-hover:border-dark-primary  dark:group-hover:text-dark-primary", children: getInitials(app.name) })
      )
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "flex h-full max-w-full items-center whitespace-normal break-words text-center text-xs font-medium text-grayscale-100 group-hover:text-primary dark:text-dark-grayscale-100 dark:group-hover:text-dark-primary", children: t2(humanizeAppName(app.name)) })
  ] }) }) }) }) });
};
const AppSwitcher = ({ applications }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(NavigationMenuItem, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      NavigationMenuTrigger,
      {
        className: "group h-13 w-full px-0 text-lg font-bold focus:!bg-inherit disabled:!pointer-events-auto disabled:cursor-not-allowed disabled:text-grayscale-500  dark:bg-dark-bg-444",
        onPointerMove: (event) => event.preventDefault(),
        onPointerLeave: (event) => event.preventDefault(),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SvgAppSwitch, { className: "h-6 w-6 group-data-[state=open]:text-primary" }) })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      NavigationMenuContent,
      {
        onPointerEnter: (event) => event.preventDefault(),
        onPointerLeave: (event) => event.preventDefault(),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollArea, { className: "h-[calc(100vh-8rem)] w-[100vw] sm:h-125 sm:w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: "mx-auto grid w-90 grid-cols-3 justify-center gap-1.5 py-5 text-center sm:p-3", children: applications.map((app) => /* @__PURE__ */ jsxRuntimeExports.jsx(AppSwitcherItem, { app }, app == null ? void 0 : app.name)) }) })
      }
    )
  ] }) });
};
const UserMenuItem = forwardRef(
  ({ icon: IconComponent, title: title2, children, ...props }, ref) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(NavigationMenuLink, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("a", { ref, ...props, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex h-20 w-full transform items-center justify-center gap-x-2.5 border-y border-grayscale-600 px-5 text-base font-bold text-grayscale-400 hover:text-primary dark:border-dark-bg-333 dark:hover:text-dark-primary sm:h-[65px] sm:w-full sm:px-12.5", children: [
        IconComponent && /* @__PURE__ */ jsxRuntimeExports.jsx(IconComponent, { className: "h-5 w-5" }),
        title2
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children })
    ] }) }) });
  }
);
UserMenuItem.displayName = "UserMenuItem";
const UserMenu = () => {
  const { i18n, t: t2 } = useTranslation();
  const { toggleTheme } = useDark();
  const { currentUser, tenant: tenant2, logout: logout2 } = useAuth();
  const toggleLanguage = () => {
    const newLang = i18n.language === "en" ? "ko" : "en";
    i18n.changeLanguage(newLang);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(NavigationMenuItem, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      NavigationMenuTrigger,
      {
        className: "group h-13 !bg-inherit bg-white px-0 text-lg focus:!bg-inherit data-[state=open]:text-primary  dark:bg-dark-bg-444 dark:text-dark-grayscale-300 dark:data-[state=open]:text-dark-primary",
        onPointerMove: (event) => event.preventDefault(),
        onPointerLeave: (event) => event.preventDefault(),
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-1.5", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(SvgProfile, { className: "h-6 w-6 group-data-[state=open]:text-primary" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "my-auto hidden text-grayscale-300 group-data-[state=open]:text-primary dark:text-dark-grayscale-200 sm:flex", children: currentUser.userName })
        ] })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      NavigationMenuContent,
      {
        onPointerEnter: (event) => event.preventDefault(),
        onPointerLeave: (event) => event.preventDefault(),
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: "h-[calc(100vh-8rem)] w-[100vw] sm:h-fit sm:w-full", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            UserMenuItem,
            {
              icon: SvgMoonNight,
              className: "cursor-pointer",
              onClick: toggleTheme,
              title: t2("dark mode")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            UserMenuItem,
            {
              icon: SvgTranslate,
              className: "cursor-pointer",
              onClick: toggleLanguage,
              title: i18n.language === "en" ? t2("korean") : t2("english")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            UserMenuItem,
            {
              icon: SvgLogOut,
              className: "cursor-pointer",
              onClick: logout2,
              title: t2("logout")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(UserMenuItem, { title: `${t2("Tenant")} ID: ${tenant2}` })
        ] })
      }
    )
  ] }) });
};
const Sidebar = ({ children }) => {
  const { sidebarIsOpen, responsiveSidebar } = useSidebarStore(
    (state) => state
  );
  useEffect(() => {
    window.addEventListener("resize", responsiveSidebar, { passive: true });
    return () => window.removeEventListener("resize", responsiveSidebar);
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "aside",
    {
      className: `z-0 mb-5 mt-5 flex w-full flex-col rounded-2xl border border-solid border-grayscale-700 bg-grayscale-1000 text-lg font-medium shadow-lg duration-300 dark:border-grayscale-300 dark:border-opacity-10 dark:bg-dark-bg-444 ${sidebarIsOpen ? "ml-5 min-w-[calc(100%-40px)] max-w-[calc(100%-40px)]  xs:min-w-[280px] xs:max-w-[280px]" : "min-w-0 max-w-0 border-0 duration-100"}`,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "no-scrollbar flex flex-col overflow-y-auto duration-300 ease-linear", children: /* @__PURE__ */ jsxRuntimeExports.jsx("nav", { className: "p-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: "flex flex-col gap-1.5", children }) }) }) })
    }
  );
};
const SidebarAccordionItem = ({
  className,
  icon: icon2,
  label: label2,
  to,
  asChild,
  depth = 0
}) => {
  const responsiveSidebar = useSidebarStore((state) => state.responsiveSidebar);
  const { t: t2 } = useTranslation();
  const { goTo } = useTransitionNavigate();
  const [open, setOpen] = useState(false);
  const Icon2 = icon2 ? icon2 : open ? SvgFolderOpen : SvgFolder;
  const match2 = useMatch(`${to}/*`);
  const accordionTriggerClasses = cn(
    "p-0 w-full",
    `${match2 ? "active-sidebar-item" : "sidebar-item"}`,
    {
      "h-11 text-sm text-grayscale-300 dark:text-dark-grayscale-200": depth === 1,
      "h-10 text-sm text-grayscale-400 dark:text-dark-grayscale-300": depth > 1
    },
    className
  );
  const handleValueChange = (value2) => setOpen(value2 === "1");
  const handleTriggerClick = () => {
    if (to) {
      goTo(to);
      responsiveSidebar();
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Accordion,
    {
      type: "single",
      className: "relative w-full",
      collapsible: true,
      onValueChange: handleValueChange,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(AccordionItem, { value: "1", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          AccordionTrigger,
          {
            className: accordionTriggerClasses,
            arrowDownIconWrap: true,
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "div",
              {
                title: label2,
                className: "flex max-w-[calc(100%-4rem)] flex-1 items-center gap-x-3 p-3",
                onClick: handleTriggerClick,
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Icon2, { className: "h-6 w-6 shrink-0" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "flex-grow truncate", children: label2 })
                ]
              }
            )
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          FallbackUi,
          {
            customRetryUi: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "span",
              {
                className: cn("p-4 text-sm", {
                  "text-grayscale-200": depth === 1,
                  "text-grayscale-300": depth > 1
                }),
                children: t2("Try again")
              }
            ),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              LazyLoader,
              {
                fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full p-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "svg",
                    {
                      "aria-hidden": "true",
                      className: "text-gray-200 dark:text-gray-600 h-4 w-4 animate-spin fill-blue-600",
                      viewBox: "0 0 100 101",
                      fill: "none",
                      xmlns: "http://www.w3.org/2000/svg",
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          "path",
                          {
                            d: "M100 50.5908C100 78.2051 77.6142 100.591 50 100.591C22.3858 100.591 0 78.2051 0 50.5908C0 22.9766 22.3858 0.59082 50 0.59082C77.6142 0.59082 100 22.9766 100 50.5908ZM9.08144 50.5908C9.08144 73.1895 27.4013 91.5094 50 91.5094C72.5987 91.5094 90.9186 73.1895 90.9186 50.5908C90.9186 27.9921 72.5987 9.67226 50 9.67226C27.4013 9.67226 9.08144 27.9921 9.08144 50.5908Z",
                            fill: "currentColor"
                          }
                        ),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          "path",
                          {
                            d: "M93.9676 39.0409C96.393 38.4038 97.8624 35.9116 97.0079 33.5539C95.2932 28.8227 92.871 24.3692 89.8167 20.348C85.8452 15.1192 80.8826 10.7238 75.2124 7.41289C69.5422 4.10194 63.2754 1.94025 56.7698 1.05124C51.7666 0.367541 46.6976 0.446843 41.7345 1.27873C39.2613 1.69328 37.813 4.19778 38.4501 6.62326C39.0873 9.04874 41.5694 10.4717 44.0505 10.1071C47.8511 9.54855 51.7191 9.52689 55.5402 10.0491C60.8642 10.7766 65.9928 12.5457 70.6331 15.2552C75.2735 17.9648 79.3347 21.5619 82.5849 25.841C84.9175 28.9121 86.7997 32.2913 88.1811 35.8758C89.083 38.2158 91.5421 39.6781 93.9676 39.0409Z",
                            fill: "currentFill"
                          }
                        )
                      ]
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "pl-2 text-sm", children: t2("Loading...") })
                ] }) }),
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(AccordionContent, { className: "pl-2", children: asChild })
              }
            )
          }
        )
      ] })
    }
  );
};
const SidebarItem = ({ icon: icon2, label: label2, to = "/", className }) => {
  const { goTo } = useTransitionNavigate();
  const responsiveSidebar = useSidebarStore((state) => state.responsiveSidebar);
  const IconComponent = icon2;
  const match2 = useMatch(`${to}/*`);
  const accordionTriggerClasses = cn(
    `${match2 ? "active-sidebar-item" : "sidebar-item"}`,
    className
  );
  const handleTriggerClick = () => {
    if (to) {
      goTo(to);
      responsiveSidebar();
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      onClick: handleTriggerClick,
      title: label2,
      className: accordionTriggerClasses,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IconComponent, { className: "h-6 w-6" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "flex-grow truncate leading-[22px]", children: label2 })
      ]
    }
  );
};
const GroupAccordion = ({ managedObject = null, onlyGroup = false, depth }) => {
  const { deviceList } = useDeviceTree({
    managedObject,
    onlyGroup
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: deviceList.map(
    (device2) => (device2 == null ? void 0 : device2.c8y_IsDeviceGroup) ? (
      // group
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        SidebarAccordionItem,
        {
          label: device2 == null ? void 0 : device2.name,
          to: `/group/${device2.id}`,
          depth,
          asChild: /* @__PURE__ */ jsxRuntimeExports.jsx(
            GroupAccordion,
            {
              managedObject: device2,
              depth: depth + 1
            },
            device2.id
          )
        },
        device2.id
      )
    ) : device2.childDevices.references.length > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      SidebarAccordionItem,
      {
        icon: SvgDevice,
        label: device2 == null ? void 0 : device2.name,
        to: `/device/${device2.id}`,
        depth,
        asChild: /* @__PURE__ */ jsxRuntimeExports.jsx(
          GroupAccordion,
          {
            managedObject: device2,
            depth: depth + 1
          },
          device2.id
        )
      },
      device2.id
    ) : (
      //   device
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        SidebarItem,
        {
          icon: SvgDevice,
          to: `/device/${device2.id}`,
          label: device2 == null ? void 0 : device2.name,
          className: "h-10 text-sm text-grayscale-400"
        },
        device2.id
      )
    )
  ) });
};
const Layout = ({ headerItems, sidebarItems, pageTitle }) => {
  const isFullScreen = useDashboardStore((state) => state.isFullScreen);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "h-screen bg-grayscale-900 dark:bg-dark-grayscale-900", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Header, { pageTitle: pageTitle(), headerItems }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative top-16 flex h-full max-h-[calc(100vh-4rem)] flex-1 overflow-hidden", children: [
      sidebarItems && /* @__PURE__ */ jsxRuntimeExports.jsx(Sidebar, { children: sidebarItems }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("main", { className: "fullscreen mt-5 flex h-full w-full flex-col bg-grayscale-900 duration-300 dark:bg-dark-grayscale-900 tablet:pb-12", children: [
        !isFullScreen && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ml-2 hidden w-full px-5 py-3 text-3xl font-bold  text-grayscale-100 dark:text-dark-grayscale-200 tablet:block", children: pageTitle() }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: `relative flex h-full flex-col px-5 pb-10 tablet:pb-13 
             ${isFullScreen ? "flex-1" : ""}
            `,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(Outlet, {})
          }
        )
      ] })
    ] })
  ] });
};
const ConetextDashboardActionItems = () => {
  var _a, _b;
  const { dashboardId } = useRoutingContext();
  const { pathname } = useLocation();
  const { t: t2 } = useTranslation();
  const { setDeleteModalIsOpen } = useDashboardStore((state) => ({
    setDeleteModalIsOpen: state.setDeleteModalIsOpen
  }));
  const { getInventory } = useApi();
  const { data: dashboard2 } = useQuery({
    queryKey: ["dashboard", dashboardId],
    enabled: !!dashboardId,
    staleTime: Infinity,
    queryFn: async () => {
      const res = await getInventory(dashboardId);
      return res.data;
    }
  });
  const isFrozen = (_a = dashboard2 == null ? void 0 : dashboard2.u5s_Dashboard) == null ? void 0 : _a.isFrozen;
  const { handleFullScreen, handleDashboard, mutations, access } = useDashboardActions(dashboard2);
  const handleSelect = (type2) => {
    {
      setDeleteModalIsOpen((pre) => !pre);
    }
  };
  const deleteDashboard = () => {
    if (!access) return;
    if (pathname === "/") return;
    handleSelect();
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ActionItem,
      {
        onClick: () => handleDashboard("add"),
        icon: SvgWidgetPlus,
        label: t2("Add widget"),
        isDisabled: !access || isFrozen
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ActionItem,
      {
        onClick: () => handleDashboard("edit"),
        icon: SvgEdit,
        label: t2("Edit"),
        isDisabled: !access || isFrozen
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ActionItem,
      {
        onClick: handleFullScreen,
        icon: SvgFullframe,
        label: t2("Full screen")
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ActionItem,
      {
        onClick: () => {
          var _a2;
          if (!access) return;
          mutations.handleLock(!((_a2 = dashboard2 == null ? void 0 : dashboard2["u5s_Dashboard"]) == null ? void 0 : _a2["isFrozen"]));
        },
        label: t2("Lock dashboard"),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Switch,
          {
            checked: !!((_b = dashboard2 == null ? void 0 : dashboard2["u5s_Dashboard"]) == null ? void 0 : _b["isFrozen"]),
            className: `${access ? "cursor-pointer" : "cursor-not-allowed"}`
          }
        )
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "my-auto hidden h-3 w-px shrink-0 bg-grayscale-600 dark:bg-dark-grayscale-600 sm:block" }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(DropdownMenu, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(DropdownMenuTrigger, { className: "hidden sm:block", disabled: isFrozen, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: cn(
            "flex items-center gap-x-1 stroke-grayscale-400 text-base",
            isFrozen ? "cursor-not-allowed" : ""
          ),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(SvgMore, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: t2("More") })
          ]
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(DropdownMenuContent, { className: "dark:bg-dark-bg-333", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        DropdownMenuItem,
        {
          onSelect: deleteDashboard,
          className: `dark:stroke-dark-grayscale-300 dark:text-dark-grayscale-300 ${access && pathname !== "/" ? "cursor-pointer" : "cursor-not-allowed"} `,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(SvgTrash, { className: "h-5 w-5" }),
            "",
            t2("Delete dashboard")
          ]
        }
      ) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ActionItem,
      {
        className: "sm:hidden",
        onClick: deleteDashboard,
        icon: SvgTrash,
        label: t2("Delete dashboard")
      }
    )
  ] });
};
const ActionBar = ({ children }) => {
  const { headerIsOpen } = useSidebarStore((state) => state);
  const isDevice = useUserAgentStore((state) => state.isDevice);
  const { isDashboard } = useDashboardStore((state) => state);
  useEffect(() => {
    if (isDevice === null) {
      const parser = new UAParser();
      const { type: type2 } = parser.getDevice();
      const setIsDevice = useUserAgentStore.getState().setIsDevice;
      setIsDevice(type2);
    }
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: !isDevice && /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: `ease fixed left-0 w-full transition-[top] duration-150 sm:static ${headerIsOpen ? "top-32" : "top-16"} z-[40]`,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "ul",
        {
          className: `flex w-full ${!headerIsOpen ? "h-0 w-0 divide-y-[0px] py-0 shadow-none" : "h-[calc(100vh-8rem)] divide-y-[1px] py-1 shadow-lg "} flex-col overflow-hidden whitespace-nowrap bg-white text-base text-grayscale-400 shadow-lg dark:bg-dark-bg-444 sm:relative sm:top-0 sm:z-0 sm:h-11.5 sm:flex-row sm:justify-end sm:gap-x-4 sm:divide-y-0 sm:bg-transparent sm:shadow-none  sm:dark:bg-transparent`,
          children: [
            isDashboard && /* @__PURE__ */ jsxRuntimeExports.jsx(ConetextDashboardActionItems, {}),
            children
          ]
        }
      )
    }
  ) });
};
const Tabs = ({ context, children }) => {
  const sourceRef = useRef();
  const { goTo } = useTransitionNavigate();
  const { dashboardId, sourceId, category, subCategory } = useRoutingContext();
  const isDevice = useUserAgentStore((state) => state.isDevice);
  const { handleDashboard, access } = useDashboardActions();
  const { dashboardModalIsOpen, setDashboardModalIsOpen } = useDashboardStore(
    (state) => state
  );
  const {
    newDashboardId,
    setNewDashboardId,
    isQueryDeleteInvalidated,
    isQueryAddInvalidated,
    resetQueryDeleteInvalidated,
    resetQueryAddInvalidated
  } = useQueryDashboardStore((state) => ({
    newDashboardId: state.newDashboardId,
    setNewDashboardId: state.setNewDashboardId,
    isQueryDeleteInvalidated: state.isQueryDeleteInvalidated,
    isQueryAddInvalidated: state.isQueryAddInvalidated,
    resetQueryDeleteInvalidated: state.resetQueryDeleteInvalidated,
    resetQueryAddInvalidated: state.resetQueryAddInvalidated
  }));
  const [tabList, setTabList] = useState([]);
  useEffect(() => {
    const tabs = children.props.children.flat().filter((child) => child).map((child) => child.props.to);
    if (sourceRef.current === sourceId && JSON.stringify(tabs) === JSON.stringify(tabList))
      return;
    sourceRef.current = sourceId;
    setTabList(tabs);
  }, [sourceId, children]);
  useEffect(() => {
    if (newDashboardId || subCategory) return;
    goTo(tabList[0], true);
  }, [tabList]);
  useEffect(() => {
    if (isQueryDeleteInvalidated || isQueryAddInvalidated && newDashboardId) {
      const targetPath = isQueryAddInvalidated && newDashboardId ? `dashboard/${newDashboardId}` : tabList[0];
      goTo(targetPath, true);
    }
    if (isQueryDeleteInvalidated) {
      resetQueryDeleteInvalidated();
    }
    if (isQueryAddInvalidated) {
      resetQueryAddInvalidated();
    }
    if (newDashboardId) {
      setNewDashboardId(null);
    }
  }, [isQueryDeleteInvalidated, isQueryAddInvalidated]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: "items-cente flex h-10 w-full", children: [
      context && access && !isDevice && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "relative h-10 cursor-pointer pb-2 pt-3  text-grayscale-300 dark:text-dark-grayscale-300", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            type: "button",
            disabled: !access,
            onClick: () => handleDashboard("dashboard"),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(SvgWidgetPlus, { className: "h-5 w-5 hover:text-primary dark:hover:text-primary-dark" })
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Separator,
          {
            className: "mb-2 ml-1.5 mt-3 h-5",
            orientation: "vertical"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Carousel,
        {
          opts: {
            align: "center",
            containScroll: "trimSnaps",
            skipSnaps: true
          },
          className: "w-full",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(CarouselContent, { className: "flex max-w-full whitespace-nowrap lg:max-w-[400px] tablet:max-w-[600px] 3xl:max-w-[980px]", children })
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(LazyLoader, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {}), children: dashboardModalIsOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(
      DashboardModal,
      {
        category,
        sourceId,
        dashboardId,
        open: dashboardModalIsOpen,
        onOpenChange: () => {
          if (dashboardModalIsOpen) {
            setDashboardModalIsOpen((pre) => !pre);
          }
        },
        mode: "dashboard"
      }
    ) })
  ] });
};
const MenuBar = ({ context = true, tabItems = null, actionItems = null }) => {
  const isFullScreen = useDashboardStore((state) => state.isFullScreen);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "sticky top-0 z-[48] flex flex-wrap bg-grayscale-900 pb-4 pl-2 dark:bg-dark-grayscale-900 xl:flex-nowrap xl:justify-between", children: [
    tabItems && !isFullScreen && /* @__PURE__ */ jsxRuntimeExports.jsx(Tabs, { context, children: tabItems }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ActionBar, { children: actionItems })
  ] });
};
const TabItem = ({ to, label: label2, icon: icon2 = "default", className, ...props }) => {
  const IconComponent = icon2;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CarouselItem, { className: "lg:basis-1/8 basis-1/9 h-10", children: /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "relative flex cursor-pointer flex-col items-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    NavLink,
    {
      to,
      className: ({ isActive }) => cn(
        `${isActive ? "font-bold text-primary dark:text-dark-primary" : "font-medium text-grayscale-300 dark:text-dark-grayscale-300"} cursor-pointer flex-col items-center py-2 text-lg lg:flex-row`,
        className
      ),
      ...props,
      children: ({ isActive }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-x-1", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(IconComponent, { className: "h-7 w-5" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-lg", children: label2 })
        ] }),
        isActive && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute mt-1 h-1 w-full rounded-full bg-primary dark:bg-dark-primary" })
      ] })
    }
  ) }) });
};
const ActionItem = ({
  onClick,
  icon: Icon2,
  label: label2,
  isDisabled = false,
  className,
  children
}) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "li",
  {
    className: cn(
      `${isDisabled ? "cursor-not-allowed" : "cursor-pointer"} flex items-center gap-x-1 p-4 sm:p-0`,
      className
    ),
    onClick: isDisabled ? null : onClick,
    children: [
      Icon2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Icon2, { className: "h-4 w-4" }),
      children,
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: label2 })
    ]
  }
);
const HeaderStyleEnum = z.enum([
  "panel-title-regular",
  "panel-title-border",
  "panel-title-hidden"
]);
const baseSchema = z.object({
  title: z.string().min(1, {
    message: "Please enter a widget title."
  }),
  headerStyle: HeaderStyleEnum,
  link: z.array(z.record(z.string(), z.unknown())).optional()
});
const dataSchema = z.array(z.record(z.string(), z.unknown()));
const dataRequireSchema = z.array(z.record(z.string(), z.unknown())).refine(
  (data) => data.length !== 0 || data.some((dp) => dp.__active === true),
  {
    message: "You must add at least one."
  }
);
const dataMinMaxRequireSchema = dataRequireSchema.refine(
  (data) => (
    // datapoints   min max   false 
    data.some(
      (point2) => Object.hasOwn(point2, "min") && Object.hasOwn(point2, "max") && point2.min !== "" && point2.max !== ""
    )
  ),
  {
    message: "Set the minimum and maximum values of the data point"
  }
);
const deviceSchema = z.object({
  id: z.string(),
  name: z.string()
}).refine((data) => data.id !== void 0 && data.name !== void 0, {
  message: "please select an asset."
});
const TreeParent = ({ device: device2, groupSelectable, onSelect, selectedDevice }) => {
  useEffect(() => {
    if (groupSelectable) onSelect(device2);
  }, [groupSelectable]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "parent ml-5", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "button",
    {
      onClick: () => onSelect(device2),
      type: "button",
      disabled: groupSelectable === false,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "span",
          {
            className: groupSelectable && selectedDevice === (device2 == null ? void 0 : device2.id) ? "dlt-c8y-icon-check text-primary" : "dlt-c8y-icon-folder-open1"
          }
        ),
        "",
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "span",
          {
            className: groupSelectable && selectedDevice === (device2 == null ? void 0 : device2.id) ? "font-bold underline" : "",
            children: (device2 == null ? void 0 : device2.name) ?? "Home"
          }
        )
      ]
    }
  ) });
};
const TreeItem = ({ device: device2, onSelect, selectedDevice, groupSelectable }) => {
  const [open, setOpen] = useState(false);
  const handleSelect = useCallback(() => {
    onSelect(device2);
  }, [device2, onSelect]);
  const getClassName = (device22, selectedDevice2, groupSelectable2) => {
    if (selectedDevice2 === device22.id) {
      if (device22 == null ? void 0 : device22.c8y_IsDeviceGroup) {
        return groupSelectable2 ? "dlt-c8y-icon-check text-primary" : "dlt-c8y-icon-folder";
      }
      return "dlt-c8y-icon-check text-primary";
    } else {
      return (device22 == null ? void 0 : device22.c8y_IsDeviceGroup) ? "dlt-c8y-icon-folder" : "dlt-c8y-icon-exchange";
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: "deviceRow", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: "flex " + (selectedDevice === device2.id ? (device2 == null ? void 0 : device2.c8y_IsDeviceGroup) ? groupSelectable ? "font-bold underline" : "" : "font-bold underline" : ""),
        children: [
          (device2 == null ? void 0 : device2.childDevices.references.length) > 0 || (device2 == null ? void 0 : device2.childAssets.references.length) > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => setOpen((pre) => !pre), type: "button", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              className: `dlt-c8y-icon-${open ? "minus-square" : "plus-square"} bg-grayscale-800 dark:bg-dark-bg-444`
            }
          ) }) : /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "dlt-c8y-icon-square opacity-0" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              className: "label truncate",
              onClick: handleSelect,
              disabled: !groupSelectable && (device2 == null ? void 0 : device2.c8y_IsDeviceGroup),
              type: "button",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "span",
                  {
                    className: getClassName(device2, selectedDevice, groupSelectable)
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "pl-1 text-grayscale-200 dark:text-dark-grayscale-200", children: device2 == null ? void 0 : device2.name })
              ]
            }
          )
        ]
      }
    ),
    open && /* @__PURE__ */ jsxRuntimeExports.jsx(
      DeviceTree,
      {
        managedObject: device2,
        context: device2,
        selected: onSelect,
        onlyGroup: false,
        getSelectedDevice: selectedDevice,
        parent: false
      }
    )
  ] });
};
function withSuspenseAndErrorBoundary(Component2, Fallback, ErrorFallback) {
  return function WrappedComponent(props) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(FallbackUi, { customRetryUi: ErrorFallback, children: /* @__PURE__ */ jsxRuntimeExports.jsx(LazyLoader, { fallback: Fallback, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Component2, { ...props }) }) });
  };
}
const DeviceTree = withSuspenseAndErrorBoundary(
  ({
    managedObject,
    selected,
    context,
    onlyGroup,
    groupSelectable = false,
    getSelectedDevice = null,
    parent = true
  }) => {
    const [deviceLists, setDeviceLists] = useState();
    const { t: t2 } = useTranslation();
    const [selectedDevice, setSelectedDevice] = useState(null);
    const { deviceList } = useDeviceTree({
      managedObject: managedObject && context,
      onlyGroup
    });
    const [isExpanded, setIsExpanded] = useState(false);
    const handleSelect = useCallback(
      (device2) => {
        setSelectedDevice(device2 == null ? void 0 : device2.id);
        selected(device2);
      },
      [selected]
    );
    useEffect(() => {
      if (getSelectedDevice) setSelectedDevice(getSelectedDevice);
    }, [getSelectedDevice]);
    const maxDevices = 15;
    const visibleDevices = isExpanded ? deviceLists : deviceLists == null ? void 0 : deviceLists.slice(0, maxDevices);
    useEffect(() => {
      if (managedObject && managedObject.length > 0) {
        setDeviceLists(managedObject);
      } else {
        setDeviceLists(deviceList);
      }
    }, [managedObject, deviceList]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
        parent ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          TreeParent,
          {
            device: context,
            onSelect: handleSelect,
            selectedDevice,
            groupSelectable
          }
        ) : null,
        visibleDevices == null ? void 0 : visibleDevices.map((device2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          TreeItem,
          {
            device: device2,
            selectedDevice,
            onSelect: handleSelect,
            groupSelectable
          },
          device2 == null ? void 0 : device2.id
        ))
      ] }),
      (deviceLists == null ? void 0 : deviceLists.length) > maxDevices && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button$1,
        {
          type: "button",
          className: "mt-4 flex h-6 w-full bg-transparent px-2 text-primary hover:bg-grayscale-700 dark:bg-transparent dark:text-primary-dark hover:dark:bg-dark-grayscale-700",
          variant: "destructive",
          onClick: () => {
            setIsExpanded((prev) => !prev);
          },
          children: isExpanded ? t2("Collapse") : t2("Show more")
        }
      )
    ] });
  },
  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "pl-6", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Loading, {}) }),
  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "cursor-pointer py-4 pl-6 text-sm text-grayscale-300", children: "Try again" })
);
const SearchDeviceTree = ({
  selected,
  context,
  groupSelectable,
  onlyGroup = false,
  getSelectedDevice
}) => {
  const { getInventoryByText } = useApi();
  const { t: t2 } = useTranslation();
  const [searchQuery, setSearchQuery] = useState("");
  const [searchResults, setSearchResults] = useState([]);
  const [childGroupIds, setChildGroupIds] = useState([]);
  const { sourceId } = useRoutingContext();
  const handleSearchChange = (e) => {
    setSearchQuery(e.target.value);
  };
  const handleKeyPress = async (e) => {
    if (e.key === "Enter") {
      e.preventDefault();
      await handleSearchClick();
    }
  };
  const { deviceList } = useDeviceTree({
    managedObject: context,
    onlyGroup
  });
  const handleSearchClick = async () => {
    let result;
    if (searchQuery === "") {
      result = deviceList;
    } else {
      const deviceSearchResults = await getInventoryByText(
        searchQuery,
        childGroupIds
        //  ID  context   
      );
      const groupSearchResults = deviceList.filter(
        (item) => item.c8y_IsDeviceGroup && //  
        item.name.includes(searchQuery)
      );
      result = uniqWith(
        [...deviceSearchResults, ...groupSearchResults],
        (a, b) => a.id === b.id
      );
    }
    const filteredResult = result.filter(
      (r2) => Object.hasOwn(r2, "c8y_IsDevice") || Object.hasOwn(r2, "c8y_IsDeviceGroup") || Object.hasOwn(r2, "u5s_IsDevice") || r2.deviceParents.references.length > 0
      //  
    );
    const sortFilteredResult = sortBy(
      filteredResult,
      // result,
      "c8y_IsDeviceGroup",
      "name"
    );
    setSearchResults(sortFilteredResult);
  };
  useEffect(() => {
    if (context) handleSearchClick();
  }, [context]);
  useEffect(() => {
    if (searchQuery === "") {
      handleSearchClick();
    }
  }, [searchQuery]);
  useEffect(() => {
    if (deviceList) {
      const childGroups = deviceList.filter(
        (item) => item.c8y_IsDeviceGroup || item.childDevices.references.length > 0
        // NOTE :      
      );
      const childGroupsId = childGroups.map((group2) => group2.id);
      if (sourceId) {
        setChildGroupIds([context == null ? void 0 : context.id, ...childGroupsId]);
      }
    }
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative mb-2 flex h-14 w-full items-center space-x-2 rounded-md border border-grayscale-600 bg-grayscale-1000 focus-within:ring-1 focus-within:ring-primary dark:border-dark-grayscale-400 dark:bg-dark-bg-444", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Input,
        {
          id: "device-search",
          className: "h-10 w-full truncate border-none focus:ring-0",
          placeholder: t2("Device name or the value of any device property"),
          onChange: handleSearchChange,
          value: searchQuery,
          onKeyDown: handleKeyPress,
          clearable: true
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: "text-gray-300 pr-2",
          onClick: handleSearchClick,
          type: "button",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(SvgSearch, { className: "h-6 w-6" })
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rounded-lg border border-grayscale-600 bg-grayscale-800 py-4 dark:border-dark-grayscale-400 dark:bg-dark-bg-444", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      DeviceTree,
      {
        managedObject: searchResults,
        selected,
        context,
        groupSelectable,
        onlyGroup,
        getSelectedDevice
      }
    ) })
  ] });
};
const EmptyState = ({ message: message2, className }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: cn(
        "flex h-full w-full flex-col items-center justify-center gap-y-3",
        className
      ),
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(SvgEmptyList, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm font-medium text-grayscale-400", children: message2 })
      ]
    }
  );
};
const ErrorBoundaryContext = createContext(null);
const initialState = {
  didCatch: false,
  error: null
};
class ErrorBoundary extends Component {
  constructor(props) {
    super(props);
    this.resetErrorBoundary = this.resetErrorBoundary.bind(this);
    this.state = initialState;
  }
  static getDerivedStateFromError(error2) {
    return {
      didCatch: true,
      error: error2
    };
  }
  resetErrorBoundary() {
    const {
      error: error2
    } = this.state;
    if (error2 !== null) {
      var _this$props$onReset, _this$props;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      (_this$props$onReset = (_this$props = this.props).onReset) === null || _this$props$onReset === void 0 ? void 0 : _this$props$onReset.call(_this$props, {
        args,
        reason: "imperative-api"
      });
      this.setState(initialState);
    }
  }
  componentDidCatch(error2, info) {
    var _this$props$onError, _this$props2;
    (_this$props$onError = (_this$props2 = this.props).onError) === null || _this$props$onError === void 0 ? void 0 : _this$props$onError.call(_this$props2, error2, info);
  }
  componentDidUpdate(prevProps, prevState) {
    const {
      didCatch
    } = this.state;
    const {
      resetKeys
    } = this.props;
    if (didCatch && prevState.error !== null && hasArrayChanged(prevProps.resetKeys, resetKeys)) {
      var _this$props$onReset2, _this$props3;
      (_this$props$onReset2 = (_this$props3 = this.props).onReset) === null || _this$props$onReset2 === void 0 ? void 0 : _this$props$onReset2.call(_this$props3, {
        next: resetKeys,
        prev: prevProps.resetKeys,
        reason: "keys"
      });
      this.setState(initialState);
    }
  }
  render() {
    const {
      children,
      fallbackRender,
      FallbackComponent,
      fallback
    } = this.props;
    const {
      didCatch,
      error: error2
    } = this.state;
    let childToRender = children;
    if (didCatch) {
      const props = {
        error: error2,
        resetErrorBoundary: this.resetErrorBoundary
      };
      if (typeof fallbackRender === "function") {
        childToRender = fallbackRender(props);
      } else if (FallbackComponent) {
        childToRender = createElement(FallbackComponent, props);
      } else if (fallback !== void 0) {
        childToRender = fallback;
      } else {
        throw error2;
      }
    }
    return createElement(ErrorBoundaryContext.Provider, {
      value: {
        didCatch,
        error: error2,
        resetErrorBoundary: this.resetErrorBoundary
      }
    }, childToRender);
  }
}
function hasArrayChanged() {
  let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  let b = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  return a.length !== b.length || a.some((item, index2) => !Object.is(item, b[index2]));
}
const FallbackUi = ({ children, customRetryUi, fullScreen }) => {
  const { t: t2 } = useTranslation();
  const FallbackComponent = /* @__PURE__ */ jsxRuntimeExports.jsx(QueryErrorResetBoundary, { children: ({ reset }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    ErrorBoundary,
    {
      onReset: reset,
      fallbackRender: ({ resetErrorBoundary }) => {
        if (customRetryUi)
          return /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => resetErrorBoundary(), children: customRetryUi });
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 gap-2.5 text-lg font-bold", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(SvgAlarmCritical, { className: "h-16 w-full " }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "w-full", onClick: () => resetErrorBoundary(), children: [
            t2("There was an error!"),
            " ",
            /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
            " ",
            t2("Try again")
          ] })
        ] });
      },
      children
    }
  ) });
  return fullScreen ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative h-screen w-screen", children: FallbackComponent }) : FallbackComponent;
};
const FormInputField$1 = ({
  control,
  name: name2,
  label: label2,
  suffix,
  suffixPosition = "right",
  className,
  ...props
}) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  FormField,
  {
    control,
    name: name2,
    render: ({ field, fieldState: { error: error2 } }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
      label2 && /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { children: label2 }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative flex justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex w-full items-center ", children: [
        suffix && suffixPosition === "left" && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: " text h-14 w-14 rounded-md rounded-e-none border border-grayscale-400 bg-grayscale-400  py-3.5 text-center dark:text-dark-grayscale-200", children: suffix }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Input,
          {
            ...field,
            ...props,
            value: (props == null ? void 0 : props.type) === "file" ? void 0 : field.value,
            onChange: (e) => {
              const files = e.target.files;
              if (files) {
                field.onChange(files[0]);
              } else {
                field.onChange(e.target.value);
              }
            },
            className: cn(
              `w-full ${error2 && "outline outline-1 outline-destructive focus:outline-destructive"} ${suffix && suffixPosition === "left" && "rounded-s-none"} ${suffix && suffixPosition === "right" && "rounded-e-none"} px-2 leading-6`,
              className
            )
          }
        ),
        suffix && suffixPosition === "right" && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: " text h-14 w-14 rounded-md rounded-s-none border border-grayscale-600 bg-grayscale-600 py-3.5 text-center dark:border-dark-grayscale-400 dark:bg-grayscale-400 dark:text-dark-grayscale-200 ", children: suffix })
      ] }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, {})
    ] })
  }
);
const FormSelectField = ({
  control,
  name: name2,
  label: label2,
  options,
  style,
  disabled,
  onOptionDisabled
}) => {
  const { t: t2 } = useTranslation();
  const opts = Array.isArray(options) ? options : Object.keys(options);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    FormField,
    {
      control,
      name: name2,
      render: ({ field: { value: value2, onChange } }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
        label2 && /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { children: label2 }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Select,
          {
            value: value2,
            onValueChange: onChange,
            disabled: disabled ?? false,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectTrigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectValue, {}) }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContent, { children: opts.map((option) => {
                const selectOptionDisabled = onOptionDisabled ? onOptionDisabled(option) : false;
                return /* @__PURE__ */ jsxRuntimeExports.jsx(
                  SelectItem,
                  {
                    value: Array.isArray(options) ? option : options[option],
                    style: style ? { [style]: option } : {},
                    disabled: selectOptionDisabled,
                    children: t2(option)
                  },
                  option
                );
              }) })
            ]
          }
        )
      ] })
    }
  );
};
const FormCheckboxField = ({
  control,
  name: name2,
  label: label2,
  options,
  prefix = false,
  className
}) => {
  const { t: t2 } = useTranslation();
  const handleChangeStatus = (checkboxId, checked, value2, onChange) => {
    options.length > 1 ? onChange({
      ...value2,
      [checkboxId]: checked
    }) : onChange(checked);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    FormField,
    {
      control,
      name: name2,
      render: () => /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-1.5", children: /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { children: label2 }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className, children: options.map((option) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          FormField,
          {
            control,
            name: name2,
            render: ({ field: { value: value2, onChange } }) => {
              return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                FormItem,
                {
                  className: "mb-2 flex h-6 flex-row items-center space-x-2 space-y-0",
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Checkbox,
                      {
                        checked: options.length === 1 ? value2 : value2[option.id],
                        onCheckedChange: (checked) => {
                          handleChangeStatus(
                            option.id,
                            checked,
                            value2,
                            onChange
                          );
                        }
                      }
                    ) }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(FormLabel, { className: "font-bold", children: [
                      prefix && /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: cn(option.icon, "mx-0.5") }),
                      option.label && t2(option.label)
                    ] })
                  ]
                },
                option.id
              );
            }
          },
          option.id
        )) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, {})
      ] })
    }
  );
};
const FormRadioField = ({ control, name: name2, label: label2, options }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    FormField,
    {
      control,
      name: name2,
      render: ({ field: { value: value2, onChange } }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { children: label2 }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          RadioGroup,
          {
            onValueChange: onChange,
            defaultValue: value2,
            className: "flex gap-x-4",
            children: options.map((option) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
              FormItem,
              {
                className: "flex items-center gap-x-2 pb-2",
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(RadioGroupItem, { value: option.id }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { className: "-mt-2 font-normal leading-[100%]", children: option.label }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      QuestionTooltip,
                      {
                        description: option.description,
                        className: "-mt-3 pl-1 text-blue-500"
                      }
                    )
                  ] })
                ]
              },
              option.id
            ))
          }
        ) })
      ] })
    }
  );
};
const FormInputArrayField = ({
  control,
  name: name2,
  label: label2,
  fieldKey,
  appendButtonIcon = "dlt-c8y-icon-plus-circle text-blue-500",
  appendButtonLabel,
  className,
  ...props
}) => {
  const { fields, append, remove: remove2 } = useFieldArray({
    control,
    name: name2
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      FormField,
      {
        control,
        name: name2,
        render: () => /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { children: label2 }),
          fields.map((field, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            FormField,
            {
              control,
              name: `${name2}.${index2}.${fieldKey}`,
              render: ({ field: field2 }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-2 flex pb-2", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input, { ...props, ...field2 }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Button$1,
                    {
                      className: "h-14 w-14",
                      variant: "ghost",
                      type: "button",
                      onClick: () => remove2(index2),
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx(SvgPopClose, { className: "h-8 w-8 text-primary" })
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, {})
              ] })
            },
            field.id
          ))
        ] })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Button$1,
      {
        variant: "secondary",
        type: "button",
        onClick: () => append({ [fieldKey]: "" }),
        className: "flex items-center gap-x-2 pt-2",
        children: [
          appendButtonIcon && /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: appendButtonIcon }),
          appendButtonLabel
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Separator, { className: "my-6" })
  ] });
};
const FormInputField = ({ control, name: name2, label: label2, className, ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  FormField,
  {
    control,
    name: name2,
    render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { children: label2 }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Textarea, { ...field, ...props, className: cn(className) }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, {})
    ] })
  }
);
const FormColorField = ({ control, name: name2, label: label2, className, ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  FormField,
  {
    control,
    name: name2,
    render: ({ field: { value: value2, onChange } }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { children: label2 }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex h-14 items-center gap-x-2 rounded-lg border border-grayscale-600 bg-grayscale-1000 px-4 py-2 dark:border-dark-grayscale-400 dark:bg-dark-bg-444 dark:text-dark-grayscale-100 dark:placeholder:text-dark-grayscale-400", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Input,
          {
            type: "color",
            value: value2,
            onChange: (e) => onChange(e.target.value),
            className: "h-6 w-6 border-none p-0"
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Input,
          {
            type: "text",
            value: value2,
            onChange: (e) => onChange(e.target.value),
            className: "h-6 border-none p-0",
            ...props
          }
        ) })
      ] })
    ] })
  }
);
const LastUpdated = ({
  fontFamily = "SUIT-regular",
  timeWeight = "700",
  // time   
  textWeight = "400",
  // Last Updated    
  format: format$1 = "yy.MM.dd HH:mm:ss",
  justify = "center",
  textFormat = "pascalCase",
  time: time2
}, className) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      style: { fontFamily },
      className: cn(
        `flex flex-wrap justify-${justify} w-full text-center text-xs text-grayscale-400`,
        className
      ),
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "span",
          {
            className: "min-w-[100px] max-w-[100px] flex-1",
            style: { fontWeight: textWeight },
            children: t2("Last Updated", { format: textFormat })
          }
        ),
        time2 && /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "span",
          {
            className: "min-w-[120px] max-w-[120px] flex-1",
            style: { fontWeight: timeWeight },
            children: [
              "",
              format(parseISO(time2), format$1)
            ]
          }
        )
      ]
    }
  );
};
const LazyLoader = ({ fallback = /* @__PURE__ */ jsxRuntimeExports.jsx(Loading, {}), children }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Suspense, { fallback, children });
};
const LoginForm = () => {
  const { t: t$1 } = useTranslation();
  const { tenant: tenant2, login } = useAuth();
  const schema2 = z.object({
    tenantId: z.string().min(1, { message: t$1("This field is required") }),
    user: z.string().min(1, { message: t$1("This field is required") }),
    password: z.string().min(1, { message: t$1("This field is required") }),
    rememberMe: z.boolean()
  });
  const methods = useForm({
    mode: "onBlur",
    resolver: t(schema2),
    defaultValues: {
      tenantId: tenant2,
      user: "",
      password: "",
      rememberMe: false
    }
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Form, { ...methods, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "form",
    {
      className: "relative flex w-full flex-col gap-4",
      onSubmit: methods.handleSubmit(login),
      children: [
        tenant2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(
          FormInputField$1,
          {
            control: methods.control,
            name: "tenantId",
            placeholder: t$1("e.g. t12345"),
            label: t$1("tenant")
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          FormInputField$1,
          {
            control: methods.control,
            name: "user",
            placeholder: t$1("e.g.joe or joe.doe@example.com"),
            label: t$1("username")
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          FormInputField$1,
          {
            control: methods.control,
            name: "password",
            type: "password",
            label: t$1("password")
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative inline-flex items-start gap-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          FormCheckboxField,
          {
            control: methods.control,
            name: "rememberMe",
            type: false,
            options: [
              {
                id: "rememberMe",
                label: t$1("Remember me")
              }
            ]
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button$1,
          {
            className: "mt-4",
            type: "submit",
            disabled: !methods.formState.isValid,
            size: "lg",
            children: t$1("Log in")
          }
        )
      ]
    }
  ) }) });
};
const ForgotPassword = () => {
  const { t: t$1 } = useTranslation();
  const { resetPassword } = useAuth();
  const schema2 = z.object({
    email: z.string().min(1, { message: t$1("This field is required") }).email({ message: t$1("Invalid email address") })
  });
  const methods = useForm({
    mode: "onBlur",
    resolver: t(schema2),
    defaultValues: {
      email: ""
    }
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Form, { ...methods, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "form",
    {
      className: "relative flex w-full flex-col gap-4",
      onSubmit: methods.handleSubmit(resetPassword),
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          FormInputField$1,
          {
            control: methods.control,
            name: "email",
            placeholder: t$1("Email address"),
            label: t$1("Email")
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button$1,
          {
            className: "mt-4",
            type: "submit",
            disabled: !methods.formState.isValid,
            size: "lg",
            children: t$1("Reset password")
          }
        )
      ]
    }
  ) }) });
};
const Login = () => {
  const { t: t2 } = useTranslation();
  const [isLoginForm, setIsLoginForm] = useState(true);
  const clickHandler = () => {
    setIsLoginForm(!isLoginForm);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex h-screen items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative flex h-125 min-w-[335px] max-w-[400px] flex-col items-center gap-10", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SvgLogo02, { className: "relative h-[62.5px] w-full" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative flex w-full flex-col gap-2", children: [
      isLoginForm ? /* @__PURE__ */ jsxRuntimeExports.jsx(LoginForm, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(ForgotPassword, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button$1,
        {
          className: "text-grayscale-400",
          variant: "link",
          onClick: clickHandler,
          children: isLoginForm ? t2("Forgot password?") : t2("Log in")
        }
      )
    ] })
  ] }) });
};
const img = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAATgAAAC4CAYAAAB3uPAGAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAFSoSURBVHgB7b0LfFP13T/++Z6kF+RiEZG7BJVS7i1VqG5CmM4pXij4KOqmlOnUZ+ooz9xPp26UZ865Z/OhfZT9p4PRTjfFCxQvbDqFUDcBsaXolF42CBPBO4FW6C3n+/++T3LSkzSXc5KTtEnz9hVJk5M0PTnf9/dzfX8YpZGGTuTlF9lkC8snzvMlIqfMiIv/JnTIVOms3+mkNNJII41kxMT88/InzZpTGuy5vFlFJbmF5xdTGmmkkUayAZZbbmHR0nDHTDlPEGDhnOWURhp9CIzSSIM8JEZWsjW8s9OhEhUn5upwZ2/OZG3lTXt2lmiPt+Xbc7IsJxXSY262t6F+pwMk1yVbZjbV7qyiNNLoA5AojTQE3BIrBbnhfmPtrgrcJDdtz5baijt4dg/XNENqL2t3D6jCcYIYKbegqPJEp8XFOB9qA1mmoQvYKLChYHOgNExH2oJLgyaKGFqnTA69iQJh7dklcrs+qN9dr30cMTqLLDtkyZLvJuXisok8hAvPNdbtKqc0fACxZQ85bbnc+pHYPFgOY+RorN05n9IwFWmC64eAxcA5G4pMqEiD5ghXNKepbmeZ7tcLIjNCWHB/ucSL0yTn2RysEy9dTkPziq1nL6B2x73k/qROeU6SaL5qRadhDqyURr9C7qwi4VoaK+tABpVJlmLG+FERbzvGhR9KBiDic05BqoZek2rIzT+/OGPCN5ZbJi22W0bM8j0OklMJzi0zZKIdlIZpSFtw/QhGXVEA1h5ibc56h+Jq5hUV2Rp2Gq95w+9urttZSf0IqhtqtX2j1GK7JEcaOrHHMbyjlU5uWiz+bcFPrg55wAT1XKcRO9IWXD+AmvEUJpTLaEEuJ+mgdsFFQ26AJFxh6idQXPLBZyzPyP2PEmtucQ7LHBzyWJY5iDImX0sde9fhp5xMqQ0JnTJKwxSkLbgUBogtw9q+ksm8WMTZNqsB/7iDsfoOd5Yjm9p8xb+yRDYjcb5kBOJrlgkXrZQmfNNuHTdP9+vSVlz8kCa4OCPPUzJhQ50YpZFyUK1j65kXFwfG14yg451y6ty3wfMDo5J0LaE5SLuo8cbwvJWZhXeVTJvdLPbmf9V3Hdnl4C2fbe8gXp/u30xe+OJrE4tLI7mhemAZN9dHcMLqKBH/pAnOBKQtuDgCgfWBizauZ4NG+T0uH20m+csmko87691H3qmXv2xwWN3uvYF1ZWn0PSgW+ehZS62jikwhNi3aXrsjXTJiMtIEFydgIWTMWbHNmnetLdKxvPUIuUF6R5ud/LP3BOntdKjtT5RGnwK+18xL1xyI1hUNB5AbSA5IF/6ag7SLGi8I11QPuQGw8Kyw8sbNxfE2EWwuhpU3bcYOF285Ut958I3tkkyONsquTwefUxcgTem0XMW655zsaHlLhzFiQ5rg4gDUjmXPfaiEogTcHlzs4obSCnsmPWgXu/tK65fNNHXy5Y6O5o31rItEHC/LkSa8xIO3fkw0guKCDHQ3CIJT7ksMJSOllEbUSDfbmwzFhcm/oyww7hYrQHgZk5eQdeJVdibzUpL4pkypbTWlkVA0xNmispx1OalxPUbyUiQzKI2okSY4k8HGz91knXZj3C5K+ZM9ml8mb6Y0Ugpq4a/3J7XwN40okXZRTUTu3OKVWeeWxlX2puvjOt/9DrfUp7OusD5Ooa9sMlnyuYWfigZ/7fPobeVu6aCVupzJlEHmXx2heMKad523s0H5bdDmK6M0okKa4EyCkjWdcYvprmkguEg+eOHsawFob1GzXRqeN4+GjLeTxWKTBo72uAkZgzwHdbaS3NGi/B2yiCkSb6EuslDurDku4ZM5BO1V9/UiV+FCOsU/NooTYMVZz76cuv71Cn7KyS2cXdxU+3Y1pWEYaYIzCZYp127DRRlPyEebSG71Wg+c76VehlLsSm3FlrzieWJRFrPTp+dYRhSQkdowZIvdwirtatiQI/42tHYVQ/FE/FvZIVNVn8wiKi1V8QVURjwEh1icBCsuTXBRIE1wJiBvwfdXZky+zkZxhvzlP7t/kNgm6iWg55KdddFCy9BJJbEWu0JhAzckUFAH1vnuOhCeTTxVlilRSW5hUVlfs+jkzva4Z669WXTlnKBkJO/cInu68Nc40gQXIxTX9KwFcXdNAbXKHUDnAyUY0IXLnHDJ6lh6LsNBWdTfnKVYLiA6YdHZiFPlpMKiknY3Lesr1hyzZiWkNCdj5s3kfs3znQuSW0lprTjDSGdRY0QiXFMVsi/+xl2JDMorcwMuvGp19jd+tSdz7oNxITctcD6zv7mG1PMKC0ZYc9v6yqwH3n6UEgGl8Ne7cXoKf9MlI0aRJrgYMPlbt65OhGsKQFJH9haAMmIJs95goQ7M/ea2AVc8VWpEAihWwCLOuuABxYrxwpYp8T19YjgL7zpICQJicSrSJSPGkSa4KOHR1r+qNBGuKaB1T8UKS0jAGS4p+mkzz78v38ymciPInHGLhuRYTpdb2tbbJCe3fkGJAkpGus89X5624owhTXBRAFaNJf+W9YlyTQFZQ3BMYnF3T/E3ZhfetU1vP2080ZPkLJt6013l7Z9TopAu/I0NaYKLBsPzRNY0sQtfqRnzIt7ZNJ8SShw7MowCJKfZUGxZFlpPvYWMU5yUQMCK02AppaEbaYIzCGi8oZE+kS4b4m+qi8qItlOcwUbM2NQXLLdAZJ5b6hd0x/hC6g20HtZ9KDehZg5WnCaxY0PJCKWhC2mCMwDFbTtvxcpExd1U8KNNvvsyxdc9VdrNvl7W+4H8IMBCzxSJBxWcaGVvuKq89YjuMhH3oRpTSE6TbFFLRtLQgTTBGYEBjTcVvDX2vkW3psHeIsUvwQACz5pWUppoAjcCWDLWyUu8P7Gc3nBVRRZbfx0cZ+Tev4VihVr4q7ylt/CX0oiINMHphOqaGnkNmrK7PqyhWOHWNNi3dWXHz4IDgU9c2OezdIjHqSGC3lrsehvupUEjqUMdJhMjuoldWPI8HYvTgzTB6UC0rikUIcywhnwFvozHTdFXSSxM+o8SSgL4ZxYT77LJTL8FxwaO8kjS+5X5RAfruLndJSOcF6dLRiIjTXB6MHTCesOuqSAltByh+TwWoDxEjeFwLsUtwcCGTy9NZNlLrNDWhyXaipPcBubLej9jp0/+KDakS0aMIU1wETDJfs3y7G88YieDaHPco+jrx5pt7W7Pgn6a20FxgjR88kJKIgRacW6ZFVMCIeuMreJz4hqABWeKFZcu/DWENMGFgSI/PuXbhhvpO/euVRYAVDJiRSIELifmX5BvOXOejZIMlrFzffcTLO/tNHIwSA5wmxCP9WjFqe1bIskinSyhNEIiTXBhwMadv81o0B3B586GZ5X7GOYbKxIhcCnljDa9gR7S6nDL2msecLXVPODoqF2z14wFrgUs5O7PndjFjtpE3fBaXAhZmFEyYj2ruz9VmPVJZXknGkkrl+RVj8WN4jFODxpvWbN/ZCODQGJBvYgtMVpwfgKXcZTKsQyfZloXPe9sofZt93p0zIhVdMpZZep3g+9MmnLttqzzVtjIJFjPnNvt+nkWezklAgYIDpa8Mgqwo8Xlbt5M1qnficnSVIk9rRUXGUlnwaEBXFF8lchO2eSUMtyubKmtGFXtaIAnExCtxlvXv7Z0q7CK18aaQfUTuGTxIzjp1HNsZBLaXl6qEo6zuW5HqXbjwUSqEx+8WNDx7jonmQRMoVKRKEkho5O1VBcVVmZn0wsV6cLfxCGpLLjcwqKljPOhjXU7ywKeUmJT2MlAdI11u2LaxaPReIPl0vnu2u73GDYFCzumxZYogUtmsZrSuQCC91mcTF4R7BgQ3pSMrxa5RxTsMcMtVtuY1HOVaTlhp0TIe3fqJyltokluObzJvX/LSmveEooFgYq/U8TGn2iNwExL20Jhpk8QVpKTE88RFntOh0yVfUlmPmksOMUlFSczHHnBTGcyq84tKKqMdiePVn6864MNvsUN18wy5vyYLYlECFwiwcBMSIYAqvUKhBuS8sHu3fWde35bQSbBMrK7FIdzi50SAXeHoVo4FVbOWden7znIBMA9V9EpWUsoQVA6Xiwnl0JKvkkYGw11OyuxLnE/S2LFGHxOfQR9huBUQoLWF6wwWGtqnyFOqCxRSVNPy60H4D508OzSTNZm2IqL1jVFYkG4XeqPTovMqxEniQV4T1XgUjBm3OrfLCTnmCEcYFQQ4OQnzWVaQowFksYSZMQTE3S3GJAt97moYhOwMBv/8I1VZpSM9MaQaKwRbuELG2t3Bd2gGut2lDM324z1S30AfcJF9Zy0k7gwK7C7i3/rPSZwu13E20rciF2IYHWw1yIep5jIjJ8K04kzdrSp1lElXl9qxF3F77NMuSoq+fE2EVT3gbEVfNDw4lhLRNxfauvf4hd/ky0sh2kWYLTQCgJwogORjoerOnnC1xzifNspRkhDPfWG3tiWDd9lvDo+VMgtH+k+Fu1aKjiXchpqd1ZPHrfRIVxMO8UAtRbQM0PVV/hbRjFCXXtNtTuqcwvPLxYfOl8w6IEON21XDI3aXWWBx8Oiw9xbSSaHMDIcYk0TLLlQRJgo9AkLDict8ETgAsUJhtUWGKxWcbY4+fD5FRNZvB5kJokvwTN2ri0HwpDoIVWPxxcRapcbMCI3OtcUcafuxV2Jz2wdPn0mxYhECVxKnOdoXahoIRspm1Bfc/D1zWbJCWmt7mxrmykxxbCQ9FtwLKPbQmbezL/731srzBggHVj4SyYARNnhznLgvroGsa4yLSwf6y3Y8e3uAYq7iqSfsv6sZGOM7e3tORq9bsGBgIKdND2wkjz+X/W7/GI93gxXGay3hnd2lSPGpMYEGG87BktPfAFDO+Tsck35gj2j4LbSaFxTTWLBKf6OVbgjnTHdTjFCqyCSFCUAURBcuzygMvPDN1dr5w5EC7TEqS49lzkIzkFxhJHJWgHX1Xj8D8QxbeomV0bB92NyK5Uky7i5miHRRUtjGbOohIOY3KPsyruunJGOVz0wWH4S4y6QoljjdsmbhMAx2rUXbySU4EBm+EMRKFEe4FCe4dxZv8tJ0QCvDwHVNW2uf0s54drnFJPaUxRarsqPR5PRg2ugJhbEn1SBv0OZGRqje+o/YCb+ApemIAo3Fxf51GnX4LuJ2eKSNCQiLouYLehIkL86ZGiB4vMp1wrnQ9XHupx/rbBOvXFlrDFQ/yHRVCL+0U1wypoUm76I7Sibv5uzCc21b5fqfb0Mq859iiPwcRB4sOO1a48SgIQRnOIqyu76xiizgUiDy2TJafNW9MMqa3ezqMoBsLCEhef5IUr5cUUKqTtI7lQJlUs8P9byh4B4loPiDLiJsS4ySUtwmkUcCfJndSDw2AlOK2rAeNxdVGbJOmboBcr5PYKg0Hj1obbjrvKM5s3LYy38jXZINNZkp4iZGTEw1IQfY/yoSCYc4ySfasQaw7HCg4p7MkRFQmJw6olsjpLcEGujDPFhhX8Pkxc+Pvz7WOptOJMUkoxWfrzttTt894VrOl+9bx1/ccxZPK17KknxJThF+qfTuHsZCL84nmYRRwL/7P16U+JwA0dr3tQT54on3F80GjqeDfQmGjjzLW4s9o6G56J2J7UwWvirlAeJ797IGsI6FgYGIdamxMyzyRFNEgFJwUT1DcfdglMypML0jdYNBbm53bz+g9rdTu9DIMmYCzkheZNReMf6aLoN1GZ6L/wKG9ng0TFbDwkTuCSD0j/hoN0kjBCM2PhA6NYY+3YRi/K5gSLWg+B2PAtOmWQxdN40m6jN7/HWT8u7PqxZHuvfrw6Jxt+vdnQEs6x8GU+SXUZjdRYJ3Snd57RhZ98p6A2FuBFc94nkFEuqWHJ3Of9V7yM38zA8b2k0U6O0zfSkSSwA2BWl0bGb3929lfETuNTAiZIUa4yZ1J4Eo69UA8Hr6V87GnPXB4B6OLnVEzbIQCsfRZe80gNupA6O/GOE2nODv3/yhNccguDsFCMyJi+h9t2e0FawkhHh+QjLrq1E5tJmETP2ZDsNQJaV97AbeQ1+D8I3wtAp8b0Po3ni76+kBMB0gvMQW9smzk/mixNZFc2JDIR4fTFFCfUE++p5PA+ONyo/rkLbTC/ep0xrJUiS2x5r/Zu2PCSeApcq2ijbldERu4sKKMkVr2XrLdVw6HmdfOwjJ5kQh7OcNlHERX2fJq5xOPljY4W6/rWGbSBzH0F6Cn8Xx6zoohT++q5PRSvOL1spXEtsxquoFyCIvFLzYyUlCKYTnPeEzqc+Bm9Wp1qd+RmNa6ptphfW1eam2l1+Jr6w3uYli8ClCnxf0wu+4ySKPW4FK8XtvW+kVMOsRANprFDGZRvFEZJBTTjS1MJlW5Vz7VR/RkKgLxf+JjP6nx5cFPLjKrTN9B1u1iOVLp0+PeZFmgiBy0DIX31iihuMjgIVRko15M/+4TQj0eAnTyXcIIozjHxm6bRzfPfdcs/NxKyiZ/8h0eYU/iYz+hXBRSs/DgQkFlYFBrAVrbPTJtooRshqBlWJvyUmiCsf22+KK6xdxEZKNWTZ4uBffUyxQpGo8lnQLCfumToD2WdtN4NSCxoAFD27mzfHvNH4D4lmOf19vGC/ITjP1Kiry6NxTQOb6YM1/btFUNsMgUvfLs5ZQqw35feaZEFpLTjx+XUTXCdlOmUTms89n6H7O/BKJ8UHskEXVSuZRJIt8GmECtJaceaj3xCcdPa3tmVEqcHV/vcHu39gwWMalmF585JF4LLH7zXJggK0KiooztbzGixuueWwk0yAsKJ99xlnNoojjMiWq8NnlPvETw12DAp/zbDi0kOiu9EvCA4ab5n5t9koCiCxoJG2qQxVO2QddV7s8bcPuz3FeApcBiJeFlSnZNHvph4/bI6bHGUc0CjcJLmMWltqJpURTQj2vGLFHXxjM5mA9JBoD1Ke4KLVeAP8m+m5S1vzpgViPWzI+JgJTjtgJpHqrErmu6PVSSbAcprWTdfvpsqtTlP+Xr84ICm1cHGBhWTDlpba7cEpTKfH0YZK84dEU4meeKRZkv99CSlPcNHIj6vwb6bvmVhQAe0sUwQu1SQG5wmz3lR0fdZgigWlFRqQGNdtQfGWj5xmyAf5tWx5teEoTuCtxtz67k2Wh/xMKBnpbNzoIBOgnRsbbkg0iG1SYdE2WaJtuYWzo6457YtIaYKLVn4cCNVMHwxswHB7sghchoJpFpTWReT6M6mSm9e7P95DsULtqFBxCn1lozgABdJkENrhM+GI1yzF33BDonEfvdhTF92/zTp7+TbE6pRPRlJKlZakLMFh+la0rikQqpk+GKzjLkwagctQMM2C8iMYT0+ontehZYkfd5pTj6fpCDASBzSCaFroJL9rsS2sFdf17+1OihHBhkSD2PLmLl45qPC7BwZc+9fyzLkP2oURkLJJiZQkOEVyecr1m6J1Tbv2bQjZTB8M0pBxdooR3Qoi3NUbApdmWVAA8yvVkHUTDO84YQqxRxsHNArDG4KmFu4Ucod1nd2H3zKnZERTOcAGn7kcxJZ9eWVZxrQb/WZxpGppSUoSnCI/PvMWG0WBwJq3UIkFFeYLXLKEx98AUy2oQdqWKWbT+zr5aIM5f7umZctIHNAoBEE4jRyvnc0QybJsd31uTuGv+C6QUc2+ZA0NKH7WFkhsKlQ1EiBR82UTgZQjOGhWKfLjUfaEhmumDwYZBb5JJnAZ8nOEsKDQH9sprFq9Fku0pRpmacNpvw8jcUDDMFomYkCxxczC36xzS0nPNZqhKS0Jl5RIJqQUwaEkJPu8FSujJRy/ZnqivXr0sjLGXxRzz2PXhzW++/EWuAwHrQWFQdZu8bnQOtaxu5w63imnky/f5CcGEAoWrbqugVINtyzV63n/SNAW1RqJAxqF3H7c0PHabgamQ9xAKfzdv4USBe0YwsCkRLIitSy44XkrAxvpUVsmf6IvtuTXTC+TrnS5NGxSzBaCrMmgxlvgMhxUCwqEe+KZS6jNcQ+dfO37vkJnuNKw5CLBvydUf6kGCo65CQQHaCXMjcQBjYBlDnEaO95vbkVE1WNYce7PG0wp/NUDVY3E+1NOKlhxfWIuqhmA3ptW4w3WGAhLkyxQzHRklSxnzvVrfgYiNdMHgyL7fPpU0wQuMWAmUdOGgn4OrwWFntpu8Up/DGIt1KFjhgNIjn/pca+8pRoRiVsZQjPlKieZLN0Ur5Yt3n6UjCLY8JlggDfitrLlXQf+PE/+dK8nliauXTVxBgsbCLyOYwVKSzxySwrQAVFGSYyUseAsp02zqyUh6B1tf+tnPRYoiKT9rQfp5MarlX/VmJKeZvpgiFXgEiR86Ynu8jqZWK9Zb4DPgsoaFHRK1uIrL6e/rv0JTThYETEe1x9atnjXV8Y3I3VjCDO3AvVpIrZ7gMm8FJaULM6179oVYYJ2x72KhY0bHjMT6hhCL2zJXjKSOgQ3do5yESNe1LX/lbDHKm6YiLWd2LhYuUD0NNMHQ6wCl1eMP0IP3dftBSRC4DIcYEF1fd7gRA2g1m0G7rrtFvpF2QM0ZPAgqnp4OS05vaZ7gxDWhGpRqIi6ZevwmyYlGqKLAxoBP9lqbLIWBR8+Ayj1aSIjnzuraD3nLGRROSxsbc8yruPO7s3ZFGiTDcleMpISBKf0gg4caYeb2dkQOUakBS4QPc30wRCtwCXIYPjhDXTHtxfQo49rRTR7zpdMJBS36MBfepDbxfZ5dOetnjqpqqc30KEjH9O9ty2h0rO2U/aBDXQZ20DXZj/rJwAZdcsWk5zma8PFp2WLt39ORhE4fAbnHG1SIt51FK1S5Jlragid+54hM5FKaiQpQXDZ1JaPna0jxp2MMSwEfRk3ZcBMFAKX+JzXDt5Cz/9kAb39Th21tLbSfXeX0sPCOjpz1JAy6kV4F5gt8PF9TU206SWPVTxm1EianDtRPNasEN+rDy6gh+6+hW66eoHIur7pe00sLVuBBBstWJxbtoxO1gK0NYK5+ecXyxLfo7ZJRQuljtKk5IwKbeEv1EiStRE/NZIMQ0ba3ZpSi2iBCy172MQDU2/6Tj0/dqC+69DfHZAtCqrsIcn5RgUuBxzaQrcVcbrpPzwuwCIR01rkfa6lpYUee+L3vZZgUAZzhwjuf3T4CN1b9iCNGT1KITXg7dpaQdB7aM0jv/Qcc+SIIJTuQtZox/ih4HjaDKc5U7bE96MWULslyU46Eh1GwE9+EbWiiAJJXo9zQyYAm0Ks/dBa4LtDzDVv0kR8/yXi+y0RbDG/N7psYkFKEBzvbJ8XLqM1u3AWjRWL83VHDR1vCR/fgQuRWXAHLI78zI6WErRQTZvxnotOfu7o3P9nB3OzvWIROjLGfU23wCViVWd9voH+7/8tERZQ8Nf84U/POvcf+rKcegmMseVg+FAAueE8qlh6/XXKzfe8+LsGflVDbdR9jHbKlrdUw0k64G45XJ9hQtxMO2UrmIpurJBbo3Cl/ZI3zDS3Wbu5mIEZLRto9tdmKRvXxfa59MDPHna2dRlUMe4DSA0LLnNAPoUgOCzMh1c9oCzAXxAsjzqF6HbV7qGGxqYex8ua7CDIThnIO24uLsRi67n/VQxXYFrh+7p3btSUXTe+ie67P3xJUdP+/Qd7q0QEcSA5ghu59Ibwasg4z+VLJ9Itla/4Shksp+WSz7LmEt6/mnRA/uw9FBzbKUZo44CMyaYPoTE8WYv827XMAjbaaIrbUR+6YFgdjRk2SBgJ/urEs6+Zq1juQKWIu44YMbzqr5ufc1KSIekJDrEBueVwyJ0QZrZqNcENROxoyODB9NTjjyn3b7z1Dr/jpTBWGQjPG4CNuPPi4snPqKNRg4/QfT94INLh9O4HDQ7qJcgWkeUMY70BVX/aQHOEBZeXG9oNgoV394FXaHXjEcUV8+vRNRCHYyc+rYfVy2IcRu0/IyL22rpAYIAxNjwjrqHZdWuWkbMo6/zI11cgcH6/N+2wSHTdHPR5JJOGDPJ81o6OTudTT/ymjJIQSZ9k4FLoheOJGc1VzGzgeEsrLb5igZIRHCxILi83V7FMQIIqYl1UqG27LOsVenrZIJo/eZCIsy1QrMZQAOk+8n+/cTkPHa6k3oIO8sFuvvGlVyIdJuKLl9PMdk97kf8YP/21aCg4dn9pTstWNNJNeoCNVSRbSi6kVwyND4S1dcqS1yhWgdTZ586iqXOXUPY311A0kmBnfLZFkNvlyvWH9aHe3haeDW4wCo63ttCJEyf3vvHmjj4351gvkt6C40yaF8r6wJc0ePAgsRN54h4gPACLFV8iyAfWnBYB9VO6AWJDXdsd9y3wWYxwgWHVPPbEOuVf/M43djfRVxmj6NDBZnI1bxcX1cfiIju+ylm/y0m9BPS/ynLweidkd7GY9jU20+RJ+iwVdDsAaqmGlwCUUg09bnhz/Vv10+fErk2nfAZNHDBDUtzeSjIB2FiXXr+ELhJJl6/fV6PRXdPxmcQ5YRmDKBoggz1m9Gi687ab6SdPRieKiWv19/d5Pu/rjjdFAulnGIRTzSRWIRjBqR7XsDMxYyvjieSPwYWwPrAY1dhbIGBRLfJabXge7pcKo7EMf2Lzv8hBqPhdhz9voQuWb6CTYxaIi7sAcrDU9RWnruN1IqDejEp7l97FHw8gM5Y7qwiyUD1IDhsAzlGo5IgW2Dju/+0W2pu5BG1nCuC+qXWG2dY2/dPuv/oCGc+Ye0i1LVtmasNdteCyefh+DwurZ5DUgq807kAG++Gy+5X74pqhJtcgsg7T/3ploxFfzPVTW3zfp2qVCxPB3vjOzkWUYkhqFxW1aBSitAHlC+qX+OgTnvq4Fm8GdZHGJb1IuLBqZhXBcb3mvtJm1bWO/nxfAT10981BCQBW28O/3UB/lpdQ24Qlfv2b1nHzFPdi4I07aMAla9YPmn370anX/2rbpAuvWo36qEQrOaA9TZJpgrjS/QqdUYisnjf82xIkC43H1qzfQJf+dw29e9rNfudQO8aPy/rjcO5PdpuiDaeNwzEu28gk5J5zjg0hDsRxycD4wGihJMsEuSG0svGlLZ7vwWAXDa6/Ea436aaFnlYsbEi7G1VLOTWHRCe3BScFV4m4eP5ccQGIi867ztBeBGx8eQvBrdACz+HiwZedOeNmCgd0IJzyaQ1dcXYr3XTf3B4WWyDW/HELHRhfGpE0NZXj9szZd9tF4Lo068smmnRKVj1vPwZLxmGkwyJaNHjq1EpEfKmMjZixiZ/8LB8LeOENS31ufvXTf/B7zSax2B56pJxO5BRQlv2XPd4zam24L/ahZWtpLK1wgF/IgZnXk3rs+DEbrp3Zswro28JCX/tpZAECLYyqAd/ljRsDCBngmh3UWWPIcsTvRB2muhkjZJJ5bim1O+7xPO9py3JQCiGpLTjUogU+hovu4ZUPKKUgKlRSQ/wCi7FBLFpt4B/ZwYyZt4QkIhAbWpJuOX0L/eWnc+nHty+J6LLBoll7oCCqADDcOouw8HjbsXyMfGOcllECoaj7yh17ByzaSFkXPEAfy6MUSyWwVARJm0rh3sMCDvV3+o3xY/otuL7esrXltb9WwIoC0dx49eVKEbdeBCjX6MLkSd0bxWRvJvuqqWQIX6ctft7Li3tblDKoVB4SndQEx9uO92h2xqJD1T3yDiAyLXBh3PfDUuUYtcYHaM0YGdR60xIbWpLuWLbEt4uGwx+e30K/OzArKnJToZ2q1Bsqv14LSnHb4UpnXfATv8UBYDPZ/HQV3SUC3qGsF78xfgZKNTrcWQ6zhlFrvwdvHDBm7D/kKt+w0SMpjvNw5cTIbiquJ0U8NIqWQpTnvO7Y7rumcY292Kw/UYGQyr3f7fY4cP3XfuJ5vX9bFk9P1eor2Pfq70oZsRWBj8N6e+yJtX6N7ACKe1Hfg5WmXaxNLv/FGYnY1LKTYMDv/vWOgX6xp2igXdy9ofKLyV6qBYXPks9rlHOHntTAjePOW28JFHPsfp8oSzWQcJFbDjvJBGjdVCNxwHDA53v6+Rcq1Jjk6NPDkw3qItteXmpYDEIFfg+SDPtEZh5JsdUNBXRyxFxdri6O0SYWALinqiySdh6DMJ2LU2UeA5D0WdTGuh3lebOKXDLx1YGtLyCbRx9fp1gYAGriAoEY0qenzlWyfiA2uBrfFkvgptsXBLXWcPzsc4OXkiAjVfZXcVLPim6alxbahvPe6P+DsnCGt79xxMk99IfHHlYex84Pd3WXxsVXCkLD1A9ijJ/c6snWGSnVkI8fRPzRRjFCW7xtpjYcrLjXt7+5ctEVC+hIGPVyuKSxCkGgnChPXI/YmH/8UDl1Nr6wVz5Us56G5hZnz33QHu61ZxyroZu+63/twz1lgzRJr7MX+IQuvUq+ZZQCSAk1kYa6nZWSzMA6zsDnYMk99OuKoFYXdrHfbK5TBB71uqIofgwWf4PLYBa5AVqVX+oFKCUrXx1x4r49r9s6UYunEddUb2NGj6QfnnuEZny5jniQ2FLU2nCuAwfJBEh+iQbzhtBoy3pGDwtuwcE17DBBr23ji54YHzaYTS88s+L9p+7K3+d4riLSkGhYb7dfOMjvmtW6pyrCDYlOZqSMZDkC4yL7N1+2sE2BtXFVTz+jSP4guwogw4oCYEj/oNvg1NO2hLTYtEBiYnKQViUkFBBzs55ljpqD1j3tTZVfd+uhestXR2z7/lknziFimLk0u7Cn9YpyGNwmi/Nz64utvho4HwZqxwjqL9Uwq2Ur2jigHnzxhaIokjP69MHEG3t+1mhd0kDgGq565ulqQddVTXW7fD29sO6nnrPVIdxMe+BrhjvX0ciuJqIZc5XwAr6/ybnn0Ovba4R76l8BoM5j8FhxniHR4k45JTlSguDQLM4ttF6GrlaIrgaoiajZVMQzUDICs1+bfo8EWHyq8KMK1Llt+HyuiLnFtgi10Gp79abKr/tI3UF2wSgamztLOXcgeE8M04PA3lQkb9jAniQfbcuWYHcHhlFbz46R4KKUbtKDrKwsheBA8O4Xanp+VhPUiQGUhohrtXh37Z78rTWTFn7wfkMVVG3wXFfT85szCm6zaxM9iuV20Ujh0nquV1zzECpFHBo6hDSiZ4mTdh6DcOWRbEgTXG9DUcKAUGOEnRkxI5XYAPSk6iU2wNP90H1R4L1+8fst9OeWuTFlS4Oh69/dJS69qfILCwruz0Xf8vx9qqUGqMIFKuGhTg4/s8yecc5oW7ZM1YaLMg4YCa5jHgJDJnVUdgt9FniAQjqxt53Bc/Cef9sdt95cIs51yVZHjXNrzd8c/3i/cTOGRFunfsd3ntwf19Hgr3Vf37jWJ+Mm3mfbu8LSlHte+8o8BnGevC6vMo8h2fTfApH0BOeWmMikcluk4+CWgtyMEpsKxXrzLm7EMH5QsYX2D7vWL1BrFnwWHOP1vTllCxYUJN3zJt3S4ymcw0DCO/xFK/GPgruU2patTMsJO+mUTuJtLieZ0LKl1YYzs2Xr+PHu7MI51mb6NGDimHXchdTxZRPFijmF/i2EICpxU8hObL4l1a/W0J6TdUrNouf8M4V0PaUl//R+V57wQiNYOESLF0pG3K95x0SmQOFv0icZGOdhd3fGyAG1kK0vvaC4WdGQGzKnqvUGclu2uoYOjLqZYq2yDwb5aFO3OgXv3SlbsKBGy/tdaoAaWelgyihqTeEdJUvorOPBC161ZTNGxvi5jzab0rIVbRwwEk7N6Z6NOub0QeT+91a/Dckydi7FCiR2LrKHfh+QF4YX/fnHs+inM+poZvsrVJBRpzyuztNAzBmiDyh0bzoR2uNIpXkMQNITnMTC7zC2M8/MwTSoaIhNxeDBA5UsFKy4ax6uoc/HLKF4wW9INev93XP2jIlO/AsSw212YU8xAqU/0uv633NtAQXL6sXYskWxIuo4YAQc/dJfaDWfveW34UIWyTouepKD2MF9P9Rfe4sykvX3XK70R4PQ9nlrFmHxoZzlGefEiIo5WmUUzGOgJEbSExxKRMQFG9TSwcXx3/ffE5M7ohZYogzklqrD1HZW9OQGdy/S5Pauj7vJocPdOyUiWuROPFs5f4i1hVL1hSuEBQTrDgRYkLGnxzHRtmyh4NiMgSrxatlqaf3KBeKHZQRy+cWPS5XvWQVqK/MmjOohyxUJSCo8+cQaxfNQ52AYAaw+WG7arH/1azUeQYkInoffMZwndeFvStTBuYlW+T/CXePGjnbBrQxmcegFqvaPt7YqHRGP1I6MqcYNWS3MYD3x8k10cvO1zo63f+3o3LehB+FpfnaalemLFl5RR0+JjT28FaLq3QHfX1jQQwTSX12X5etdNCg45iZNjPLvtmgzZdH+/e23lbILtAB6tNpG0ayhng4QfOeYoFb53zfTnbd9V/d7YsN48vE1yjmNxfMIxOZ6/aonKBnxgOV4C3+TEklPcLmzilZaON/U/Qh3WS3y/BuvuzZncm5sdWlY1L9/8hnnmue2V0ejea8Fyh18n/D4vyvef/pH81vf/u3Qti03zT+56epVbTUPODr/8aTL14TNuTmxpxgAUUePZbZH10YBFwibAo4N1nyuVbHVO8bPzJYtrYS6dwhOTFi45Dub1j5aXqxVqEGcsvGtFxyde9fRikl1ijADSAoDetSOmkhQeqWPmCP4qQLW9ScD9Iu5pkrhb1ITXJ6nr7HM/1GWM27shPVKlmlS9LLQcDu+/8N7tv/+6RcLrGfMjPnL1calLLLswL9YvEjDN9RsLNu36efz/7HupqFWi7tAfCnLJAvr9RqkESNG2FQLoqUlchwM1gssXhyLAupAaGcXdEoW/R0NXx0xJZPsVyfGpZi/06PHjx9UN1Fl7OPj65RzMG7MKNuzP56ryLdrgZ7drS9t1OWuatVwzED1tj2GxFxh7XbH4nyFv0mH5FYTkXhxsMfXrSlXdMzyorTgYLFAkeSdPXvK8LM0ZJydYkR3HIm7gs5Z9eKD3bvrEVfsC/VHcwpnjce/i664XPeCw7FIOJw7lvVwU6Nt2eInPjNH/NLkesVPP/u0GpYRrhdFa/CGa6mhsZlWP/ygLZT3AMvsuI7NQinGVe9jApy4nvVsMqHwziEyDOtZmmJgxhZSEiKp6+Da5QGVIj6AFJNNfUw7RSsaIJiOgcaQO7/h5tuLPz3yqVIkGguUyePeWihGrNddT73o6OxUrBzEhFTLLFJMSE04YBFjpqw2gxjtGD9+8kvTawGZCU382IQeXv2o694Vd+XATcW1A/c83PWnd6PYp1FsQUshiBHF6vAs4MLiu4CHgk0cXTo4JtR3g98JQQmj1gxCCmrhr1oykh78nEB4i2An5BaeX4z+0/Fnjlt652032ygK4MJRRqUhLX/3cuUiveqyby1d+/xfXbFODPcvm+C6Clz7AgYPGuRrdodl9ugTa5VgeiSog3YmnTqK/qV5HIvF19HgTTToKWTmJz7tvWLnyNgs/l6llOLieXN9g41ihXZAEpIYKrB55AliGysI7X9/87jjeytWLlI07mSyjRw92pZ3ztnjs7IybeL1OV2ZpytWcq2w3qTToytVsU5eIq7fWnH+WQUSPpRkSIle1KbaHdUiHlf/n99dulLdPXEhNOh0U1HIi+qs7t3Q8x4XXlCU8/tXG2MWANQ2z6PsgZIQsMxQBoEkQqDwZTAoCYf/epCoyL/nUdvRkCG1IcRQSUmMgQNPce7zuo96EjFIXGmHHAWDp/bNs5GM0fRQB8J2pid0olpVDXXdbQfYPAZ//e6jyhDu08kwUI/ZdejviiRThzygqlc7amJASpSJAFOm5q3ULjxlIEhj+BYZtX4J+m7YFdHOpb1I8R6njpsRczC6t7XdzIIaV9KT4cPCXPSNgh6CjNYzuy0JifVeESmPYip9KMCa0luOhOMumHNeSLJAiKX66SoKVwGgxuJgMXrb3noAhNT10Q4HGYQizFlz//b2178/X5VkSlZyA1JGTeQ7S/6jRPuYGjcKB7V+CUSHGaaBhax4j/kzRtKf2ylqIP7W29puZgKbCNzPQFWVYLjp+uvopZ+9Qp8N7D6vlrMuF1HIdYqbiriOHjdVGpZnI5MhYoCmLVojajTrn3q60rFj96of/uctBzyxNU/NHO7DuhusM8OK7wGbyMzpM+1NtW8HDXt4tOIW2yNlT1GM7HZudXU2V1fT0YaqZG+w1yIlCO5b37pofTC3SVtdr8IzubtOmP3XKqa/IiD48itKCj8YkA3csq8l6r5TfrTbiuxNbTczAfcToxjvikBy2CB+tmQi3fpis69ERJEu0jbe61CPtQwaM55MgHbQi8QkUwhu9zu1Ed8H19j/VDy2/bWtW8tU8jhj+L0ucc0a9g7gDmuv9ZlTJi98jihoYBS/a/K4jUG14gAQW1djtaurubqi7fiX5clsqYVC0ruoqLb/0fI77MGeA7Fps1HqPIY7vRpwMPUROA9FbgCanN379U9MCoRb01tqkZInwRAOsBzmFBYEbbwPBL4DzHPQQjvkxFNEGnpOA6xz6YzpdjIBWrXhti5zXFSRFQ9JCsq82MfXOb9x1dWL/u9/HvLLQLa3txsmE9XT0GJK3iRbuPPn/vfWisAwAdzQ9rd/tf3EhktKWmt/PwF1mKlIbkDSE5yw3laGSsvjAlOaxL0xI1hsWnmfn4v42/3CRd3XFLoVCFZI4ViKGm5Nb2myZaFaWltDWk7q5qEnHvfz2xco82RVwGVCds4DlpNpYZtCVcq7JbKbocgB8E41ZMFdZrXByYy5As8Brq21lU+6rrqhZNWvf/tUAZJgga9TdeT0Au+JkEqgp4IN2KtvFxT43W7nGwp5uT+s8cXXPnj6/9kxazdViU1F0ncyXHnpJfZgz8EVvWfVg0pcw5Ml9QcsOJDb6443fYOhQ+HcsUTRKlr0GW23OECp/fpTZEluWHzX5x7xO4eZM27p7k/lPD/T0r4tkOTw/Waft2KlGYKi8apFlNy8XhkyTv7E9vOK309wvBzaMmKSMQuy6ulnFS3DQODanT45L2xNYdc/N69CO+DxrfdM2LfpoaQXsTSCpI7BuUnKGRxATmqMLS/3HJqizBCY5SuM7HZL1ynJBVSfgwAjFQZjsO/jP3qFrHnGlES02m6cS0mfYAgGleRCKY2owDl8EQmH0Z7jEIvLvmQNtb12h3KeFJKT2vbkziqqkmRycAufaZl+S6k171obmYB4xUKhmfen5za6hg8bdmzjK3+udB4yP5aF0AqEI0IlIERWtnjjHytDDgff53i+nPopkprgmuvfqhdkterhslGKm+oRXvTE2JDpQyIhECA7NXOqh9wA7JKzzmild8kYtNpuvTlbIZ6AdYZbYDInEKESDgOuqFLkhdyHamBl2digkSulnNyV6IM0U1A0nnMunnz+LxOMktonn3wWdmIYrk8RIiB1wki46xT1mlPyz8sP1wLYX5H0MbinnvhN2cVXLF72qAjm4oJQ64fu1AyTQYxEva9WiI/RFPTqASSA3AYnrftru0lJd/Gdc/YEXcdho9ATjwuWcABQjJo175eU/c01lHX+TyhDxOfMVkvunnPBXaHKKqJFPEIPSH4NHjTIU750fXjrGPWabkmyUxo9kBJlImhO/8HtOyvRKydzljN61Kh8tKyMHnmG7ZRTBuS3t3fFXKyLxTlw7TpqM9CX2pe03eINLEI99XFIOCx5rIZOnGFO4kAPkEXs3pxYn8hkv9/QGPI5uKQlN1yn/KunNQ7W8aXfvHhhY92ufuuKhkLKzEUF1OCpiLZUOzSP//fDv9om/rFTjLgqfxA9e1LfsYgraequHJSEOHmy3dDGgPo4Rfk3jMXhSTjU0NpPWygeMy2CQauwK0lURX0AaPEK9jjOn9rOddet+vTjgKmTJ+VTGj2QMq1a4TBq5AhTvvwWAx0N8pf/7P6hD8xWiAYd7cYIDuSlFleHAxIOZ3wefW2hUWC6PIBOkr6cQTzubRXc9OIWJWljRM135rSpOck+ICYeSCkLLhhQejBh/PioXFSlju7Ix7Sv0RNfeql5pIgX6XutNl5ndbuTRiJJizPHjSGjwAKFFRIuxhks4RAvgNxUS9picUf293oJG196BQSsxDJBbkYlv5TB03LsElCphpQnuAzqsIV7HsSFOiaQ2PHW7jotPIb+QDThX2y/EJOg6Dev/NSJTJ/ltFySIkwm0itwmYqAiwoRg7s0iZ5AKAmHzetEZjp+BIfYW+e7a9UfKyEmSn0E/oKWdYq2m2fA0dyo5jBgboaZ/bWpgpQnOJSSrFm73nW8pSUH1hh2Ri2RYSK7SmLarCsI7pDSGtNMbzhqFAHH09r/6fj7E6uXwRVgg8bNZMOn26UhNrtl+LQcdto5xDI8r8fCUotKBTMmbf1bu0EXVQu0v218+ZWw8bh4Jxw69q5TrTdnhxw4mKh3MXb0SN/9WAYj4VrF5vzCi6/sNTs7nApIeYIDFl1xmWv2ubNyVNICVOnofeK28aUtPlILLyetjFBb0fCOw0GEWM5zFXh0ynnn5ctuS7509oKFbNDofGpvsamvYEkafwPa2juiJji4oUo8KYx+XDwTDl37NviSCyKxsMxZl7xZbG2oBJszZMAalLDJx97rlbs65AF2SqMHGPUD5M4q4mQSGPEVkdLxaDGSLSwfckAZlq4+5RoZQeWfnuGRarAiAQSnSmsHAwLr12g6HMwALOiTLy9Vu0hWNdXtLKM+Blwj5b/6+Z5vXfwNZRMJjPceOnxYITFIfn10WNeErT75d/Y2Up7gkGTIlNqOkkmARdZYu3M+9QOIwDdfFKT/0SiQdEAfZajYEmJQt7442JSEA8hNaf/yuKZ9etFPzL8gf+zYEXsiew56oFhxE1K9ed4oUr5MJJvaTK0PUkUaKQ3d8MxzWBfy+VAdDkahJTdY2slg0XiGyMRKbkByD2iOF1Ke4ISraDoZ9YcLKS+MxphRIB4XSXkkUFIpEAM+eoW6Pgydr0G8DW6pIDeniLnNT4aqfgvJJl+bPOb5IamG1C/05dz0Cm/hpuoeeZfMQJmMae+FIuBJoYuAtZJKsMRmtm6gS7vW0WVZW+gayzpa971cKhz6cY/XQZW2Y3c5tb/1IMkdrRUdcnZBssgBccnsa5Oli30DkPIEx8l8C06dEUlpGEIkkUy5vYXcH74pSO0VWv/AErrjhgU08EQTNX5GdPPvmqg+szseCGLr3LuOTm68mroaNmyH1dZct6M0mWJQcbo2V1IaPqR8mYjE+ExuWg61G7Ks9LY6KEUBrT2KA0IVAT/2+DpafNXlNOfcIzQ590LlMVh19ymipDW09Z1meufQs/Sxe5QiPd7ZsOGgsPYqhcVW7qzfmZyBdU42s9N8egf59BekPMF5dsk4MJwn3lFGKQrz40Ne2W3Hm3T4uCC0P26hH9/uKQ25t+xBWnzlAqUIO1iLEqr7cQNAdnf+8HcrUkE5g0k0Ph6bbyrMmzULqV/oG4cYnAeeeEeqyj8LC87l+PuOvSLLNzNcHVsowA396PDHSgsRClOhtIyMochuVtMpIw6yjIEzT8/uzK95a0dOnWsUvVS/gWadsY6uvOwSl+3MM3NmFxb43gek5jz47+3vNzbXv/eP96oFuTkoBRCvzVcYhYgRV1IaqV0HpxTcSnSA4ofKprqdyyiFAXcn29qWL1zy9ZNzJ9rgVo7xthmNHT1a+RdlDrgpPb3KlPdwdV3c1VS3ayju5RaeX9zhznIEulPYODjnM5WjSToY7JhUQO6sIlybNjId3ee4vyPVCc4uCG4bxQ39p7gyt6CokkyaRI+EQH8afBIKZnbYBMIquwvSEuYpnkWNRw2cP1hOlnSyhPoBOGOmkXg60xd/pCXMPUjtMpG4xd80YGwh9QNYiJtmDSDThyEplEbcgHNMaaQ6wcVfALC/tG61ydnVcMnJJHRK1hJKI37oJ8XokZDSBIc0PCUA/aF1C3FGxsybJ8pIXpru6TU2/NkYWI7NxHa7ZEVKExxPgAXnhSnB974Oxs0c2NJ/4pehwIltDvXcXbfdotxmnxu9GGaWxIupnyPVW7VslBjY+kPrltluan+JX4aCReIhFXgffXytckOZHIhuSBQy5oJAZ1I/R8oSXF6CzXO3zFJ+tzTbTe3vPb3eUhlnuGMgTlD1p2do0ZVR6fLZqZ8jlS04GyUQ/SWmxANmTGCqeozv199LRiK6/VA9jsaCE7D19zhn6hKclOgRaizH2wOY2mD+bs+cwgKlKT5a9HcBUYgF6HH7d71TF9VwmkzLCTv1Y6QswcmUaIKDckm/SDbYtD8ok+xviG2eQn9WooXbz0mKaMXBVZ0TRcKBc4ud+jFS14JjiQ+w9gtrJEjx9GMiGB4byfHl/dmKC5ds0AL9vUZdVcZlG/VjpCzBMeK9smBS2RrBkJRgjyNGhEHG0ZMcy+nPrhSSDXrGS3pGMBpMNrD+nUlNWYLjPPEuqvc3p6wuPrNwW6jnoCICoos26cBI6tfzBATBRRxMfTyq6Vs8nWRIUdgoQfB3G1JXFz9SfyMsjDnnFkRXs5UuGdFlxUFjz1iyoX93NKQkwYVypeIFXHDaRZ2qNXGQf490DEguWldV5v17KhQnVhHpmGiSDZkWud8KG6QkwcVDbjscLrZf6Kd4y5icko3Oetx+uFEbBclF5apyVtyfrY2m2h1INjgjHWc02cC51G/d1JQkOPPHsYUHJL3hmnV/AJafallB799j03MspMkbmhqjaunKlKiE+jFEciyiFWc82cDSFlwqIR7j2EIBQ41hvQXGRSDzTSmEbDL697AKPS5XT/TvkpF2eUBlpMJfo50N/blUJDWTDAlMjedN8rhigXE4LvOUIjijVnGHTJWdclYZGZYEYjn9vfCXdGwM6GxQr72I6MelIilJcImsgZusib1p43Cppqgqk2TTeywj2u6s3+nEYpUkimIoT/+24vS0bynJhsIC0of+WyqSmi4qT5z1NEfjml48f273EymmqKong6qCM1qv3kf5g3FXtX9rxem14ibrHuWIUpH+uWGkaB1c4mJwszW76Gy/HTW1LioDm4azqXanX29lc92OUjIosyRIsV+XjISy4hAGQRkObg89on/fOIW+slE/RMoRXCJr4KCiMVgTd5ucm+sXh0uV9iMPUeveNBzBHpTcfJFBscx+ISIaCooVx7sVf1ViQ/Z000tbqOpPGwx1NXRZmI36IVKO4BJZAxfMRThPUy7COLNRCsBIBtUqu4OaFQ0iJsdIitiOpEVaK86ziYLYLrJfGBWxqeivtXApR3CJrIELppevjcmlimS07nPKeH24YcONdTvK9bQj+X5vP23fgsWcO6topTifC1taWhVSA7lFQ2wAkj6dsv7znkpIOYIzku2LFcEsuIvnzdX+aKcUAGeSzoQJK494hBtZVf2uan+y4lRiy5ROHhA/liEsEC2pASA2kcWe31i3046sNvVDpBzBCQshIaMCgWBNz3ApNHG4pJeMVmZbcH3TmTrc/nLmwWDUVe0PVlwwYqMoAVJjjJeKJMVQEJt37kO/hZXiCHxxmZaT6wXpOBvf2bWCEgDUwHGKP8KNc7vYPlfpxwS82StDGcS+BFl/69QqvVYCXNVJhUUL9dYKylxRSnZQCgFrY6Jt+NIpk3KLC2ZOsz/0a4QuGUUDkJq45h1SJlU27OyfllooxJXglBkFnBWLC1l8oUUViTCTPeUM0V0oRtDQ1OxqaWnJGRykZQaWnUpwnZIF8aukJTjSN/PVic4FMgC4qiK2t0eXtcKpRBDCCk99WHJDWMT2q668dHlhwUz7ZRdf5Lt+Xt/2plK8GwnwEHCDwCgstXb3gKpUOC/xQlwJjmGH9nCNM1ZyU6xBqW25eD9bU+3OZaGOIWpLiEsoYiOlf359a/m1ixb2+H1qPZw3BuKkJEVu4fligwotcukDozKj3y9cVfH+y8T7b9JzvLd9q4ySELgubWNPW/7tq4tLZ0yfmhMstIEi8UCCQ6hjtsjKDx40yBf2gJABxEUFKhtrd0XR69u/EFeC80AElJkUs3uaZWnbpLg0whqckn9eRbBsXQZ12ChBsLrde3fX1m8XBNdjeDF22Jkzplc8V/m7ZO+p1GW9BRb26gXkgSYVzqnmXI9+ntK+VZ5M1gqstXPPK1x5sf1C++IrF9DgMA3yi664nB57fJ3YOI9jvTgx+wKtf/samxVSC4SwmA2V3PRXxDXJYLW6y7ksz/fqXOkCgtq5hXM2KWlyLybOKirxxWsYC1mKEE5S21xwFz7Dy6/+pTyUWzE7f2ZSt2rpTi6w2Kwq4WLBGndGPjJ5mvAn5p+Xv/ye+7dVrV2z7cknHlO8mFDk9nbtHnrk0TWuhTcsXdXa3jKhqW7XUHF91XueqwtKbmqvL5kMWJogZUohmGrBYVHIFiWt78CufqJzoBOPi4DyNkgYdbiz5kfagZWgtmdHLxYnvALHW8QPbmIVEpMPtLuzQ1oLVqnL2SVbKsUFYBOEiAtlvDltWyhrYMfEHZdImBzljCnZQmSo3v3HvnrhcvSoEzv7rAmKJlyyxkd0Jheitt58byDOj8iSLpNl2hb56OSw4r63rGT9j37w/ZC1gyJ2SxteqHa990FD1Wvbtlb3zHRCvy10qoxJ8XHVMy1tq0VCpyS3cPaiptq3dRslfRmmEpyHnJSFUTJp1pyh7XJbdaYgPI/1xVWNNEe49xAxK4e42BXrDccL0nQ21O2sJB34YLdi2QWNz+UVeZRiJbc7R+YWH+lBXvw3jzy8HLpugHaIcfVLW5y//v/WClLe5aQQePr55zcvWXxVfuAOjTict1UrWS+UyO4pY6ZkxrHAJ846v4JFHNiD6VttCAnERKrxxst/eXW7luBwLXgsfUZ/3brNuf2tneXNzs+CJgeUODIP2znijFvph2KxM5KYFNUGAgPHbWXLM1hXlXct9jpMJTirxV3d5cZ0JJYjLLbV2cLikT2Ep5jVer4Yv4tdJpywhSIYbcdzEuMrov1yQ6XPf/Lgw0tR1hEIuAY7a+uqIrkC+w+5ykWyYXlgsgFEOfKMkfamJCQ4XckFxjcL6820vw3accIFBXnZwh/J4ab2aYL79LNPqwWhLVeTCehRhgovroknn3m2orEudHIAbXFyuDdn8U20QPml4Z0dDjIIxXuTaBuTua2LFAMiCpks82FqDA6sLcmsAOlrnCgu8ZmKVA5ji1B0GO61InGQr+rxK+oTRKs4o6XihJUqw4bFLR7DXIYPP90e7PGtNX9z/u3tukqKAOzCSDYEe+6ahVcla6tWROutw81MjYfp1o7jLL+vF/5iE971zh6n9rFFV15OY0aNEu5leFWVCG1xMYcEwv5uES/H2tNTnC6MkNViI9yjHusNadjIUzLUZxIgpicZkP5H+honql1myr/C8nLhZAi3NeiiALl1SZY9mWIHUEkOrqrS1sOpCv2LIEqvQqxpgPLInMICW+DjkIR+bZujSm8gN1SyYfCQQUk36V5ncqEyHkFuvdpxydC+Vf3yy1UtAW1WHx05Qm1d4RMqYdviTLbelITerDlHcwuL1uM67aSBTpHcWy8s6aORNhGxJnGd5EO3D6/lslQtZZJIkuyc0JfawkwnOGRh1EzMKRnuHMV0lfkm8hTgBl04nZSh3rUJkluJ1+BCaKNsl8RR77NT2VlMDy5Lcn6wftI3HDWkx3pToSYbAh9H7CXZZjPoSS7Ec4fWI3OeDO1bCF1sfHmL32OYaRpx8YfW3XN2uLM3k+kQSTgRRkLHkVdkFLeIRMy4py0PyUOruMYli3se79DX0pdImEpwiN3AD8cNu0K7bLV5Fownk6lVetWiuf4tkIO6aOwiMgiiW4rePLyXMIfLKQ4oXnDpwmDp+6c2PGfYQkGyIXDHRuxl5MiRdkouRHJPK+O5Q+t1Vfu6FYe/Y8/e9xzax1pPfOUM95o8j/diC/aciElXm73Bw9tC+EiElKqVenzGFqoN+qG+Y9UjQbudII9lYk3Pk4QBwzkrR9wd3hj1IZhKcHBFfT+IXcGKRAGnYvWkhYsfCNO2DMeIk7TZe/GWqcTIjAkl6sb0aVN6fBmQpal7v8GwheJNNvT4nPavfy1p6uGU5EL4IH9C4it6XFVYcX19huqrb7yxShu6aG/rCF8iZQk93g/hHooDUKMqQkqLcLNI7hXtcnYxen+914IfPN1EJw8IN/YA7qO6wcJwPbAKD0nyFeHksnoDphIcLkxJpglIMuCGE+aWWJmqauAtJCwJvDDVXQHHWGRe3e7OXoSdRTy0SiFGQX5kMhB/m3TO2bbAx6Ox3oBQyYbJE89Jphmpkay3qkTFV/TInGdI5iY6zAau5z89t9Gh/nzy5MljYV8Q2j2Nm9Wcm39+MW64L3daXKiFg3HCOA93bm2e2JtYx10w/PjRdjdbIbLDcfG0YoHprVoNni/Ct9uIxIJdvS+Cl3tkxNlIacxW3BBPevnkHrEruIR1MB+fyPmOYopXUxxLLCTJbQ/sCYzWelOBZMM1i65cqH1fYSXm6Kn/602cLXZrK8njefjkgjMeG004WKWuZV1uy55QzzOSl4rNo6wvF/56rLjFyrUmSSyslNecwsJ5XAS3Ghqb/cQt42U1e9aepxd4UmGRg7t5uYgjlaCwXSQ7epAVzvOU886bL76TTXBnMy00UykDE36qCCnhGu8TpSFaxK1Va1LhnOUiDrdUlmWHOCn5aLcir/sjTNm96nFuklS9f1uWhdbLXR63FIkKQXpl8XJDrlpwWQ/XMVrrTUWwZEMyxOEu/8Z8+xsvbipffOXloQcKs8Q3uqPsiFG4YmKWk2U9uRLXWagjQN6P/nbttv+peGwPrkNKMHBNPLz60SpkUIecOiTkcbDyF115mf3Jx9fQbsdrtPWljbTmkV9S3sSzN8fLevMaIyDPg8Lln8AlT4lXhzxgQqj2SnwnyJQKYqsiWZHS2IsQVLQkjL8bnU7x8nLi0mwP/11YA8oOwCSL0+0W/jljSCsrwVKtKYsEg7hAq4RZvBRSR7KVXPiDZW/vaaaFo/hT7wBI3Th3Vr5d+zNiJbFYbyqCdTZcfcUV8xwvx80YjRmnDxs6E0Wovyh7gO48fIRe316jyGRr+iDjWn8VDpG042667rpSFGrf/+Avhr5e/bzvusKCmZ2fu7Lsx3eXqpny3Xv2logFmnC3dtMfK0vw78xpU2yhjsm0tNu1GoNqR03DP/+lS20lWnitctyUcwb9QlhqHsl0VgwrWu1KgNEiVnA+1HwsMjkFQZaEe2/FM2DyvHBakN7fZYuXlxMXC67DneWg7lS/TZyUUnGBHvSojO5aFHi8OGElyMgIEqwXMbjlfhezZrKQWcAXVbf3vRzsqir++OwLpjQwB0s29PV6uFEjR/gsG2XIyfVLFAviYUF4+FlsSr0qyxNK5vy+u0vpvh+WKvp73/9uyWpYaDjP9isWr7x/+XcPrP2/X/vIDWS997339lAvASRXuWFLyBDA/AsvWIhCYC3QiB+f0pCeQGwcUmOy1ZLjzeaWISbYJTObeoxYl2WIz8GzgmkUKqauIsPN61GYnVs4uxhkBxGNwGMgTICseVtXdn08MrBxITiwMsxYJAisFncBiA2N8mqsxKMYUrQeRKO+BhkZ2S2tYBKrUI4Xr8W/Zsd98LvxRaF15htXLKYbb72Dqp7eQH95Y+t6MgHaZAPKRvDer2+r8Yh/9kHgfAwbNiwo+aL6HkR3xvAzerUjI1DmXGl5emKNQsQq8FnPL/r6JhDbi3+qLLul5EY/MVJ0puiRVI8nwsUKp06ebA987K3duzcnIr7oLe9aL+JoB2TOl7u9yRtksrVN95rvAJnW8d4yLrwuqFACvjfZ7V5BbgtJjOZxLh0MPEZ4eMWyTOutUnsJiv3NDknFVQ9O2zead27RXhRnKiUAItYmzp6dE7lEbO6Y+OtndnZlrbKIHQQFht4v1UFxgKJ2wrsVRuCa4ibI1LSdEskGi9WyEAXDarBYWEGrBalz7Mjaixa7YJbl5FK1CLpdWCuJrATHRbiu6imHsHDscPXyAgqfn3zmOeeHn3zW6603qquaN3Gifc3//pK01g6ss00vb6FVP/6RLdAKUp//w4ZnK/pShb0WwTpq8Jlf3PKXuLqnKuBxiQQg4uIzxdpAOEjxtgLJFd+B2BCruYWvlrlUIGJvIKxj4Sx8SbKKdc5LxbGVMFZg2Ig10K3OLItMuYXqJeVz9PydsSLugpdIFgiWtwviqoSyiPiZ1PgaJ6lKnJz1eCDTchKW1XZn3S6lnARNxxK5XWbW1XibyEuCPeet4jYlzQ1ze5NXsrwbSsV4pbiQPBkruPDKeWgTfzfzHZVpYbioTY85hgIsuJtv+rYdFhCIXv3c+BmL7MFf/29ZXyAGfM7vLLnW9oPbb/HTVoMbt6+pie689eaQr73jv+6p1sbn+hqCZfQT6Z56ScXnHsLV75Q5jIAesThsiHmzijY31+2o1PPeno1pDof6k3f92bXPMwtfLnO2l8l8D7opxNpfZibJxX2qlmxhq8U/K2H+QqdNtkASR4mnrEKtk29OJmfFIqOqEKLaweAxWc2MXfGFIZ8hFkGqRz8iKQt7lYlLKFhRrYh7hMsKmo3vLrtxE8gMwCLDffz70CPltOL+lRW9lVwIBBZW7d53tx9vbfU9hrKejw4f9nNVA7Hm8XXOvY3NCRl4FC0u/ebFPa7LRLmngcBGAiLLEEaJXyzObVkuyI7j2nSTMQhD5iCSE4zk8cIyLFD/LrijiK9aiNcjgys4YG/SWXDi5GAXyvfcVWY01HtUSz1Qho8wVo4htxLxElnyE6l0kpkIP8VJiQuGmvdgBBaSc2SKHomKFaF054ZrFvUI7CLGBZL73VMb+pTVo2YjH/rpfUtfF+7/oisXUDCXVAXc61//du38vj4T9II5/sH1RLqnWni9rW2CyJxinTpEOGeeV3dzFbqJUAMhFnG5iKeVIWlgIYR7OJIE88PJmCkuMLUTy6b6TGpbLd4f2dtlwltZzZns7OLSdoubHE315slvqYi7Bae0YMmkJBygNiBxVqE2SkNyRVh0qzt4VgmOEQ9VQ24JXQzIqmrZPlYgzkGRtMY8GaIDJlhQTooOznB9gGZj6XXXrgxFEMg+ZlrkhNeNRQJIbtH1Ny07duy4M9RnR3LnZ/+z2vnTX/5vnyc3kIrtzHF+XgrcU8z8oASjjbIRDnIS1gm6GcSaVBN97fKASij7KFqPwlCwcFVAg7siNeYrHo3EN8ntVM043tNTMye5+QoRnslR3kviq+NRacAoQcAX2aacvGwX4l0yMZf45Z7MJZMXSW6pHjtGvFwiSDWhGdjAS7CLlUX7eRSZdp1zP72S6BWJ7BSA9bbt5Y3rw1lAN956p+Nvu2uX9UWSgPu06if37rl2sb/QKMjttuV31+/Y0zS/N1w8o7im5Hvlty79znK1ZGmOsJxhnf5z/wFHxS9/Pp96AYoBYiWnu4PsnXJ2tcXSboe1hjgc2rm4xIstFtnRJVttsM6MnGe4pZlwV0WoijEP0cVzOLWFEgCli4HRJgujUivr/EQmySbM3G+RalFxGiBLrK1Tpu3DR48tHjZm3NIhZ4xtdH18yLQLdNjoM0eKf4rEzbsglDig4FxhOAcHjiseNnpM8RdHPnqcDGL4mLGoDi/p8QRj9YzxnZ7fC/uf/bJDHnD9v/b87S+UQJwxYqxL5rw4Ozs7RyvTrsXiKxfYhuUMKX7fecj1xZFDCbcowuFzcW28+6+DjSL7eJ36+ZON3IDiRVf/4ntLvzMyf/o0wm2/86AyVPxrc2bbPvqyJef9+tpXKcEYOnKsnWQaL8htM2T3hdcFwyBPZE4/ERaYi1nYx/veeXunuCYaXB872/S8J2rgho0alydJbL64/hHv3iwswIUyk0YOHzX2XvFecTFsEkJwZ4wZm9O92NmlgtzavAOaG8UDI8WizyaJuTIY3S5+LhUnsUiQ4THxRzvIJODLELcKcTIPQsyqQ2aL3HzALy2s6zrykV4wsJHidYbLJD4/fMg5bPQ4lH6MDHjqcRGD/E98lsEjJj4OYtN7kZgJEMTWv75a8be6vdvfe7+BdXV15k+elNvjuJnTpuYsvuLy4tNGji7Z/9nxzWZuOrEC3+n+w5+yi+fPs7e0tNL9P/9F1fad/7g+WcgNLtnVV11SDmJTAbJGuxxuZ44bU1RT+95e/J2UICiJBabUtRVbpK6RYt2OYmLNqh9ZJPyPdQnva/jocU+fPnrsdXqJafiocQPEdj4UG7uw3J4RoZi9IvnQyDhHzWsV1gvFAQkhOHx4EIs4OS4kGYRrmsM8C71EIRwS8TeuWFfemA93CQL6z3gsps+PHKoXFtkGvDeI5fRRYxh1f4FBMXjE2KpoPot47wEEq5GxZ8SuVWm1yD9uqH37GfX53iC2QOC7qd21o3rvvv1V/3Q686dPnWwL7EfFz3O/dn7O+DGjSr842XFsf8MHO6mP4EBTg+PDL44PfWbjpg3PVa67ty+cU73IGWnLnjU977o5584KusGC7MaOGnnd5JkF9oxBOTly9pBP4r3BYOMbNmossgkwQIoEuWGDRp2bSHxxkSSURkoepRFl48ZGret9xbobNmJcDpP4UfHmGANaItZEg+CDonY32xCvvythMTgtvAMqStSYE7KXwqpTdgKZK+MFHYnahVHz45Ytq8PFy4IVPaYq8kQ44fu33rJy8VULbMFah35X9YcVax8t71PZ1WQG1sLXLywqto07c/k3v2G3QQU6GOB+l/znDyo3/rEyoYodiF0jwaCMdxTXhqwKZigSSQOq9K4Lj5Zc2x5Bkjne0jCHSDAsE3Fxh3cGS1xgGsEhzsYiTkTS/GJ0Mnhr4EQKGsNpejfGwwmmOSzIYLtpJfU/FM+YOiVn5vSpdOrgIfTSq6/Sv/99yMn7sOxTskMs/Hlnjhs7YcbUaZRz6mDlvB9rOU6uYy305lt/p6PHWqvjJf4aEp51gWDxQbFm54k1q7uESWRLFXUeL7mVdr9lZCFb9bUUI/5/X1w9tzbLi+4AAAAASUVORK5CYII=";
const NotFound = () => {
  const { t: t2 } = useTranslation();
  const { goTo } = useTransitionNavigate();
  const goToHome = () => {
    goTo("/");
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex h-screen items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-160 flex h-125 flex-col gap-10", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: img, alt: t2("Not Found") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-center text-lg font-bold", children: t2("Page not found.") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { onClick: goToHome, children: t2("Go to homepage") })
  ] }) });
};
/**
   * table-core
   *
   * Copyright (c) TanStack
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   */
function functionalUpdate(updater, input) {
  return typeof updater === "function" ? updater(input) : updater;
}
function makeStateUpdater(key, instance2) {
  return (updater) => {
    instance2.setState((old) => {
      return {
        ...old,
        [key]: functionalUpdate(updater, old[key])
      };
    });
  };
}
function isFunction(d) {
  return d instanceof Function;
}
function isNumberArray(d) {
  return Array.isArray(d) && d.every((val) => typeof val === "number");
}
function flattenBy(arr, getChildren) {
  const flat = [];
  const recurse = (subArr) => {
    subArr.forEach((item) => {
      flat.push(item);
      const children = getChildren(item);
      if (children != null && children.length) {
        recurse(children);
      }
    });
  };
  recurse(arr);
  return flat;
}
function memo(getDeps, fn, opts) {
  let deps = [];
  let result;
  return (depArgs) => {
    let depTime;
    if (opts.key && opts.debug) depTime = Date.now();
    const newDeps = getDeps(depArgs);
    const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index2) => deps[index2] !== dep);
    if (!depsChanged) {
      return result;
    }
    deps = newDeps;
    let resultTime;
    if (opts.key && opts.debug) resultTime = Date.now();
    result = fn(...newDeps);
    opts == null || opts.onChange == null || opts.onChange(result);
    if (opts.key && opts.debug) {
      if (opts != null && opts.debug()) {
        const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;
        const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;
        const resultFpsPercentage = resultEndTime / 16;
        const pad = (str, num) => {
          str = String(str);
          while (str.length < num) {
            str = " " + str;
          }
          return str;
        };
        console.info(`%c ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`, `
            font-size: .6rem;
            font-weight: bold;
            color: hsl(${Math.max(0, Math.min(120 - 120 * resultFpsPercentage, 120))}deg 100% 31%);`, opts == null ? void 0 : opts.key);
      }
    }
    return result;
  };
}
function getMemoOptions(tableOptions, debugLevel, key, onChange) {
  return {
    debug: () => {
      var _tableOptions$debugAl;
      return (_tableOptions$debugAl = tableOptions == null ? void 0 : tableOptions.debugAll) != null ? _tableOptions$debugAl : tableOptions[debugLevel];
    },
    key: process.env.NODE_ENV === "development" && key,
    onChange
  };
}
function createCell(table, row, column, columnId) {
  const getRenderValue = () => {
    var _cell$getValue;
    return (_cell$getValue = cell.getValue()) != null ? _cell$getValue : table.options.renderFallbackValue;
  };
  const cell = {
    id: `${row.id}_${column.id}`,
    row,
    column,
    getValue: () => row.getValue(columnId),
    renderValue: getRenderValue,
    getContext: memo(() => [table, column, row, cell], (table2, column2, row2, cell2) => ({
      table: table2,
      column: column2,
      row: row2,
      cell: cell2,
      getValue: cell2.getValue,
      renderValue: cell2.renderValue
    }), getMemoOptions(table.options, "debugCells", "cell.getContext"))
  };
  table._features.forEach((feature) => {
    feature.createCell == null || feature.createCell(cell, column, row, table);
  }, {});
  return cell;
}
function createColumn(table, columnDef, depth, parent) {
  var _ref, _resolvedColumnDef$id;
  const defaultColumn = table._getDefaultColumnDef();
  const resolvedColumnDef = {
    ...defaultColumn,
    ...columnDef
  };
  const accessorKey = resolvedColumnDef.accessorKey;
  let id2 = (_ref = (_resolvedColumnDef$id = resolvedColumnDef.id) != null ? _resolvedColumnDef$id : accessorKey ? typeof String.prototype.replaceAll === "function" ? accessorKey.replaceAll(".", "_") : accessorKey.replace(/\./g, "_") : void 0) != null ? _ref : typeof resolvedColumnDef.header === "string" ? resolvedColumnDef.header : void 0;
  let accessorFn;
  if (resolvedColumnDef.accessorFn) {
    accessorFn = resolvedColumnDef.accessorFn;
  } else if (accessorKey) {
    if (accessorKey.includes(".")) {
      accessorFn = (originalRow) => {
        let result = originalRow;
        for (const key of accessorKey.split(".")) {
          var _result;
          result = (_result = result) == null ? void 0 : _result[key];
          if (process.env.NODE_ENV !== "production" && result === void 0) {
            console.warn(`"${key}" in deeply nested key "${accessorKey}" returned undefined.`);
          }
        }
        return result;
      };
    } else {
      accessorFn = (originalRow) => originalRow[resolvedColumnDef.accessorKey];
    }
  }
  if (!id2) {
    if (process.env.NODE_ENV !== "production") {
      throw new Error(resolvedColumnDef.accessorFn ? `Columns require an id when using an accessorFn` : `Columns require an id when using a non-string header`);
    }
    throw new Error();
  }
  let column = {
    id: `${String(id2)}`,
    accessorFn,
    parent,
    depth,
    columnDef: resolvedColumnDef,
    columns: [],
    getFlatColumns: memo(() => [true], () => {
      var _column$columns;
      return [column, ...(_column$columns = column.columns) == null ? void 0 : _column$columns.flatMap((d) => d.getFlatColumns())];
    }, getMemoOptions(table.options, "debugColumns", "column.getFlatColumns")),
    getLeafColumns: memo(() => [table._getOrderColumnsFn()], (orderColumns2) => {
      var _column$columns2;
      if ((_column$columns2 = column.columns) != null && _column$columns2.length) {
        let leafColumns = column.columns.flatMap((column2) => column2.getLeafColumns());
        return orderColumns2(leafColumns);
      }
      return [column];
    }, getMemoOptions(table.options, "debugColumns", "column.getLeafColumns"))
  };
  for (const feature of table._features) {
    feature.createColumn == null || feature.createColumn(column, table);
  }
  return column;
}
const debug = "debugHeaders";
function createHeader(table, column, options) {
  var _options$id;
  const id2 = (_options$id = options.id) != null ? _options$id : column.id;
  let header = {
    id: id2,
    column,
    index: options.index,
    isPlaceholder: !!options.isPlaceholder,
    placeholderId: options.placeholderId,
    depth: options.depth,
    subHeaders: [],
    colSpan: 0,
    rowSpan: 0,
    headerGroup: null,
    getLeafHeaders: () => {
      const leafHeaders = [];
      const recurseHeader = (h) => {
        if (h.subHeaders && h.subHeaders.length) {
          h.subHeaders.map(recurseHeader);
        }
        leafHeaders.push(h);
      };
      recurseHeader(header);
      return leafHeaders;
    },
    getContext: () => ({
      table,
      header,
      column
    })
  };
  table._features.forEach((feature) => {
    feature.createHeader == null || feature.createHeader(header, table);
  });
  return header;
}
const Headers = {
  createTable: (table) => {
    table.getHeaderGroups = memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allColumns, leafColumns, left2, right2) => {
      var _left$map$filter, _right$map$filter;
      const leftColumns = (_left$map$filter = left2 == null ? void 0 : left2.map((columnId) => leafColumns.find((d) => d.id === columnId)).filter(Boolean)) != null ? _left$map$filter : [];
      const rightColumns = (_right$map$filter = right2 == null ? void 0 : right2.map((columnId) => leafColumns.find((d) => d.id === columnId)).filter(Boolean)) != null ? _right$map$filter : [];
      const centerColumns = leafColumns.filter((column) => !(left2 != null && left2.includes(column.id)) && !(right2 != null && right2.includes(column.id)));
      const headerGroups = buildHeaderGroups(allColumns, [...leftColumns, ...centerColumns, ...rightColumns], table);
      return headerGroups;
    }, getMemoOptions(table.options, debug, "getHeaderGroups"));
    table.getCenterHeaderGroups = memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allColumns, leafColumns, left2, right2) => {
      leafColumns = leafColumns.filter((column) => !(left2 != null && left2.includes(column.id)) && !(right2 != null && right2.includes(column.id)));
      return buildHeaderGroups(allColumns, leafColumns, table, "center");
    }, getMemoOptions(table.options, debug, "getCenterHeaderGroups"));
    table.getLeftHeaderGroups = memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.left], (allColumns, leafColumns, left2) => {
      var _left$map$filter2;
      const orderedLeafColumns = (_left$map$filter2 = left2 == null ? void 0 : left2.map((columnId) => leafColumns.find((d) => d.id === columnId)).filter(Boolean)) != null ? _left$map$filter2 : [];
      return buildHeaderGroups(allColumns, orderedLeafColumns, table, "left");
    }, getMemoOptions(table.options, debug, "getLeftHeaderGroups"));
    table.getRightHeaderGroups = memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.right], (allColumns, leafColumns, right2) => {
      var _right$map$filter2;
      const orderedLeafColumns = (_right$map$filter2 = right2 == null ? void 0 : right2.map((columnId) => leafColumns.find((d) => d.id === columnId)).filter(Boolean)) != null ? _right$map$filter2 : [];
      return buildHeaderGroups(allColumns, orderedLeafColumns, table, "right");
    }, getMemoOptions(table.options, debug, "getRightHeaderGroups"));
    table.getFooterGroups = memo(() => [table.getHeaderGroups()], (headerGroups) => {
      return [...headerGroups].reverse();
    }, getMemoOptions(table.options, debug, "getFooterGroups"));
    table.getLeftFooterGroups = memo(() => [table.getLeftHeaderGroups()], (headerGroups) => {
      return [...headerGroups].reverse();
    }, getMemoOptions(table.options, debug, "getLeftFooterGroups"));
    table.getCenterFooterGroups = memo(() => [table.getCenterHeaderGroups()], (headerGroups) => {
      return [...headerGroups].reverse();
    }, getMemoOptions(table.options, debug, "getCenterFooterGroups"));
    table.getRightFooterGroups = memo(() => [table.getRightHeaderGroups()], (headerGroups) => {
      return [...headerGroups].reverse();
    }, getMemoOptions(table.options, debug, "getRightFooterGroups"));
    table.getFlatHeaders = memo(() => [table.getHeaderGroups()], (headerGroups) => {
      return headerGroups.map((headerGroup) => {
        return headerGroup.headers;
      }).flat();
    }, getMemoOptions(table.options, debug, "getFlatHeaders"));
    table.getLeftFlatHeaders = memo(() => [table.getLeftHeaderGroups()], (left2) => {
      return left2.map((headerGroup) => {
        return headerGroup.headers;
      }).flat();
    }, getMemoOptions(table.options, debug, "getLeftFlatHeaders"));
    table.getCenterFlatHeaders = memo(() => [table.getCenterHeaderGroups()], (left2) => {
      return left2.map((headerGroup) => {
        return headerGroup.headers;
      }).flat();
    }, getMemoOptions(table.options, debug, "getCenterFlatHeaders"));
    table.getRightFlatHeaders = memo(() => [table.getRightHeaderGroups()], (left2) => {
      return left2.map((headerGroup) => {
        return headerGroup.headers;
      }).flat();
    }, getMemoOptions(table.options, debug, "getRightFlatHeaders"));
    table.getCenterLeafHeaders = memo(() => [table.getCenterFlatHeaders()], (flatHeaders) => {
      return flatHeaders.filter((header) => {
        var _header$subHeaders;
        return !((_header$subHeaders = header.subHeaders) != null && _header$subHeaders.length);
      });
    }, getMemoOptions(table.options, debug, "getCenterLeafHeaders"));
    table.getLeftLeafHeaders = memo(() => [table.getLeftFlatHeaders()], (flatHeaders) => {
      return flatHeaders.filter((header) => {
        var _header$subHeaders2;
        return !((_header$subHeaders2 = header.subHeaders) != null && _header$subHeaders2.length);
      });
    }, getMemoOptions(table.options, debug, "getLeftLeafHeaders"));
    table.getRightLeafHeaders = memo(() => [table.getRightFlatHeaders()], (flatHeaders) => {
      return flatHeaders.filter((header) => {
        var _header$subHeaders3;
        return !((_header$subHeaders3 = header.subHeaders) != null && _header$subHeaders3.length);
      });
    }, getMemoOptions(table.options, debug, "getRightLeafHeaders"));
    table.getLeafHeaders = memo(() => [table.getLeftHeaderGroups(), table.getCenterHeaderGroups(), table.getRightHeaderGroups()], (left2, center2, right2) => {
      var _left$0$headers, _left$, _center$0$headers, _center$, _right$0$headers, _right$;
      return [...(_left$0$headers = (_left$ = left2[0]) == null ? void 0 : _left$.headers) != null ? _left$0$headers : [], ...(_center$0$headers = (_center$ = center2[0]) == null ? void 0 : _center$.headers) != null ? _center$0$headers : [], ...(_right$0$headers = (_right$ = right2[0]) == null ? void 0 : _right$.headers) != null ? _right$0$headers : []].map((header) => {
        return header.getLeafHeaders();
      }).flat();
    }, getMemoOptions(table.options, debug, "getLeafHeaders"));
  }
};
function buildHeaderGroups(allColumns, columnsToGroup, table, headerFamily) {
  var _headerGroups$0$heade, _headerGroups$;
  let maxDepth = 0;
  const findMaxDepth = function(columns, depth) {
    if (depth === void 0) {
      depth = 1;
    }
    maxDepth = Math.max(maxDepth, depth);
    columns.filter((column) => column.getIsVisible()).forEach((column) => {
      var _column$columns;
      if ((_column$columns = column.columns) != null && _column$columns.length) {
        findMaxDepth(column.columns, depth + 1);
      }
    }, 0);
  };
  findMaxDepth(allColumns);
  let headerGroups = [];
  const createHeaderGroup = (headersToGroup, depth) => {
    const headerGroup = {
      depth,
      id: [headerFamily, `${depth}`].filter(Boolean).join("_"),
      headers: []
    };
    const pendingParentHeaders = [];
    headersToGroup.forEach((headerToGroup) => {
      const latestPendingParentHeader = [...pendingParentHeaders].reverse()[0];
      const isLeafHeader = headerToGroup.column.depth === headerGroup.depth;
      let column;
      let isPlaceholder = false;
      if (isLeafHeader && headerToGroup.column.parent) {
        column = headerToGroup.column.parent;
      } else {
        column = headerToGroup.column;
        isPlaceholder = true;
      }
      if (latestPendingParentHeader && (latestPendingParentHeader == null ? void 0 : latestPendingParentHeader.column) === column) {
        latestPendingParentHeader.subHeaders.push(headerToGroup);
      } else {
        const header = createHeader(table, column, {
          id: [headerFamily, depth, column.id, headerToGroup == null ? void 0 : headerToGroup.id].filter(Boolean).join("_"),
          isPlaceholder,
          placeholderId: isPlaceholder ? `${pendingParentHeaders.filter((d) => d.column === column).length}` : void 0,
          depth,
          index: pendingParentHeaders.length
        });
        header.subHeaders.push(headerToGroup);
        pendingParentHeaders.push(header);
      }
      headerGroup.headers.push(headerToGroup);
      headerToGroup.headerGroup = headerGroup;
    });
    headerGroups.push(headerGroup);
    if (depth > 0) {
      createHeaderGroup(pendingParentHeaders, depth - 1);
    }
  };
  const bottomHeaders = columnsToGroup.map((column, index2) => createHeader(table, column, {
    depth: maxDepth,
    index: index2
  }));
  createHeaderGroup(bottomHeaders, maxDepth - 1);
  headerGroups.reverse();
  const recurseHeadersForSpans = (headers) => {
    const filteredHeaders = headers.filter((header) => header.column.getIsVisible());
    return filteredHeaders.map((header) => {
      let colSpan = 0;
      let rowSpan = 0;
      let childRowSpans = [0];
      if (header.subHeaders && header.subHeaders.length) {
        childRowSpans = [];
        recurseHeadersForSpans(header.subHeaders).forEach((_ref) => {
          let {
            colSpan: childColSpan,
            rowSpan: childRowSpan
          } = _ref;
          colSpan += childColSpan;
          childRowSpans.push(childRowSpan);
        });
      } else {
        colSpan = 1;
      }
      const minChildRowSpan = Math.min(...childRowSpans);
      rowSpan = rowSpan + minChildRowSpan;
      header.colSpan = colSpan;
      header.rowSpan = rowSpan;
      return {
        colSpan,
        rowSpan
      };
    });
  };
  recurseHeadersForSpans((_headerGroups$0$heade = (_headerGroups$ = headerGroups[0]) == null ? void 0 : _headerGroups$.headers) != null ? _headerGroups$0$heade : []);
  return headerGroups;
}
const createRow = (table, id2, original, rowIndex, depth, subRows, parentId) => {
  let row = {
    id: id2,
    index: rowIndex,
    original,
    depth,
    parentId,
    _valuesCache: {},
    _uniqueValuesCache: {},
    getValue: (columnId) => {
      if (row._valuesCache.hasOwnProperty(columnId)) {
        return row._valuesCache[columnId];
      }
      const column = table.getColumn(columnId);
      if (!(column != null && column.accessorFn)) {
        return void 0;
      }
      row._valuesCache[columnId] = column.accessorFn(row.original, rowIndex);
      return row._valuesCache[columnId];
    },
    getUniqueValues: (columnId) => {
      if (row._uniqueValuesCache.hasOwnProperty(columnId)) {
        return row._uniqueValuesCache[columnId];
      }
      const column = table.getColumn(columnId);
      if (!(column != null && column.accessorFn)) {
        return void 0;
      }
      if (!column.columnDef.getUniqueValues) {
        row._uniqueValuesCache[columnId] = [row.getValue(columnId)];
        return row._uniqueValuesCache[columnId];
      }
      row._uniqueValuesCache[columnId] = column.columnDef.getUniqueValues(row.original, rowIndex);
      return row._uniqueValuesCache[columnId];
    },
    renderValue: (columnId) => {
      var _row$getValue;
      return (_row$getValue = row.getValue(columnId)) != null ? _row$getValue : table.options.renderFallbackValue;
    },
    subRows: [],
    getLeafRows: () => flattenBy(row.subRows, (d) => d.subRows),
    getParentRow: () => row.parentId ? table.getRow(row.parentId, true) : void 0,
    getParentRows: () => {
      let parentRows = [];
      let currentRow = row;
      while (true) {
        const parentRow = currentRow.getParentRow();
        if (!parentRow) break;
        parentRows.push(parentRow);
        currentRow = parentRow;
      }
      return parentRows.reverse();
    },
    getAllCells: memo(() => [table.getAllLeafColumns()], (leafColumns) => {
      return leafColumns.map((column) => {
        return createCell(table, row, column, column.id);
      });
    }, getMemoOptions(table.options, "debugRows", "getAllCells")),
    _getAllCellsByColumnId: memo(() => [row.getAllCells()], (allCells) => {
      return allCells.reduce((acc, cell) => {
        acc[cell.column.id] = cell;
        return acc;
      }, {});
    }, getMemoOptions(table.options, "debugRows", "getAllCellsByColumnId"))
  };
  for (let i2 = 0; i2 < table._features.length; i2++) {
    const feature = table._features[i2];
    feature == null || feature.createRow == null || feature.createRow(row, table);
  }
  return row;
};
const ColumnFaceting = {
  createColumn: (column, table) => {
    column._getFacetedRowModel = table.options.getFacetedRowModel && table.options.getFacetedRowModel(table, column.id);
    column.getFacetedRowModel = () => {
      if (!column._getFacetedRowModel) {
        return table.getPreFilteredRowModel();
      }
      return column._getFacetedRowModel();
    };
    column._getFacetedUniqueValues = table.options.getFacetedUniqueValues && table.options.getFacetedUniqueValues(table, column.id);
    column.getFacetedUniqueValues = () => {
      if (!column._getFacetedUniqueValues) {
        return /* @__PURE__ */ new Map();
      }
      return column._getFacetedUniqueValues();
    };
    column._getFacetedMinMaxValues = table.options.getFacetedMinMaxValues && table.options.getFacetedMinMaxValues(table, column.id);
    column.getFacetedMinMaxValues = () => {
      if (!column._getFacetedMinMaxValues) {
        return void 0;
      }
      return column._getFacetedMinMaxValues();
    };
  }
};
const includesString = (row, columnId, filterValue) => {
  var _filterValue$toString, _row$getValue;
  const search = filterValue == null || (_filterValue$toString = filterValue.toString()) == null ? void 0 : _filterValue$toString.toLowerCase();
  return Boolean((_row$getValue = row.getValue(columnId)) == null || (_row$getValue = _row$getValue.toString()) == null || (_row$getValue = _row$getValue.toLowerCase()) == null ? void 0 : _row$getValue.includes(search));
};
includesString.autoRemove = (val) => testFalsey(val);
const includesStringSensitive = (row, columnId, filterValue) => {
  var _row$getValue2;
  return Boolean((_row$getValue2 = row.getValue(columnId)) == null || (_row$getValue2 = _row$getValue2.toString()) == null ? void 0 : _row$getValue2.includes(filterValue));
};
includesStringSensitive.autoRemove = (val) => testFalsey(val);
const equalsString = (row, columnId, filterValue) => {
  var _row$getValue3;
  return ((_row$getValue3 = row.getValue(columnId)) == null || (_row$getValue3 = _row$getValue3.toString()) == null ? void 0 : _row$getValue3.toLowerCase()) === (filterValue == null ? void 0 : filterValue.toLowerCase());
};
equalsString.autoRemove = (val) => testFalsey(val);
const arrIncludes = (row, columnId, filterValue) => {
  var _row$getValue4;
  return (_row$getValue4 = row.getValue(columnId)) == null ? void 0 : _row$getValue4.includes(filterValue);
};
arrIncludes.autoRemove = (val) => testFalsey(val) || !(val != null && val.length);
const arrIncludesAll = (row, columnId, filterValue) => {
  return !filterValue.some((val) => {
    var _row$getValue5;
    return !((_row$getValue5 = row.getValue(columnId)) != null && _row$getValue5.includes(val));
  });
};
arrIncludesAll.autoRemove = (val) => testFalsey(val) || !(val != null && val.length);
const arrIncludesSome = (row, columnId, filterValue) => {
  return filterValue.some((val) => {
    var _row$getValue6;
    return (_row$getValue6 = row.getValue(columnId)) == null ? void 0 : _row$getValue6.includes(val);
  });
};
arrIncludesSome.autoRemove = (val) => testFalsey(val) || !(val != null && val.length);
const equals = (row, columnId, filterValue) => {
  return row.getValue(columnId) === filterValue;
};
equals.autoRemove = (val) => testFalsey(val);
const weakEquals = (row, columnId, filterValue) => {
  return row.getValue(columnId) == filterValue;
};
weakEquals.autoRemove = (val) => testFalsey(val);
const inNumberRange = (row, columnId, filterValue) => {
  let [min2, max2] = filterValue;
  const rowValue = row.getValue(columnId);
  return rowValue >= min2 && rowValue <= max2;
};
inNumberRange.resolveFilterValue = (val) => {
  let [unsafeMin, unsafeMax] = val;
  let parsedMin = typeof unsafeMin !== "number" ? parseFloat(unsafeMin) : unsafeMin;
  let parsedMax = typeof unsafeMax !== "number" ? parseFloat(unsafeMax) : unsafeMax;
  let min2 = unsafeMin === null || Number.isNaN(parsedMin) ? -Infinity : parsedMin;
  let max2 = unsafeMax === null || Number.isNaN(parsedMax) ? Infinity : parsedMax;
  if (min2 > max2) {
    const temp = min2;
    min2 = max2;
    max2 = temp;
  }
  return [min2, max2];
};
inNumberRange.autoRemove = (val) => testFalsey(val) || testFalsey(val[0]) && testFalsey(val[1]);
const filterFns = {
  includesString,
  includesStringSensitive,
  equalsString,
  arrIncludes,
  arrIncludesAll,
  arrIncludesSome,
  equals,
  weakEquals,
  inNumberRange
};
function testFalsey(val) {
  return val === void 0 || val === null || val === "";
}
const ColumnFiltering = {
  getDefaultColumnDef: () => {
    return {
      filterFn: "auto"
    };
  },
  getInitialState: (state) => {
    return {
      columnFilters: [],
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onColumnFiltersChange: makeStateUpdater("columnFilters", table),
      filterFromLeafRows: false,
      maxLeafRowFilterDepth: 100
    };
  },
  createColumn: (column, table) => {
    column.getAutoFilterFn = () => {
      const firstRow = table.getCoreRowModel().flatRows[0];
      const value2 = firstRow == null ? void 0 : firstRow.getValue(column.id);
      if (typeof value2 === "string") {
        return filterFns.includesString;
      }
      if (typeof value2 === "number") {
        return filterFns.inNumberRange;
      }
      if (typeof value2 === "boolean") {
        return filterFns.equals;
      }
      if (value2 !== null && typeof value2 === "object") {
        return filterFns.equals;
      }
      if (Array.isArray(value2)) {
        return filterFns.arrIncludes;
      }
      return filterFns.weakEquals;
    };
    column.getFilterFn = () => {
      var _table$options$filter, _table$options$filter2;
      return isFunction(column.columnDef.filterFn) ? column.columnDef.filterFn : column.columnDef.filterFn === "auto" ? column.getAutoFilterFn() : (
        // @ts-ignore
        (_table$options$filter = (_table$options$filter2 = table.options.filterFns) == null ? void 0 : _table$options$filter2[column.columnDef.filterFn]) != null ? _table$options$filter : filterFns[column.columnDef.filterFn]
      );
    };
    column.getCanFilter = () => {
      var _column$columnDef$ena, _table$options$enable, _table$options$enable2;
      return ((_column$columnDef$ena = column.columnDef.enableColumnFilter) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableColumnFilters) != null ? _table$options$enable : true) && ((_table$options$enable2 = table.options.enableFilters) != null ? _table$options$enable2 : true) && !!column.accessorFn;
    };
    column.getIsFiltered = () => column.getFilterIndex() > -1;
    column.getFilterValue = () => {
      var _table$getState$colum;
      return (_table$getState$colum = table.getState().columnFilters) == null || (_table$getState$colum = _table$getState$colum.find((d) => d.id === column.id)) == null ? void 0 : _table$getState$colum.value;
    };
    column.getFilterIndex = () => {
      var _table$getState$colum2, _table$getState$colum3;
      return (_table$getState$colum2 = (_table$getState$colum3 = table.getState().columnFilters) == null ? void 0 : _table$getState$colum3.findIndex((d) => d.id === column.id)) != null ? _table$getState$colum2 : -1;
    };
    column.setFilterValue = (value2) => {
      table.setColumnFilters((old) => {
        const filterFn = column.getFilterFn();
        const previousFilter = old == null ? void 0 : old.find((d) => d.id === column.id);
        const newFilter = functionalUpdate(value2, previousFilter ? previousFilter.value : void 0);
        if (shouldAutoRemoveFilter(filterFn, newFilter, column)) {
          var _old$filter;
          return (_old$filter = old == null ? void 0 : old.filter((d) => d.id !== column.id)) != null ? _old$filter : [];
        }
        const newFilterObj = {
          id: column.id,
          value: newFilter
        };
        if (previousFilter) {
          var _old$map;
          return (_old$map = old == null ? void 0 : old.map((d) => {
            if (d.id === column.id) {
              return newFilterObj;
            }
            return d;
          })) != null ? _old$map : [];
        }
        if (old != null && old.length) {
          return [...old, newFilterObj];
        }
        return [newFilterObj];
      });
    };
  },
  createRow: (row, _table) => {
    row.columnFilters = {};
    row.columnFiltersMeta = {};
  },
  createTable: (table) => {
    table.setColumnFilters = (updater) => {
      const leafColumns = table.getAllLeafColumns();
      const updateFn = (old) => {
        var _functionalUpdate;
        return (_functionalUpdate = functionalUpdate(updater, old)) == null ? void 0 : _functionalUpdate.filter((filter2) => {
          const column = leafColumns.find((d) => d.id === filter2.id);
          if (column) {
            const filterFn = column.getFilterFn();
            if (shouldAutoRemoveFilter(filterFn, filter2.value, column)) {
              return false;
            }
          }
          return true;
        });
      };
      table.options.onColumnFiltersChange == null || table.options.onColumnFiltersChange(updateFn);
    };
    table.resetColumnFilters = (defaultState) => {
      var _table$initialState$c, _table$initialState;
      table.setColumnFilters(defaultState ? [] : (_table$initialState$c = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.columnFilters) != null ? _table$initialState$c : []);
    };
    table.getPreFilteredRowModel = () => table.getCoreRowModel();
    table.getFilteredRowModel = () => {
      if (!table._getFilteredRowModel && table.options.getFilteredRowModel) {
        table._getFilteredRowModel = table.options.getFilteredRowModel(table);
      }
      if (table.options.manualFiltering || !table._getFilteredRowModel) {
        return table.getPreFilteredRowModel();
      }
      return table._getFilteredRowModel();
    };
  }
};
function shouldAutoRemoveFilter(filterFn, value2, column) {
  return (filterFn && filterFn.autoRemove ? filterFn.autoRemove(value2, column) : false) || typeof value2 === "undefined" || typeof value2 === "string" && !value2;
}
const sum = (columnId, _leafRows, childRows) => {
  return childRows.reduce((sum2, next) => {
    const nextValue = next.getValue(columnId);
    return sum2 + (typeof nextValue === "number" ? nextValue : 0);
  }, 0);
};
const min$2 = (columnId, _leafRows, childRows) => {
  let min2;
  childRows.forEach((row) => {
    const value2 = row.getValue(columnId);
    if (value2 != null && (min2 > value2 || min2 === void 0 && value2 >= value2)) {
      min2 = value2;
    }
  });
  return min2;
};
const max$2 = (columnId, _leafRows, childRows) => {
  let max2;
  childRows.forEach((row) => {
    const value2 = row.getValue(columnId);
    if (value2 != null && (max2 < value2 || max2 === void 0 && value2 >= value2)) {
      max2 = value2;
    }
  });
  return max2;
};
const extent = (columnId, _leafRows, childRows) => {
  let min2;
  let max2;
  childRows.forEach((row) => {
    const value2 = row.getValue(columnId);
    if (value2 != null) {
      if (min2 === void 0) {
        if (value2 >= value2) min2 = max2 = value2;
      } else {
        if (min2 > value2) min2 = value2;
        if (max2 < value2) max2 = value2;
      }
    }
  });
  return [min2, max2];
};
const mean = (columnId, leafRows) => {
  let count2 = 0;
  let sum2 = 0;
  leafRows.forEach((row) => {
    let value2 = row.getValue(columnId);
    if (value2 != null && (value2 = +value2) >= value2) {
      ++count2, sum2 += value2;
    }
  });
  if (count2) return sum2 / count2;
  return;
};
const median = (columnId, leafRows) => {
  if (!leafRows.length) {
    return;
  }
  const values = leafRows.map((row) => row.getValue(columnId));
  if (!isNumberArray(values)) {
    return;
  }
  if (values.length === 1) {
    return values[0];
  }
  const mid = Math.floor(values.length / 2);
  const nums = values.sort((a, b) => a - b);
  return values.length % 2 !== 0 ? nums[mid] : (nums[mid - 1] + nums[mid]) / 2;
};
const unique = (columnId, leafRows) => {
  return Array.from(new Set(leafRows.map((d) => d.getValue(columnId))).values());
};
const uniqueCount = (columnId, leafRows) => {
  return new Set(leafRows.map((d) => d.getValue(columnId))).size;
};
const count$2 = (_columnId, leafRows) => {
  return leafRows.length;
};
const aggregationFns = {
  sum,
  min: min$2,
  max: max$2,
  extent,
  mean,
  median,
  unique,
  uniqueCount,
  count: count$2
};
const ColumnGrouping = {
  getDefaultColumnDef: () => {
    return {
      aggregatedCell: (props) => {
        var _toString, _props$getValue;
        return (_toString = (_props$getValue = props.getValue()) == null || _props$getValue.toString == null ? void 0 : _props$getValue.toString()) != null ? _toString : null;
      },
      aggregationFn: "auto"
    };
  },
  getInitialState: (state) => {
    return {
      grouping: [],
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onGroupingChange: makeStateUpdater("grouping", table),
      groupedColumnMode: "reorder"
    };
  },
  createColumn: (column, table) => {
    column.toggleGrouping = () => {
      table.setGrouping((old) => {
        if (old != null && old.includes(column.id)) {
          return old.filter((d) => d !== column.id);
        }
        return [...old != null ? old : [], column.id];
      });
    };
    column.getCanGroup = () => {
      var _column$columnDef$ena, _table$options$enable;
      return ((_column$columnDef$ena = column.columnDef.enableGrouping) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableGrouping) != null ? _table$options$enable : true) && (!!column.accessorFn || !!column.columnDef.getGroupingValue);
    };
    column.getIsGrouped = () => {
      var _table$getState$group;
      return (_table$getState$group = table.getState().grouping) == null ? void 0 : _table$getState$group.includes(column.id);
    };
    column.getGroupedIndex = () => {
      var _table$getState$group2;
      return (_table$getState$group2 = table.getState().grouping) == null ? void 0 : _table$getState$group2.indexOf(column.id);
    };
    column.getToggleGroupingHandler = () => {
      const canGroup = column.getCanGroup();
      return () => {
        if (!canGroup) return;
        column.toggleGrouping();
      };
    };
    column.getAutoAggregationFn = () => {
      const firstRow = table.getCoreRowModel().flatRows[0];
      const value2 = firstRow == null ? void 0 : firstRow.getValue(column.id);
      if (typeof value2 === "number") {
        return aggregationFns.sum;
      }
      if (Object.prototype.toString.call(value2) === "[object Date]") {
        return aggregationFns.extent;
      }
    };
    column.getAggregationFn = () => {
      var _table$options$aggreg, _table$options$aggreg2;
      if (!column) {
        throw new Error();
      }
      return isFunction(column.columnDef.aggregationFn) ? column.columnDef.aggregationFn : column.columnDef.aggregationFn === "auto" ? column.getAutoAggregationFn() : (_table$options$aggreg = (_table$options$aggreg2 = table.options.aggregationFns) == null ? void 0 : _table$options$aggreg2[column.columnDef.aggregationFn]) != null ? _table$options$aggreg : aggregationFns[column.columnDef.aggregationFn];
    };
  },
  createTable: (table) => {
    table.setGrouping = (updater) => table.options.onGroupingChange == null ? void 0 : table.options.onGroupingChange(updater);
    table.resetGrouping = (defaultState) => {
      var _table$initialState$g, _table$initialState;
      table.setGrouping(defaultState ? [] : (_table$initialState$g = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.grouping) != null ? _table$initialState$g : []);
    };
    table.getPreGroupedRowModel = () => table.getFilteredRowModel();
    table.getGroupedRowModel = () => {
      if (!table._getGroupedRowModel && table.options.getGroupedRowModel) {
        table._getGroupedRowModel = table.options.getGroupedRowModel(table);
      }
      if (table.options.manualGrouping || !table._getGroupedRowModel) {
        return table.getPreGroupedRowModel();
      }
      return table._getGroupedRowModel();
    };
  },
  createRow: (row, table) => {
    row.getIsGrouped = () => !!row.groupingColumnId;
    row.getGroupingValue = (columnId) => {
      if (row._groupingValuesCache.hasOwnProperty(columnId)) {
        return row._groupingValuesCache[columnId];
      }
      const column = table.getColumn(columnId);
      if (!(column != null && column.columnDef.getGroupingValue)) {
        return row.getValue(columnId);
      }
      row._groupingValuesCache[columnId] = column.columnDef.getGroupingValue(row.original);
      return row._groupingValuesCache[columnId];
    };
    row._groupingValuesCache = {};
  },
  createCell: (cell, column, row, table) => {
    cell.getIsGrouped = () => column.getIsGrouped() && column.id === row.groupingColumnId;
    cell.getIsPlaceholder = () => !cell.getIsGrouped() && column.getIsGrouped();
    cell.getIsAggregated = () => {
      var _row$subRows;
      return !cell.getIsGrouped() && !cell.getIsPlaceholder() && !!((_row$subRows = row.subRows) != null && _row$subRows.length);
    };
  }
};
function orderColumns(leafColumns, grouping, groupedColumnMode) {
  if (!(grouping != null && grouping.length) || !groupedColumnMode) {
    return leafColumns;
  }
  const nonGroupingColumns = leafColumns.filter((col) => !grouping.includes(col.id));
  if (groupedColumnMode === "remove") {
    return nonGroupingColumns;
  }
  const groupingColumns = grouping.map((g) => leafColumns.find((col) => col.id === g)).filter(Boolean);
  return [...groupingColumns, ...nonGroupingColumns];
}
const ColumnOrdering = {
  getInitialState: (state) => {
    return {
      columnOrder: [],
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onColumnOrderChange: makeStateUpdater("columnOrder", table)
    };
  },
  createColumn: (column, table) => {
    column.getIndex = memo((position2) => [_getVisibleLeafColumns(table, position2)], (columns) => columns.findIndex((d) => d.id === column.id), getMemoOptions(table.options, "debugColumns", "getIndex"));
    column.getIsFirstColumn = (position2) => {
      var _columns$;
      const columns = _getVisibleLeafColumns(table, position2);
      return ((_columns$ = columns[0]) == null ? void 0 : _columns$.id) === column.id;
    };
    column.getIsLastColumn = (position2) => {
      var _columns;
      const columns = _getVisibleLeafColumns(table, position2);
      return ((_columns = columns[columns.length - 1]) == null ? void 0 : _columns.id) === column.id;
    };
  },
  createTable: (table) => {
    table.setColumnOrder = (updater) => table.options.onColumnOrderChange == null ? void 0 : table.options.onColumnOrderChange(updater);
    table.resetColumnOrder = (defaultState) => {
      var _table$initialState$c;
      table.setColumnOrder(defaultState ? [] : (_table$initialState$c = table.initialState.columnOrder) != null ? _table$initialState$c : []);
    };
    table._getOrderColumnsFn = memo(() => [table.getState().columnOrder, table.getState().grouping, table.options.groupedColumnMode], (columnOrder, grouping, groupedColumnMode) => (columns) => {
      let orderedColumns = [];
      if (!(columnOrder != null && columnOrder.length)) {
        orderedColumns = columns;
      } else {
        const columnOrderCopy = [...columnOrder];
        const columnsCopy = [...columns];
        while (columnsCopy.length && columnOrderCopy.length) {
          const targetColumnId = columnOrderCopy.shift();
          const foundIndex = columnsCopy.findIndex((d) => d.id === targetColumnId);
          if (foundIndex > -1) {
            orderedColumns.push(columnsCopy.splice(foundIndex, 1)[0]);
          }
        }
        orderedColumns = [...orderedColumns, ...columnsCopy];
      }
      return orderColumns(orderedColumns, grouping, groupedColumnMode);
    }, getMemoOptions(table.options, "debugTable", "_getOrderColumnsFn"));
  }
};
const getDefaultColumnPinningState = () => ({
  left: [],
  right: []
});
const ColumnPinning = {
  getInitialState: (state) => {
    return {
      columnPinning: getDefaultColumnPinningState(),
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onColumnPinningChange: makeStateUpdater("columnPinning", table)
    };
  },
  createColumn: (column, table) => {
    column.pin = (position2) => {
      const columnIds = column.getLeafColumns().map((d) => d.id).filter(Boolean);
      table.setColumnPinning((old) => {
        var _old$left3, _old$right3;
        if (position2 === "right") {
          var _old$left, _old$right;
          return {
            left: ((_old$left = old == null ? void 0 : old.left) != null ? _old$left : []).filter((d) => !(columnIds != null && columnIds.includes(d))),
            right: [...((_old$right = old == null ? void 0 : old.right) != null ? _old$right : []).filter((d) => !(columnIds != null && columnIds.includes(d))), ...columnIds]
          };
        }
        if (position2 === "left") {
          var _old$left2, _old$right2;
          return {
            left: [...((_old$left2 = old == null ? void 0 : old.left) != null ? _old$left2 : []).filter((d) => !(columnIds != null && columnIds.includes(d))), ...columnIds],
            right: ((_old$right2 = old == null ? void 0 : old.right) != null ? _old$right2 : []).filter((d) => !(columnIds != null && columnIds.includes(d)))
          };
        }
        return {
          left: ((_old$left3 = old == null ? void 0 : old.left) != null ? _old$left3 : []).filter((d) => !(columnIds != null && columnIds.includes(d))),
          right: ((_old$right3 = old == null ? void 0 : old.right) != null ? _old$right3 : []).filter((d) => !(columnIds != null && columnIds.includes(d)))
        };
      });
    };
    column.getCanPin = () => {
      const leafColumns = column.getLeafColumns();
      return leafColumns.some((d) => {
        var _d$columnDef$enablePi, _ref, _table$options$enable;
        return ((_d$columnDef$enablePi = d.columnDef.enablePinning) != null ? _d$columnDef$enablePi : true) && ((_ref = (_table$options$enable = table.options.enableColumnPinning) != null ? _table$options$enable : table.options.enablePinning) != null ? _ref : true);
      });
    };
    column.getIsPinned = () => {
      const leafColumnIds = column.getLeafColumns().map((d) => d.id);
      const {
        left: left2,
        right: right2
      } = table.getState().columnPinning;
      const isLeft = leafColumnIds.some((d) => left2 == null ? void 0 : left2.includes(d));
      const isRight = leafColumnIds.some((d) => right2 == null ? void 0 : right2.includes(d));
      return isLeft ? "left" : isRight ? "right" : false;
    };
    column.getPinnedIndex = () => {
      var _table$getState$colum, _table$getState$colum2;
      const position2 = column.getIsPinned();
      return position2 ? (_table$getState$colum = (_table$getState$colum2 = table.getState().columnPinning) == null || (_table$getState$colum2 = _table$getState$colum2[position2]) == null ? void 0 : _table$getState$colum2.indexOf(column.id)) != null ? _table$getState$colum : -1 : 0;
    };
  },
  createRow: (row, table) => {
    row.getCenterVisibleCells = memo(() => [row._getAllVisibleCells(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allCells, left2, right2) => {
      const leftAndRight = [...left2 != null ? left2 : [], ...right2 != null ? right2 : []];
      return allCells.filter((d) => !leftAndRight.includes(d.column.id));
    }, getMemoOptions(table.options, "debugRows", "getCenterVisibleCells"));
    row.getLeftVisibleCells = memo(() => [row._getAllVisibleCells(), table.getState().columnPinning.left], (allCells, left2) => {
      const cells = (left2 != null ? left2 : []).map((columnId) => allCells.find((cell) => cell.column.id === columnId)).filter(Boolean).map((d) => ({
        ...d,
        position: "left"
      }));
      return cells;
    }, getMemoOptions(table.options, "debugRows", "getLeftVisibleCells"));
    row.getRightVisibleCells = memo(() => [row._getAllVisibleCells(), table.getState().columnPinning.right], (allCells, right2) => {
      const cells = (right2 != null ? right2 : []).map((columnId) => allCells.find((cell) => cell.column.id === columnId)).filter(Boolean).map((d) => ({
        ...d,
        position: "right"
      }));
      return cells;
    }, getMemoOptions(table.options, "debugRows", "getRightVisibleCells"));
  },
  createTable: (table) => {
    table.setColumnPinning = (updater) => table.options.onColumnPinningChange == null ? void 0 : table.options.onColumnPinningChange(updater);
    table.resetColumnPinning = (defaultState) => {
      var _table$initialState$c, _table$initialState;
      return table.setColumnPinning(defaultState ? getDefaultColumnPinningState() : (_table$initialState$c = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.columnPinning) != null ? _table$initialState$c : getDefaultColumnPinningState());
    };
    table.getIsSomeColumnsPinned = (position2) => {
      var _pinningState$positio;
      const pinningState = table.getState().columnPinning;
      if (!position2) {
        var _pinningState$left, _pinningState$right;
        return Boolean(((_pinningState$left = pinningState.left) == null ? void 0 : _pinningState$left.length) || ((_pinningState$right = pinningState.right) == null ? void 0 : _pinningState$right.length));
      }
      return Boolean((_pinningState$positio = pinningState[position2]) == null ? void 0 : _pinningState$positio.length);
    };
    table.getLeftLeafColumns = memo(() => [table.getAllLeafColumns(), table.getState().columnPinning.left], (allColumns, left2) => {
      return (left2 != null ? left2 : []).map((columnId) => allColumns.find((column) => column.id === columnId)).filter(Boolean);
    }, getMemoOptions(table.options, "debugColumns", "getLeftLeafColumns"));
    table.getRightLeafColumns = memo(() => [table.getAllLeafColumns(), table.getState().columnPinning.right], (allColumns, right2) => {
      return (right2 != null ? right2 : []).map((columnId) => allColumns.find((column) => column.id === columnId)).filter(Boolean);
    }, getMemoOptions(table.options, "debugColumns", "getRightLeafColumns"));
    table.getCenterLeafColumns = memo(() => [table.getAllLeafColumns(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allColumns, left2, right2) => {
      const leftAndRight = [...left2 != null ? left2 : [], ...right2 != null ? right2 : []];
      return allColumns.filter((d) => !leftAndRight.includes(d.id));
    }, getMemoOptions(table.options, "debugColumns", "getCenterLeafColumns"));
  }
};
const defaultColumnSizing = {
  size: 150,
  minSize: 20,
  maxSize: Number.MAX_SAFE_INTEGER
};
const getDefaultColumnSizingInfoState = () => ({
  startOffset: null,
  startSize: null,
  deltaOffset: null,
  deltaPercentage: null,
  isResizingColumn: false,
  columnSizingStart: []
});
const ColumnSizing = {
  getDefaultColumnDef: () => {
    return defaultColumnSizing;
  },
  getInitialState: (state) => {
    return {
      columnSizing: {},
      columnSizingInfo: getDefaultColumnSizingInfoState(),
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      columnResizeMode: "onEnd",
      columnResizeDirection: "ltr",
      onColumnSizingChange: makeStateUpdater("columnSizing", table),
      onColumnSizingInfoChange: makeStateUpdater("columnSizingInfo", table)
    };
  },
  createColumn: (column, table) => {
    column.getSize = () => {
      var _column$columnDef$min, _ref, _column$columnDef$max;
      const columnSize = table.getState().columnSizing[column.id];
      return Math.min(Math.max((_column$columnDef$min = column.columnDef.minSize) != null ? _column$columnDef$min : defaultColumnSizing.minSize, (_ref = columnSize != null ? columnSize : column.columnDef.size) != null ? _ref : defaultColumnSizing.size), (_column$columnDef$max = column.columnDef.maxSize) != null ? _column$columnDef$max : defaultColumnSizing.maxSize);
    };
    column.getStart = memo((position2) => [position2, _getVisibleLeafColumns(table, position2), table.getState().columnSizing], (position2, columns) => columns.slice(0, column.getIndex(position2)).reduce((sum2, column2) => sum2 + column2.getSize(), 0), getMemoOptions(table.options, "debugColumns", "getStart"));
    column.getAfter = memo((position2) => [position2, _getVisibleLeafColumns(table, position2), table.getState().columnSizing], (position2, columns) => columns.slice(column.getIndex(position2) + 1).reduce((sum2, column2) => sum2 + column2.getSize(), 0), getMemoOptions(table.options, "debugColumns", "getAfter"));
    column.resetSize = () => {
      table.setColumnSizing((_ref2) => {
        let {
          [column.id]: _,
          ...rest
        } = _ref2;
        return rest;
      });
    };
    column.getCanResize = () => {
      var _column$columnDef$ena, _table$options$enable;
      return ((_column$columnDef$ena = column.columnDef.enableResizing) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableColumnResizing) != null ? _table$options$enable : true);
    };
    column.getIsResizing = () => {
      return table.getState().columnSizingInfo.isResizingColumn === column.id;
    };
  },
  createHeader: (header, table) => {
    header.getSize = () => {
      let sum2 = 0;
      const recurse = (header2) => {
        if (header2.subHeaders.length) {
          header2.subHeaders.forEach(recurse);
        } else {
          var _header$column$getSiz;
          sum2 += (_header$column$getSiz = header2.column.getSize()) != null ? _header$column$getSiz : 0;
        }
      };
      recurse(header);
      return sum2;
    };
    header.getStart = () => {
      if (header.index > 0) {
        const prevSiblingHeader = header.headerGroup.headers[header.index - 1];
        return prevSiblingHeader.getStart() + prevSiblingHeader.getSize();
      }
      return 0;
    };
    header.getResizeHandler = (_contextDocument) => {
      const column = table.getColumn(header.column.id);
      const canResize = column == null ? void 0 : column.getCanResize();
      return (e) => {
        if (!column || !canResize) {
          return;
        }
        e.persist == null || e.persist();
        if (isTouchStartEvent(e)) {
          if (e.touches && e.touches.length > 1) {
            return;
          }
        }
        const startSize = header.getSize();
        const columnSizingStart = header ? header.getLeafHeaders().map((d) => [d.column.id, d.column.getSize()]) : [[column.id, column.getSize()]];
        const clientX = isTouchStartEvent(e) ? Math.round(e.touches[0].clientX) : e.clientX;
        const newColumnSizing = {};
        const updateOffset = (eventType, clientXPos) => {
          if (typeof clientXPos !== "number") {
            return;
          }
          table.setColumnSizingInfo((old) => {
            var _old$startOffset, _old$startSize;
            const deltaDirection = table.options.columnResizeDirection === "rtl" ? -1 : 1;
            const deltaOffset = (clientXPos - ((_old$startOffset = old == null ? void 0 : old.startOffset) != null ? _old$startOffset : 0)) * deltaDirection;
            const deltaPercentage = Math.max(deltaOffset / ((_old$startSize = old == null ? void 0 : old.startSize) != null ? _old$startSize : 0), -0.999999);
            old.columnSizingStart.forEach((_ref3) => {
              let [columnId, headerSize] = _ref3;
              newColumnSizing[columnId] = Math.round(Math.max(headerSize + headerSize * deltaPercentage, 0) * 100) / 100;
            });
            return {
              ...old,
              deltaOffset,
              deltaPercentage
            };
          });
          if (table.options.columnResizeMode === "onChange" || eventType === "end") {
            table.setColumnSizing((old) => ({
              ...old,
              ...newColumnSizing
            }));
          }
        };
        const onMove = (clientXPos) => updateOffset("move", clientXPos);
        const onEnd = (clientXPos) => {
          updateOffset("end", clientXPos);
          table.setColumnSizingInfo((old) => ({
            ...old,
            isResizingColumn: false,
            startOffset: null,
            startSize: null,
            deltaOffset: null,
            deltaPercentage: null,
            columnSizingStart: []
          }));
        };
        const contextDocument = _contextDocument || typeof document !== "undefined" ? document : null;
        const mouseEvents = {
          moveHandler: (e2) => onMove(e2.clientX),
          upHandler: (e2) => {
            contextDocument == null || contextDocument.removeEventListener("mousemove", mouseEvents.moveHandler);
            contextDocument == null || contextDocument.removeEventListener("mouseup", mouseEvents.upHandler);
            onEnd(e2.clientX);
          }
        };
        const touchEvents = {
          moveHandler: (e2) => {
            if (e2.cancelable) {
              e2.preventDefault();
              e2.stopPropagation();
            }
            onMove(e2.touches[0].clientX);
            return false;
          },
          upHandler: (e2) => {
            var _e$touches$;
            contextDocument == null || contextDocument.removeEventListener("touchmove", touchEvents.moveHandler);
            contextDocument == null || contextDocument.removeEventListener("touchend", touchEvents.upHandler);
            if (e2.cancelable) {
              e2.preventDefault();
              e2.stopPropagation();
            }
            onEnd((_e$touches$ = e2.touches[0]) == null ? void 0 : _e$touches$.clientX);
          }
        };
        const passiveIfSupported = passiveEventSupported() ? {
          passive: false
        } : false;
        if (isTouchStartEvent(e)) {
          contextDocument == null || contextDocument.addEventListener("touchmove", touchEvents.moveHandler, passiveIfSupported);
          contextDocument == null || contextDocument.addEventListener("touchend", touchEvents.upHandler, passiveIfSupported);
        } else {
          contextDocument == null || contextDocument.addEventListener("mousemove", mouseEvents.moveHandler, passiveIfSupported);
          contextDocument == null || contextDocument.addEventListener("mouseup", mouseEvents.upHandler, passiveIfSupported);
        }
        table.setColumnSizingInfo((old) => ({
          ...old,
          startOffset: clientX,
          startSize,
          deltaOffset: 0,
          deltaPercentage: 0,
          columnSizingStart,
          isResizingColumn: column.id
        }));
      };
    };
  },
  createTable: (table) => {
    table.setColumnSizing = (updater) => table.options.onColumnSizingChange == null ? void 0 : table.options.onColumnSizingChange(updater);
    table.setColumnSizingInfo = (updater) => table.options.onColumnSizingInfoChange == null ? void 0 : table.options.onColumnSizingInfoChange(updater);
    table.resetColumnSizing = (defaultState) => {
      var _table$initialState$c;
      table.setColumnSizing(defaultState ? {} : (_table$initialState$c = table.initialState.columnSizing) != null ? _table$initialState$c : {});
    };
    table.resetHeaderSizeInfo = (defaultState) => {
      var _table$initialState$c2;
      table.setColumnSizingInfo(defaultState ? getDefaultColumnSizingInfoState() : (_table$initialState$c2 = table.initialState.columnSizingInfo) != null ? _table$initialState$c2 : getDefaultColumnSizingInfoState());
    };
    table.getTotalSize = () => {
      var _table$getHeaderGroup, _table$getHeaderGroup2;
      return (_table$getHeaderGroup = (_table$getHeaderGroup2 = table.getHeaderGroups()[0]) == null ? void 0 : _table$getHeaderGroup2.headers.reduce((sum2, header) => {
        return sum2 + header.getSize();
      }, 0)) != null ? _table$getHeaderGroup : 0;
    };
    table.getLeftTotalSize = () => {
      var _table$getLeftHeaderG, _table$getLeftHeaderG2;
      return (_table$getLeftHeaderG = (_table$getLeftHeaderG2 = table.getLeftHeaderGroups()[0]) == null ? void 0 : _table$getLeftHeaderG2.headers.reduce((sum2, header) => {
        return sum2 + header.getSize();
      }, 0)) != null ? _table$getLeftHeaderG : 0;
    };
    table.getCenterTotalSize = () => {
      var _table$getCenterHeade, _table$getCenterHeade2;
      return (_table$getCenterHeade = (_table$getCenterHeade2 = table.getCenterHeaderGroups()[0]) == null ? void 0 : _table$getCenterHeade2.headers.reduce((sum2, header) => {
        return sum2 + header.getSize();
      }, 0)) != null ? _table$getCenterHeade : 0;
    };
    table.getRightTotalSize = () => {
      var _table$getRightHeader, _table$getRightHeader2;
      return (_table$getRightHeader = (_table$getRightHeader2 = table.getRightHeaderGroups()[0]) == null ? void 0 : _table$getRightHeader2.headers.reduce((sum2, header) => {
        return sum2 + header.getSize();
      }, 0)) != null ? _table$getRightHeader : 0;
    };
  }
};
let passiveSupported = null;
function passiveEventSupported() {
  if (typeof passiveSupported === "boolean") return passiveSupported;
  let supported = false;
  try {
    const options = {
      get passive() {
        supported = true;
        return false;
      }
    };
    const noop2 = () => {
    };
    window.addEventListener("test", noop2, options);
    window.removeEventListener("test", noop2);
  } catch (err) {
    supported = false;
  }
  passiveSupported = supported;
  return passiveSupported;
}
function isTouchStartEvent(e) {
  return e.type === "touchstart";
}
const ColumnVisibility = {
  getInitialState: (state) => {
    return {
      columnVisibility: {},
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onColumnVisibilityChange: makeStateUpdater("columnVisibility", table)
    };
  },
  createColumn: (column, table) => {
    column.toggleVisibility = (value2) => {
      if (column.getCanHide()) {
        table.setColumnVisibility((old) => ({
          ...old,
          [column.id]: value2 != null ? value2 : !column.getIsVisible()
        }));
      }
    };
    column.getIsVisible = () => {
      var _ref, _table$getState$colum;
      const childColumns = column.columns;
      return (_ref = childColumns.length ? childColumns.some((c) => c.getIsVisible()) : (_table$getState$colum = table.getState().columnVisibility) == null ? void 0 : _table$getState$colum[column.id]) != null ? _ref : true;
    };
    column.getCanHide = () => {
      var _column$columnDef$ena, _table$options$enable;
      return ((_column$columnDef$ena = column.columnDef.enableHiding) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableHiding) != null ? _table$options$enable : true);
    };
    column.getToggleVisibilityHandler = () => {
      return (e) => {
        column.toggleVisibility == null || column.toggleVisibility(e.target.checked);
      };
    };
  },
  createRow: (row, table) => {
    row._getAllVisibleCells = memo(() => [row.getAllCells(), table.getState().columnVisibility], (cells) => {
      return cells.filter((cell) => cell.column.getIsVisible());
    }, getMemoOptions(table.options, "debugRows", "_getAllVisibleCells"));
    row.getVisibleCells = memo(() => [row.getLeftVisibleCells(), row.getCenterVisibleCells(), row.getRightVisibleCells()], (left2, center2, right2) => [...left2, ...center2, ...right2], getMemoOptions(table.options, "debugRows", "getVisibleCells"));
  },
  createTable: (table) => {
    const makeVisibleColumnsMethod = (key, getColumns) => {
      return memo(() => [getColumns(), getColumns().filter((d) => d.getIsVisible()).map((d) => d.id).join("_")], (columns) => {
        return columns.filter((d) => d.getIsVisible == null ? void 0 : d.getIsVisible());
      }, getMemoOptions(table.options, "debugColumns", key));
    };
    table.getVisibleFlatColumns = makeVisibleColumnsMethod("getVisibleFlatColumns", () => table.getAllFlatColumns());
    table.getVisibleLeafColumns = makeVisibleColumnsMethod("getVisibleLeafColumns", () => table.getAllLeafColumns());
    table.getLeftVisibleLeafColumns = makeVisibleColumnsMethod("getLeftVisibleLeafColumns", () => table.getLeftLeafColumns());
    table.getRightVisibleLeafColumns = makeVisibleColumnsMethod("getRightVisibleLeafColumns", () => table.getRightLeafColumns());
    table.getCenterVisibleLeafColumns = makeVisibleColumnsMethod("getCenterVisibleLeafColumns", () => table.getCenterLeafColumns());
    table.setColumnVisibility = (updater) => table.options.onColumnVisibilityChange == null ? void 0 : table.options.onColumnVisibilityChange(updater);
    table.resetColumnVisibility = (defaultState) => {
      var _table$initialState$c;
      table.setColumnVisibility(defaultState ? {} : (_table$initialState$c = table.initialState.columnVisibility) != null ? _table$initialState$c : {});
    };
    table.toggleAllColumnsVisible = (value2) => {
      var _value;
      value2 = (_value = value2) != null ? _value : !table.getIsAllColumnsVisible();
      table.setColumnVisibility(table.getAllLeafColumns().reduce((obj, column) => ({
        ...obj,
        [column.id]: !value2 ? !(column.getCanHide != null && column.getCanHide()) : value2
      }), {}));
    };
    table.getIsAllColumnsVisible = () => !table.getAllLeafColumns().some((column) => !(column.getIsVisible != null && column.getIsVisible()));
    table.getIsSomeColumnsVisible = () => table.getAllLeafColumns().some((column) => column.getIsVisible == null ? void 0 : column.getIsVisible());
    table.getToggleAllColumnsVisibilityHandler = () => {
      return (e) => {
        var _target;
        table.toggleAllColumnsVisible((_target = e.target) == null ? void 0 : _target.checked);
      };
    };
  }
};
function _getVisibleLeafColumns(table, position2) {
  return !position2 ? table.getVisibleLeafColumns() : position2 === "center" ? table.getCenterVisibleLeafColumns() : position2 === "left" ? table.getLeftVisibleLeafColumns() : table.getRightVisibleLeafColumns();
}
const GlobalFaceting = {
  createTable: (table) => {
    table._getGlobalFacetedRowModel = table.options.getFacetedRowModel && table.options.getFacetedRowModel(table, "__global__");
    table.getGlobalFacetedRowModel = () => {
      if (table.options.manualFiltering || !table._getGlobalFacetedRowModel) {
        return table.getPreFilteredRowModel();
      }
      return table._getGlobalFacetedRowModel();
    };
    table._getGlobalFacetedUniqueValues = table.options.getFacetedUniqueValues && table.options.getFacetedUniqueValues(table, "__global__");
    table.getGlobalFacetedUniqueValues = () => {
      if (!table._getGlobalFacetedUniqueValues) {
        return /* @__PURE__ */ new Map();
      }
      return table._getGlobalFacetedUniqueValues();
    };
    table._getGlobalFacetedMinMaxValues = table.options.getFacetedMinMaxValues && table.options.getFacetedMinMaxValues(table, "__global__");
    table.getGlobalFacetedMinMaxValues = () => {
      if (!table._getGlobalFacetedMinMaxValues) {
        return;
      }
      return table._getGlobalFacetedMinMaxValues();
    };
  }
};
const GlobalFiltering = {
  getInitialState: (state) => {
    return {
      globalFilter: void 0,
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onGlobalFilterChange: makeStateUpdater("globalFilter", table),
      globalFilterFn: "auto",
      getColumnCanGlobalFilter: (column) => {
        var _table$getCoreRowMode;
        const value2 = (_table$getCoreRowMode = table.getCoreRowModel().flatRows[0]) == null || (_table$getCoreRowMode = _table$getCoreRowMode._getAllCellsByColumnId()[column.id]) == null ? void 0 : _table$getCoreRowMode.getValue();
        return typeof value2 === "string" || typeof value2 === "number";
      }
    };
  },
  createColumn: (column, table) => {
    column.getCanGlobalFilter = () => {
      var _column$columnDef$ena, _table$options$enable, _table$options$enable2, _table$options$getCol;
      return ((_column$columnDef$ena = column.columnDef.enableGlobalFilter) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableGlobalFilter) != null ? _table$options$enable : true) && ((_table$options$enable2 = table.options.enableFilters) != null ? _table$options$enable2 : true) && ((_table$options$getCol = table.options.getColumnCanGlobalFilter == null ? void 0 : table.options.getColumnCanGlobalFilter(column)) != null ? _table$options$getCol : true) && !!column.accessorFn;
    };
  },
  createTable: (table) => {
    table.getGlobalAutoFilterFn = () => {
      return filterFns.includesString;
    };
    table.getGlobalFilterFn = () => {
      var _table$options$filter, _table$options$filter2;
      const {
        globalFilterFn
      } = table.options;
      return isFunction(globalFilterFn) ? globalFilterFn : globalFilterFn === "auto" ? table.getGlobalAutoFilterFn() : (_table$options$filter = (_table$options$filter2 = table.options.filterFns) == null ? void 0 : _table$options$filter2[globalFilterFn]) != null ? _table$options$filter : filterFns[globalFilterFn];
    };
    table.setGlobalFilter = (updater) => {
      table.options.onGlobalFilterChange == null || table.options.onGlobalFilterChange(updater);
    };
    table.resetGlobalFilter = (defaultState) => {
      table.setGlobalFilter(defaultState ? void 0 : table.initialState.globalFilter);
    };
  }
};
const RowExpanding = {
  getInitialState: (state) => {
    return {
      expanded: {},
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onExpandedChange: makeStateUpdater("expanded", table),
      paginateExpandedRows: true
    };
  },
  createTable: (table) => {
    let registered = false;
    let queued = false;
    table._autoResetExpanded = () => {
      var _ref, _table$options$autoRe;
      if (!registered) {
        table._queue(() => {
          registered = true;
        });
        return;
      }
      if ((_ref = (_table$options$autoRe = table.options.autoResetAll) != null ? _table$options$autoRe : table.options.autoResetExpanded) != null ? _ref : !table.options.manualExpanding) {
        if (queued) return;
        queued = true;
        table._queue(() => {
          table.resetExpanded();
          queued = false;
        });
      }
    };
    table.setExpanded = (updater) => table.options.onExpandedChange == null ? void 0 : table.options.onExpandedChange(updater);
    table.toggleAllRowsExpanded = (expanded) => {
      if (expanded != null ? expanded : !table.getIsAllRowsExpanded()) {
        table.setExpanded(true);
      } else {
        table.setExpanded({});
      }
    };
    table.resetExpanded = (defaultState) => {
      var _table$initialState$e, _table$initialState;
      table.setExpanded(defaultState ? {} : (_table$initialState$e = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.expanded) != null ? _table$initialState$e : {});
    };
    table.getCanSomeRowsExpand = () => {
      return table.getPrePaginationRowModel().flatRows.some((row) => row.getCanExpand());
    };
    table.getToggleAllRowsExpandedHandler = () => {
      return (e) => {
        e.persist == null || e.persist();
        table.toggleAllRowsExpanded();
      };
    };
    table.getIsSomeRowsExpanded = () => {
      const expanded = table.getState().expanded;
      return expanded === true || Object.values(expanded).some(Boolean);
    };
    table.getIsAllRowsExpanded = () => {
      const expanded = table.getState().expanded;
      if (typeof expanded === "boolean") {
        return expanded === true;
      }
      if (!Object.keys(expanded).length) {
        return false;
      }
      if (table.getRowModel().flatRows.some((row) => !row.getIsExpanded())) {
        return false;
      }
      return true;
    };
    table.getExpandedDepth = () => {
      let maxDepth = 0;
      const rowIds = table.getState().expanded === true ? Object.keys(table.getRowModel().rowsById) : Object.keys(table.getState().expanded);
      rowIds.forEach((id2) => {
        const splitId = id2.split(".");
        maxDepth = Math.max(maxDepth, splitId.length);
      });
      return maxDepth;
    };
    table.getPreExpandedRowModel = () => table.getSortedRowModel();
    table.getExpandedRowModel = () => {
      if (!table._getExpandedRowModel && table.options.getExpandedRowModel) {
        table._getExpandedRowModel = table.options.getExpandedRowModel(table);
      }
      if (table.options.manualExpanding || !table._getExpandedRowModel) {
        return table.getPreExpandedRowModel();
      }
      return table._getExpandedRowModel();
    };
  },
  createRow: (row, table) => {
    row.toggleExpanded = (expanded) => {
      table.setExpanded((old) => {
        var _expanded;
        const exists = old === true ? true : !!(old != null && old[row.id]);
        let oldExpanded = {};
        if (old === true) {
          Object.keys(table.getRowModel().rowsById).forEach((rowId) => {
            oldExpanded[rowId] = true;
          });
        } else {
          oldExpanded = old;
        }
        expanded = (_expanded = expanded) != null ? _expanded : !exists;
        if (!exists && expanded) {
          return {
            ...oldExpanded,
            [row.id]: true
          };
        }
        if (exists && !expanded) {
          const {
            [row.id]: _,
            ...rest
          } = oldExpanded;
          return rest;
        }
        return old;
      });
    };
    row.getIsExpanded = () => {
      var _table$options$getIsR;
      const expanded = table.getState().expanded;
      return !!((_table$options$getIsR = table.options.getIsRowExpanded == null ? void 0 : table.options.getIsRowExpanded(row)) != null ? _table$options$getIsR : expanded === true || (expanded == null ? void 0 : expanded[row.id]));
    };
    row.getCanExpand = () => {
      var _table$options$getRow, _table$options$enable, _row$subRows;
      return (_table$options$getRow = table.options.getRowCanExpand == null ? void 0 : table.options.getRowCanExpand(row)) != null ? _table$options$getRow : ((_table$options$enable = table.options.enableExpanding) != null ? _table$options$enable : true) && !!((_row$subRows = row.subRows) != null && _row$subRows.length);
    };
    row.getIsAllParentsExpanded = () => {
      let isFullyExpanded = true;
      let currentRow = row;
      while (isFullyExpanded && currentRow.parentId) {
        currentRow = table.getRow(currentRow.parentId, true);
        isFullyExpanded = currentRow.getIsExpanded();
      }
      return isFullyExpanded;
    };
    row.getToggleExpandedHandler = () => {
      const canExpand = row.getCanExpand();
      return () => {
        if (!canExpand) return;
        row.toggleExpanded();
      };
    };
  }
};
const defaultPageIndex = 0;
const defaultPageSize = 10;
const getDefaultPaginationState = () => ({
  pageIndex: defaultPageIndex,
  pageSize: defaultPageSize
});
const RowPagination = {
  getInitialState: (state) => {
    return {
      ...state,
      pagination: {
        ...getDefaultPaginationState(),
        ...state == null ? void 0 : state.pagination
      }
    };
  },
  getDefaultOptions: (table) => {
    return {
      onPaginationChange: makeStateUpdater("pagination", table)
    };
  },
  createTable: (table) => {
    let registered = false;
    let queued = false;
    table._autoResetPageIndex = () => {
      var _ref, _table$options$autoRe;
      if (!registered) {
        table._queue(() => {
          registered = true;
        });
        return;
      }
      if ((_ref = (_table$options$autoRe = table.options.autoResetAll) != null ? _table$options$autoRe : table.options.autoResetPageIndex) != null ? _ref : !table.options.manualPagination) {
        if (queued) return;
        queued = true;
        table._queue(() => {
          table.resetPageIndex();
          queued = false;
        });
      }
    };
    table.setPagination = (updater) => {
      const safeUpdater = (old) => {
        let newState = functionalUpdate(updater, old);
        return newState;
      };
      return table.options.onPaginationChange == null ? void 0 : table.options.onPaginationChange(safeUpdater);
    };
    table.resetPagination = (defaultState) => {
      var _table$initialState$p;
      table.setPagination(defaultState ? getDefaultPaginationState() : (_table$initialState$p = table.initialState.pagination) != null ? _table$initialState$p : getDefaultPaginationState());
    };
    table.setPageIndex = (updater) => {
      table.setPagination((old) => {
        let pageIndex = functionalUpdate(updater, old.pageIndex);
        const maxPageIndex = typeof table.options.pageCount === "undefined" || table.options.pageCount === -1 ? Number.MAX_SAFE_INTEGER : table.options.pageCount - 1;
        pageIndex = Math.max(0, Math.min(pageIndex, maxPageIndex));
        return {
          ...old,
          pageIndex
        };
      });
    };
    table.resetPageIndex = (defaultState) => {
      var _table$initialState$p2, _table$initialState;
      table.setPageIndex(defaultState ? defaultPageIndex : (_table$initialState$p2 = (_table$initialState = table.initialState) == null || (_table$initialState = _table$initialState.pagination) == null ? void 0 : _table$initialState.pageIndex) != null ? _table$initialState$p2 : defaultPageIndex);
    };
    table.resetPageSize = (defaultState) => {
      var _table$initialState$p3, _table$initialState2;
      table.setPageSize(defaultState ? defaultPageSize : (_table$initialState$p3 = (_table$initialState2 = table.initialState) == null || (_table$initialState2 = _table$initialState2.pagination) == null ? void 0 : _table$initialState2.pageSize) != null ? _table$initialState$p3 : defaultPageSize);
    };
    table.setPageSize = (updater) => {
      table.setPagination((old) => {
        const pageSize = Math.max(1, functionalUpdate(updater, old.pageSize));
        const topRowIndex = old.pageSize * old.pageIndex;
        const pageIndex = Math.floor(topRowIndex / pageSize);
        return {
          ...old,
          pageIndex,
          pageSize
        };
      });
    };
    table.setPageCount = (updater) => table.setPagination((old) => {
      var _table$options$pageCo;
      let newPageCount = functionalUpdate(updater, (_table$options$pageCo = table.options.pageCount) != null ? _table$options$pageCo : -1);
      if (typeof newPageCount === "number") {
        newPageCount = Math.max(-1, newPageCount);
      }
      return {
        ...old,
        pageCount: newPageCount
      };
    });
    table.getPageOptions = memo(() => [table.getPageCount()], (pageCount) => {
      let pageOptions = [];
      if (pageCount && pageCount > 0) {
        pageOptions = [...new Array(pageCount)].fill(null).map((_, i2) => i2);
      }
      return pageOptions;
    }, getMemoOptions(table.options, "debugTable", "getPageOptions"));
    table.getCanPreviousPage = () => table.getState().pagination.pageIndex > 0;
    table.getCanNextPage = () => {
      const {
        pageIndex
      } = table.getState().pagination;
      const pageCount = table.getPageCount();
      if (pageCount === -1) {
        return true;
      }
      if (pageCount === 0) {
        return false;
      }
      return pageIndex < pageCount - 1;
    };
    table.previousPage = () => {
      return table.setPageIndex((old) => old - 1);
    };
    table.nextPage = () => {
      return table.setPageIndex((old) => {
        return old + 1;
      });
    };
    table.firstPage = () => {
      return table.setPageIndex(0);
    };
    table.lastPage = () => {
      return table.setPageIndex(table.getPageCount() - 1);
    };
    table.getPrePaginationRowModel = () => table.getExpandedRowModel();
    table.getPaginationRowModel = () => {
      if (!table._getPaginationRowModel && table.options.getPaginationRowModel) {
        table._getPaginationRowModel = table.options.getPaginationRowModel(table);
      }
      if (table.options.manualPagination || !table._getPaginationRowModel) {
        return table.getPrePaginationRowModel();
      }
      return table._getPaginationRowModel();
    };
    table.getPageCount = () => {
      var _table$options$pageCo2;
      return (_table$options$pageCo2 = table.options.pageCount) != null ? _table$options$pageCo2 : Math.ceil(table.getRowCount() / table.getState().pagination.pageSize);
    };
    table.getRowCount = () => {
      var _table$options$rowCou;
      return (_table$options$rowCou = table.options.rowCount) != null ? _table$options$rowCou : table.getPrePaginationRowModel().rows.length;
    };
  }
};
const getDefaultRowPinningState = () => ({
  top: [],
  bottom: []
});
const RowPinning = {
  getInitialState: (state) => {
    return {
      rowPinning: getDefaultRowPinningState(),
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onRowPinningChange: makeStateUpdater("rowPinning", table)
    };
  },
  createRow: (row, table) => {
    row.pin = (position2, includeLeafRows, includeParentRows) => {
      const leafRowIds = includeLeafRows ? row.getLeafRows().map((_ref) => {
        let {
          id: id2
        } = _ref;
        return id2;
      }) : [];
      const parentRowIds = includeParentRows ? row.getParentRows().map((_ref2) => {
        let {
          id: id2
        } = _ref2;
        return id2;
      }) : [];
      const rowIds = /* @__PURE__ */ new Set([...parentRowIds, row.id, ...leafRowIds]);
      table.setRowPinning((old) => {
        var _old$top3, _old$bottom3;
        if (position2 === "bottom") {
          var _old$top, _old$bottom;
          return {
            top: ((_old$top = old == null ? void 0 : old.top) != null ? _old$top : []).filter((d) => !(rowIds != null && rowIds.has(d))),
            bottom: [...((_old$bottom = old == null ? void 0 : old.bottom) != null ? _old$bottom : []).filter((d) => !(rowIds != null && rowIds.has(d))), ...Array.from(rowIds)]
          };
        }
        if (position2 === "top") {
          var _old$top2, _old$bottom2;
          return {
            top: [...((_old$top2 = old == null ? void 0 : old.top) != null ? _old$top2 : []).filter((d) => !(rowIds != null && rowIds.has(d))), ...Array.from(rowIds)],
            bottom: ((_old$bottom2 = old == null ? void 0 : old.bottom) != null ? _old$bottom2 : []).filter((d) => !(rowIds != null && rowIds.has(d)))
          };
        }
        return {
          top: ((_old$top3 = old == null ? void 0 : old.top) != null ? _old$top3 : []).filter((d) => !(rowIds != null && rowIds.has(d))),
          bottom: ((_old$bottom3 = old == null ? void 0 : old.bottom) != null ? _old$bottom3 : []).filter((d) => !(rowIds != null && rowIds.has(d)))
        };
      });
    };
    row.getCanPin = () => {
      var _ref3;
      const {
        enableRowPinning,
        enablePinning
      } = table.options;
      if (typeof enableRowPinning === "function") {
        return enableRowPinning(row);
      }
      return (_ref3 = enableRowPinning != null ? enableRowPinning : enablePinning) != null ? _ref3 : true;
    };
    row.getIsPinned = () => {
      const rowIds = [row.id];
      const {
        top,
        bottom
      } = table.getState().rowPinning;
      const isTop = rowIds.some((d) => top == null ? void 0 : top.includes(d));
      const isBottom = rowIds.some((d) => bottom == null ? void 0 : bottom.includes(d));
      return isTop ? "top" : isBottom ? "bottom" : false;
    };
    row.getPinnedIndex = () => {
      var _ref4, _visiblePinnedRowIds$;
      const position2 = row.getIsPinned();
      if (!position2) return -1;
      const visiblePinnedRowIds = (_ref4 = position2 === "top" ? table.getTopRows() : table.getBottomRows()) == null ? void 0 : _ref4.map((_ref5) => {
        let {
          id: id2
        } = _ref5;
        return id2;
      });
      return (_visiblePinnedRowIds$ = visiblePinnedRowIds == null ? void 0 : visiblePinnedRowIds.indexOf(row.id)) != null ? _visiblePinnedRowIds$ : -1;
    };
  },
  createTable: (table) => {
    table.setRowPinning = (updater) => table.options.onRowPinningChange == null ? void 0 : table.options.onRowPinningChange(updater);
    table.resetRowPinning = (defaultState) => {
      var _table$initialState$r, _table$initialState;
      return table.setRowPinning(defaultState ? getDefaultRowPinningState() : (_table$initialState$r = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.rowPinning) != null ? _table$initialState$r : getDefaultRowPinningState());
    };
    table.getIsSomeRowsPinned = (position2) => {
      var _pinningState$positio;
      const pinningState = table.getState().rowPinning;
      if (!position2) {
        var _pinningState$top, _pinningState$bottom;
        return Boolean(((_pinningState$top = pinningState.top) == null ? void 0 : _pinningState$top.length) || ((_pinningState$bottom = pinningState.bottom) == null ? void 0 : _pinningState$bottom.length));
      }
      return Boolean((_pinningState$positio = pinningState[position2]) == null ? void 0 : _pinningState$positio.length);
    };
    table._getPinnedRows = (visibleRows, pinnedRowIds, position2) => {
      var _table$options$keepPi;
      const rows = ((_table$options$keepPi = table.options.keepPinnedRows) != null ? _table$options$keepPi : true) ? (
        //get all rows that are pinned even if they would not be otherwise visible
        //account for expanded parent rows, but not pagination or filtering
        (pinnedRowIds != null ? pinnedRowIds : []).map((rowId) => {
          const row = table.getRow(rowId, true);
          return row.getIsAllParentsExpanded() ? row : null;
        })
      ) : (
        //else get only visible rows that are pinned
        (pinnedRowIds != null ? pinnedRowIds : []).map((rowId) => visibleRows.find((row) => row.id === rowId))
      );
      return rows.filter(Boolean).map((d) => ({
        ...d,
        position: position2
      }));
    };
    table.getTopRows = memo(() => [table.getRowModel().rows, table.getState().rowPinning.top], (allRows, topPinnedRowIds) => table._getPinnedRows(allRows, topPinnedRowIds, "top"), getMemoOptions(table.options, "debugRows", "getTopRows"));
    table.getBottomRows = memo(() => [table.getRowModel().rows, table.getState().rowPinning.bottom], (allRows, bottomPinnedRowIds) => table._getPinnedRows(allRows, bottomPinnedRowIds, "bottom"), getMemoOptions(table.options, "debugRows", "getBottomRows"));
    table.getCenterRows = memo(() => [table.getRowModel().rows, table.getState().rowPinning.top, table.getState().rowPinning.bottom], (allRows, top, bottom) => {
      const topAndBottom = /* @__PURE__ */ new Set([...top != null ? top : [], ...bottom != null ? bottom : []]);
      return allRows.filter((d) => !topAndBottom.has(d.id));
    }, getMemoOptions(table.options, "debugRows", "getCenterRows"));
  }
};
const RowSelection = {
  getInitialState: (state) => {
    return {
      rowSelection: {},
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onRowSelectionChange: makeStateUpdater("rowSelection", table),
      enableRowSelection: true,
      enableMultiRowSelection: true,
      enableSubRowSelection: true
      // enableGroupingRowSelection: false,
      // isAdditiveSelectEvent: (e: unknown) => !!e.metaKey,
      // isInclusiveSelectEvent: (e: unknown) => !!e.shiftKey,
    };
  },
  createTable: (table) => {
    table.setRowSelection = (updater) => table.options.onRowSelectionChange == null ? void 0 : table.options.onRowSelectionChange(updater);
    table.resetRowSelection = (defaultState) => {
      var _table$initialState$r;
      return table.setRowSelection(defaultState ? {} : (_table$initialState$r = table.initialState.rowSelection) != null ? _table$initialState$r : {});
    };
    table.toggleAllRowsSelected = (value2) => {
      table.setRowSelection((old) => {
        value2 = typeof value2 !== "undefined" ? value2 : !table.getIsAllRowsSelected();
        const rowSelection = {
          ...old
        };
        const preGroupedFlatRows = table.getPreGroupedRowModel().flatRows;
        if (value2) {
          preGroupedFlatRows.forEach((row) => {
            if (!row.getCanSelect()) {
              return;
            }
            rowSelection[row.id] = true;
          });
        } else {
          preGroupedFlatRows.forEach((row) => {
            delete rowSelection[row.id];
          });
        }
        return rowSelection;
      });
    };
    table.toggleAllPageRowsSelected = (value2) => table.setRowSelection((old) => {
      const resolvedValue = typeof value2 !== "undefined" ? value2 : !table.getIsAllPageRowsSelected();
      const rowSelection = {
        ...old
      };
      table.getRowModel().rows.forEach((row) => {
        mutateRowIsSelected(rowSelection, row.id, resolvedValue, true, table);
      });
      return rowSelection;
    });
    table.getPreSelectedRowModel = () => table.getCoreRowModel();
    table.getSelectedRowModel = memo(() => [table.getState().rowSelection, table.getCoreRowModel()], (rowSelection, rowModel) => {
      if (!Object.keys(rowSelection).length) {
        return {
          rows: [],
          flatRows: [],
          rowsById: {}
        };
      }
      return selectRowsFn(table, rowModel);
    }, getMemoOptions(table.options, "debugTable", "getSelectedRowModel"));
    table.getFilteredSelectedRowModel = memo(() => [table.getState().rowSelection, table.getFilteredRowModel()], (rowSelection, rowModel) => {
      if (!Object.keys(rowSelection).length) {
        return {
          rows: [],
          flatRows: [],
          rowsById: {}
        };
      }
      return selectRowsFn(table, rowModel);
    }, getMemoOptions(table.options, "debugTable", "getFilteredSelectedRowModel"));
    table.getGroupedSelectedRowModel = memo(() => [table.getState().rowSelection, table.getSortedRowModel()], (rowSelection, rowModel) => {
      if (!Object.keys(rowSelection).length) {
        return {
          rows: [],
          flatRows: [],
          rowsById: {}
        };
      }
      return selectRowsFn(table, rowModel);
    }, getMemoOptions(table.options, "debugTable", "getGroupedSelectedRowModel"));
    table.getIsAllRowsSelected = () => {
      const preGroupedFlatRows = table.getFilteredRowModel().flatRows;
      const {
        rowSelection
      } = table.getState();
      let isAllRowsSelected = Boolean(preGroupedFlatRows.length && Object.keys(rowSelection).length);
      if (isAllRowsSelected) {
        if (preGroupedFlatRows.some((row) => row.getCanSelect() && !rowSelection[row.id])) {
          isAllRowsSelected = false;
        }
      }
      return isAllRowsSelected;
    };
    table.getIsAllPageRowsSelected = () => {
      const paginationFlatRows = table.getPaginationRowModel().flatRows.filter((row) => row.getCanSelect());
      const {
        rowSelection
      } = table.getState();
      let isAllPageRowsSelected = !!paginationFlatRows.length;
      if (isAllPageRowsSelected && paginationFlatRows.some((row) => !rowSelection[row.id])) {
        isAllPageRowsSelected = false;
      }
      return isAllPageRowsSelected;
    };
    table.getIsSomeRowsSelected = () => {
      var _table$getState$rowSe;
      const totalSelected = Object.keys((_table$getState$rowSe = table.getState().rowSelection) != null ? _table$getState$rowSe : {}).length;
      return totalSelected > 0 && totalSelected < table.getFilteredRowModel().flatRows.length;
    };
    table.getIsSomePageRowsSelected = () => {
      const paginationFlatRows = table.getPaginationRowModel().flatRows;
      return table.getIsAllPageRowsSelected() ? false : paginationFlatRows.filter((row) => row.getCanSelect()).some((d) => d.getIsSelected() || d.getIsSomeSelected());
    };
    table.getToggleAllRowsSelectedHandler = () => {
      return (e) => {
        table.toggleAllRowsSelected(e.target.checked);
      };
    };
    table.getToggleAllPageRowsSelectedHandler = () => {
      return (e) => {
        table.toggleAllPageRowsSelected(e.target.checked);
      };
    };
  },
  createRow: (row, table) => {
    row.toggleSelected = (value2, opts) => {
      const isSelected = row.getIsSelected();
      table.setRowSelection((old) => {
        var _opts$selectChildren;
        value2 = typeof value2 !== "undefined" ? value2 : !isSelected;
        if (row.getCanSelect() && isSelected === value2) {
          return old;
        }
        const selectedRowIds = {
          ...old
        };
        mutateRowIsSelected(selectedRowIds, row.id, value2, (_opts$selectChildren = opts == null ? void 0 : opts.selectChildren) != null ? _opts$selectChildren : true, table);
        return selectedRowIds;
      });
    };
    row.getIsSelected = () => {
      const {
        rowSelection
      } = table.getState();
      return isRowSelected(row, rowSelection);
    };
    row.getIsSomeSelected = () => {
      const {
        rowSelection
      } = table.getState();
      return isSubRowSelected(row, rowSelection) === "some";
    };
    row.getIsAllSubRowsSelected = () => {
      const {
        rowSelection
      } = table.getState();
      return isSubRowSelected(row, rowSelection) === "all";
    };
    row.getCanSelect = () => {
      var _table$options$enable;
      if (typeof table.options.enableRowSelection === "function") {
        return table.options.enableRowSelection(row);
      }
      return (_table$options$enable = table.options.enableRowSelection) != null ? _table$options$enable : true;
    };
    row.getCanSelectSubRows = () => {
      var _table$options$enable2;
      if (typeof table.options.enableSubRowSelection === "function") {
        return table.options.enableSubRowSelection(row);
      }
      return (_table$options$enable2 = table.options.enableSubRowSelection) != null ? _table$options$enable2 : true;
    };
    row.getCanMultiSelect = () => {
      var _table$options$enable3;
      if (typeof table.options.enableMultiRowSelection === "function") {
        return table.options.enableMultiRowSelection(row);
      }
      return (_table$options$enable3 = table.options.enableMultiRowSelection) != null ? _table$options$enable3 : true;
    };
    row.getToggleSelectedHandler = () => {
      const canSelect = row.getCanSelect();
      return (e) => {
        var _target;
        if (!canSelect) return;
        row.toggleSelected((_target = e.target) == null ? void 0 : _target.checked);
      };
    };
  }
};
const mutateRowIsSelected = (selectedRowIds, id2, value2, includeChildren, table) => {
  var _row$subRows;
  const row = table.getRow(id2, true);
  if (value2) {
    if (!row.getCanMultiSelect()) {
      Object.keys(selectedRowIds).forEach((key) => delete selectedRowIds[key]);
    }
    if (row.getCanSelect()) {
      selectedRowIds[id2] = true;
    }
  } else {
    delete selectedRowIds[id2];
  }
  if (includeChildren && (_row$subRows = row.subRows) != null && _row$subRows.length && row.getCanSelectSubRows()) {
    row.subRows.forEach((row2) => mutateRowIsSelected(selectedRowIds, row2.id, value2, includeChildren, table));
  }
};
function selectRowsFn(table, rowModel) {
  const rowSelection = table.getState().rowSelection;
  const newSelectedFlatRows = [];
  const newSelectedRowsById = {};
  const recurseRows = function(rows, depth) {
    return rows.map((row) => {
      var _row$subRows2;
      const isSelected = isRowSelected(row, rowSelection);
      if (isSelected) {
        newSelectedFlatRows.push(row);
        newSelectedRowsById[row.id] = row;
      }
      if ((_row$subRows2 = row.subRows) != null && _row$subRows2.length) {
        row = {
          ...row,
          subRows: recurseRows(row.subRows)
        };
      }
      if (isSelected) {
        return row;
      }
    }).filter(Boolean);
  };
  return {
    rows: recurseRows(rowModel.rows),
    flatRows: newSelectedFlatRows,
    rowsById: newSelectedRowsById
  };
}
function isRowSelected(row, selection) {
  var _selection$row$id;
  return (_selection$row$id = selection[row.id]) != null ? _selection$row$id : false;
}
function isSubRowSelected(row, selection, table) {
  var _row$subRows3;
  if (!((_row$subRows3 = row.subRows) != null && _row$subRows3.length)) return false;
  let allChildrenSelected = true;
  let someSelected = false;
  row.subRows.forEach((subRow) => {
    if (someSelected && !allChildrenSelected) {
      return;
    }
    if (subRow.getCanSelect()) {
      if (isRowSelected(subRow, selection)) {
        someSelected = true;
      } else {
        allChildrenSelected = false;
      }
    }
    if (subRow.subRows && subRow.subRows.length) {
      const subRowChildrenSelected = isSubRowSelected(subRow, selection);
      if (subRowChildrenSelected === "all") {
        someSelected = true;
      } else if (subRowChildrenSelected === "some") {
        someSelected = true;
        allChildrenSelected = false;
      } else {
        allChildrenSelected = false;
      }
    }
  });
  return allChildrenSelected ? "all" : someSelected ? "some" : false;
}
const reSplitAlphaNumeric = /([0-9]+)/gm;
const alphanumeric = (rowA, rowB, columnId) => {
  return compareAlphanumeric(toString(rowA.getValue(columnId)).toLowerCase(), toString(rowB.getValue(columnId)).toLowerCase());
};
const alphanumericCaseSensitive = (rowA, rowB, columnId) => {
  return compareAlphanumeric(toString(rowA.getValue(columnId)), toString(rowB.getValue(columnId)));
};
const text$2 = (rowA, rowB, columnId) => {
  return compareBasic(toString(rowA.getValue(columnId)).toLowerCase(), toString(rowB.getValue(columnId)).toLowerCase());
};
const textCaseSensitive = (rowA, rowB, columnId) => {
  return compareBasic(toString(rowA.getValue(columnId)), toString(rowB.getValue(columnId)));
};
const datetime = (rowA, rowB, columnId) => {
  const a = rowA.getValue(columnId);
  const b = rowB.getValue(columnId);
  return a > b ? 1 : a < b ? -1 : 0;
};
const basic = (rowA, rowB, columnId) => {
  return compareBasic(rowA.getValue(columnId), rowB.getValue(columnId));
};
function compareBasic(a, b) {
  return a === b ? 0 : a > b ? 1 : -1;
}
function toString(a) {
  if (typeof a === "number") {
    if (isNaN(a) || a === Infinity || a === -Infinity) {
      return "";
    }
    return String(a);
  }
  if (typeof a === "string") {
    return a;
  }
  return "";
}
function compareAlphanumeric(aStr, bStr) {
  const a = aStr.split(reSplitAlphaNumeric).filter(Boolean);
  const b = bStr.split(reSplitAlphaNumeric).filter(Boolean);
  while (a.length && b.length) {
    const aa = a.shift();
    const bb = b.shift();
    const an = parseInt(aa, 10);
    const bn = parseInt(bb, 10);
    const combo = [an, bn].sort();
    if (isNaN(combo[0])) {
      if (aa > bb) {
        return 1;
      }
      if (bb > aa) {
        return -1;
      }
      continue;
    }
    if (isNaN(combo[1])) {
      return isNaN(an) ? -1 : 1;
    }
    if (an > bn) {
      return 1;
    }
    if (bn > an) {
      return -1;
    }
  }
  return a.length - b.length;
}
const sortingFns = {
  alphanumeric,
  alphanumericCaseSensitive,
  text: text$2,
  textCaseSensitive,
  datetime,
  basic
};
const RowSorting = {
  getInitialState: (state) => {
    return {
      sorting: [],
      ...state
    };
  },
  getDefaultColumnDef: () => {
    return {
      sortingFn: "auto",
      sortUndefined: 1
    };
  },
  getDefaultOptions: (table) => {
    return {
      onSortingChange: makeStateUpdater("sorting", table),
      isMultiSortEvent: (e) => {
        return e.shiftKey;
      }
    };
  },
  createColumn: (column, table) => {
    column.getAutoSortingFn = () => {
      const firstRows = table.getFilteredRowModel().flatRows.slice(10);
      let isString2 = false;
      for (const row of firstRows) {
        const value2 = row == null ? void 0 : row.getValue(column.id);
        if (Object.prototype.toString.call(value2) === "[object Date]") {
          return sortingFns.datetime;
        }
        if (typeof value2 === "string") {
          isString2 = true;
          if (value2.split(reSplitAlphaNumeric).length > 1) {
            return sortingFns.alphanumeric;
          }
        }
      }
      if (isString2) {
        return sortingFns.text;
      }
      return sortingFns.basic;
    };
    column.getAutoSortDir = () => {
      const firstRow = table.getFilteredRowModel().flatRows[0];
      const value2 = firstRow == null ? void 0 : firstRow.getValue(column.id);
      if (typeof value2 === "string") {
        return "asc";
      }
      return "desc";
    };
    column.getSortingFn = () => {
      var _table$options$sortin, _table$options$sortin2;
      if (!column) {
        throw new Error();
      }
      return isFunction(column.columnDef.sortingFn) ? column.columnDef.sortingFn : column.columnDef.sortingFn === "auto" ? column.getAutoSortingFn() : (_table$options$sortin = (_table$options$sortin2 = table.options.sortingFns) == null ? void 0 : _table$options$sortin2[column.columnDef.sortingFn]) != null ? _table$options$sortin : sortingFns[column.columnDef.sortingFn];
    };
    column.toggleSorting = (desc, multi) => {
      const nextSortingOrder = column.getNextSortingOrder();
      const hasManualValue = typeof desc !== "undefined" && desc !== null;
      table.setSorting((old) => {
        const existingSorting = old == null ? void 0 : old.find((d) => d.id === column.id);
        const existingIndex = old == null ? void 0 : old.findIndex((d) => d.id === column.id);
        let newSorting = [];
        let sortAction;
        let nextDesc = hasManualValue ? desc : nextSortingOrder === "desc";
        if (old != null && old.length && column.getCanMultiSort() && multi) {
          if (existingSorting) {
            sortAction = "toggle";
          } else {
            sortAction = "add";
          }
        } else {
          if (old != null && old.length && existingIndex !== old.length - 1) {
            sortAction = "replace";
          } else if (existingSorting) {
            sortAction = "toggle";
          } else {
            sortAction = "replace";
          }
        }
        if (sortAction === "toggle") {
          if (!hasManualValue) {
            if (!nextSortingOrder) {
              sortAction = "remove";
            }
          }
        }
        if (sortAction === "add") {
          var _table$options$maxMul;
          newSorting = [...old, {
            id: column.id,
            desc: nextDesc
          }];
          newSorting.splice(0, newSorting.length - ((_table$options$maxMul = table.options.maxMultiSortColCount) != null ? _table$options$maxMul : Number.MAX_SAFE_INTEGER));
        } else if (sortAction === "toggle") {
          newSorting = old.map((d) => {
            if (d.id === column.id) {
              return {
                ...d,
                desc: nextDesc
              };
            }
            return d;
          });
        } else if (sortAction === "remove") {
          newSorting = old.filter((d) => d.id !== column.id);
        } else {
          newSorting = [{
            id: column.id,
            desc: nextDesc
          }];
        }
        return newSorting;
      });
    };
    column.getFirstSortDir = () => {
      var _ref, _column$columnDef$sor;
      const sortDescFirst = (_ref = (_column$columnDef$sor = column.columnDef.sortDescFirst) != null ? _column$columnDef$sor : table.options.sortDescFirst) != null ? _ref : column.getAutoSortDir() === "desc";
      return sortDescFirst ? "desc" : "asc";
    };
    column.getNextSortingOrder = (multi) => {
      var _table$options$enable, _table$options$enable2;
      const firstSortDirection = column.getFirstSortDir();
      const isSorted = column.getIsSorted();
      if (!isSorted) {
        return firstSortDirection;
      }
      if (isSorted !== firstSortDirection && ((_table$options$enable = table.options.enableSortingRemoval) != null ? _table$options$enable : true) && // If enableSortRemove, enable in general
      (multi ? (_table$options$enable2 = table.options.enableMultiRemove) != null ? _table$options$enable2 : true : true)) {
        return false;
      }
      return isSorted === "desc" ? "asc" : "desc";
    };
    column.getCanSort = () => {
      var _column$columnDef$ena, _table$options$enable3;
      return ((_column$columnDef$ena = column.columnDef.enableSorting) != null ? _column$columnDef$ena : true) && ((_table$options$enable3 = table.options.enableSorting) != null ? _table$options$enable3 : true) && !!column.accessorFn;
    };
    column.getCanMultiSort = () => {
      var _ref2, _column$columnDef$ena2;
      return (_ref2 = (_column$columnDef$ena2 = column.columnDef.enableMultiSort) != null ? _column$columnDef$ena2 : table.options.enableMultiSort) != null ? _ref2 : !!column.accessorFn;
    };
    column.getIsSorted = () => {
      var _table$getState$sorti;
      const columnSort = (_table$getState$sorti = table.getState().sorting) == null ? void 0 : _table$getState$sorti.find((d) => d.id === column.id);
      return !columnSort ? false : columnSort.desc ? "desc" : "asc";
    };
    column.getSortIndex = () => {
      var _table$getState$sorti2, _table$getState$sorti3;
      return (_table$getState$sorti2 = (_table$getState$sorti3 = table.getState().sorting) == null ? void 0 : _table$getState$sorti3.findIndex((d) => d.id === column.id)) != null ? _table$getState$sorti2 : -1;
    };
    column.clearSorting = () => {
      table.setSorting((old) => old != null && old.length ? old.filter((d) => d.id !== column.id) : []);
    };
    column.getToggleSortingHandler = () => {
      const canSort = column.getCanSort();
      return (e) => {
        if (!canSort) return;
        e.persist == null || e.persist();
        column.toggleSorting == null || column.toggleSorting(void 0, column.getCanMultiSort() ? table.options.isMultiSortEvent == null ? void 0 : table.options.isMultiSortEvent(e) : false);
      };
    };
  },
  createTable: (table) => {
    table.setSorting = (updater) => table.options.onSortingChange == null ? void 0 : table.options.onSortingChange(updater);
    table.resetSorting = (defaultState) => {
      var _table$initialState$s, _table$initialState;
      table.setSorting(defaultState ? [] : (_table$initialState$s = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.sorting) != null ? _table$initialState$s : []);
    };
    table.getPreSortedRowModel = () => table.getGroupedRowModel();
    table.getSortedRowModel = () => {
      if (!table._getSortedRowModel && table.options.getSortedRowModel) {
        table._getSortedRowModel = table.options.getSortedRowModel(table);
      }
      if (table.options.manualSorting || !table._getSortedRowModel) {
        return table.getPreSortedRowModel();
      }
      return table._getSortedRowModel();
    };
  }
};
const builtInFeatures = [
  Headers,
  ColumnVisibility,
  ColumnOrdering,
  ColumnPinning,
  ColumnFaceting,
  ColumnFiltering,
  GlobalFaceting,
  //depends on ColumnFaceting
  GlobalFiltering,
  //depends on ColumnFiltering
  RowSorting,
  ColumnGrouping,
  //depends on RowSorting
  RowExpanding,
  RowPagination,
  RowPinning,
  RowSelection,
  ColumnSizing
];
function createTable(options) {
  var _options$_features, _options$initialState;
  if (process.env.NODE_ENV !== "production" && (options.debugAll || options.debugTable)) {
    console.info("Creating Table Instance...");
  }
  const _features = [...builtInFeatures, ...(_options$_features = options._features) != null ? _options$_features : []];
  let table = {
    _features
  };
  const defaultOptions2 = table._features.reduce((obj, feature) => {
    return Object.assign(obj, feature.getDefaultOptions == null ? void 0 : feature.getDefaultOptions(table));
  }, {});
  const mergeOptions = (options2) => {
    if (table.options.mergeOptions) {
      return table.options.mergeOptions(defaultOptions2, options2);
    }
    return {
      ...defaultOptions2,
      ...options2
    };
  };
  const coreInitialState = {};
  let initialState2 = {
    ...coreInitialState,
    ...(_options$initialState = options.initialState) != null ? _options$initialState : {}
  };
  table._features.forEach((feature) => {
    var _feature$getInitialSt;
    initialState2 = (_feature$getInitialSt = feature.getInitialState == null ? void 0 : feature.getInitialState(initialState2)) != null ? _feature$getInitialSt : initialState2;
  });
  const queued = [];
  let queuedTimeout = false;
  const coreInstance = {
    _features,
    options: {
      ...defaultOptions2,
      ...options
    },
    initialState: initialState2,
    _queue: (cb) => {
      queued.push(cb);
      if (!queuedTimeout) {
        queuedTimeout = true;
        Promise.resolve().then(() => {
          while (queued.length) {
            queued.shift()();
          }
          queuedTimeout = false;
        }).catch((error2) => setTimeout(() => {
          throw error2;
        }));
      }
    },
    reset: () => {
      table.setState(table.initialState);
    },
    setOptions: (updater) => {
      const newOptions = functionalUpdate(updater, table.options);
      table.options = mergeOptions(newOptions);
    },
    getState: () => {
      return table.options.state;
    },
    setState: (updater) => {
      table.options.onStateChange == null || table.options.onStateChange(updater);
    },
    _getRowId: (row, index2, parent) => {
      var _table$options$getRow;
      return (_table$options$getRow = table.options.getRowId == null ? void 0 : table.options.getRowId(row, index2, parent)) != null ? _table$options$getRow : `${parent ? [parent.id, index2].join(".") : index2}`;
    },
    getCoreRowModel: () => {
      if (!table._getCoreRowModel) {
        table._getCoreRowModel = table.options.getCoreRowModel(table);
      }
      return table._getCoreRowModel();
    },
    // The final calls start at the bottom of the model,
    // expanded rows, which then work their way up
    getRowModel: () => {
      return table.getPaginationRowModel();
    },
    //in next version, we should just pass in the row model as the optional 2nd arg
    getRow: (id2, searchAll) => {
      let row = (searchAll ? table.getPrePaginationRowModel() : table.getRowModel()).rowsById[id2];
      if (!row) {
        row = table.getCoreRowModel().rowsById[id2];
        if (!row) {
          if (process.env.NODE_ENV !== "production") {
            throw new Error(`getRow could not find row with ID: ${id2}`);
          }
          throw new Error();
        }
      }
      return row;
    },
    _getDefaultColumnDef: memo(() => [table.options.defaultColumn], (defaultColumn) => {
      var _defaultColumn;
      defaultColumn = (_defaultColumn = defaultColumn) != null ? _defaultColumn : {};
      return {
        header: (props) => {
          const resolvedColumnDef = props.header.column.columnDef;
          if (resolvedColumnDef.accessorKey) {
            return resolvedColumnDef.accessorKey;
          }
          if (resolvedColumnDef.accessorFn) {
            return resolvedColumnDef.id;
          }
          return null;
        },
        // footer: props => props.header.column.id,
        cell: (props) => {
          var _props$renderValue$to, _props$renderValue;
          return (_props$renderValue$to = (_props$renderValue = props.renderValue()) == null || _props$renderValue.toString == null ? void 0 : _props$renderValue.toString()) != null ? _props$renderValue$to : null;
        },
        ...table._features.reduce((obj, feature) => {
          return Object.assign(obj, feature.getDefaultColumnDef == null ? void 0 : feature.getDefaultColumnDef());
        }, {}),
        ...defaultColumn
      };
    }, getMemoOptions(options, "debugColumns", "_getDefaultColumnDef")),
    _getColumnDefs: () => table.options.columns,
    getAllColumns: memo(() => [table._getColumnDefs()], (columnDefs) => {
      const recurseColumns = function(columnDefs2, parent, depth) {
        if (depth === void 0) {
          depth = 0;
        }
        return columnDefs2.map((columnDef) => {
          const column = createColumn(table, columnDef, depth, parent);
          const groupingColumnDef = columnDef;
          column.columns = groupingColumnDef.columns ? recurseColumns(groupingColumnDef.columns, column, depth + 1) : [];
          return column;
        });
      };
      return recurseColumns(columnDefs);
    }, getMemoOptions(options, "debugColumns", "getAllColumns")),
    getAllFlatColumns: memo(() => [table.getAllColumns()], (allColumns) => {
      return allColumns.flatMap((column) => {
        return column.getFlatColumns();
      });
    }, getMemoOptions(options, "debugColumns", "getAllFlatColumns")),
    _getAllFlatColumnsById: memo(() => [table.getAllFlatColumns()], (flatColumns) => {
      return flatColumns.reduce((acc, column) => {
        acc[column.id] = column;
        return acc;
      }, {});
    }, getMemoOptions(options, "debugColumns", "getAllFlatColumnsById")),
    getAllLeafColumns: memo(() => [table.getAllColumns(), table._getOrderColumnsFn()], (allColumns, orderColumns2) => {
      let leafColumns = allColumns.flatMap((column) => column.getLeafColumns());
      return orderColumns2(leafColumns);
    }, getMemoOptions(options, "debugColumns", "getAllLeafColumns")),
    getColumn: (columnId) => {
      const column = table._getAllFlatColumnsById()[columnId];
      if (process.env.NODE_ENV !== "production" && !column) {
        console.error(`[Table] Column with id '${columnId}' does not exist.`);
      }
      return column;
    }
  };
  Object.assign(table, coreInstance);
  for (let index2 = 0; index2 < table._features.length; index2++) {
    const feature = table._features[index2];
    feature == null || feature.createTable == null || feature.createTable(table);
  }
  return table;
}
function getCoreRowModel() {
  return (table) => memo(() => [table.options.data], (data) => {
    const rowModel = {
      rows: [],
      flatRows: [],
      rowsById: {}
    };
    const accessRows = function(originalRows, depth, parentRow) {
      if (depth === void 0) {
        depth = 0;
      }
      const rows = [];
      for (let i2 = 0; i2 < originalRows.length; i2++) {
        const row = createRow(table, table._getRowId(originalRows[i2], i2, parentRow), originalRows[i2], i2, depth, void 0, parentRow == null ? void 0 : parentRow.id);
        rowModel.flatRows.push(row);
        rowModel.rowsById[row.id] = row;
        rows.push(row);
        if (table.options.getSubRows) {
          var _row$originalSubRows;
          row.originalSubRows = table.options.getSubRows(originalRows[i2], i2);
          if ((_row$originalSubRows = row.originalSubRows) != null && _row$originalSubRows.length) {
            row.subRows = accessRows(row.originalSubRows, depth + 1, row);
          }
        }
      }
      return rows;
    };
    rowModel.rows = accessRows(data);
    return rowModel;
  }, getMemoOptions(table.options, "debugTable", "getRowModel", () => table._autoResetPageIndex()));
}
function filterRows(rows, filterRowImpl, table) {
  if (table.options.filterFromLeafRows) {
    return filterRowModelFromLeafs(rows, filterRowImpl, table);
  }
  return filterRowModelFromRoot(rows, filterRowImpl, table);
}
function filterRowModelFromLeafs(rowsToFilter, filterRow, table) {
  var _table$options$maxLea;
  const newFilteredFlatRows = [];
  const newFilteredRowsById = {};
  const maxDepth = (_table$options$maxLea = table.options.maxLeafRowFilterDepth) != null ? _table$options$maxLea : 100;
  const recurseFilterRows = function(rowsToFilter2, depth) {
    if (depth === void 0) {
      depth = 0;
    }
    const rows = [];
    for (let i2 = 0; i2 < rowsToFilter2.length; i2++) {
      var _row$subRows;
      let row = rowsToFilter2[i2];
      const newRow = createRow(table, row.id, row.original, row.index, row.depth, void 0, row.parentId);
      newRow.columnFilters = row.columnFilters;
      if ((_row$subRows = row.subRows) != null && _row$subRows.length && depth < maxDepth) {
        newRow.subRows = recurseFilterRows(row.subRows, depth + 1);
        row = newRow;
        if (filterRow(row) && !newRow.subRows.length) {
          rows.push(row);
          newFilteredRowsById[row.id] = row;
          newFilteredFlatRows.push(row);
          continue;
        }
        if (filterRow(row) || newRow.subRows.length) {
          rows.push(row);
          newFilteredRowsById[row.id] = row;
          newFilteredFlatRows.push(row);
          continue;
        }
      } else {
        row = newRow;
        if (filterRow(row)) {
          rows.push(row);
          newFilteredRowsById[row.id] = row;
          newFilteredFlatRows.push(row);
        }
      }
    }
    return rows;
  };
  return {
    rows: recurseFilterRows(rowsToFilter),
    flatRows: newFilteredFlatRows,
    rowsById: newFilteredRowsById
  };
}
function filterRowModelFromRoot(rowsToFilter, filterRow, table) {
  var _table$options$maxLea2;
  const newFilteredFlatRows = [];
  const newFilteredRowsById = {};
  const maxDepth = (_table$options$maxLea2 = table.options.maxLeafRowFilterDepth) != null ? _table$options$maxLea2 : 100;
  const recurseFilterRows = function(rowsToFilter2, depth) {
    if (depth === void 0) {
      depth = 0;
    }
    const rows = [];
    for (let i2 = 0; i2 < rowsToFilter2.length; i2++) {
      let row = rowsToFilter2[i2];
      const pass = filterRow(row);
      if (pass) {
        var _row$subRows2;
        if ((_row$subRows2 = row.subRows) != null && _row$subRows2.length && depth < maxDepth) {
          const newRow = createRow(table, row.id, row.original, row.index, row.depth, void 0, row.parentId);
          newRow.subRows = recurseFilterRows(row.subRows, depth + 1);
          row = newRow;
        }
        rows.push(row);
        newFilteredFlatRows.push(row);
        newFilteredRowsById[row.id] = row;
      }
    }
    return rows;
  };
  return {
    rows: recurseFilterRows(rowsToFilter),
    flatRows: newFilteredFlatRows,
    rowsById: newFilteredRowsById
  };
}
function getFilteredRowModel() {
  return (table) => memo(() => [table.getPreFilteredRowModel(), table.getState().columnFilters, table.getState().globalFilter], (rowModel, columnFilters, globalFilter) => {
    if (!rowModel.rows.length || !(columnFilters != null && columnFilters.length) && !globalFilter) {
      for (let i2 = 0; i2 < rowModel.flatRows.length; i2++) {
        rowModel.flatRows[i2].columnFilters = {};
        rowModel.flatRows[i2].columnFiltersMeta = {};
      }
      return rowModel;
    }
    const resolvedColumnFilters = [];
    const resolvedGlobalFilters = [];
    (columnFilters != null ? columnFilters : []).forEach((d) => {
      var _filterFn$resolveFilt;
      const column = table.getColumn(d.id);
      if (!column) {
        return;
      }
      const filterFn = column.getFilterFn();
      if (!filterFn) {
        if (process.env.NODE_ENV !== "production") {
          console.warn(`Could not find a valid 'column.filterFn' for column with the ID: ${column.id}.`);
        }
        return;
      }
      resolvedColumnFilters.push({
        id: d.id,
        filterFn,
        resolvedValue: (_filterFn$resolveFilt = filterFn.resolveFilterValue == null ? void 0 : filterFn.resolveFilterValue(d.value)) != null ? _filterFn$resolveFilt : d.value
      });
    });
    const filterableIds = (columnFilters != null ? columnFilters : []).map((d) => d.id);
    const globalFilterFn = table.getGlobalFilterFn();
    const globallyFilterableColumns = table.getAllLeafColumns().filter((column) => column.getCanGlobalFilter());
    if (globalFilter && globalFilterFn && globallyFilterableColumns.length) {
      filterableIds.push("__global__");
      globallyFilterableColumns.forEach((column) => {
        var _globalFilterFn$resol;
        resolvedGlobalFilters.push({
          id: column.id,
          filterFn: globalFilterFn,
          resolvedValue: (_globalFilterFn$resol = globalFilterFn.resolveFilterValue == null ? void 0 : globalFilterFn.resolveFilterValue(globalFilter)) != null ? _globalFilterFn$resol : globalFilter
        });
      });
    }
    let currentColumnFilter;
    let currentGlobalFilter;
    for (let j = 0; j < rowModel.flatRows.length; j++) {
      const row = rowModel.flatRows[j];
      row.columnFilters = {};
      if (resolvedColumnFilters.length) {
        for (let i2 = 0; i2 < resolvedColumnFilters.length; i2++) {
          currentColumnFilter = resolvedColumnFilters[i2];
          const id2 = currentColumnFilter.id;
          row.columnFilters[id2] = currentColumnFilter.filterFn(row, id2, currentColumnFilter.resolvedValue, (filterMeta) => {
            row.columnFiltersMeta[id2] = filterMeta;
          });
        }
      }
      if (resolvedGlobalFilters.length) {
        for (let i2 = 0; i2 < resolvedGlobalFilters.length; i2++) {
          currentGlobalFilter = resolvedGlobalFilters[i2];
          const id2 = currentGlobalFilter.id;
          if (currentGlobalFilter.filterFn(row, id2, currentGlobalFilter.resolvedValue, (filterMeta) => {
            row.columnFiltersMeta[id2] = filterMeta;
          })) {
            row.columnFilters.__global__ = true;
            break;
          }
        }
        if (row.columnFilters.__global__ !== true) {
          row.columnFilters.__global__ = false;
        }
      }
    }
    const filterRowsImpl = (row) => {
      for (let i2 = 0; i2 < filterableIds.length; i2++) {
        if (row.columnFilters[filterableIds[i2]] === false) {
          return false;
        }
      }
      return true;
    };
    return filterRows(rowModel.rows, filterRowsImpl, table);
  }, getMemoOptions(table.options, "debugTable", "getFilteredRowModel", () => table._autoResetPageIndex()));
}
/**
   * react-table
   *
   * Copyright (c) TanStack
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   */
function flexRender(Comp, props) {
  return !Comp ? null : isReactComponent(Comp) ? /* @__PURE__ */ React.createElement(Comp, props) : Comp;
}
function isReactComponent(component) {
  return isClassComponent(component) || typeof component === "function" || isExoticComponent(component);
}
function isClassComponent(component) {
  return typeof component === "function" && (() => {
    const proto = Object.getPrototypeOf(component);
    return proto.prototype && proto.prototype.isReactComponent;
  })();
}
function isExoticComponent(component) {
  return typeof component === "object" && typeof component.$$typeof === "symbol" && ["react.memo", "react.forward_ref"].includes(component.$$typeof.description);
}
function useReactTable(options) {
  const resolvedOptions = {
    state: {},
    // Dummy state
    onStateChange: () => {
    },
    // noop
    renderFallbackValue: null,
    ...options
  };
  const [tableRef] = React.useState(() => ({
    current: createTable(resolvedOptions)
  }));
  const [state, setState] = React.useState(() => tableRef.current.initialState);
  tableRef.current.setOptions((prev) => ({
    ...prev,
    ...options,
    state: {
      ...state,
      ...options.state
    },
    // Similarly, we'll maintain both our internal state and any user-provided
    // state.
    onStateChange: (updater) => {
      setState(updater);
      options.onStateChange == null || options.onStateChange(updater);
    }
  }));
  return tableRef.current;
}
const PropertyTable = ({ data, columns, getProperty, multi }) => {
  var _a, _b;
  const { t: t2 } = useTranslation();
  const [columnFilters, setColumnFilters] = useState([]);
  const [rowSelection, setRowSelection] = useState({});
  const table = useReactTable({
    data,
    columns,
    getCoreRowModel: getCoreRowModel(),
    getFilteredRowModel: getFilteredRowModel(),
    onColumnFiltersChange: setColumnFilters,
    onRowSelectionChange: setRowSelection,
    enableMultiRowSelection: multi,
    state: {
      columnFilters,
      rowSelection
    },
    initialState: {
      columnVisibility: {
        complex: false,
        computed: false
      }
    }
  });
  useEffect(() => {
    getProperty(rowSelection);
  }, [rowSelection, getProperty]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center py-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "max-w relative mb-2 flex w-full items-center space-x-2 rounded-md border border-input", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Input,
        {
          id: "device-search",
          className: "w-full truncate border-none italic",
          placeholder: t2("Filter properties"),
          onChange: (event) => {
            var _a2;
            return (_a2 = table.getColumn("label")) == null ? void 0 : _a2.setFilterValue(event.target.value);
          },
          value: ((_a = table.getColumn("label")) == null ? void 0 : _a.getFilterValue()) ?? ""
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "text-gray-300 dlt-c8y-icon-search pr-2", type: "button" })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollArea, { className: "flex h-[50vh] items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Table, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TableHeader, { children: table.getHeaderGroups().map((headerGroup) => /* @__PURE__ */ jsxRuntimeExports.jsx(TableRow, { children: headerGroup.headers.map((header) => {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(TableHead, { className: "font-bold", children: header.isPlaceholder ? null : flexRender(
          header.column.columnDef.header,
          header.getContext()
        ) }, header.id);
      }) }, headerGroup.id)) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TableBody, { children: ((_b = table.getRowModel().rows) == null ? void 0 : _b.length) ? table.getRowModel().rows.map((row) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        TableRow,
        {
          "data-state": row.getIsSelected() && "selected",
          children: row.getVisibleCells().map((cell) => /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: flexRender(
            cell.column.columnDef.cell,
            cell.getContext()
          ) }, cell.id))
        },
        row.id
      )) : /* @__PURE__ */ jsxRuntimeExports.jsx(TableRow, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        TableCell,
        {
          colSpan: columns.length,
          className: "h-24 text-center",
          children: t2("No results.")
        }
      ) }) })
    ] }) })
  ] });
};
const schema = {
  MANAGED_OBJECTS: { ...managedObjectSchema },
  ALARMS: { ...alarmSchema },
  EVENTS: { ...eventSchema },
  MEAUSUREMENTS: { ...measurementSchema }
};
const convertDataSchema = (data, t2, parentPath = "") => {
  let rows = [];
  Object.entries(data.properties).forEach(([key, property2]) => {
    const path2 = parentPath ? `${parentPath}.${key}` : key;
    const row = {
      path: path2,
      label: t2(property2.title),
      computed: property2.computed ?? false,
      complex: false,
      show: true
    };
    if (property2.type === "object" && property2.properties) {
      row.complex = true;
      rows.push(row);
      const childRows = convertDataSchema(property2, t2, path2);
      rows = [...rows, ...childRows];
    } else {
      rows.push(row);
    }
  });
  return rows;
};
const PropertySelectTable = ({
  type: type2,
  customSchema,
  selectedProperty,
  multi
}) => {
  const { t: t2 } = useTranslation();
  const [isSelect, setIsSelect] = useState(false);
  const selectedRowRef = useRef([]);
  const targetSchema = schema[type2];
  targetSchema.properties = { ...targetSchema.properties, ...customSchema };
  const data = useMemo(
    () => convertDataSchema(targetSchema, t2),
    [targetSchema, t2]
  );
  const columns = useMemo(
    () => [
      {
        id: "show",
        header: t2("Show"),
        cell: ({ row }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          Checkbox,
          {
            checked: row.getIsSelected(),
            onCheckedChange: (value2) => row.toggleSelected(!!value2),
            "aria-label": "Select"
          }
        )
      },
      {
        id: "label",
        accessorKey: "label",
        header: () => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          "",
          t2("Label")
        ] }),
        cell: ({ row }) => row.getValue("complex") ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "font-bold", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "dlt-c8y-icon-tags" }),
          "",
          row.getValue("label")
        ] }) : row.getValue("computed") ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "font-bold", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "dlt-c8y-icon-bolt" }),
          "",
          row.getValue("label")
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          "",
          row.getValue("label")
        ] })
      },
      {
        id: "path",
        accessorKey: "path",
        header: t2("Property"),
        cell: ({ row }) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: row.getValue("path") })
      },
      {
        id: "complex",
        accessorKey: "complex"
      },
      {
        id: "computed",
        accessorKey: "computed"
      }
    ],
    []
  );
  const getProperty = (event) => {
    const row = multi ? Object.keys(event).map((key) => data[key]) : data[Object.keys(event)[0]];
    selectedRowRef.current = row;
    setIsSelect(!!row);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(DialogHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, { className: "p-0 text-xl font-bold", children: t2("Select property") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      PropertyTable,
      {
        data,
        columns,
        getProperty,
        multi
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogFooter, { className: "pb-0", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(DialogClose, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { type: "button", variant: "destructive", children: t2("Cancel") }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(DialogClose, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button$1,
        {
          onClick: () => selectedProperty(selectedRowRef.current),
          type: "button",
          disabled: !isSelect,
          children: t2("Select")
        }
      ) })
    ] })
  ] });
};
const PropertySelector = ({
  type: type2,
  selectedProperty,
  dialogTriggerButton,
  multi = false
}) => {
  const { getInventoryByFragmentType } = useApi();
  const { t: t2 } = useTranslation();
  const [customSchema, setCustomSchema] = useState({});
  const getCustomSchema = async () => {
    return await getInventoryByFragmentType("c8y_JsonSchema").then(
      (res) => res.data
    );
  };
  const TriggerButton = dialogTriggerButton ?? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "dlt-c8y-icon-plus-circle" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: t2("select property") })
  ] });
  useEffect(() => {
    const getSchema = async () => {
      const data = await getCustomSchema();
      setCustomSchema(
        data.reduce((acc, cur) => {
          if (get$1(cur.appliesTo, type2) === true) {
            acc = { ...acc, ...get$1(cur.c8y_JsonSchema, "properties") };
          }
          return acc;
        }, {})
      );
    };
    getSchema();
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTrigger, { children: TriggerButton }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      DialogContent,
      {
        closeButton: false,
        className: "overflow-y-auto p-6 sm:max-w-[750px] md:w-[750px] md:p-7 lg:w-[750px]",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          PropertySelectTable,
          {
            type: type2,
            customSchema,
            selectedProperty,
            multi
          }
        )
      }
    )
  ] }) });
};
const ComputedPropertyConfig = ({
  type: type2,
  path: path2,
  selectedTarget,
  context,
  getComputedRow
}) => {
  const name2 = "target";
  const methods = useForm({
    defaultValues: {
      target: []
    }
  });
  const { t: t2 } = useTranslation();
  const { control, reset } = methods;
  const target2 = useWatch({ control, name: name2 });
  const isMounted = useRef(false);
  const [previousTarget, setPreviousTarget] = useState([]);
  const dataType = type2 === "measurement" ? "datapoints" : `${type2}s`;
  const resetTarget = () => {
    reset({
      target: previousTarget
      //      
    });
  };
  const handleDialogOpen = () => {
    setPreviousTarget([...target2]);
  };
  useEffect(() => {
    if (isMounted.current) {
      reset({ target: [] });
    }
  }, [dataType, reset]);
  useEffect(() => {
    if (!isMounted.current) {
      if (selectedTarget && selectedTarget.length > 0 && type2) {
        reset({
          target: [...selectedTarget]
        });
      }
      isMounted.current = true;
    }
  }, [selectedTarget, reset, type2]);
  const handleSaveClick = () => {
    getComputedRow({
      type: type2,
      detail: target2
    });
  };
  const multiSelectable = ["alarmsStatusCheck"].includes(path2);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { onOpenChange: (isOpen) => isOpen && handleDialogOpen(), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogTrigger, { className: "h-10 w-full bg-orange-200", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "dlt-c8y-icon-bolt" }),
      "",
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: path2 })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      DialogContent,
      {
        closeButton: false,
        className: "w-full gap-0 rounded-2xl p-6 sm:p-7",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(DialogHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, { className: "p-0 text-xl font-bold", children: t2("Computed property configuration") }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "my-6 text-center text-xl", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "dlt-c8y-icon-bolt" }),
            "",
            path2
          ] }),
          type2 && /* @__PURE__ */ jsxRuntimeExports.jsx(FormProvider, { ...methods, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            DataManager,
            {
              dataType,
              data: target2,
              multiSelect: multiSelectable,
              name: name2,
              context
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogFooter, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(DialogClose, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button$1,
              {
                onClick: resetTarget,
                type: "button",
                variant: "destructive",
                className: "rounded-lg",
                children: t2("Cancel")
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(DialogClose, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button$1,
              {
                onClick: handleSaveClick,
                type: "button",
                disabled: (target2 == null ? void 0 : target2.length) === 0,
                className: "rounded-lg",
                children: t2("Save")
              }
            ) })
          ] })
        ]
      }
    )
  ] }) });
};
const computedInventoryList = [
  "lastDeviceMessage",
  "childDevicesCount",
  "childAssetsCount",
  "configurationSnapshot"
];
const computedDetail = z.object({
  type: z.enum(["alarm", "event", "measurement"]),
  detail: dataSchema
});
const propertySchema = z.object({
  path: z.string(),
  label: z.string(),
  computed: z.boolean(),
  complex: z.boolean(),
  show: z.boolean(),
  targetPath: z.string(),
  computedDetail: computedDetail.optional()
}).refine((data) => {
  if (data.computed && !computedInventoryList.includes(data.path)) {
    return data.computedDetail !== void 0;
  }
  return true;
});
const QuestionTooltip = ({
  hover = false,
  description: description2,
  className,
  children
}) => {
  const [tooltipIsOpen, setTooltipIsOpen] = useState(false);
  const handleTooltip = () => setTooltipIsOpen((pre) => !pre);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Tooltip, { open: !hover ? tooltipIsOpen : void 0, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TooltipTrigger,
      {
        type: "button",
        className: cn(
          `${hover ? "" : "dlt-c8y-icon-question-circle-o relative text-sm"}`,
          className
        ),
        onClick: handleTooltip,
        children: hover && children
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TooltipContent,
      {
        className: "max-w-[265px]",
        onPointerDownOutside: handleTooltip,
        children: description2
      }
    )
  ] }) });
};
const Toaster = () => {
  const { toasts } = useToast();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ToastProvider, { children: [
    toasts.map(function({ id: id2, title: title2, description: description2, action, ...props }) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Toast, { ...props, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid gap-1", children: [
          title2 && /* @__PURE__ */ jsxRuntimeExports.jsx(ToastTitle, { children: title2 }),
          description2 && /* @__PURE__ */ jsxRuntimeExports.jsx(ToastDescription, { children: description2 })
        ] }),
        action,
        /* @__PURE__ */ jsxRuntimeExports.jsx(ToastClose, {})
      ] }, id2);
    }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ToastViewport, {})
  ] });
};
const aggregation$1 = "";
const alarm$1 = "";
const alarms$1 = "";
const appearance$1 = "";
const border$1 = "";
const cancel$1 = "";
const configuration$1 = "";
const count$1 = "";
const day$1 = "";
const distance$1 = "";
const edit$1 = "";
const general$1 = "";
const hidden$1 = "";
const hour$1 = "";
const icon$1 = "";
const image$1 = "";
const integration$1 = "";
const label$1 = "";
const layout$1 = "";
const map$1 = "";
const max$1 = "";
const min$1 = "";
const minute$1 = "";
const month$1 = "";
const more$1 = "";
const none$1 = "";
const preview$1 = "";
const range$1 = "";
const regular$1 = "";
const remove$1 = "";
const save$1 = "";
const second$1 = "";
const signal$1 = "";
const text$1 = "";
const title$1 = "";
const trend$1 = "";
const type$1 = "";
const value$1 = "";
const video$1 = "";
const week$1 = "";
const widget$1 = "";
const datapoints$1 = " ";
const target$1 = "";
const current$1 = "";
const threshold$1 = "";
const background$1 = "";
const operator$1 = "";
const status$1 = "";
const fragment$1 = "";
const series$1 = "";
const fill$1 = "";
const last$1 = "";
const minutely$1 = "";
const hourly$1 = "";
const daily$1 = "";
const monthly$1 = "";
const weekly$1 = "";
const interval$1 = "";
const percent$1 = "";
const add$1 = "";
const logout$1 = "";
const tenant$1 = "";
const backend$1 = "";
const ui$1 = "UI";
const username$1 = " ";
const korean$1 = "";
const english$1 = "English";
const realtime$1 = "";
const reload$1 = " ";
const home$1 = "";
const origin$1 = "";
const bars$1 = "";
const line$1 = "";
const points$1 = "";
const custom$1 = " ";
const minutes$1 = "";
const hours$1 = "";
const days$1 = "";
const weeks$1 = "";
const months$1 = "";
const years$1 = "";
const properties$1 = "";
const show$1 = "";
const property$1 = "";
const select$1 = "";
const owner$1 = "";
const name$1 = "";
const notes$1 = "";
const critical$1 = "";
const major$1 = "";
const minor$1 = "";
const warning$1 = "";
const availability$1 = "";
const address$1 = "";
const city$1 = "";
const territory$1 = "";
const region$1 = "";
const country$1 = "";
const connection$1 = "";
const mode$1 = "";
const firmware$1 = "";
const version$1 = "";
const hardware$1 = "";
const model$1 = "";
const revision$1 = "";
const mobile$1 = "";
const provisioned$1 = "";
const network$1 = "";
const start$1 = "";
const end$1 = "";
const enabled$1 = "";
const netmask$1 = "";
const password$1 = "";
const position$1 = "";
const longitude$1 = "";
const latitude$1 = "";
const altitude$1 = "";
const software$1 = "";
const id$1 = "ID";
const street$1 = "";
const url$1 = "URL";
const ecn0$1 = "ECN0";
const iccid$1 = "ICCID";
const imei$1 = "IMEI";
const imsi$1 = "IMSI";
const lac$1 = "LAC";
const mcc$1 = "MCC";
const mnc$1 = "MNC";
const msisdn$1 = "MSISDN";
const rcsp$1 = "RCSP";
const rscp$1 = "RSCP";
const rsrp$1 = "RSRP";
const rsrq$1 = "RSRQ";
const rssi$1 = "RSSI";
const dhcp$1 = "DHCP";
const lan$1 = "LAN";
const ip$1 = "IP";
const mac$1 = "MAC";
const wan$1 = "WAN";
const apn$1 = "APN";
const filter$1 = "";
const sensor$1 = "";
const manage$1 = "";
const legends$1 = "";
const severity$1 = "";
const all$1 = "";
const active$1 = "";
const acknowledged$1 = "";
const cleared$1 = "";
const group$1 = "";
const expand$1 = "";
const location$1 = "";
const events$1 = "";
const path$1 = "";
const auto$1 = "Auto";
const blackhansans$1 = "BlackHanSans";
const cursive$1 = "Cursive";
const fantasy$1 = "Fantasy";
const monospace$1 = "Monospace";
const nanumgothic$1 = "NanumGothic";
const notosans$1 = "NotoSans";
const roboto$1 = "Roboto";
const serif$1 = "Serif";
const songmyung$1 = "SongMyung";
const source$1 = "";
const display$1 = "";
const transparent$1 = "";
const empty$1 = "";
const left$1 = "";
const center$1 = "";
const right$1 = "";
const align$1 = "";
const hide$1 = "";
const link$1 = "";
const message$1 = "";
const device$1 = "";
const email$1 = "";
const time$1 = "";
const details$1 = " ";
const file$1 = "";
const asset$1 = "";
const dashboard$1 = "";
const close$1 = "";
const operation$1 = "";
const post$1 = "";
const on$1 = "";
const off$1 = "";
const command$1 = "";
const color$1 = "";
const administration$1 = "";
const devicemanagement$1 = " ";
const streaminganalytics$1 = " ";
const maintenance$1 = " ";
const assets$1 = "";
const dashed$1 = "";
const dotted$1 = "";
const placeholder$1 = " ";
const collapse$1 = "";
const application$1 = "";
const features$1 = "";
const creationtime$1 = "  ";
const lastupdated$1 = "  ";
const description$1 = "";
const point$1 = "";
const bar$1 = "";
const koTranslation = {
  "add widget": " ",
  aggregation: aggregation$1,
  alarm: alarm$1,
  alarms: alarms$1,
  appearance: appearance$1,
  border: border$1,
  cancel: cancel$1,
  configuration: configuration$1,
  count: count$1,
  "dashboard deleted.": " .",
  "dashboard is locked.": " .",
  "dashboard is unlocked.": "  .",
  "data point": " ",
  "data points": " ",
  day: day$1,
  "default unit": " ",
  "delete dashboard": " ",
  "device name or the value of any device property": "     ",
  distance: distance$1,
  "do you want to proceed?": "?",
  edit: edit$1,
  "failed to delete dashboard.": "  .",
  "failed to lock the dashboard.": "  .",
  "failed to unlock the dashboard.": "   .",
  "full screen": " ",
  general: general$1,
  hidden: hidden$1,
  hour: hour$1,
  icon: icon$1,
  image: image$1,
  integration: integration$1,
  label: label$1,
  "last updated": " ",
  layout: layout$1,
  "lock dashboard": " ",
  map: map$1,
  max: max$1,
  min: min$1,
  minute: minute$1,
  month: month$1,
  more: more$1,
  none: none$1,
  "position in navigation": " ",
  "position in navigation menu (0 ~ 10000)": "   (0 ~ 10000)",
  preview: preview$1,
  range: range$1,
  regular: regular$1,
  remove: remove$1,
  "remove from list": " ",
  save: save$1,
  second: second$1,
  "select color": " ",
  "select widget": " ",
  signal: signal$1,
  "tab and layout": "  ",
  "target assets or devices": "   ",
  "target value": " ",
  text: text$1,
  "the widget has a small separation border between header and content.": "       .",
  "the widget has no border between header and content.": "      .",
  "the widget header is not shown.": "   .",
  title: title$1,
  trend: trend$1,
  type: type$1,
  value: value$1,
  video: video$1,
  week: week$1,
  widget: widget$1,
  "widget edited successfully.": "  .",
  "widget editing failed.": "  .",
  "widget header style": "",
  "widget margin": " ",
  "widget title": " ",
  "x axis": "X",
  "y axis": "Y",
  "you are about to delete the dashboard": '"{{dashboardName}}"  . ?',
  "you cannot click or change the contents of the dashboard displayed in the widget.": "       .",
  datapoints: datapoints$1,
  target: target$1,
  current: current$1,
  threshold: threshold$1,
  background: background$1,
  operator: operator$1,
  status: status$1,
  fragment: fragment$1,
  series: series$1,
  fill: fill$1,
  last: last$1,
  minutely: minutely$1,
  hourly: hourly$1,
  daily: daily$1,
  monthly: monthly$1,
  weekly: weekly$1,
  interval: interval$1,
  percent: percent$1,
  "select device": " ",
  "select alarms": " ",
  "select events": " ",
  "select datapoints": " ",
  "no data found.": " .",
  "no datapoints found.": " .",
  "no alarms found.": " .",
  "no events found.": " .",
  "you must add at least one datapoints.": "1     .",
  "you must add at least one events.": "1    .",
  "you must add at least one alarms.": "1    .",
  add: add$1,
  "loading...": " ...",
  "page not found.": "   .",
  "not found": "  ",
  "go to homepage": " ",
  "dark mode": " ",
  logout: logout$1,
  "no dashboard to display.": "  .",
  "no widgets to display.": "  .",
  "add a dashboard.": " .",
  "add widgets to this dashboard.": "   .",
  "user settings": " ",
  tenant: tenant$1,
  backend: backend$1,
  ui: ui$1,
  username: username$1,
  korean: korean$1,
  english: english$1,
  realtime: realtime$1,
  "toggle realtime": " ",
  reload: reload$1,
  home: home$1,
  origin: origin$1,
  "there was an error!": " !",
  "try again": " .",
  "widget example content": "  ",
  "chart type": " ",
  bars: bars$1,
  line: line$1,
  points: points$1,
  "step before": "  ",
  "step after": "  ",
  "last week": " ",
  "last month": " ",
  "last year": "",
  custom: custom$1,
  "last minute": "1 ",
  "last hour": "1 ",
  "last day": "",
  minutes: minutes$1,
  hours: hours$1,
  days: days$1,
  weeks: weeks$1,
  months: months$1,
  years: years$1,
  "filter by date range": "  ",
  "edit dashboard": " ",
  "add dashboard": " ",
  properties: properties$1,
  show: show$1,
  property: property$1,
  "select property": " ",
  "add property": " ",
  select: select$1,
  "No results.": " .",
  owner: owner$1,
  name: name$1,
  "creation time": " ",
  notes: notes$1,
  "active alarms status": "  ",
  critical: critical$1,
  major: major$1,
  minor: minor$1,
  warning: warning$1,
  availability: availability$1,
  address: address$1,
  city: city$1,
  "city code": " ",
  territory: territory$1,
  region: region$1,
  country: country$1,
  connection: connection$1,
  "communication mode": " ",
  mode: mode$1,
  firmware: firmware$1,
  "module version": " ",
  version: version$1,
  hardware: hardware$1,
  model: model$1,
  revision: revision$1,
  "serial number": " ",
  mobile: mobile$1,
  "lpwan device": "LPWAN ",
  provisioned: provisioned$1,
  "cell id": " ID",
  "connection type": " ",
  "current operator": " ",
  "current band": " ",
  network: network$1,
  "address range": " ",
  start: start$1,
  end: end$1,
  enabled: enabled$1,
  netmask: netmask$1,
  password: password$1,
  "auth type": " ",
  "sim status": "SIM ",
  position: position$1,
  longitude: longitude$1,
  latitude: latitude$1,
  altitude: altitude$1,
  "required availability": " ",
  "response interval": " ",
  software: software$1,
  "alarm count today": " ()",
  "alarm count 3 months": " (3)",
  "event count today": " ()",
  "event count 3 months": " (3)",
  "last device message": "  ",
  "last measurement": " ",
  "number of child devices": "  ",
  "number of child assets": "  ",
  "configuration snapshot": " ",
  id: id$1,
  street: street$1,
  "last message": " ",
  url: url$1,
  ecn0: ecn0$1,
  iccid: iccid$1,
  imei: imei$1,
  imsi: imsi$1,
  lac: lac$1,
  mcc: mcc$1,
  mnc: mnc$1,
  msisdn: msisdn$1,
  rcsp: rcsp$1,
  rscp: rscp$1,
  rsrp: rsrp$1,
  rsrq: rsrq$1,
  rssi: rssi$1,
  dhcp: dhcp$1,
  "dns 1": "DNS 1",
  "dns 2": "DNS 2",
  lan: lan$1,
  ip: ip$1,
  mac: mac$1,
  wan: wan$1,
  apn: apn$1,
  "filter properties": " ",
  filter: filter$1,
  "reset filter": " ",
  sensor: sensor$1,
  manage: manage$1,
  "you must add at least one data.": "1    .",
  legends: legends$1,
  severity: severity$1,
  all: all$1,
  active: active$1,
  acknowledged: acknowledged$1,
  cleared: cleared$1,
  "fetching more...": " ...",
  group: group$1,
  expand: expand$1,
  location: location$1,
  events: events$1,
  path: path$1,
  "(required)": "()",
  "suit-regular": "SUIT",
  auto: auto$1,
  blackhansans: blackhansans$1,
  cursive: cursive$1,
  fantasy: fantasy$1,
  monospace: monospace$1,
  nanumgothic: nanumgothic$1,
  notosans: notosans$1,
  roboto: roboto$1,
  serif: serif$1,
  songmyung: songmyung$1,
  "save to library": " ",
  "load from library": " {{label}} ",
  "update in library": " {{label}} ",
  source: source$1,
  "yellow range": "Yellow ",
  "red range": "Red ",
  display: display$1,
  "value displayed when data is aggregated": "    ",
  "save as default": " ",
  "if you select the current settings as default, these values will be used whenever this data point is added to a data explorer or in existing threshold smart rules which refer to this data point": "                Smart rule    .",
  "use settings as default": "  ",
  transparent: transparent$1,
  empty: empty$1,
  left: left$1,
  center: center$1,
  right: right$1,
  align: align$1,
  hide: hide$1,
  link: link$1,
  message: message$1,
  device: device$1,
  "remove widget": " ",
  "you are about to remove widget from your dashboard.": "   .",
  "remember me": "",
  "forgot password?": " ?",
  "log in": "",
  "e.g.joe or joe.doe@example.com": ":   Cheolsoo@example.com",
  "this field is required": "  ",
  "invalid email address": "   ",
  "reset password": " ",
  "email address": " ",
  "password reset request has been sent. Please check your email.": "   .  .",
  "somethings wrong": "   ",
  "invalid credentials": "   ",
  email: email$1,
  "widgets added successfully.": "  .",
  "widgets addition failed.": "  .",
  "dashboard edited successfully.": "  .",
  "failed to edit dashboard.": "  .",
  "this feature is not supported on mobile.": "   .",
  "error loading widget:": "  :",
  "computed property configuration": "  ",
  "delete": "",
  time: time$1,
  details: details$1,
  "apply dashboard to all devices of type": "{{type}}     ",
  file: file$1,
  asset: asset$1,
  dashboard: dashboard$1,
  close: close$1,
  operation: operation$1,
  post: post$1,
  "event type": " ",
  on: on$1,
  off: off$1,
  command: command$1,
  color: color$1,
  "widget removed.": " .",
  "widget removal failed.": "  .",
  administration: administration$1,
  devicemanagement: devicemanagement$1,
  streaminganalytics: streaminganalytics$1,
  "digital-twin-manager": "  ",
  maintenance: maintenance$1,
  "you must add at least one.": "     .",
  "please select at least one severity level to display.": "      .",
  "please select at least one status to display.": "      ",
  assets: assets$1,
  "active alarm message": "  ",
  "active alarm severity": "  ",
  "active alarms check": "  ",
  dashed: dashed$1,
  dotted: dotted$1,
  "line style": " ",
  placeholder: placeholder$1,
  "please enter a widget title.": "   .",
  "please select an asset.": "  .",
  "show more": "",
  collapse: collapse$1,
  application: application$1,
  features: features$1,
  creationtime: creationtime$1,
  lastupdated: lastupdated$1,
  description: description$1,
  "define which are the enabled features in the current application": "    ",
  "search...": "...",
  point: point$1,
  bar: bar$1,
  "column visibility": " ",
  "dashboard created successfully.": " .",
  "failed to created dashboard.": "  .",
  "menu label": " ",
  "add link": " ",
  "add datapoints": " ",
  "add events": " ",
  "add alarms": " ",
  "set the minimum and maximum values of the data point": "   "
};
const aggregation = "Aggregation";
const alarm = "Alarm";
const alarms = "Alarms";
const appearance = "Appearance";
const border = "Border";
const cancel = "Cancel";
const configuration = "Configuration";
const count = "Count";
const day = "Day";
const distance = "Distance";
const edit = "Edit";
const general = "General";
const hidden = "Hidden";
const hour = "Hour";
const icon = "Icon";
const image = "Image";
const integration = "Integration";
const label = "Label";
const layout = "Layout";
const map = "Map";
const max = "Max";
const min = "Min";
const minute = "Minute";
const month = "Month";
const more = "More";
const none = "None";
const preview = "Preview";
const range = "Range";
const regular = "Regular";
const remove = "Remove";
const save = "Save";
const second = "Second";
const signal = "Signal";
const text = "Text";
const title = "Title";
const trend = "Trend";
const type = "Type";
const value = "Value";
const video = "Video";
const week = "Week";
const widget = "Widget";
const datapoints = "Datapoints";
const target = "Target";
const current = "Current";
const threshold = "Threshold";
const background = "Background";
const operator = "Operator";
const status = "Status";
const fragment = "Fragment";
const series = "Series";
const fill = "Fill";
const last = "Last";
const minutely = "Minutely";
const hourly = "Hourly";
const daily = "Daily";
const monthly = "Monthly";
const weekly = "Weekly";
const interval = "Interval";
const percent = "Percent";
const add = "Add";
const logout = "Logout";
const tenant = "Tenant";
const backend = "Backend";
const ui = "UI";
const username = "Username";
const korean = "";
const english = "English";
const realtime = "Realtime";
const reload = "Reload";
const home = "Home";
const origin = "Origin";
const bars = "Bars";
const line = "Line";
const points = "Points";
const custom = "Custom";
const minutes = "Minutes";
const hours = "Hours";
const days = "Days";
const weeks = "Weeks";
const months = "Months";
const years = "Years";
const properties = "Properties";
const show = "Show";
const property = "Property";
const select = "Select";
const owner = "Owner";
const name = "Name";
const notes = "Notes";
const critical = "Critical";
const major = "Major";
const minor = "Minor";
const warning = "Warning";
const availability = "Availability";
const address = "Address";
const city = "City";
const territory = "Territory";
const region = "Region";
const country = "Country";
const connection = "Connection";
const mode = "Mode";
const firmware = "Firmware";
const version = "Version";
const hardware = "Hardware";
const model = "Model";
const revision = "Revision";
const mobile = "Mobile";
const provisioned = "Provisioned";
const network = "Network";
const start = "Start";
const end = "End";
const enabled = "Enabled";
const netmask = "Netmask";
const password = "Password";
const position = "Position";
const longitude = "Longitude";
const latitude = "Latitude";
const altitude = "Altitude";
const software = "Software";
const id = "ID";
const street = "Street";
const url = "URL";
const ecn0 = "ECN0";
const iccid = "ICCID";
const imei = "IMEI";
const imsi = "IMSI";
const lac = "LAC";
const mcc = "MCC";
const mnc = "MNC";
const msisdn = "MSISDN";
const rcsp = "RCSP";
const rscp = "RSCP";
const rsrp = "RSRP";
const rsrq = "RSRQ";
const rssi = "RSSI";
const dhcp = "DHCP";
const lan = "LAN";
const ip = "IP";
const mac = "MAC";
const wan = "WAN";
const apn = "APN";
const filter = "Filter";
const sensor = "Sensor";
const manage = "Manage";
const legends = "Legends";
const severity = "Severity";
const all = "All";
const active = "Active";
const acknowledged = "Acknowledged";
const cleared = "Cleared";
const group = "Group";
const expand = "Expand";
const location = "Location";
const events = "Events";
const path = "Path";
const auto = "Auto";
const blackhansans = "BlackHanSans";
const cursive = "Cursive";
const fantasy = "Fantasy";
const monospace = "Monospace";
const nanumgothic = "NanumGothic";
const notosans = "NotoSans";
const roboto = "Roboto";
const serif = "Serif";
const songmyung = "SongMyung";
const source = "Source";
const display = "Display";
const transparent = "Transparent";
const empty = "Empty";
const left = "Left";
const center = "Center";
const right = "Right";
const align = "Align";
const hide = "Hide";
const link = "Link";
const message = "Message";
const device = "Device";
const email = "Email";
const time = "Time";
const details = "Details";
const file = "File";
const asset = "Asset";
const dashboard = "Dashboard";
const close = "Close";
const operation = "Operation";
const post = "Poist";
const on = "On";
const off = "Off";
const command = "Command";
const color = "Color";
const administration = "Administration";
const devicemanagement = "Device Management";
const streaminganalytics = "Streaming Analytics";
const maintenance = "Maintenance";
const assets = "Assets";
const dashed = "Dashed";
const dotted = "Dotted";
const placeholder = "Placeholder";
const collapse = "Collapse";
const application = "Application";
const features = "Features";
const creationtime = "creationTime";
const lastupdated = "lastUpdated";
const description = "Description";
const point = "Point";
const bar = "Bar";
const enTranslation = {
  "add widget": "Add widget",
  aggregation,
  alarm,
  alarms,
  appearance,
  border,
  cancel,
  configuration,
  count,
  "dashboard deleted.": "Dashboard deleted.",
  "dashboard is locked.": "Dashboard is locked.",
  "dashboard is unlocked.": "Dashboard is unlocked.",
  "data point": "Data point",
  "data points": "Data points",
  day,
  "default unit": "Default unit",
  "delete dashboard": "Delete dashboard",
  "device name or the value of any device property": "Device name or the value of any device property",
  distance,
  "do you want to proceed?": "Do you want to proceed?",
  edit,
  "failed to delete dashboard.": "Failed to delete dashboard.",
  "failed to lock the dashboard.": "Failed to lock the dashboard.",
  "failed to unlock the dashboard.": "Failed to unlock the dashboard.",
  "full screen": "Full screen",
  general,
  hidden,
  hour,
  icon,
  image,
  integration,
  label,
  "last updated": "Last updated",
  layout,
  "lock dashboard": "Lock dashboard",
  map,
  max,
  min,
  minute,
  month,
  more,
  none,
  "position in navigation": "Position in navigation",
  "position in navigation menu (0 ~ 10000)": "Position in navigation menu (0 ~ 10000)",
  preview,
  range,
  regular,
  remove,
  "remove from list": "Remove from list",
  save,
  second,
  "select color": "Select color",
  "select widget": "Select widget",
  signal,
  "tab and layout": "Tab and layout",
  "target assets or devices": "Target assets or devices",
  "target value": "Target value",
  text,
  "the widget has a small separation border between header and content.": "The widget has a small separation border between header and content.",
  "the widget has no border between header and content.": "The widget has no border between header and content.",
  "the widget header is not shown.": "The widget header is not shown.",
  title,
  trend,
  type,
  value,
  video,
  week,
  widget,
  "widget edited successfully.": "Widget edited successfully.",
  "widget editing failed.": "Widget editing failed.",
  "widget header style": "Widget header style",
  "widget margin": "Widget margin",
  "widget title": "Widget title",
  "x axis": "X axis",
  "y axis": "Y axis",
  "you are about to delete the dashboard": 'You are about to delete the dashboard "{{dashboardName}}". Do you want to proceed?',
  "you cannot click or change the contents of the dashboard displayed in the widget.": "You cannot click or change the contents of the dashboard displayed in the widget.",
  datapoints,
  target,
  current,
  threshold,
  background,
  operator,
  status,
  fragment,
  series,
  fill,
  last,
  minutely,
  hourly,
  daily,
  monthly,
  weekly,
  interval,
  percent,
  "select device": "Select device",
  "select alarms": "Select alarms",
  "select events": "Select events",
  "select datapoints": "Select datapoints",
  "no data found.": "No data found.",
  "no datapoints found.": "No datapoints found.",
  "no alarms found.": "No alarms found.",
  "no events found.": "No events found.",
  "you must add at least one datapoints.": "You must add at least one datapoints.",
  "you must add at least one events.": "You must add at least one events.",
  "you must add at least one alarms.": "You must add at least one alarms.",
  add,
  "loading...": "Loading...",
  "page not found.": "Page not found.",
  "not found": "Not found",
  "go to homepage": "Go to homepage",
  "dark mode": "Dark mode",
  logout,
  "no dashboard to display.": "No dashboard to display.",
  "no widgets to display.": "No widgets to display.",
  "add a dashboard.": "Add a dashboard.",
  "add widgets to this dashboard.": "Add widgets to this dashboard.",
  "user settings": "User settings",
  tenant,
  backend,
  ui,
  username,
  korean,
  english,
  realtime,
  "toggle realtime": "Toggle realtime",
  reload,
  home,
  origin,
  "there was an error!": "There was an error!",
  "try again": "Try again",
  "widget example content": "Widget example content",
  "chart type": "Chart type",
  bars,
  line,
  points,
  "step before": "Step before",
  "step after": "Step after",
  "last week": "Last week",
  "last month": "Last month",
  "last year": "Last year",
  custom,
  "last minute": "Last minute",
  "last hour": "Last hour",
  "last day": "Last day",
  minutes,
  hours,
  days,
  weeks,
  months,
  years,
  "filter by date range": "Filter by date range",
  "edit dashboard": "Edit dashboard",
  "add dashboard": "Add dashboard",
  properties,
  show,
  property,
  "select property": "Select property",
  "add property": "Add property",
  select,
  "no results.": "No results.",
  owner,
  name,
  "creation time": "Creation time",
  notes,
  "active alarms status": "Active alarms status",
  critical,
  major,
  minor,
  warning,
  availability,
  address,
  city,
  "city code": "City code",
  territory,
  region,
  country,
  connection,
  "communication mode": "Communication mode",
  mode,
  firmware,
  "module version": "Module version",
  version,
  hardware,
  model,
  revision,
  "serial number": "Serial number",
  mobile,
  "lpwan device": "LPWAN device",
  provisioned,
  "cell id": "Cell ID",
  "connection type": "Connection type",
  "current operator": "Current operator",
  "current band": "Current band",
  network,
  "address range": "Address range",
  start,
  end,
  enabled,
  netmask,
  password,
  "auth type": "Auth type",
  "sim status": "SIM status",
  position,
  longitude,
  latitude,
  altitude,
  "required availability": "Required availability",
  "response interval": "Response interval",
  software,
  "alarm count today": "Alarm count today",
  "alarm count 3 months": "Alarm count 3 months",
  "event count today": "Event count today",
  "event count 3 months": "Event count 3 months",
  "last device message": "Last device message",
  "last measurement": "Last measurement",
  "number of child devices": "Number of child devices",
  "number of child assets": "Number of child assets",
  "configuration snapshot": "Configuration snapshot",
  id,
  street,
  "last message": "Last message",
  url,
  ecn0,
  iccid,
  imei,
  imsi,
  lac,
  mcc,
  mnc,
  msisdn,
  rcsp,
  rscp,
  rsrp,
  rsrq,
  rssi,
  dhcp,
  "dns 1": "DNS 1",
  "dns 2": "DNS 2",
  lan,
  ip,
  mac,
  wan,
  apn,
  "filter properties": "Filter properties",
  filter,
  "reset filter": "Reset filter",
  sensor,
  manage,
  "you must add at least one data.": "You must add at least one data.",
  legends,
  severity,
  all,
  active,
  acknowledged,
  cleared,
  "fetching more...": "Fetching more...",
  group,
  expand,
  location,
  events,
  path,
  "(required)": "(Required)",
  "suit-regular": "SUIT",
  auto,
  blackhansans,
  cursive,
  fantasy,
  monospace,
  nanumgothic,
  notosans,
  roboto,
  serif,
  songmyung,
  "save to library": "Save to library",
  "load from library": "Load {{label}} from library",
  "update in library": "Update {{label}} in library",
  source,
  "yellow range": "Yellow range",
  "red range": "Red range",
  display,
  "value displayed when data is aggregated": "Value displayed when data is aggregated",
  "save as default": "Save as default",
  "if you select the current settings as default, these values will be used whenever this data point is added to a data explorer or in existing threshold smart rules which refer to this data point": "If you select the current settings as default, these values will be used whenever this data point is added to a data explorer or in existing threshold smart rules which refer to this data point",
  "use settings as default": "Use settings as default",
  transparent,
  empty,
  left,
  center,
  right,
  align,
  hide,
  link,
  message,
  device,
  "remove widget": "Remove widget",
  "you are about to remove widget from your dashboard.": "You are about to remove widget from your dashboard.",
  "remember me": "Remember me",
  "forgot password?": "Forgot password?",
  "log in": "Log in",
  "e.g.joe or joe.doe@example.com": "e.g.joe or joe.doe@example.com",
  "this field is required": "This field is required",
  "invalid email address": "Invalid email address",
  "reset password": "Reset password",
  "email address": "Email address",
  "password reset request has been sent. Please check your email.": "Password reset request has been sent. Please check your email.",
  "somethings wrong": "Somethings wrong",
  "invalid credentials": "Invalid credentials",
  email,
  "widgets added successfully.": "Widgets added successfully.",
  "widgets addition failed.": "widgets addition failed.",
  "dashboard edited successfully.": "Dashboard edited successfully.",
  "failed to edit dashboard.": "Failed to edit dashboard.",
  "this feature is not supported on mobile.": "This feature is not supported on mobile.",
  "error loading widget:": "Error loading widget:",
  "computed property configuration": "Computed property configuration",
  "delete": "Delete",
  time,
  details,
  "apply dashboard to all devices of type": "Apply dashboard to all devices of type {{type}}",
  file,
  asset,
  dashboard,
  close,
  operation,
  post,
  "event type": "Event type",
  on,
  off,
  command,
  color,
  "widget removed.": "Widget removed.",
  "widget removal failed.": "Widget removal failed.",
  administration,
  devicemanagement,
  streaminganalytics,
  "digital-twin-manager": "Digital Twin Manager",
  maintenance,
  "you must add at least one.": "You must add at least one.",
  "please select at least one severity level to display.": "Please select at least one severity level to display.",
  "please select at least one status to display.": "Please select at least one status to display.",
  assets,
  "active alarm message": "Active alarm message",
  "active alarm severity": "Active alarm severity",
  "active alarms check": "Active alarms check",
  dashed,
  dotted,
  "line style": "Line style",
  placeholder,
  "please enter a widget title.": "Please enter a widget title.",
  "please select an asset.": "Please select an asset.",
  "show more": "Show more",
  collapse,
  application,
  features,
  creationtime,
  lastupdated,
  description,
  "define which are the enabled features in the current application": "Define which are the enabled features in the current application",
  "search...": "Search...",
  point,
  bar,
  "column visibility": "Column visibility",
  "dashboard created successfully.": "Dashboard created successfully.",
  "failed to created dashboard.": "Failed to created dashboard.",
  "menu label": "Menu label",
  "add link": "Add link",
  "add datapoints": "Add datapoints",
  "add events": "Add events",
  "add alarms": "Add alarms",
  "set the minimum and maximum values of the data point": "Set the minimum and maximum values of the data point"
};
const ProtectedRoute = ({ children }) => {
  const { isAuthenticated } = useAuth();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: !isAuthenticated ? /* @__PURE__ */ jsxRuntimeExports.jsx(Login, {}) : children });
};
const AppProviders = ({ router, login = true }) => {
  useEffect(() => {
    addLanguagePack("ko", "translation", koTranslation);
    addLanguagePack("en", "translation", enTranslation);
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DarkProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(QueryClientProvider, { client: new QueryClient(), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(FallbackUi, { fullScreen: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(LazyLoader, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx(Loading, { fullScreen: true }), children: login ? /* @__PURE__ */ jsxRuntimeExports.jsx(AuthProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ProtectedRoute, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(RouterProvider, { router }) }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(RouterProvider, { router }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Toaster, {})
  ] }) });
};
export {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
  ActionItem,
  SvgAdministration as AdministrationIcon,
  SvgAdvancedSimulators as AdvancedSimulatorsIcon,
  SvgAlarmBreakdownPurple as AlarmBreakdownPurpleIcon,
  SvgAlarmBreakdownRed as AlarmBreakdownRedIcon,
  SvgAlarmClear as AlarmClearIcon,
  SvgAlarmCritical as AlarmCriticalIcon,
  SvgDangerZone as AlarmDangerZoneIcon,
  SvgDetection as AlarmDetectionIcon,
  SvgAlarmFilter as AlarmFilterIcon,
  SvgAlarm as AlarmIcon,
  SvgAlarmMajor as AlarmMajorIcon,
  SvgAlarmManage as AlarmManageIcon,
  SvgAlarmMinor as AlarmMinorIcon,
  SvgAlarmOff as AlarmOffIcon,
  SvgAlarmOn as AlarmOnIcon,
  SvgSafetyGear as AlarmSafetyGearIcon,
  SvgAlarmSensor as AlarmSensorIcon,
  SvgShield as AlarmShieldIcon,
  SvgAlarmWarning as AlarmWarningIcon,
  AppProviders,
  SvgAppSwitch as AppSwitchIcon,
  AppSwitcher,
  AppSwitcherItem,
  SvgArrowDown as ArrowDownIcon,
  SvgArrowLeft as ArrowLeftIcon,
  SvgArrowRight as ArrowRightIcon,
  SvgArrowUp as ArrowUpIcon,
  AuthProvider,
  Badge,
  SvgBookmark as BookmarkIcon,
  Button$1 as Button,
  Calendar,
  SvgCalendar as CalendarIcon,
  Carousel,
  CarouselContent,
  CarouselItem,
  CarouselNext,
  CarouselPrevious,
  SvgCheckOff as CheckOffIcon,
  Checkbox,
  SvgCheckbox as CheckboxIcon,
  SvgCircle as CircleIcon,
  SvgPopClose as CloseIcon,
  SvgCockpit as CockpitIcon,
  SvgComposition as CompositionIcon,
  ComputedPropertyConfig,
  ContextDashboard,
  SvgCritical as CriticalIcon,
  DarkProvider,
  SvgDashboard as DashboardIcon,
  SvgDashboardPlus as DashboardPlusIcon,
  SvgData as DataIcon,
  DataManager,
  SvgDataSearch as DataSearchIcon,
  DatePicker,
  SvgDefault as DefaultIcon,
  SvgDevice as DeviceIcon,
  SvgDeviceManagement as DeviceManagementIcon,
  DeviceTree,
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
  DropdownMenu,
  DropdownMenuCheckboxItem,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuPortal,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuTrigger,
  SvgEdit as EditIcon,
  SvgEmergencyAlert as EmergencyAlertIcon,
  SvgEmergency as EmergencyIcon,
  SvgEmptyList as EmptyListIcon,
  EmptyState,
  SvgFail as FailIcon,
  FallbackUi,
  SvgFilter as FilterIcon,
  SvgFilter2 as FilterIcon2,
  SvgFolder as FolderIcon,
  SvgFolderOpen as FolderOpenIcon,
  Form,
  FormCheckboxField,
  FormColorField,
  FormControl,
  FormDescription,
  FormField,
  FormInputArrayField,
  FormInputField$1 as FormInputField,
  FormItem,
  FormLabel,
  FormMessage,
  FormRadioField,
  FormSelectField,
  FormInputField as FormTextareaField,
  SvgFullframe as FullFrameIcon,
  GroupAccordion,
  Header,
  HeaderDivider,
  SvgHome as HomeIcon,
  SvgImage as ImageIcon,
  SvgInfo as InfoIcon,
  Input,
  SvgInputDelete as InputDeleteIcon,
  Label$1 as Label,
  LastUpdated,
  Layout,
  LazyLoader,
  Loading,
  Login,
  SvgLogo01 as Logo01Icon,
  SvgLogo02 as Logo02Icon,
  SvgLogOut as LogoutIcon,
  SvgMachineLearningWorkbench as MachineLearningWorkbenchIcon,
  SvgMajor as MajorIcon,
  SvgMapPin as MapPinIcon,
  MenuBar,
  SvgMenuDrawer as MenuDrawerIcon,
  SvgMigrationTool as MigrationToolIcon,
  SvgMinor as MinorIcon,
  SvgMinus as MinusIcon,
  SvgMoonNight as MoonNightIcon,
  SvgMore as MoreIcon,
  SvgMoreVertical as MoreVerticalIcon,
  SvgNavigation as NavigationIcon,
  NavigationMenu,
  NavigationMenuContent,
  NavigationMenuIndicator,
  NavigationMenuItem,
  NavigationMenuLink,
  NavigationMenuList,
  NavigationMenuTrigger,
  NavigationMenuViewport,
  NotFound,
  SvgPlus as PlusIcon,
  Popover,
  PopoverContent,
  PopoverTrigger,
  SvgProfile as ProfileIcon,
  PropertySelector,
  QuestionTooltip,
  RadioGroup,
  RadioGroupItem,
  SvgRefresh as RefreshIcon,
  SvgReport as ReportIcon,
  SvgResetfilter as ResetFilterIcon,
  ScrollArea,
  ScrollBar,
  SearchDeviceTree,
  SvgSearch as SearchIcon,
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
  Separator,
  SvgSetting as SettingIcon,
  Sidebar,
  SidebarAccordionItem,
  SidebarItem,
  StaticDashboard,
  Status,
  SvgStyle as StyleIcon,
  SvgSuccess as SuccessIcon,
  Switch,
  TabItem,
  Table,
  TableBody,
  TableCaption,
  TableCell,
  TableFooter,
  TableHead,
  TableHeader,
  TableRow,
  Tabs$1 as Tabs,
  TabsContent,
  TabsList,
  TabsTrigger,
  Textarea,
  Toast,
  ToastAction,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
  Toaster,
  SvgTool as ToolIcon,
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
  SvgTranslate as TranslateIcon,
  SvgTrash as TrashIcon,
  UltivisDeviceProvider,
  UserMenu,
  UserMenuItem,
  SvgVideo as VideoIcon,
  SvgWarning as WarningIcon,
  WidgetDatePicker,
  SvgWidgetPlus as WidgetPlusIcon,
  addLanguagePack,
  alarmPeriod,
  alarmSchema,
  alarmSeverityIcon,
  alarmStatusIcon,
  badgeVariants,
  baseSchema,
  buttonVariants,
  chartDisplayOptions,
  chartTypeOptions,
  cn,
  customPeriod,
  dataMinMaxRequireSchema,
  dataRequireSchema,
  dataSchema,
  deviceSchema,
  deviceTypeDashboardForDevice,
  encodeAuth,
  eventSchema,
  fontSchema,
  fontWeightSchema,
  fontWeights,
  fonts,
  getActiveData,
  getApiMap,
  getComputedType,
  getDatapointsFromLocal,
  getTargetPath,
  getTypesFromLocal,
  humanizeAppName,
  intervalSchema,
  intervals,
  isSameDatapoint,
  isSameId,
  isSameType,
  managedObjectSchema,
  measurementSchema,
  navigationMenuTriggerStyle,
  period,
  periodSchema,
  propertySchema,
  setBasicAuth,
  setDatapointsToLocal,
  setTypesToLocal,
  tenantSchema,
  textSchema,
  useApi,
  useAuth,
  useCustomMutation,
  useDark,
  useDatePickerStore,
  useDeviceInventory,
  useDeviceTree,
  useFormField,
  useIntersectionObserver,
  useInventoryContext,
  useRoleStore,
  useRoutingContext,
  useSidebarStore,
  useToast,
  useTransitionNavigate,
  useTranslation,
  useUltivisDeviceContext,
  useUltivisLogic,
  useUpdateForTypeDashboard,
  useUpdatedConfig,
  useUserAgentStore,
  useWidgetSize,
  widgetManager,
  yAxisPositionOptions
};
